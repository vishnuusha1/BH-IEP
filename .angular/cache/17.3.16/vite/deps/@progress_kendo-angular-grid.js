import {
  AutoCompleteComponent,
  DropDownListComponent
} from "./chunk-7SJ6IDH3.js";
import {
  TabContentDirective,
  TabStripComponent,
  TabStripTabComponent,
  TabTitleDirective
} from "./chunk-JRZSRHZY.js";
import {
  FloatingLabelComponent,
  KENDO_LABELS,
  LabelComponent
} from "./chunk-I7KWFGRO.js";
import {
  KENDO_TOOLBAR,
  RefreshService,
  ToolBarButtonComponent,
  ToolBarButtonGroupComponent,
  ToolBarComponent,
  ToolBarDropDownButtonComponent,
  ToolBarSeparatorComponent,
  ToolBarSpacerComponent,
  ToolBarSplitButtonComponent,
  ToolBarToolComponent,
  ToolbarCustomMessagesComponent
} from "./chunk-5QTXJB5V.js";
import {
  filterBy,
  groupBy,
  isCompositeFilterDescriptor,
  orderBy,
  process
} from "./chunk-Z36VZMCP.js";
import "./chunk-VPWY4DO5.js";
import {
  AdaptiveService,
  CheckBoxComponent,
  DialogActionsComponent,
  DialogContainerService,
  DialogContentBase,
  DialogRef,
  DialogService,
  DragTargetContainerDirective,
  DropTargetContainerDirective,
  ErrorComponent,
  FormFieldComponent,
  HintComponent,
  KENDO_CHECKBOX,
  KENDO_FORMFIELD,
  KENDO_NUMERICTEXTBOX,
  KENDO_TEXTBOX,
  NumericTextBoxComponent,
  NumericTextBoxCustomMessagesComponent,
  RadioButtonComponent,
  TextBoxComponent,
  WindowContainerService,
  WindowService
} from "./chunk-YXHVJSUC.js";
import {
  Deflate,
  Inflate,
  drawDOM,
  exportPDF
} from "./chunk-ZJJ2SPTS.js";
import {
  IntlService,
  localeData,
  toString
} from "./chunk-IENMZ6ZE.js";
import {
  ActionSheetComponent,
  ActionSheetContentTemplateDirective,
  ActionSheetFooterTemplateDirective,
  ActionSheetHeaderTemplateDirective,
  ActionSheetTemplateDirective,
  ActionSheetViewComponent
} from "./chunk-G2IGECBX.js";
import "./chunk-VE7R6MCM.js";
import {
  FormControl,
  FormControlDirective,
  FormGroup,
  FormGroupDirective,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  ReactiveFormsModule,
  ɵNgNoValidate
} from "./chunk-VMBA77VA.js";
import {
  ButtonComponent,
  ChipComponent,
  ChipListComponent,
  KENDO_BUTTON,
  PopupService
} from "./chunk-ZV3R3EPT.js";
import {
  arrowLeftIcon,
  arrowRightIcon,
  arrowRotateCcwIcon,
  arrowsSwapIcon,
  calendarIcon,
  cancelIcon,
  caretAltDownIcon,
  caretAltLeftIcon,
  caretAltRightIcon,
  caretAltToLeftIcon,
  caretAltToRightIcon,
  caretAltUpIcon,
  checkIcon,
  chevronDownIcon,
  chevronLeftIcon,
  chevronRightIcon,
  chevronUpIcon,
  clockIcon,
  columnsIcon,
  displayInlineFlexIcon,
  fileExcelIcon,
  filePdfIcon,
  filterClearIcon,
  filterIcon,
  groupIcon,
  insertMiddleIcon,
  lockIcon,
  maxWidthIcon,
  minusIcon,
  moreVerticalIcon,
  pencilIcon,
  plusCircleIcon,
  plusIcon,
  redoIcon,
  reorderIcon,
  saveIcon,
  setColumnPositionIcon,
  slidersIcon,
  sortAscSmallIcon,
  sortDescSmallIcon,
  stickIcon,
  trashIcon,
  undoIcon,
  unlockIcon,
  unstickIcon,
  xCircleIcon,
  xIcon
} from "./chunk-2A7OSQWA.js";
import {
  IconComponent,
  IconWrapperComponent,
  IconsService,
  KENDO_ICONS,
  SVGIconComponent
} from "./chunk-2RQ6XJGS.js";
import {
  DraggableDirective,
  EventsOutsideAngularDirective,
  KENDO_TOGGLEBUTTONTABSTOP,
  KendoInput,
  Keys,
  MultiTabStop,
  PreventableEvent,
  ResizeBatchService,
  ResizeSensorComponent,
  ScrollbarWidthService,
  TemplateContextDirective,
  ToggleButtonTabStopDirective,
  WatermarkOverlayComponent,
  anyChanged,
  closest,
  getter,
  guid,
  hasObservers,
  isChanged,
  isControlRequired,
  isDocumentAvailable,
  isFocusable,
  isObject,
  isObjectPresent,
  isPresent,
  parseAttributes,
  removeHTMLAttributes,
  setHTMLAttributes,
  shouldShowValidationUI,
  touchEnabled
} from "./chunk-TCXXA5LR.js";
import {
  ComponentMessages,
  L10N_PREFIX,
  LocalizationService,
  RTL
} from "./chunk-632K3S7H.js";
import {
  validatePackage
} from "./chunk-D2DMRN4R.js";
import {
  animate,
  state,
  style,
  transition,
  trigger
} from "./chunk-PMNJ5QTY.js";
import {
  DomSanitizer
} from "./chunk-RETLQKIM.js";
import "./chunk-6QM5PHEX.js";
import {
  KeyValuePipe,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet
} from "./chunk-STNL7G5M.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  IterableDiffers,
  NgModule,
  NgZone,
  Optional,
  Output,
  Pipe,
  QueryList,
  Renderer2,
  SecurityContext,
  Self,
  SkipSelf,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  forwardRef,
  inject,
  isDevMode,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵi18nApply,
  ɵɵi18nAttributes,
  ɵɵi18nExp,
  ɵɵinject,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind3,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction6,
  ɵɵpureFunction8,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate5,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-DTS3OAND.js";
import {
  BehaviorSubject,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  animationFrameScheduler,
  auditTime,
  bufferCount,
  combineLatest,
  debounceTime,
  delay,
  distinctUntilChanged,
  filter,
  flatMap,
  from,
  fromEvent,
  interval,
  map,
  merge,
  of,
  scan,
  skip,
  switchMap,
  switchMapTo,
  take,
  takeUntil,
  takeWhile,
  tap,
  throttleTime,
  zip
} from "./chunk-BTNZXMHM.js";
import {
  __assign,
  __extends
} from "./chunk-QEJIEICB.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-XWLXMCJQ.js";

// node_modules/@progress/kendo-angular-pager/fesm2022/progress-kendo-angular-pager.mjs
var _c0 = ["dropdownlist"];
function PagerPageSizesComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.textFor("itemsPerPage"));
  }
}
var _c1 = ["select"];
var _c2 = ["numbers"];
function PagerNumericButtonsComponent_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(ctx_r1.start - 2));
    });
    ɵɵtext(1, "...");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.start - 1))("title", ctx_r1.pageLabel(ctx_r1.start - 1));
  }
}
function PagerNumericButtonsComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_3_Template_button_click_0_listener() {
      const num_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.currentPage === num_r4 ? false : ctx_r1.changePage(num_r4 - 1));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const num_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("selected", ctx_r1.currentPage === num_r4);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(num_r4))("title", ctx_r1.pageLabel(num_r4))("aria-current", ctx_r1.currentPage === num_r4 ? "page" : void 0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", num_r4, " ");
  }
}
function PagerNumericButtonsComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_4_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(ctx_r1.end));
    });
    ɵɵtext(1, "...");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.end + 1))("title", ctx_r1.pageLabel(ctx_r1.end + 1));
  }
}
var _c3 = (a0) => ({
  "aria-label": a0
});
var _c4 = (a0, a1) => ({
  keydown: a0,
  focusout: a1
});
function PagerInputComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.textFor("page"));
  }
}
var _c5 = (a0) => ({
  opacity: a0
});
function PagerComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template.first == null ? null : ctx_r0.template.first.templateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function PagerComponent_ng_template_3_kendo_pager_prev_buttons_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-prev-buttons", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size);
  }
}
function PagerComponent_ng_template_3_kendo_pager_numeric_buttons_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-numeric-buttons", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("buttonCount", ctx_r0.buttonCount);
  }
}
function PagerComponent_ng_template_3_kendo_pager_input_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-input", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size);
  }
}
function PagerComponent_ng_template_3_kendo_pager_next_buttons_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-next-buttons", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size);
  }
}
function PagerComponent_ng_template_3_kendo_pager_page_sizes_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-page-sizes", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(4, _c5, ctx_r0.initialized ? null : "0"))("size", ctx_r0.size)("pageSizes", ctx_r0._pageSizeValues)("adaptiveMode", ctx_r0.adaptiveMode);
  }
}
function PagerComponent_ng_template_3_kendo_pager_info_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-info", 14);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngStyle", ɵɵpureFunction1(1, _c5, ctx_r0.initialized ? null : "0"));
  }
}
function PagerComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, PagerComponent_ng_template_3_kendo_pager_prev_buttons_1_Template, 1, 1, "kendo-pager-prev-buttons", 7)(2, PagerComponent_ng_template_3_kendo_pager_numeric_buttons_2_Template, 1, 2, "kendo-pager-numeric-buttons", 8)(3, PagerComponent_ng_template_3_kendo_pager_input_3_Template, 1, 1, "kendo-pager-input", 7)(4, PagerComponent_ng_template_3_kendo_pager_next_buttons_4_Template, 1, 1, "kendo-pager-next-buttons", 7);
    ɵɵelementEnd();
    ɵɵtemplate(5, PagerComponent_ng_template_3_kendo_pager_page_sizes_5_Template, 1, 6, "kendo-pager-page-sizes", 9)(6, PagerComponent_ng_template_3_kendo_pager_info_6_Template, 1, 3, "kendo-pager-info", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(7, _c5, ctx_r0.initialized ? null : "0"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.type === "numeric" && ctx_r0.buttonCount > 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showInput);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0._pageSizeValues.length);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.info);
  }
}
function PagerComponent_kendo_resize_sensor_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 15);
    ɵɵlistener("resize", function PagerComponent_kendo_resize_sensor_5_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.resizeHandler());
    });
    ɵɵelementEnd();
  }
}
var PreventableEvent2 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var PageSizeChangeEvent = class extends PreventableEvent2 {
  /**
   * The newly selected page size.
   */
  newPageSize;
  /**
   * Constructs the event arguments for the `pageSizeChange` event.
   * @param newPageSize - The newly selected page size.
   * @hidden
   */
  constructor(newPageSize) {
    super();
    this.newPageSize = newPageSize;
  }
};
var Messages = class _Messages extends ComponentMessages {
  /**
   * The label of the pager. Follows the pattern **Page navigation, page {currentPage} of {totalPages}** by default.
   * Тhe default label text when the current page is 1, and the total number of pages is 10 will be
   * **Page navigation, page 1 of 10**.
   *
   * The message consists of several parts - the current page number, the total number of pages, and a localizable string.
   * To allow for reordering its parts, the `ariaLabel` input accepts a string with placeholders for the current page
   * and total number of pages. The `{currentPage}` and `{totalPages}` placeholders will be replaced
   * internally with the respective actual values.
   */
  ariaLabel;
  /**
   * The label for the **First page** button.
   */
  firstPage;
  /**
   * The label for the **Last page** button.
   */
  lastPage;
  /**
   * The label for the **Previous page** button.
   */
  previousPage;
  /**
   * The label for the **Next page** button.
   */
  nextPage;
  /**
   * The label displayed before the pager input.
   */
  page;
  /**
   * The title attribute of the page number input element.
   */
  pageNumberInputTitle;
  /**
   * The label displayed after the page-size selector.
   */
  itemsPerPage;
  /**
   * The label before the total-page number.
   */
  of;
  /**
   * The label after the total-page number.
   */
  items;
  /**
   * The text of the title and aria-label attributes applied to the page chooser.
   */
  selectPage;
  /**
   * The text of the aria-label attribute applied to the input element for entering the page number."
   */
  inputLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(t) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(t || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendoPagerMessages"]],
    inputs: {
      ariaLabel: "ariaLabel",
      firstPage: "firstPage",
      lastPage: "lastPage",
      previousPage: "previousPage",
      nextPage: "nextPage",
      page: "page",
      pageNumberInputTitle: "pageNumberInputTitle",
      itemsPerPage: "itemsPerPage",
      of: "of",
      items: "items",
      selectPage: "selectPage",
      inputLabel: "inputLabel"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendoPagerMessages"
    }]
  }], null, {
    ariaLabel: [{
      type: Input
    }],
    firstPage: [{
      type: Input
    }],
    lastPage: [{
      type: Input
    }],
    previousPage: [{
      type: Input
    }],
    nextPage: [{
      type: Input
    }],
    page: [{
      type: Input
    }],
    pageNumberInputTitle: [{
      type: Input
    }],
    itemsPerPage: [{
      type: Input
    }],
    of: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    selectPage: [{
      type: Input
    }],
    inputLabel: [{
      type: Input
    }]
  });
})();
var CustomMessagesComponent = class _CustomMessagesComponent extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(t) {
    return new (t || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-datapager-messages"], ["kendo-pager-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => CustomMessagesComponent)
      }],
      selector: "kendo-datapager-messages, kendo-pager-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var LocalizedMessagesDirective = class _LocalizedMessagesDirective extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(t) {
    return new (t || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoPagerLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => LocalizedMessagesDirective)
      }],
      selector: "[kendoPagerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PagerContextService = class {
  total;
  skip;
  pageSize;
  localization;
  changes = new Subject();
  pageChange = new Subject();
  pageSizeChange = new Subject();
  get currentPage() {
    return this.skip / this.pageSize;
  }
  notifyChanges(changes) {
    this.total = changes.total;
    this.pageSize = changes.pageSize;
    this.skip = changes.skip;
    this.changes.next(changes);
  }
  changePage(page) {
    this.pageChange.next({
      skip: page * this.pageSize,
      take: this.pageSize
    });
  }
  changePageSize(event2) {
    this.pageSizeChange.next(event2);
  }
  nextPage() {
    const nextPage = this.currentPage + 1;
    if (nextPage * this.pageSize < this.total) {
      this.changePage(nextPage);
    }
  }
  prevPage() {
    const prevPage = this.currentPage - 1;
    if (prevPage * this.pageSize >= 0) {
      this.changePage(prevPage);
    }
  }
};
var PagerElementComponent = class _PagerElementComponent {
  localization;
  pagerContext;
  cd;
  total;
  skip;
  pageSize;
  caretAltLeftIcon = caretAltLeftIcon;
  caretAltToLeftIcon = caretAltToLeftIcon;
  caretAltRightIcon = caretAltRightIcon;
  caretAltToRightIcon = caretAltToRightIcon;
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerElementComponent
   */
  get currentPage() {
    return Math.floor((this.skip || 0) / this.pageSize) + 1;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerElementComponent
   */
  get totalPages() {
    return Math.ceil((this.total || 0) / this.pageSize);
  }
  subscriptions;
  constructor(localization, pagerContext, cd) {
    this.localization = localization;
    this.pagerContext = pagerContext;
    this.cd = cd;
    this.total = pagerContext.total;
    this.skip = pagerContext.skip;
    this.pageSize = pagerContext.pageSize;
  }
  /**
   * @hidden
   *
   * @param {string} key
   * @returns {string}
   *
   * @memberOf PagerElementComponent
   */
  textFor(key) {
    const isPagerLocalization = this.localization.prefix === "kendo.pager";
    return this.localization.get(isPagerLocalization ? key : `pager${key[0].toLocaleUpperCase()}${key.slice(1)}`);
  }
  /**
   * @hidden
   *
   * @param {number} page
   *
   * @memberOf PagerElementComponent
   */
  changePage(page) {
    this.pagerContext.changePage(page);
    return false;
  }
  /**
   * @hidden
   *
   * @memberOf PagerElementComponent
   */
  ngOnInit() {
    this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));
    this.subscriptions.add(this.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  get prevArrowIcons() {
    return !this.localization.rtl ? ["caret-alt-to-left", "caret-alt-left"] : ["caret-alt-to-right", "caret-alt-right"];
  }
  get prevArrowSVGIcons() {
    return !this.localization.rtl ? [this.caretAltToLeftIcon, this.caretAltLeftIcon] : [this.caretAltToRightIcon, this.caretAltRightIcon];
  }
  get nextArrowIcons() {
    return !this.localization.rtl ? ["caret-alt-right", "caret-alt-to-right"] : ["caret-alt-left", "caret-alt-to-left"];
  }
  get nextArrowSVGIcons() {
    return !this.localization.rtl ? [this.caretAltRightIcon, this.caretAltToRightIcon] : [this.caretAltLeftIcon, this.caretAltToLeftIcon];
  }
  static ɵfac = function PagerElementComponent_Factory(t) {
    return new (t || _PagerElementComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerElementComponent,
    selectors: [["kendo-pager-element"]],
    decls: 0,
    vars: 0,
    template: function PagerElementComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerElementComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pager-element",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var DEFAULT_PAGE_SIZE_VALUES = [5, 10, 20].map((n) => ({
  text: String(n),
  value: n
}));
var focusableDirectiveSelector = "[kendoPagerFocusable]";
var getAllFocusableChildren = (parent) => {
  return parent.querySelectorAll(focusableDirectiveSelector);
};
var focusableSelector = ['a[href]:not([disabled]):not([aria-hidden="true"])', 'area[href]:not([disabled]):not([aria-hidden="true"])', 'input:not([disabled]):not([aria-hidden="true"])', 'select:not([disabled]):not([aria-hidden="true"])', 'textarea:not([disabled]):not([aria-hidden="true"])', 'button:not([aria-hidden="true"])', "iframe:not([disabled])", "object:not([disabled])", "embed:not([disabled])", '*[tabindex]:not([disabled]):not([aria-hidden="true"])', '*[contenteditable]:not([disabled]):not([contenteditable="false"])'].join(",");
var DEFAULT_SIZE = "medium";
var SIZES = {
  small: "sm",
  medium: "md",
  large: "lg"
};
var getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
  switch (stylingOption) {
    case "size":
      return {
        toRemove: `k-${componentType}-${SIZES[previousValue]}`,
        toAdd: newValue !== "none" ? `k-${componentType}-${SIZES[newValue]}` : ""
      };
    default:
      break;
  }
};
var replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`{\\s*${name}\\s*}`, "g"), value);
var calculatePadding = (element) => {
  if (!element || !isDocumentAvailable()) {
    return {
      padding: 0,
      gapNumbersSizes: 0,
      gapSizesInfo: 0
    };
  }
  const computedStyle = window.getComputedStyle(element);
  const paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
  const paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
  const padding = (paddingLeft + paddingRight) * 1.2;
  const style2 = getComputedStyle(document.documentElement);
  const gapNumbersSizes = 2 * (parseFloat(style2.getPropertyValue("--kendo-spacing-3\\.5") || "0.875rem") * (parseFloat(getComputedStyle(document.documentElement).fontSize) || 16));
  const gapSizesInfo = gapNumbersSizes;
  return {
    padding,
    gapNumbersSizes,
    gapSizesInfo
  };
};
var createMeasurementSpan = (renderer, container, className) => {
  const span2 = renderer.createElement("span");
  renderer.appendChild(container, span2);
  renderer.addClass(span2, className);
  return span2;
};
var copyComputedStyles = (renderer, source, destination) => {
  const computedStyle = getComputedStyle(source);
  const importantStyles = ["font-family", "font-size", "font-weight", "font-style", "letter-spacing", "text-transform", "white-space", "word-spacing", "padding-left", "padding-right", "margin-left", "margin-right", "border-left-width", "border-right-width", "box-sizing"];
  importantStyles.forEach((style2) => {
    renderer.setStyle(destination, style2, computedStyle.getPropertyValue(style2));
  });
};
var positionOffScreen = (renderer, element) => {
  renderer.setStyle(element, "position", "absolute");
  renderer.setStyle(element, "visibility", "hidden");
  renderer.setStyle(element, "left", "-9999px");
  renderer.setStyle(element, "top", "-9999px");
  renderer.setStyle(element, "display", "flex");
};
var PagerNavigationService = class {
  isNavigable = true;
  innerNavigationChange = new Subject();
  toggleInnerNavigation(value) {
    this.innerNavigationChange.next(value);
  }
  keepFocusWithinComponent(wrapper, target, event2) {
    const [firstFocusable, lastFocusable] = this.getFirstAndLastFocusable(wrapper);
    const tabAfterLastFocusable = !event2.shiftKey && target === lastFocusable;
    const shiftTabAfterFirstFocusable = event2.shiftKey && target === firstFocusable;
    if (tabAfterLastFocusable) {
      event2.preventDefault();
      firstFocusable.focus();
    }
    if (shiftTabAfterFirstFocusable) {
      event2.preventDefault();
      lastFocusable.focus();
    }
  }
  getFirstAndLastFocusable(wrapper) {
    const all = getAllFocusableChildren(wrapper);
    const firstFocusable = all.length > 0 ? all[0] : wrapper;
    const lastFocusable = all.length > 0 ? all[all.length - 1] : wrapper;
    return [isFocusable(firstFocusable) ? firstFocusable : firstFocusable.querySelector(focusableSelector), isFocusable(lastFocusable) ? lastFocusable : lastFocusable.querySelector(focusableSelector)];
  }
};
var PagerFocusableDirective = class _PagerFocusableDirective {
  navigationService;
  element;
  renderer;
  subscriptions = new Subscription();
  constructor(navigationService, element, renderer) {
    this.navigationService = navigationService;
    this.element = element;
    this.renderer = renderer;
  }
  ngOnInit() {
    if (!(this.nativeElement instanceof HTMLElement)) {
      return;
    }
    this.subscriptions.add(this.navigationService.innerNavigationChange.subscribe(this.innerNavigationChange.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get nativeElement() {
    return this.element.nativeElement;
  }
  innerNavigationChange(value) {
    if (!this.navigationService.isNavigable) {
      return;
    }
    const index = value ? "0" : "-1";
    if (this.nativeElement.matches(focusableSelector)) {
      this.renderer.setAttribute(this.nativeElement, "tabindex", index);
    }
    const focusableElements = this.nativeElement.querySelectorAll(focusableSelector);
    focusableElements.forEach((el) => {
      this.renderer.setAttribute(el, "tabindex", index);
    });
  }
  static ɵfac = function PagerFocusableDirective_Factory(t) {
    return new (t || _PagerFocusableDirective)(ɵɵdirectiveInject(PagerNavigationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PagerFocusableDirective,
    selectors: [["", "kendoPagerFocusable", ""]],
    exportAs: ["kendoPagerFocusable"],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerFocusableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPagerFocusable]",
      exportAs: "kendoPagerFocusable",
      standalone: true
    }]
  }], function() {
    return [{
      type: PagerNavigationService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, null);
})();
var PagerPrevButtonsComponent = class _PagerPrevButtonsComponent extends PagerElementComponent {
  constructor(localization, pagerContext, cd) {
    super(localization, pagerContext, cd);
  }
  /**
   * Specifies the padding of the buttons.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE;
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerPrevButtonsComponent
   */
  get disabled() {
    return this.currentPage === 1 || !this.total;
  }
  /**
   * @hidden
   */
  onClick(isFirst = false) {
    if (this.disabled) {
      return false;
    }
    const targetPage = isFirst ? 0 : this.currentPage - 2;
    return this.currentPage !== 1 ? this.changePage(targetPage) : false;
  }
  onChanges({
    total,
    skip: skip3,
    pageSize
  }) {
    this.total = total;
    this.skip = skip3;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  static ɵfac = function PagerPrevButtonsComponent_Factory(t) {
    return new (t || _PagerPrevButtonsComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerPrevButtonsComponent,
    selectors: [["kendo-datapager-prev-buttons"], ["kendo-pager-prev-buttons"]],
    inputs: {
      size: "size"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 16,
    consts: [["type", "button", "kendoButton", "", "kendoPagerFocusable", "", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", "k-pager-first", 3, "click", "icon", "svgIcon", "size", "title"], ["type", "button", "kendoButton", "", "kendoPagerFocusable", "", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", 3, "click", "icon", "svgIcon", "size", "title"]],
    template: function PagerPrevButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "button", 0);
        ɵɵlistener("click", function PagerPrevButtonsComponent_Template_button_click_0_listener() {
          return ctx.onClick(true);
        });
        ɵɵelementEnd();
        ɵɵelementStart(1, "button", 1);
        ɵɵlistener("click", function PagerPrevButtonsComponent_Template_button_click_1_listener() {
          return ctx.onClick();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("icon", ctx.prevArrowIcons[0])("svgIcon", ctx.prevArrowSVGIcons[0])("size", ctx.size)("title", ctx.textFor("firstPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("firstPage"));
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("icon", ctx.prevArrowIcons[1])("svgIcon", ctx.prevArrowSVGIcons[1])("size", ctx.size)("title", ctx.textFor("previousPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("previousPage"));
      }
    },
    dependencies: [ButtonComponent, PagerFocusableDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerPrevButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-prev-buttons, kendo-pager-prev-buttons",
      template: `
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav k-pager-first"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[0]"
            [svgIcon]="prevArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('firstPage')"
            [attr.aria-label]="textFor('firstPage')"
            (click)="onClick(true)">
        </button>
        <button
            type="button" kendoButton
            kendoPagerFocusable
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [icon]="prevArrowIcons[1]"
            [svgIcon]="prevArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('previousPage')"
            [attr.aria-label]="textFor('previousPage')"
            (click)="onClick()">
        </button>
    `,
      standalone: true,
      imports: [ButtonComponent, PagerFocusableDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    size: [{
      type: Input
    }]
  });
})();
var PagerPageSizesComponent = class _PagerPageSizesComponent extends PagerElementComponent {
  pagerContext;
  element;
  ngZone;
  dropDownList;
  _showItemsText = true;
  /**
   * Controls the visibility of the page text label.
   * @hidden
   */
  get showItemsText() {
    return this._showItemsText;
  }
  set showItemsText(value) {
    this._showItemsText = value;
    this.cd.markForCheck();
  }
  /**
   * The page sizes collection. Can contain numbers and [PageSizeItem]({% slug api_pager_pagesizeitem %}) objects.
   *
   * @example
   *
   * ```ts-preview
   * _@Component({
   *    selector: 'my-app',
   *    template: `
   *        <div *ngFor="let item of pagedData" style="border: 1px solid black; padding: 10px;">
   *            <span>{{item.ProductID}}. </span>
   *            <span>{{item.ProductName}}</span>
   *        </div>
   *        <kendo-pager
   *             [skip]="skip"
   *             [pageSize]="pageSize"
   *             [total]="total"
   *             (pageChange)="onPageChange($event)">
   *           <ng-template kendoPagerTemplate>
   *               <kendo-pager-page-sizes [pageSizes]="pagesizes"></kendo-pager-page-sizes>
   *           </ng-template>
   *        </kendo-pager>
   *    `
   * })
   * class AppComponent {
   *    public data: any[] = products;
   *    public pagedData = [];
   *    public skip = 0;
   *    public pageSize = 2;
   *    public total = products.length;
   *    public pagesizes = [{text: 'One', value: 1}, {text: 'Two', value: 2}, {text: 'All', value : 'all'}];
   *
   *    public ngOnInit() {
   *        this.pageData();
   *    }
   *
   *    public onPageChange(e) {
   *        this.skip = e.skip;
   *        this.pageSize = e.take;
   *        this.pageData();
   *    }
   *
   *    private pageData() {
   *        this.pagedData = this.data.slice(this.skip, this.skip + this.pageSize);
   *    }
   * }
   *
   * const products = [{
   *   'ProductID' : 1,
   *   'ProductName' : "Chai",
   *   'SupplierID' : 1,
   *   'CategoryID' : 1,
   *   'QuantityPerUnit' : "10 boxes x 20 bags",
   *   'UnitPrice' : 18.0000,
   *   'UnitsInStock' : 39,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 10,
   *   'Discontinued' : false
   *
   * }, {
   *   'ProductID' : 2,
   *   'ProductName' : "Chang",
   *   'SupplierID' : 1,
   *   'CategoryID' : 1,
   *   'QuantityPerUnit' : "24 - 12 oz bottles",
   *   'UnitPrice' : 19.0000,
   *   'UnitsInStock' : 17,
   *   'UnitsOnOrder' : 40,
   *   'ReorderLevel' : 25,
   *   'Discontinued' : false
   * }, {
   *   'ProductID' : 3,
   *   'ProductName' : "Aniseed Syrup",
   *   'SupplierID' : 1,
   *   'CategoryID' : 2,
   *   'QuantityPerUnit' : "12 - 550 ml bottles",
   *   'UnitPrice' : 10.0000,
   *   'UnitsInStock' : 13,
   *   'UnitsOnOrder' : 70,
   *   'ReorderLevel' : 25,
   *   'Discontinued' : false
   * }, {
   *   'ProductID' : 4,
   *   'ProductName' : "Chef Anton\'s Cajun Seasoning",
   *   'SupplierID' : 2,
   *  'CategoryID' : 2,
   *   'QuantityPerUnit' : "48 - 6 oz jars",
   *   'UnitPrice' : 22.0000,
   *   'UnitsInStock' : 53,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 0,
   *   'Discontinued' : false
   * }, {
   *   'ProductID' : 5,
   *   'ProductName' : "Chef Anton\'s Gumbo Mix",
   *   'SupplierID' : 2,
   *   'CategoryID' : 2,
   *   'QuantityPerUnit' : "36 boxes",
   *   'UnitPrice' : 21.3500,
   *   'UnitsInStock' : 0,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 0,
   *   'Discontinued' : true
   * }, {
   *   'ProductID' : 6,
   *   'ProductName' : "Grandma\'s Boysenberry Spread",
   *   'SupplierID' : 3,
   *   'CategoryID' : 2,
   *   'QuantityPerUnit' : "12 - 8 oz jars",
   *   'UnitPrice' : 25.0000,
   *   'UnitsInStock' : 120,
   *   'UnitsOnOrder' : 0,
   *   'ReorderLevel' : 25,
   *   'Discontinued' : false
   * }];
   * ```
   *
   */
  set pageSizes(pageSizes) {
    let normalizedItems = [];
    if (Array.isArray(pageSizes)) {
      pageSizes.forEach((item) => {
        if (typeof item === "number") {
          normalizedItems.push({
            text: item.toString(),
            value: item
          });
        } else {
          normalizedItems.push(item);
        }
      });
    } else {
      normalizedItems = DEFAULT_PAGE_SIZE_VALUES;
    }
    if (this.pageSize && !normalizedItems.some((item) => item.value === this.pageSize)) {
      normalizedItems = [{
        text: this.pageSize.toString(),
        value: this.pageSize
      }, ...normalizedItems];
    }
    this._pageSizes = normalizedItems;
  }
  /**
   * Specifies the padding of the dropdown.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE;
  /**
   * Toggles the adaptiveness of the internal DropDownList.
   *
   * @default 'auto'
   */
  adaptiveMode = "auto";
  /**
   * @hidden
   *
   * @readonly
   */
  get classes() {
    return true;
  }
  _pageSizes = [];
  constructor(localization, cd, pagerContext, element, ngZone) {
    super(localization, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.element = element;
    this.ngZone = ngZone;
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.element.nativeElement.addEventListener("keydown", this.keyDownHandler.bind(this), true);
    });
  }
  ngOnDestroy() {
    this.element.nativeElement.removeEventListener("keydown", this.keyDownHandler);
  }
  /**
   * @hidden
   */
  pageSizeChange(value, dropdownlist) {
    const event2 = new PageSizeChangeEvent(value);
    this.pagerContext.changePageSize(event2);
    if (event2.isDefaultPrevented()) {
      dropdownlist.writeValue(this.pageSize);
    }
  }
  onChanges({
    total,
    skip: skip3,
    pageSize
  }) {
    this.total = total;
    this.skip = skip3;
    this.pageSize = typeof pageSize === "number" ? pageSize : this.total;
    this.cd.markForCheck();
  }
  keyDownHandler(ev) {
    if (ev.keyCode === Keys.Escape && this.dropDownList.isOpen) {
      ev.stopPropagation();
      this.dropDownList.toggle(false);
    }
  }
  static ɵfac = function PagerPageSizesComponent_Factory(t) {
    return new (t || _PagerPageSizesComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerPageSizesComponent,
    selectors: [["kendo-datapager-page-sizes"], ["kendo-pager-page-sizes"]],
    viewQuery: function PagerPageSizesComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropDownList = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function PagerPageSizesComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-pager-sizes", ctx.classes);
      }
    },
    inputs: {
      showItemsText: "showItemsText",
      pageSizes: "pageSizes",
      size: "size",
      adaptiveMode: "adaptiveMode"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 7,
    consts: [["dropdownlist", ""], ["kendoPagerFocusable", "", "textField", "text", "valueField", "value", 3, "valueChange", "size", "data", "valuePrimitive", "value", "adaptiveMode"], [4, "ngIf"]],
    template: function PagerPageSizesComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-dropdownlist", 1, 0);
        ɵɵlistener("valueChange", function PagerPageSizesComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          const dropdownlist_r2 = ɵɵreference(1);
          return ɵɵresetView(ctx.pageSizeChange($event, dropdownlist_r2));
        });
        ɵɵelementEnd();
        ɵɵtemplate(2, PagerPageSizesComponent_ng_container_2_Template, 2, 1, "ng-container", 2);
      }
      if (rf & 2) {
        ɵɵproperty("size", ctx.size)("data", ctx._pageSizes)("valuePrimitive", true)("value", ctx.pageSize)("adaptiveMode", ctx.adaptiveMode);
        ɵɵattribute("aria-label", ctx.textFor("itemsPerPage"));
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showItemsText);
      }
    },
    dependencies: [DropDownListComponent, PagerFocusableDirective, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerPageSizesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-page-sizes, kendo-pager-page-sizes",
      template: `
        <kendo-dropdownlist kendoPagerFocusable
            #dropdownlist
            [size]="size"
            [data]="_pageSizes"
            textField="text"
            valueField="value"
            [valuePrimitive]="true"
            [value]="pageSize"
            (valueChange)="pageSizeChange($event, dropdownlist)"
            [adaptiveMode]="adaptiveMode"
            [attr.aria-label]="textFor('itemsPerPage')"></kendo-dropdownlist>
        <ng-container *ngIf="showItemsText">{{ textFor('itemsPerPage') }}</ng-container>
    `,
      standalone: true,
      imports: [DropDownListComponent, PagerFocusableDirective, NgIf]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    dropDownList: [{
      type: ViewChild,
      args: ["dropdownlist", {
        static: true
      }]
    }],
    showItemsText: [{
      type: Input
    }],
    pageSizes: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    classes: [{
      type: HostBinding,
      args: ["class.k-pager-sizes"]
    }]
  });
})();
var PagerTemplateDirective = class _PagerTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PagerTemplateDirective_Factory(t) {
    return new (t || _PagerTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PagerTemplateDirective,
    selectors: [["", "kendoDataPagerTemplate", ""], ["", "kendoPagerTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDataPagerTemplate], [kendoPagerTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var PagerNumericButtonsComponent = class _PagerNumericButtonsComponent extends PagerElementComponent {
  pagerContext;
  renderer;
  selectElement;
  numbersElement;
  /**
   * The count of the displayed buttons.
   *
   * @type {number}
   * @memberOf PagerNumericButtonsComponent
   */
  buttonCount;
  /**
   * Specifies the padding of the numeric buttons.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number[]}
   * @memberOf PagerNumericButtonsComponent
   */
  get buttons() {
    const result = [];
    for (let idx2 = this.start; idx2 <= this.end; idx2++) {
      result.push(idx2);
    }
    return result;
  }
  /**
   * @hidden
   */
  get end() {
    return Math.min(this.start + this.buttonCount - 1, this.totalPages);
  }
  /**
   * @hidden
   */
  get start() {
    const page = this.currentPage;
    const buttonCount = this.buttonCount;
    if (page > buttonCount) {
      const reminder = page % buttonCount;
      return reminder === 0 ? page - buttonCount + 1 : page - reminder + 1;
    }
    return 1;
  }
  constructor(localization, cd, pagerContext, renderer) {
    super(localization, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.renderer = renderer;
  }
  _size = DEFAULT_SIZE;
  ngAfterViewInit() {
    this.handleClasses(this.size, "size");
  }
  /**
   * @hidden
   */
  pageLabel(num) {
    const pageText = this.textFor("page");
    if (pageText) {
      return pageText + " " + num;
    }
    return num.toString();
  }
  /**
   * @hidden
   */
  onSelectChange(e) {
    const target = e.target;
    const valueAsNumber = Number(target.value);
    if (!Number.isNaN(valueAsNumber)) {
      this.changePage(valueAsNumber - 1);
    } else {
      if (target.value === "previousButtons") {
        this.changePage(this.start - 2);
      } else {
        this.changePage(this.end);
      }
    }
  }
  onChanges({
    total,
    skip: skip3,
    pageSize
  }) {
    this.total = total;
    this.skip = skip3;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  get pageChooserLabel() {
    return this.textFor("selectPage");
  }
  handleClasses(value, input) {
    const elem = this.selectElement?.nativeElement;
    const classes = getStylingClasses("picker", input, this[input], value);
    if (!elem) {
      return;
    }
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function PagerNumericButtonsComponent_Factory(t) {
    return new (t || _PagerNumericButtonsComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerNumericButtonsComponent,
    selectors: [["kendo-datapager-numeric-buttons"], ["kendo-pager-numeric-buttons"]],
    viewQuery: function PagerNumericButtonsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c1, 5, ElementRef);
        ɵɵviewQuery(_c2, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numbersElement = _t.first);
      }
    },
    inputs: {
      buttonCount: "buttonCount",
      size: "size"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 5,
    vars: 3,
    consts: [["numbers", ""], [1, "k-pager-numbers"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "size", "click", 4, "ngIf"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "size", "selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "click", "size"], ["type", "button", "kendoPagerFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "click", "size", "selected"]],
    template: function PagerNumericButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵtemplate(2, PagerNumericButtonsComponent_button_2_Template, 2, 3, "button", 2)(3, PagerNumericButtonsComponent_button_3_Template, 2, 6, "button", 3)(4, PagerNumericButtonsComponent_button_4_Template, 2, 3, "button", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.start > 1);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.buttons);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
      }
    },
    dependencies: [PagerFocusableDirective, NgIf, NgForOf, ButtonComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerNumericButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons",
      template: `
        <div class="k-pager-numbers" #numbers>
            <button *ngIf="start > 1"
                type="button"
                kendoPagerFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                rounded="none"
                [attr.aria-label]="pageLabel(start - 1)"
                [attr.title]="pageLabel(start - 1)"
                (click)="changePage(start - 2)">...</button>
            <button *ngFor="let num of buttons"
                type="button"
                kendoPagerFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                rounded="none"
                [attr.aria-label]="pageLabel(num)"
                [attr.title]="pageLabel(num)"
                [attr.aria-current]="currentPage === num ? 'page' : undefined"
                [selected]="currentPage === num"
                (click)="currentPage === num ? false : changePage(num - 1)">
                {{num}}
            </button>
            <button *ngIf="end < totalPages"
                type="button"
                kendoPagerFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                rounded="none"
                [attr.aria-label]="pageLabel(end + 1)"
                [attr.title]="pageLabel(end + 1)"
                (click)="changePage(end)">...</button>
        </div>
    `,
      standalone: true,
      imports: [PagerFocusableDirective, NgIf, NgForOf, ButtonComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }, {
      type: Renderer2
    }];
  }, {
    selectElement: [{
      type: ViewChild,
      args: ["select", {
        read: ElementRef
      }]
    }],
    numbersElement: [{
      type: ViewChild,
      args: ["numbers", {
        read: ElementRef
      }]
    }],
    buttonCount: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var PagerNextButtonsComponent = class _PagerNextButtonsComponent extends PagerElementComponent {
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerNextButtonsComponent
   */
  get disabled() {
    return this.currentPage === this.totalPages || !this.total;
  }
  /**
   * Specifies the padding of the buttons.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE;
  constructor(localization, pagerContext, cd) {
    super(localization, pagerContext, cd);
  }
  /**
   * @hidden
   */
  onClick(isLast = false) {
    if (this.disabled) {
      return false;
    }
    const targetPage = isLast ? this.totalPages - 1 : this.currentPage;
    return this.currentPage !== this.totalPages ? this.changePage(targetPage) : false;
  }
  onChanges({
    total,
    skip: skip3,
    pageSize
  }) {
    this.total = total;
    this.skip = skip3;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  static ɵfac = function PagerNextButtonsComponent_Factory(t) {
    return new (t || _PagerNextButtonsComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerNextButtonsComponent,
    selectors: [["kendo-datapager-next-buttons"], ["kendo-pager-next-buttons"]],
    inputs: {
      size: "size"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 16,
    consts: [["kendoButton", "", "kendoPagerFocusable", "", "type", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", 3, "click", "size", "icon", "svgIcon", "title"], ["kendoButton", "", "kendoPagerFocusable", "", "type", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", "k-pager-last", 3, "click", "size", "icon", "svgIcon", "title"]],
    template: function PagerNextButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "button", 0);
        ɵɵlistener("click", function PagerNextButtonsComponent_Template_button_click_0_listener() {
          return ctx.onClick();
        });
        ɵɵelementEnd();
        ɵɵelementStart(1, "button", 1);
        ɵɵlistener("click", function PagerNextButtonsComponent_Template_button_click_1_listener() {
          return ctx.onClick(true);
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("size", ctx.size)("icon", ctx.nextArrowIcons[0])("svgIcon", ctx.nextArrowSVGIcons[0])("title", ctx.textFor("nextPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("nextPage"));
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled);
        ɵɵproperty("size", ctx.size)("icon", ctx.nextArrowIcons[1])("svgIcon", ctx.nextArrowSVGIcons[1])("title", ctx.textFor("lastPage"));
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-label", ctx.textFor("lastPage"));
      }
    },
    dependencies: [ButtonComponent, PagerFocusableDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerNextButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-next-buttons, kendo-pager-next-buttons",
      template: `
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[0]"
            [svgIcon]="nextArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('nextPage')"
            [attr.aria-label]="textFor('nextPage')"
            (click)="onClick()">
        </button>
        <button kendoButton kendoPagerFocusable
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[1]"
            [svgIcon]="nextArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav k-pager-last"
            [attr.aria-disabled]="disabled"
            [class.k-disabled]="disabled"
            [title]="textFor('lastPage')"
            [attr.aria-label]="textFor('lastPage')"
            (click)="onClick(true)">
        </button>
    `,
      standalone: true,
      imports: [ButtonComponent, PagerFocusableDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    size: [{
      type: Input
    }]
  });
})();
var PagerInputComponent = class _PagerInputComponent extends PagerElementComponent {
  pagerContext;
  zone;
  renderer;
  numericInput;
  /**
   * Controls the visibility of the page text label.
   * @hidden
   */
  showPageText = true;
  /**
   * Specifies the padding of the internal numeric input element.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  size = DEFAULT_SIZE;
  constructor(localization, pagerContext, zone, cd, renderer) {
    super(localization, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.zone = zone;
    this.renderer = renderer;
  }
  onChanges({
    total,
    skip: skip3,
    pageSize
  }) {
    this.total = total;
    this.skip = skip3;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  /**
   * @hidden
   *
   * @param {string} value
   *
   * @memberOf PagerInputComponent
   */
  handleKeyDown = (event2) => {
    const incomingValue = this.numericInput.value || this.current;
    if (event2.keyCode === Keys.Enter) {
      event2.preventDefault();
      if (incomingValue !== this.current) {
        this.zone.run(() => {
          this.changePage(incomingValue - 1);
        });
      }
    }
  };
  /**
   * @hidden
   *
   * @param {string} value
   *
   * @memberOf PagerInputComponent
   */
  handleBlur = () => {
    const inputValue = this.numericInput.value;
    if (!inputValue) {
      this.numericInput.writeValue(this.current);
      return;
    }
    if (inputValue !== this.current) {
      this.zone.run(() => {
        this.changePage(inputValue - 1);
      });
    }
  };
  /**
   * @hidden
   */
  get current() {
    return this.hasPages ? this.currentPage : 0;
  }
  /**
   * @hidden
   */
  get hasPages() {
    return this.totalPages !== 0;
  }
  static ɵfac = function PagerInputComponent_Factory(t) {
    return new (t || _PagerInputComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerInputComponent,
    selectors: [["kendo-datapager-input"], ["kendo-pager-input"]],
    viewQuery: function PagerInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(NumericTextBoxComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numericInput = _t.first);
      }
    },
    inputs: {
      showPageText: "showPageText",
      size: "size"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 4,
    vars: 19,
    consts: [[1, "k-pager-input"], [4, "ngIf"], ["kendoPagerFocusable", "", "format", "n0", 3, "spinners", "decimals", "size", "disabled", "value", "min", "max", "autoCorrect", "inputAttributes", "title", "kendoEventsOutsideAngular"]],
    template: function PagerInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtemplate(1, PagerInputComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
        ɵɵelement(2, "kendo-numerictextbox", 2);
        ɵɵtext(3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showPageText);
        ɵɵadvance();
        ɵɵproperty("spinners", false)("decimals", 0)("size", ctx.size)("disabled", !ctx.hasPages)("value", ctx.current)("min", ctx.hasPages ? 1 : 0)("max", ctx.totalPages)("autoCorrect", true)("inputAttributes", ɵɵpureFunction1(14, _c3, ctx.textFor("inputLabel")))("title", ctx.textFor("pageNumberInputTitle"))("kendoEventsOutsideAngular", ɵɵpureFunction2(16, _c4, ctx.handleKeyDown, ctx.handleBlur));
        ɵɵadvance();
        ɵɵtextInterpolate2(" ", ctx.textFor("of"), " ", ctx.totalPages, " ");
      }
    },
    dependencies: [NgIf, NumericTextBoxComponent, PagerFocusableDirective, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-datapager-input, kendo-pager-input",
      template: `
     <span class="k-pager-input">
        <ng-container *ngIf="showPageText">{{textFor('page')}}</ng-container>
        <kendo-numerictextbox kendoPagerFocusable
            [spinners]="false"
            [decimals]="0"
            format="n0"
            [size]="size"
            [disabled]="!hasPages"
            [value]="current"
            [min]="hasPages ? 1 : 0"
            [max]="totalPages"
            [autoCorrect]="true"
            [inputAttributes]="{
                'aria-label': textFor('inputLabel')
            }"
            [title]="textFor('pageNumberInputTitle')"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                focusout: handleBlur
            }">
        </kendo-numerictextbox>
        {{textFor('of')}} {{totalPages}}
     </span>
    `,
      standalone: true,
      imports: [NgClass, NgIf, NumericTextBoxComponent, PagerFocusableDirective, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PagerContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    numericInput: [{
      type: ViewChild,
      args: [NumericTextBoxComponent, {
        static: true
      }]
    }],
    showPageText: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var PagerInfoComponent = class _PagerInfoComponent extends PagerElementComponent {
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerInfoComponent
   */
  get maxItems() {
    return Math.min(this.currentPage * this.pageSize, this.total);
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerInfoComponent
   */
  get currentPageText() {
    return this.total ? (this.currentPage - 1) * this.pageSize + 1 : 0;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerInfoComponent
   */
  hostClass = true;
  constructor(localization, cd, pagerContext) {
    super(localization, pagerContext, cd);
  }
  onChanges({
    total,
    skip: skip3,
    pageSize
  }) {
    this.total = total;
    this.skip = skip3;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
  static ɵfac = function PagerInfoComponent_Factory(t) {
    return new (t || _PagerInfoComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerInfoComponent,
    selectors: [["kendo-datapager-info"], ["kendo-pager-info"]],
    hostVars: 2,
    hostBindings: function PagerInfoComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-pager-info", ctx.hostClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 1,
    vars: 5,
    template: function PagerInfoComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtext(0);
      }
      if (rf & 2) {
        ɵɵtextInterpolate5("", ctx.currentPageText, " - ", ctx.maxItems, " ", ctx.textFor("of"), " ", ctx.total, " ", ctx.textFor("items"), "");
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerInfoComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-datapager-info, kendo-pager-info",
      template: `{{currentPageText}} - {{maxItems}} {{textFor('of')}} {{total}} {{textFor('items')}}`,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-pager-info"]
    }]
  });
})();
var packageMetadata = {
  name: "@progress/kendo-angular-pager",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1749540168,
  version: "19.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var PagerComponent = class _PagerComponent {
  pagerContext;
  element;
  localization;
  renderer;
  ngZone;
  cdr;
  navigationService;
  template;
  set numericButtons(buttons) {
    const newWidth = buttons ? buttons.nativeElement?.offsetWidth : 0;
    if (buttons && newWidth !== this.pagerDimensions.numericButtonsWidth) {
      this.pagerDimensions.numericButtonsWidth = newWidth;
    }
  }
  set pagerInput(input) {
    const newWidth = input ? input.nativeElement?.offsetWidth : 0;
    if (input && newWidth !== this.pagerDimensions.inputWidth) {
      this.pagerDimensions.inputWidth = newWidth;
    }
  }
  pagerInputComponent;
  set pageSizes(sizes) {
    const newWidth = sizes ? sizes.nativeElement?.offsetWidth : 0;
    if (sizes && newWidth !== this.pagerDimensions.pageSizesWidth) {
      this.pagerDimensions.pageSizesWidth = newWidth;
    }
  }
  pageSizesComponent;
  /**
   * @hidden
   */
  externalTemplate;
  /**
   * Represents the total number of data items in the collection.
   *
   * @default 0
   */
  total = 0;
  /**
   * Defines the number of data items to be skipped.
   *
   * @default 0
   */
  skip = 0;
  /**
   * Defines the number of data items per page.
   */
  pageSize;
  /**
   * Sets the maximum numeric buttons count before the buttons are collapsed.
   *
   * @default 10
   */
  buttonCount = 10;
  /**
   * Toggles the information about the current page and the total number of records.
   *
   * @default true
   */
  info = true;
  /**
   * Defines the type of the pager.
   *
   * @default 'numeric'
   */
  type = "numeric";
  /**
   * Shows a dropdown for selecting the page size.
   * When set to `true`, the dropdown will contain the default list of options - 5, 10, 20.
   * To customize the list of options, set `pageSizeValues` to an array of the desired values.
   * The array can contain numbers and [PageSizeItem]({% slug api_pager_pagesizeitem %}) objects.
   */
  set pageSizeValues(value) {
    if (typeof value === "boolean") {
      this._pageSizeValues = value ? DEFAULT_PAGE_SIZE_VALUES : [];
    } else {
      this._pageSizeValues = value;
    }
  }
  get pageSizeValues() {
    return this._pageSizeValues;
  }
  /**
   * Toggles the **Previous** and **Next** buttons.
   *
   * @default true
   */
  previousNext = true;
  /**
   * If set to `true`, the user can use dedicated shortcuts to interact with the Pager ([see example]({% slug keyboard_navigation_pager %})).
   * By default, navigation is enabled. To disable it and make the Pager content accessible in the normal tab sequence, set the property to `false`.
   * @default true
   */
  set navigable(value) {
    this._navigable = value;
    this.navigationService.isNavigable = value;
  }
  get navigable() {
    return this._navigable;
  }
  /**
   * Specifies the padding of all Pager elements.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Toggles the Pager responsive functionality ([see example](slug:responsive_pager)).
   *
   * @default true
   */
  responsive = true;
  /**
   * Toggles the Pager adaptiveness functionality ([see example](slug:adaptive_mode_pager)).
   *
   * @default 'auto'
   */
  adaptiveMode = "auto";
  /**
   * Fires when the current page of the Pager is changed ([see example](slug:overview_pager)).
   * You have to handle the event yourself and page the data.
   */
  pageChange = new EventEmitter();
  /**
   * Fires when the page size of the Pager is changed.
   * You have to handle the event yourself and page the data.
   * If the event is prevented, the page size will remain unchanged ([see example]({% slug pager_events %})).
   */
  pageSizeChange = new EventEmitter();
  /**
   * @hidden
   */
  pagerInputVisibilityChange = new EventEmitter();
  /**
   * @hidden
   */
  pageTextVisibilityChange = new EventEmitter();
  /**
   * @hidden
   */
  itemsTextVisibilityChange = new EventEmitter();
  pagerClass = true;
  get responsiveClass() {
    return this.responsive;
  }
  widgetRole = "application";
  roleDescription = "pager";
  keyShortcuts = "Enter ArrowRight ArrowLeft";
  get hostTabindex() {
    return this.navigable ? "0" : "-1";
  }
  get dir() {
    return this.direction;
  }
  /**
   * @hidden
   */
  focusHandler(ev) {
    const isInnerNavigationEnabled = ev.target !== this.element.nativeElement;
    this.navigationService.toggleInnerNavigation(isInnerNavigationEnabled);
  }
  get totalPages() {
    return Math.ceil((this.total || 0) / this.pageSize);
  }
  get currentPage() {
    return Math.floor((this.skip || 0) / this.pageSize) + 1;
  }
  get templateContext() {
    const context = this._templateContext;
    context.totalPages = this.totalPages;
    context.total = this.total;
    context.skip = this.skip;
    context.pageSize = this.pageSize;
    context.currentPage = this.currentPage;
    return context;
  }
  /**
   * @hidden
   */
  get showPageText() {
    return this._showPageText;
  }
  set showPageText(value) {
    this._showPageText = value;
    this.pagerInputComponent && (this.pagerInputComponent.showPageText = value);
    this.pageTextVisibilityChange.emit(value);
  }
  /**
   * @hidden
   */
  get showItemsText() {
    return this._showItemsText;
  }
  set showItemsText(value) {
    this._showItemsText = value;
    this.pageSizesComponent && (this.pageSizesComponent.showItemsText = value);
    this.itemsTextVisibilityChange.emit(value);
  }
  /**
   * @hidden
   */
  get showInput() {
    return this._showInput;
  }
  set showInput(value) {
    this._showInput = value;
    this.pagerInputVisibilityChange.emit(value);
  }
  /**
   * @hidden
   */
  initialized = false;
  subscriptions = new Subscription();
  _templateContext = {};
  _pageSizeValues = DEFAULT_PAGE_SIZE_VALUES;
  direction;
  isInnerNavigationEnabled = false;
  _navigable = true;
  _size = DEFAULT_SIZE;
  _showInput = true;
  _showPageText = true;
  _showItemsText = true;
  /**
   * Stores the measurements of various Pager elements.
   * These dimensions are used for responsive layout calculations.
   * @hidden
   */
  pagerDimensions = {
    padding: 0,
    numericButtonsWidth: 0,
    inputWidth: 0,
    pageSizesWidth: 0,
    sizesTextWidth: 0,
    pageTextWidth: 0,
    infoTextWidth: 0,
    gapNumbersSizes: 0,
    gapSizesInfo: 0,
    width: 0
  };
  constructor(pagerContext, element, localization, renderer, ngZone, cdr, navigationService) {
    this.pagerContext = pagerContext;
    this.element = element;
    this.localization = localization;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.navigationService = navigationService;
    validatePackage(packageMetadata);
    this.direction = localization.rtl ? "rtl" : "ltr";
    if (!navigationService) {
      this.navigationService = inject(PagerNavigationService);
    }
    if (!pagerContext) {
      this.pagerContext = inject(PagerContextService);
    }
    this.pagerContext.localization = localization;
  }
  ngOnInit() {
    this.subscriptions.add(this.pagerContext.pageChange.subscribe(this.changePage.bind(this)));
    this.subscriptions.add(this.pagerContext.pageSizeChange.subscribe(this.changePageSize.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.measureAllTextWidths();
      this.responsive && this.resizeHandler();
    }));
    this.subscriptions.add(this.navigationService.innerNavigationChange.subscribe(this.innerNavigationChange.bind(this)));
    if (this.navigable) {
      const wrapper = this.element.nativeElement;
      this.ngZone.runOutsideAngular(() => {
        this.subscriptions.add(this.renderer.listen(wrapper, "keydown", this.keyDownHandler.bind(this)));
      });
    }
  }
  get maxItems() {
    return Math.min(this.currentPage * this.pageSize, this.total);
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.element.nativeElement, "aria-label", this.ariaLabel);
    this.subscriptions.add(this.template.changes.subscribe(() => {
      this.measureAllTextWidths();
      this.responsive && this.resizeHandler(false);
    }));
    this.handleClasses(this.size, "size");
    this.measureAllTextWidths();
    !this.numericButtons && (this.pagerDimensions.numericButtonsWidth = this.element.nativeElement.querySelector(".k-pager-numbers")?.offsetWidth ?? 0);
    !this.pagerInput && (this.pagerDimensions.inputWidth = this.element.nativeElement.querySelector(".k-pager-input")?.offsetWidth ?? 0);
    !this.pageSizes && (this.pagerDimensions.pageSizesWidth = this.element.nativeElement.querySelector(".k-pager-sizes")?.offsetWidth ?? 0);
    const padding = calculatePadding(this.element.nativeElement);
    this.pagerDimensions.padding = padding.padding;
    this.pagerDimensions.gapNumbersSizes = padding.gapNumbersSizes;
    this.pagerDimensions.gapSizesInfo = padding.gapSizesInfo;
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      if (this.type !== "input") {
        this.showInput = false;
      }
    });
    if (!isDocumentAvailable()) {
      this.initialized = true;
      return;
    }
    this.responsive && this.resizeHandler();
    setTimeout(() => {
      this.initialized = true;
      this.cdr.markForCheck();
    }, 0);
  }
  ngOnChanges(changes) {
    if (anyChanged(["pageSize", "skip", "total"], changes, false)) {
      const previousButtonCount = Math.min(this.buttonCount, (changes["total"]?.previousValue || this.total) / (changes["pageSize"]?.previousValue || this.pageSize));
      this.pagerContext.notifyChanges({
        pageSize: this.pageSize,
        skip: this.skip,
        total: this.total
      });
      this.pagerDimensions.numericButtonsWidth = this.pagerDimensions.numericButtonsWidth * Math.min(this.buttonCount, this.total / this.pageSize) / previousButtonCount;
      this.renderer.setAttribute(this.element.nativeElement, "aria-label", this.ariaLabel);
      this.responsive && this.resizeHandler(false);
    }
    if (anyChanged(["pageSizeValues", "previousNext", "buttonCount"], changes, true)) {
      this.responsive && this.resizeHandler(false);
    }
    if (isChanged("responsive", changes, true)) {
      if (changes["responsive"].currentValue && !changes["responsive"].previousValue) {
        this.measureAllTextWidths();
        this.resizeHandler(false);
      }
      if (!this.responsive) {
        this.showInput = this.type === "input";
        this.showElementsInOrder(this.element.nativeElement.offsetWidth, this.pagerDimensions.width);
      }
    }
    if (isChanged("type", changes, true)) {
      this.showNumericButtonsResponsive();
      this.responsive && this.resizeHandler(false);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  changePage(event2) {
    this.pageChange.emit(event2);
  }
  /**
   * @hidden
   */
  changePageSize(event2) {
    this.pageSizeChange.emit(event2);
    if (!event2.isDefaultPrevented()) {
      if (event2.newPageSize === "all") {
        this.pageChange.emit({
          skip: 0,
          take: this.total
        });
      } else {
        this.pageChange.emit({
          skip: 0,
          take: event2.newPageSize
        });
      }
    }
  }
  /**
   * @hidden
   */
  onPageSizeChange(event2) {
    this.pageSizeChange.emit(event2);
    if (!event2.isDefaultPrevented()) {
      this.pageChange.emit({
        skip: this.skip,
        take: event2.newPageSize
      });
    }
  }
  /**
   * @hidden
   */
  resizeHandler = (compareWidth = true) => {
    if (this.template?.first && !this.responsive) {
      return;
    }
    if (!isDocumentAvailable() || !this.element?.nativeElement) {
      this.initialized = true;
      return;
    }
    let pagerWidth = this.element.nativeElement.offsetWidth;
    if (pagerWidth <= 0) {
      return;
    }
    if (compareWidth && pagerWidth === this.pagerDimensions.width) {
      return;
    } else {
      this.pagerDimensions.width = pagerWidth;
    }
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        if (this.template?.first && !this.responsive) {
          return;
        }
        const numericButtonsWrapperElement = this.element.nativeElement.querySelector(".k-pager-numbers-wrap");
        const pagerInfoElement = this.element.nativeElement.querySelector(".k-pager-info");
        const pagerPageSizes = this.element.nativeElement.querySelector(".k-pager-sizes");
        let elementsWidths = numericButtonsWrapperElement?.offsetWidth + (pagerPageSizes?.offsetWidth || 0) + (pagerInfoElement?.offsetWidth > 0 ? Math.min(this.pagerDimensions.infoTextWidth) : 0);
        if (this.isElementVisible(pagerInfoElement)) {
          elementsWidths += this.pagerDimensions.gapSizesInfo;
        }
        pagerWidth -= this.pagerDimensions.padding;
        if (this.isElementVisible(pagerPageSizes)) {
          pagerWidth -= this.pagerDimensions.gapNumbersSizes;
        }
        if (Math.ceil(elementsWidths) <= pagerWidth) {
          this.showElementsInOrder(pagerWidth, elementsWidths);
        } else {
          this.hideElementsInOrder(pagerWidth, elementsWidths);
        }
        !this.initialized && this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);
      });
    });
  };
  get ariaLabel() {
    const localizationMsg = this.localization.get("ariaLabel") || "";
    return replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, "currentPage", this.currentPage.toString()), "totalPages", this.totalPages.toString());
  }
  keyDownHandler(e) {
    const target = e.target;
    const wrapper = this.element.nativeElement;
    const isArrowLeftOrPageUp = e.keyCode === Keys.ArrowLeft || e.keyCode === Keys.PageUp;
    const isArrowRightOrPageDown = e.keyCode === Keys.ArrowRight || e.keyCode === Keys.PageDown;
    const isEnter = e.keyCode === Keys.Enter;
    const isHome = e.keyCode === Keys.Home;
    const isEnd = e.keyCode === Keys.End;
    const isEsc = e.keyCode === Keys.Escape;
    const isTab = e.keyCode === Keys.Tab;
    const isFirstPage = this.currentPage === 1;
    const isLastPage = this.currentPage === this.totalPages;
    this.ngZone.run(() => {
      if (isHome) {
        if (e.target !== wrapper) {
          return;
        }
        e.preventDefault();
        !isFirstPage && this.pagerContext.changePage(0);
      } else if (isEnd) {
        e.preventDefault();
        if (e.target !== wrapper) {
          return;
        }
        !isLastPage && this.pagerContext.changePage(this.totalPages - 1);
      } else if (this.isInnerNavigationEnabled) {
        if (isEsc) {
          this.navigationService.toggleInnerNavigation(false);
          wrapper.focus();
        } else if (isTab) {
          this.navigationService.keepFocusWithinComponent(wrapper, target, e);
        }
      } else {
        if (e.target !== wrapper) {
          return;
        }
        if (isArrowLeftOrPageUp) {
          e.preventDefault();
          !isFirstPage && this.pagerContext.prevPage();
        } else if (isArrowRightOrPageDown) {
          e.preventDefault();
          !isLastPage && this.pagerContext.nextPage();
        } else if (isEnter) {
          e.preventDefault();
          const [firstFocusable] = this.navigationService.getFirstAndLastFocusable(wrapper);
          this.navigationService.toggleInnerNavigation(true);
          firstFocusable?.focus();
        }
      }
    });
  }
  innerNavigationChange(value) {
    this.isInnerNavigationEnabled = value;
  }
  handleClasses(value, input) {
    const elem = this.element.nativeElement;
    const classes = getStylingClasses("pager", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  showElementsInOrder(availableWidth, currentWidth) {
    const el = this.element.nativeElement;
    const numericButtonsElement = el.querySelector("kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons");
    const pagerInfoElement = el.querySelector(".k-pager-info");
    const pagerPageSizes = el.querySelector(".k-pager-sizes");
    const pagerSizesDropDown = el.querySelector(".k-pager-sizes .k-dropdownlist");
    const checkOverflow = this.responsive;
    if (this.type === "input" && this.isElementVisible(pagerInfoElement) || this.isElementVisible(numericButtonsElement)) {
      return;
    }
    if (this.showPageSizes && !this.isElementVisible(pagerPageSizes)) {
      const addDropDownWidth = currentWidth + this.pagerDimensions.pageSizesWidth + this.pagerDimensions.gapNumbersSizes - this.pagerDimensions.sizesTextWidth;
      if (checkOverflow && addDropDownWidth > availableWidth) return;
      this.ngZone.run(() => this.showItemsText = false);
      this.showElement(pagerPageSizes);
      currentWidth = addDropDownWidth;
      if (checkOverflow && currentWidth >= availableWidth) return;
    }
    if (this.showPageSizes && this.isElementVisible(pagerPageSizes) && !this.showItemsText) {
      const addPageSizesText = currentWidth - pagerSizesDropDown?.offsetWidth + this.pagerDimensions.pageSizesWidth;
      if (checkOverflow && addPageSizesText > availableWidth) return;
      this.ngZone.run(() => this.showItemsText = true);
      currentWidth = addPageSizesText;
      if (checkOverflow && currentWidth >= availableWidth) return;
    }
    if (!this.showPageText && (!this.showPageSizes || this.isElementVisible(pagerPageSizes) && this.showItemsText)) {
      const addPageText = currentWidth + this.pagerDimensions.pageTextWidth;
      if (checkOverflow && addPageText > availableWidth) return;
      this.ngZone.run(() => this.showPageText = true);
      currentWidth = addPageText;
      if (checkOverflow && currentWidth >= availableWidth) return;
    }
    if (this.info && !this.isElementVisible(pagerInfoElement) && (!this.showPageSizes || this.isElementVisible(pagerPageSizes) && this.showPageText)) {
      const addInfoText = currentWidth + this.pagerDimensions.infoTextWidth + this.pagerDimensions.gapSizesInfo;
      if (checkOverflow && addInfoText > availableWidth) return;
      this.ngZone.run(() => {
        this.showElement(pagerInfoElement);
      });
      currentWidth = addInfoText;
    }
    if (this.type === "numeric" && (!this.info || this.isElementVisible(pagerInfoElement))) {
      const addNumericButtons = currentWidth - this.pagerDimensions.inputWidth + this.pagerDimensions.numericButtonsWidth;
      if (checkOverflow && addNumericButtons > availableWidth) return;
      this.showElement(numericButtonsElement);
      this.ngZone.run(() => {
        this.showInput = false;
        this.cdr.markForCheck();
      });
    }
  }
  hideElementsInOrder(availableWidth, currentWidth) {
    const el = this.element.nativeElement;
    const numericButtonsElement = el.querySelector("kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons");
    const pagerInfoElement = el.querySelector(".k-pager-info");
    const pagerPageSizes = el.querySelector(".k-pager-sizes");
    const pagerSizesDropDown = el.querySelector(".k-pager-sizes .k-dropdownlist");
    if (this.isElementVisible(numericButtonsElement)) {
      this.hideElement(numericButtonsElement);
      this.ngZone.run(() => this.showInput = true);
      currentWidth += this.pagerDimensions.inputWidth - this.pagerDimensions.numericButtonsWidth;
      if (currentWidth <= availableWidth) return;
    }
    if (this.isElementVisible(pagerInfoElement)) {
      this.hideElement(pagerInfoElement);
      currentWidth -= this.pagerDimensions.infoTextWidth + this.pagerDimensions.gapSizesInfo;
      if (currentWidth <= availableWidth) return;
    }
    if (this.showPageText) {
      this.ngZone.run(() => this.showPageText = false);
      currentWidth = currentWidth - this.pagerDimensions.pageTextWidth;
      if (currentWidth <= availableWidth) return;
    }
    if (this.showPageSizes && this.isElementVisible(pagerPageSizes) && this.showItemsText) {
      this.ngZone.run(() => this.showItemsText = false);
      currentWidth = currentWidth - this.pagerDimensions.pageSizesWidth + pagerSizesDropDown?.offsetWidth;
      if (currentWidth <= availableWidth) return;
    }
    this.hideElement(pagerPageSizes);
  }
  isElementVisible(element) {
    return element && !element?.classList.contains("k-hidden");
  }
  hideElement(element) {
    if (element) {
      this.renderer.addClass(element, "k-hidden");
    }
  }
  showElement(element) {
    if (element) {
      this.renderer.removeClass(element, "k-hidden");
    }
  }
  measureAllTextWidths() {
    if (!isDocumentAvailable()) {
      return;
    }
    const el = this.element.nativeElement;
    const existingInfo = el.querySelector(".k-pager-info");
    const existingInput = el.querySelector(".k-pager-input");
    const existingSizes = el.querySelector(".k-pager-sizes");
    const measureContainer = this.renderer.createElement("div");
    positionOffScreen(this.renderer, measureContainer);
    this.renderer.appendChild(this.element.nativeElement, measureContainer);
    const infoSpan = createMeasurementSpan(this.renderer, measureContainer, "k-pager-info");
    const pageSpan = createMeasurementSpan(this.renderer, measureContainer, "k-pager-input");
    const sizesSpan = createMeasurementSpan(this.renderer, measureContainer, "k-pager-sizes");
    const infoText = `${this.currentPage} - ${this.maxItems} ${this.localization.get("of")} ${this.total} ${this.localization.get("items")}`;
    this.renderer.setProperty(infoSpan, "textContent", infoText);
    this.renderer.setProperty(pageSpan, "textContent", this.localization.get("page"));
    this.renderer.setProperty(sizesSpan, "textContent", this.localization.get("itemsPerPage"));
    if (existingInfo) copyComputedStyles(this.renderer, existingInfo, infoSpan);
    if (existingInput) copyComputedStyles(this.renderer, existingInput, pageSpan);
    if (existingSizes) copyComputedStyles(this.renderer, existingSizes, sizesSpan);
    measureContainer.getBoundingClientRect();
    this.pagerDimensions.infoTextWidth = infoSpan?.offsetWidth;
    if (this.pagerDimensions.inputWidth && this.pagerDimensions.pageTextWidth) {
      this.pagerDimensions.inputWidth = this.pagerDimensions.inputWidth - this.pagerDimensions.pageTextWidth + pageSpan.offsetWidth;
    }
    this.pagerDimensions.pageTextWidth = pageSpan?.offsetWidth;
    if (this.pagerDimensions.pageSizesWidth && this.pagerDimensions.sizesTextWidth) {
      this.pagerDimensions.pageSizesWidth = this.pagerDimensions.pageSizesWidth - this.pagerDimensions.sizesTextWidth + sizesSpan.offsetWidth;
    }
    this.pagerDimensions.sizesTextWidth = sizesSpan?.offsetWidth;
    this.renderer.removeChild(this.element.nativeElement, measureContainer);
  }
  showNumericButtonsResponsive() {
    if (!isDocumentAvailable() || !this.element?.nativeElement) {
      return;
    }
    const numericButtonsElement = this.element.nativeElement.querySelector("kendo-datapager-numeric-buttons, kendo-pager-numeric-buttons");
    const hasNumericButtons = this.numericButtons || numericButtonsElement;
    const hasInput = this.pagerInput || this.element.nativeElement.querySelector(".k-pager-input");
    if (!this.responsive || !hasNumericButtons && !hasInput) {
      this.showInput = this.type === "input";
      return;
    }
    const pagerInfoElement = this.element.nativeElement.querySelector(".k-pager-info");
    if (this.type === "input" || !this.isElementVisible(pagerInfoElement)) {
      this.showInput = true;
      return;
    }
    if (this.isElementVisible(numericButtonsElement)) {
      this.showInput = false;
      return;
    }
    const pagerWidth = this.element.nativeElement?.offsetWidth;
    const numericButtonsWrapperElement = this.element.nativeElement.querySelector(".k-pager-numbers-wrap");
    const elementsWidths = numericButtonsWrapperElement?.offsetWidth + this.pagerDimensions.pageSizesWidth + this.pagerDimensions.infoTextWidth + this.pagerDimensions.gapSizesInfo;
    const hasAvailableWidth = pagerWidth > elementsWidths - this.pagerDimensions.inputWidth + this.pagerDimensions.numericButtonsWidth;
    this.showInput = !hasAvailableWidth;
  }
  get showPageSizes() {
    if (typeof this.pageSizeValues === "boolean") {
      return this.pageSizeValues;
    }
    return this.pageSizeValues?.length > 0;
  }
  static ɵfac = function PagerComponent_Factory(t) {
    return new (t || _PagerComponent)(ɵɵdirectiveInject(PagerContextService, 12), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerNavigationService, 12));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerComponent,
    selectors: [["kendo-datapager"], ["kendo-pager"]],
    contentQueries: function PagerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PagerTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t);
      }
    },
    viewQuery: function PagerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PagerNumericButtonsComponent, 5, ElementRef);
        ɵɵviewQuery(PagerInputComponent, 5, ElementRef);
        ɵɵviewQuery(PagerInputComponent, 5);
        ɵɵviewQuery(PagerPageSizesComponent, 5, ElementRef);
        ɵɵviewQuery(PagerPageSizesComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numericButtons = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pagerInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pagerInputComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageSizes = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageSizesComponent = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function PagerComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focusin", function PagerComponent_focusin_HostBindingHandler($event) {
          return ctx.focusHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.widgetRole)("aria-roledescription", ctx.roleDescription)("aria-keyshortcuts", ctx.keyShortcuts)("tabindex", ctx.hostTabindex)("dir", ctx.dir);
        ɵɵclassProp("k-pager", ctx.pagerClass)("k-pager-responsive", ctx.responsiveClass);
      }
    },
    inputs: {
      externalTemplate: "externalTemplate",
      total: "total",
      skip: "skip",
      pageSize: "pageSize",
      buttonCount: "buttonCount",
      info: "info",
      type: "type",
      pageSizeValues: "pageSizeValues",
      previousNext: "previousNext",
      navigable: "navigable",
      size: "size",
      responsive: "responsive",
      adaptiveMode: "adaptiveMode"
    },
    outputs: {
      pageChange: "pageChange",
      pageSizeChange: "pageSizeChange",
      pagerInputVisibilityChange: "pagerInputVisibilityChange",
      pageTextVisibilityChange: "pageTextVisibilityChange",
      itemsTextVisibilityChange: "itemsTextVisibilityChange"
    },
    exportAs: ["kendoDataPager", "kendoPager"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, PagerContextService, PagerNavigationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.pager"
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 6,
    vars: 4,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_0 = goog.getMsg("Go to the first page");
        i18n_0 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.pager.firstPage|The label for the first page button in the Pager:Go to the first page`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_1 = goog.getMsg("Go to the previous page");
        i18n_1 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.pager.previousPage|The label for the previous page button in the Pager:Go to the previous page`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_2 = goog.getMsg("Go to the next page");
        i18n_2 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.pager.nextPage|The label for the next page button in the Pager:Go to the next page`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_3 = goog.getMsg("Go to the last page");
        i18n_3 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.pager.lastPage|The label for the last page button in the Pager:Go to the last page`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_4 = goog.getMsg("Page");
        i18n_4 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.pager.page|The label before the current page number in the Pager:Page`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_5 = goog.getMsg("of");
        i18n_5 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.pager.of|The label before the total pages number in the Pager:of`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_6 = goog.getMsg("Page Number");
        i18n_6 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.pager.pageNumberInputTitle|The label for the pager input in the Pager:Page Number`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_7 = goog.getMsg("items");
        i18n_7 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.pager.items|The label after the total pages number in the Pager:items`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_8 = goog.getMsg("items per page");
        i18n_8 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.pager.itemsPerPage|The label for the page size chooser in the Pager:items per page`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_9 = goog.getMsg("Select page");
        i18n_9 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.pager.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Pager:Select page`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_10 = goog.getMsg("Type a page number");
        i18n_10 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.pager.inputLabel|The text of the aria-label attribute applied to the input element for entering the page number.:Type a page number`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_11 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Page navigation, page {currentPage} of {totalPages}' }}"
          }
        });
        i18n_11 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_PAGER_FESM2022_PROGRESS_KENDO_ANGULAR_PAGER_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.pager.ariaLabel|The value of the aria-label attribute of the Pager:${"�0�"}:INTERPOLATION:`;
      }
      return [["default", ""], ["ariaLabel", i18n_11], ["kendoPagerLocalizedMessages", "", "firstPage", i18n_0, "previousPage", i18n_1, "nextPage", i18n_2, "lastPage", i18n_3, "page", i18n_4, "of", i18n_5, "pageNumberInputTitle", i18n_6, "items", i18n_7, "itemsPerPage", i18n_8, "selectPage", i18n_9, "inputLabel", i18n_10, 6, "ariaLabel"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], [3, "resize", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-pager-numbers-wrap", 3, "ngStyle"], [3, "size", 4, "ngIf"], [3, "size", "buttonCount", 4, "ngIf"], [3, "ngStyle", "size", "pageSizes", "adaptiveMode", 4, "ngIf"], [3, "ngStyle", 4, "ngIf"], [3, "size"], [3, "size", "buttonCount"], [3, "ngStyle", "size", "pageSizes", "adaptiveMode"], [3, "ngStyle"], [3, "resize"]];
    },
    template: function PagerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 2);
        ɵɵi18nAttributes(1, 1);
        ɵɵelementContainerEnd();
        ɵɵtemplate(2, PagerComponent_ng_container_2_Template, 1, 2, "ng-container", 3)(3, PagerComponent_ng_template_3_Template, 7, 9, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, PagerComponent_kendo_resize_sensor_5_Template, 1, 0, "kendo-resize-sensor", 4);
      }
      if (rf & 2) {
        const default_r3 = ɵɵreference(4);
        ɵɵi18nExp("Page navigation, page {currentPage} of {totalPages}");
        ɵɵi18nApply(1);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.template.first == null ? null : ctx.template.first.templateRef)("ngIfElse", default_r3);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.responsive);
      }
    },
    dependencies: [LocalizedMessagesDirective, NgIf, NgTemplateOutlet, PagerPrevButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerNextButtonsComponent, PagerPageSizesComponent, PagerInfoComponent, ResizeSensorComponent, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-datapager, kendo-pager",
      exportAs: "kendoDataPager, kendoPager",
      providers: [LocalizationService, PagerContextService, PagerNavigationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.pager"
      }],
      template: `
        <ng-container kendoPagerLocalizedMessages
            i18n-ariaLabel="kendo.pager.ariaLabel|The value of the aria-label attribute of the Pager"
            ariaLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

            i18n-firstPage="kendo.pager.firstPage|The label for the first page button in the Pager"
            firstPage="Go to the first page"

            i18n-previousPage="kendo.pager.previousPage|The label for the previous page button in the Pager"
            previousPage="Go to the previous page"

            i18n-nextPage="kendo.pager.nextPage|The label for the next page button in the Pager"
            nextPage="Go to the next page"

            i18n-lastPage="kendo.pager.lastPage|The label for the last page button in the Pager"
            lastPage="Go to the last page"

            i18n-page="kendo.pager.page|The label before the current page number in the Pager"
            page="Page"

            i18n-of="kendo.pager.of|The label before the total pages number in the Pager"
            of="of"

            i18n-pageNumberInputTitle="kendo.pager.pageNumberInputTitle|The label for the pager input in the Pager"
            pageNumberInputTitle="Page Number"

            i18n-items="kendo.pager.items|The label after the total pages number in the Pager"
            items="items"

            i18n-itemsPerPage="kendo.pager.itemsPerPage|The label for the page size chooser in the Pager"
            itemsPerPage="items per page"

            i18n-selectPage="kendo.pager.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Pager"
            selectPage="Select page"

            i18n-inputLabel="kendo.pager.inputLabel|The text of the aria-label attribute applied to the input element for entering the page number."
            inputLabel="Type a page number"
         >
        </ng-container>
        <ng-container
            *ngIf="template.first?.templateRef; else default"
            [ngTemplateOutlet]="template.first?.templateRef"
            [ngTemplateOutletContext]="templateContext">
        </ng-container>
        <ng-template #default>
            <div class="k-pager-numbers-wrap" [ngStyle]="{opacity: initialized ? null : '0'}">
                <kendo-pager-prev-buttons [size]="size" *ngIf="previousNext"></kendo-pager-prev-buttons>
                <kendo-pager-numeric-buttons
                    [size]="size"
                    *ngIf="type === 'numeric' && buttonCount > 0"
                    [buttonCount]="buttonCount">
                </kendo-pager-numeric-buttons>
                <kendo-pager-input [size]="size" *ngIf="showInput"></kendo-pager-input>
                <kendo-pager-next-buttons [size]="size" *ngIf="previousNext"></kendo-pager-next-buttons>
            </div>
            <kendo-pager-page-sizes *ngIf="_pageSizeValues.length"
                [ngStyle]="{opacity: initialized ? null : '0'}"
                [size]="size"
                [pageSizes]="_pageSizeValues"
                [adaptiveMode]="adaptiveMode">
            </kendo-pager-page-sizes>
            <kendo-pager-info *ngIf="info" [ngStyle]="{opacity: initialized ? null : '0'}">
            </kendo-pager-info>
        </ng-template>
        <kendo-resize-sensor *ngIf="responsive" (resize)="resizeHandler()"></kendo-resize-sensor>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective, NgIf, NgTemplateOutlet, PagerPrevButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerNextButtonsComponent, PagerPageSizesComponent, PagerInfoComponent, ResizeSensorComponent, NgStyle]
    }]
  }], function() {
    return [{
      type: PagerContextService,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerNavigationService,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }];
  }, {
    template: [{
      type: ContentChildren,
      args: [PagerTemplateDirective]
    }],
    numericButtons: [{
      type: ViewChild,
      args: [PagerNumericButtonsComponent, {
        read: ElementRef
      }]
    }],
    pagerInput: [{
      type: ViewChild,
      args: [PagerInputComponent, {
        read: ElementRef
      }]
    }],
    pagerInputComponent: [{
      type: ViewChild,
      args: [PagerInputComponent]
    }],
    pageSizes: [{
      type: ViewChild,
      args: [PagerPageSizesComponent, {
        read: ElementRef
      }]
    }],
    pageSizesComponent: [{
      type: ViewChild,
      args: [PagerPageSizesComponent]
    }],
    externalTemplate: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    buttonCount: [{
      type: Input
    }],
    info: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    pageSizeValues: [{
      type: Input
    }],
    previousNext: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    pageChange: [{
      type: Output
    }],
    pageSizeChange: [{
      type: Output
    }],
    pagerInputVisibilityChange: [{
      type: Output
    }],
    pageTextVisibilityChange: [{
      type: Output
    }],
    itemsTextVisibilityChange: [{
      type: Output
    }],
    pagerClass: [{
      type: HostBinding,
      args: ["class.k-pager"]
    }],
    responsiveClass: [{
      type: HostBinding,
      args: ["class.k-pager-responsive"]
    }],
    widgetRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    roleDescription: [{
      type: HostBinding,
      args: ["attr.aria-roledescription"]
    }],
    keyShortcuts: [{
      type: HostBinding,
      args: ["attr.aria-keyshortcuts"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    focusHandler: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }]
  });
})();
var PagerSpacerComponent = class _PagerSpacerComponent {
  hostClass = true;
  get sizedClass() {
    return isPresent(this.width);
  }
  get flexBasisStyle() {
    return this.width;
  }
  /**
   * Specifies the width of the PagerSpacer.
   * Accepts the [string values of the CSS `flex-basis` property](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis).
   *
   * If not set, the PagerSpacer will take all the available space.
   */
  width;
  static ɵfac = function PagerSpacerComponent_Factory(t) {
    return new (t || _PagerSpacerComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PagerSpacerComponent,
    selectors: [["kendo-pager-spacer"]],
    hostVars: 6,
    hostBindings: function PagerSpacerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("flex-basis", ctx.flexBasisStyle);
        ɵɵclassProp("k-spacer", ctx.hostClass)("k-spacer-sized", ctx.sizedClass);
      }
    },
    inputs: {
      width: "width"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function PagerSpacerComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerSpacerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pager-spacer",
      template: ``,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-spacer"]
    }],
    sizedClass: [{
      type: HostBinding,
      args: ["class.k-spacer-sized"]
    }],
    flexBasisStyle: [{
      type: HostBinding,
      args: ["style.flexBasis"]
    }],
    width: [{
      type: Input
    }]
  });
})();
var KENDO_PAGER = [CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent];
var PagerModule = class _PagerModule {
  static ɵfac = function PagerModule_Factory(t) {
    return new (t || _PagerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PagerModule,
    imports: [CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent],
    exports: [CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService],
    imports: [PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_PAGER],
      imports: [...KENDO_PAGER],
      providers: [IconsService, PopupService, ResizeBatchService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-date-math/dist/es/clone-date.js
var cloneDate = function(date2) {
  return date2 ? new Date(date2.getTime()) : null;
};

// node_modules/@progress/kendo-date-math/dist/es/adjust-dst.js
var adjustDST = function(date2, hour) {
  var newDate = cloneDate(date2);
  if (hour === 0 && newDate.getHours() === 23) {
    newDate.setHours(newDate.getHours() + 2);
  }
  return newDate;
};

// node_modules/@progress/kendo-date-math/dist/es/add-days.js
var addDays = function(date2, offset3) {
  var newDate = cloneDate(date2);
  newDate.setDate(newDate.getDate() + offset3);
  return adjustDST(newDate, date2.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/create-date.js
var createDate = function(year, month, day, hours, minutes, seconds, milliseconds) {
  if (hours === void 0) {
    hours = 0;
  }
  if (minutes === void 0) {
    minutes = 0;
  }
  if (seconds === void 0) {
    seconds = 0;
  }
  if (milliseconds === void 0) {
    milliseconds = 0;
  }
  var date2 = new Date(year, month, day, hours, minutes, seconds, milliseconds);
  if (year > -1 && year < 100) {
    date2.setFullYear(date2.getFullYear() - 1900);
  }
  return adjustDST(date2, hours);
};

// node_modules/@progress/kendo-date-math/dist/es/last-day-of-month.js
var lastDayOfMonth = function(date2) {
  var newDate = createDate(date2.getFullYear(), date2.getMonth() + 1, 1, date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds());
  return addDays(newDate, -1);
};

// node_modules/@progress/kendo-date-math/dist/es/add-months.js
var MONTHS_LENGTH = 12;
var normalize = function(date2, expectedMonth) {
  return date2.getMonth() !== expectedMonth ? lastDayOfMonth(addMonths(date2, -1)) : date2;
};
var addMonths = function(date2, offset3) {
  var newDate = cloneDate(date2);
  var diff = (newDate.getMonth() + offset3) % MONTHS_LENGTH;
  var expectedMonth = (MONTHS_LENGTH + diff) % MONTHS_LENGTH;
  newDate.setMonth(newDate.getMonth() + offset3);
  return normalize(adjustDST(newDate, date2.getHours()), expectedMonth);
};

// node_modules/@progress/kendo-date-math/dist/es/set-year.js
var setYear = function(value, year) {
  var month = value.getMonth();
  var candidate = createDate(year, month, value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
  return candidate.getMonth() === month ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};

// node_modules/@progress/kendo-date-math/dist/es/add-years.js
var addYears = function(value, offset3) {
  return adjustDST(setYear(value, value.getFullYear() + offset3), value.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/add-centuries.js
var addCenturies = function(value, offset3) {
  return addYears(value, 100 * offset3);
};

// node_modules/@progress/kendo-date-math/dist/es/add-decades.js
var addDecades = function(value, offset3) {
  return addYears(value, 10 * offset3);
};

// node_modules/@progress/kendo-date-math/dist/es/add-weeks.js
var addWeeks = function(date2, offset3) {
  return addDays(date2, offset3 * 7);
};

// node_modules/@progress/kendo-date-math/dist/es/constants.js
var MS_PER_MINUTE = 6e4;
var MS_PER_HOUR = 36e5;
var MS_PER_DAY = 864e5;

// node_modules/@progress/kendo-date-math/dist/es/direction.enum.js
var Direction;
(function(Direction3) {
  Direction3[Direction3["Forward"] = 1] = "Forward";
  Direction3[Direction3["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));

// node_modules/@progress/kendo-date-math/dist/es/day-of-week.js
var dayOfWeek = function(date2, weekDay, direction) {
  if (direction === void 0) {
    direction = Direction.Forward;
  }
  var newDate = cloneDate(date2);
  var newDay = (weekDay - newDate.getDay() + 7 * direction) % 7;
  newDate.setDate(newDate.getDate() + newDay);
  return adjustDST(newDate, date2.getHours());
};

// node_modules/@progress/kendo-date-math/dist/es/day.enum.js
var Day;
(function(Day2) {
  Day2[Day2["Sunday"] = 0] = "Sunday";
  Day2[Day2["Monday"] = 1] = "Monday";
  Day2[Day2["Tuesday"] = 2] = "Tuesday";
  Day2[Day2["Wednesday"] = 3] = "Wednesday";
  Day2[Day2["Thursday"] = 4] = "Thursday";
  Day2[Day2["Friday"] = 5] = "Friday";
  Day2[Day2["Saturday"] = 6] = "Saturday";
})(Day || (Day = {}));

// node_modules/@progress/kendo-date-math/dist/es/normalize-year.js
var normalizeYear = function(value, year) {
  return setYear(value, year(value.getFullYear()));
};

// node_modules/@progress/kendo-date-math/dist/es/first-decade-of-century.js
var firstDecadeOfCentury = function(value) {
  return normalizeYear(value, function(y) {
    return y - y % 100;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-centuries.js
var durationInCenturies = function(start, end2) {
  return (firstDecadeOfCentury(end2).getFullYear() - firstDecadeOfCentury(start).getFullYear()) / 100;
};

// node_modules/@progress/kendo-date-math/dist/es/first-year-of-decade.js
var firstYearOfDecade = function(value) {
  return normalizeYear(value, function(y) {
    return y - y % 10;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-decades.js
var durationInDecades = function(start, end2) {
  return (firstYearOfDecade(end2).getFullYear() - firstYearOfDecade(start).getFullYear()) / 10;
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-months.js
var durationInMonths = function(start, end2) {
  return (end2.getFullYear() - start.getFullYear()) * 12 + (end2.getMonth() - start.getMonth());
};

// node_modules/@progress/kendo-date-math/dist/es/duration-in-years.js
var durationInYears = function(start, end2) {
  return end2.getFullYear() - start.getFullYear();
};

// node_modules/@progress/kendo-date-math/dist/es/first-day-of-month.js
var firstDayOfMonth = function(date2) {
  return createDate(date2.getFullYear(), date2.getMonth(), 1, date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds());
};

// node_modules/@progress/kendo-date-math/dist/es/set-month.js
var setMonth = function(value, month) {
  var day = value.getDate();
  var candidate = createDate(value.getFullYear(), month, day, value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
  return candidate.getDate() === day ? candidate : lastDayOfMonth(addMonths(candidate, -1));
};

// node_modules/@progress/kendo-date-math/dist/es/first-month-of-year.js
var firstMonthOfYear = function(value) {
  return setMonth(value, 0);
};

// node_modules/@progress/kendo-date-math/dist/es/get-date.js
var getDate = function(date2) {
  return createDate(date2.getFullYear(), date2.getMonth(), date2.getDate(), 0, 0, 0);
};

// node_modules/@progress/kendo-date-math/dist/es/is-equal.js
var isEqual = function(candidate, expected) {
  if (!candidate && !expected) {
    return true;
  }
  return candidate && expected && candidate.getTime() === expected.getTime();
};

// node_modules/@progress/kendo-date-math/dist/es/last-decade-of-century.js
var lastDecadeOfCentury = function(value) {
  return normalizeYear(value, function(y) {
    return y - y % 100 + 90;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/last-month-of-year.js
var lastMonthOfYear = function(value) {
  return setMonth(value, 11);
};

// node_modules/@progress/kendo-date-math/dist/es/last-year-of-decade.js
var lastYearOfDecade = function(value) {
  return normalizeYear(value, function(y) {
    return y - y % 10 + 9;
  });
};

// node_modules/@progress/kendo-date-math/dist/es/prev-day-of-week.js
var prevDayOfWeek = function(date2, weekDay) {
  return dayOfWeek(date2, weekDay, Direction.Backward);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/timezones.js
var timezones = {
  rules: {},
  titles: {},
  zones: {}
};

// node_modules/@progress/kendo-date-math/dist/es/tz/rule-to-date.js
var MONTHS = { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };
var DAYS = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };
var MS_PER_MINUTE2 = 6e4;
var ruleToDate = function(year, rule, zoneOffset) {
  var month = rule[3];
  var on3 = rule[4];
  var time = rule[5];
  var date2;
  var ruleOffset = time[3] === "u" ? -zoneOffset * MS_PER_MINUTE2 : 0;
  if (!isNaN(on3)) {
    date2 = new Date(Date.UTC(year, MONTHS[month], on3, time[0], time[1], time[2]) + ruleOffset);
  } else if (on3.indexOf("last") === 0) {
    date2 = new Date(Date.UTC(year, MONTHS[month] + 1, 1, time[0] - 24, time[1], time[2]) + ruleOffset);
    var targetDay = DAYS[on3.substr(4, 3)];
    var ourDay = date2.getUTCDay();
    date2.setUTCDate(date2.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));
  } else if (on3.indexOf(">=") >= 0) {
    date2 = new Date(Date.UTC(year, MONTHS[month], on3.substr(5), time[0], time[1], time[2], 0) + ruleOffset);
    var targetDay = DAYS[on3.substr(0, 3)];
    var ourDay = date2.getUTCDay();
    date2.setUTCDate(date2.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));
  }
  return date2;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/find-rule.js
var CURRENT_UTC_TIME = (/* @__PURE__ */ new Date()).getTime();
var findRule = function(zoneRule, utcTime, zoneOffset) {
  if (utcTime === void 0) {
    utcTime = CURRENT_UTC_TIME;
  }
  if (zoneOffset === void 0) {
    zoneOffset = 0;
  }
  var rules2 = timezones.rules[zoneRule];
  if (!rules2) {
    var time = zoneRule.split(":");
    var offset3 = 0;
    if (time.length > 1) {
      offset3 = time[0] * 60 + Number(time[1]);
    }
    return [-1e6, "max", "-", "Jan", 1, [0, 0, 0], offset3, "-"];
  }
  var year = new Date(utcTime).getUTCFullYear();
  rules2 = rules2.filter(function(currentRule) {
    var from2 = currentRule[0];
    var to = currentRule[1];
    return from2 <= year && (to >= year || from2 === year && to === "only" || to === "max");
  });
  rules2.push(utcTime);
  rules2.sort(function(a, b) {
    if (typeof a !== "number") {
      a = Number(ruleToDate(year, a, zoneOffset));
    }
    if (typeof b !== "number") {
      b = Number(ruleToDate(year, b, zoneOffset));
    }
    return a - b;
  });
  var rule = rules2[rules2.indexOf(utcTime) - 1] || rules2[rules2.length - 1];
  return isNaN(rule) ? rule : null;
};

// node_modules/@progress/kendo-date-math/dist/es/errors.js
var NO_TZ_INFO = "The required {0} timezone information is not provided!";
var formatRegExp = /\{(\d+)}?\}/g;
var flatten = function(arr) {
  return arr.reduce(function(a, b) {
    return a.concat(b);
  }, []);
};
var formatMessage = function(message) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var flattenValues = flatten(values);
  return message.replace(formatRegExp, function(_, index) {
    return flattenValues[parseInt(index, 10)];
  });
};

// node_modules/@progress/kendo-date-math/dist/es/tz/get-zone.js
var getZoneRules = function(timezone) {
  var zones = timezones.zones;
  if (!zones) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  var zoneRules = zones[timezone];
  var result = typeof zoneRules === "string" ? zones[zoneRules] : zoneRules;
  if (!result) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  return result;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/find-zone.js
var findZone = function(timezone, utcTime) {
  if (utcTime === void 0) {
    utcTime = (/* @__PURE__ */ new Date()).getTime();
  }
  if (timezone === "Etc/UTC" || timezone === "Etc/GMT") {
    return [0, "-", "UTC", null];
  }
  var zoneRules = getZoneRules(timezone);
  var idx2 = zoneRules.length - 1;
  for (; idx2 >= 0; idx2--) {
    var until = zoneRules[idx2][3];
    if (until && utcTime > until) {
      break;
    }
  }
  var zone = zoneRules[idx2 + 1];
  if (!zone) {
    throw new Error(formatMessage(NO_TZ_INFO, timezone));
  }
  return zone;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/zone-and-rule.js
var zoneAndRule = function(timezone, date2) {
  var utcTime = date2.getTime();
  var zone = findZone(timezone, utcTime);
  return {
    rule: findRule(zone[1], utcTime, zone[0]),
    zone
  };
};

// node_modules/@progress/kendo-date-math/dist/es/tz/pad-number.js
var padNumber = function(num, len) {
  if (len === void 0) {
    len = 2;
  }
  var sign = num < 0 ? "-" : "";
  return sign + new Array(len).concat([Math.abs(num)]).join("0").slice(-len);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/abbr-timezone.js
var abbrTimezone = function(timezone, date2) {
  if (date2 === void 0) {
    date2 = /* @__PURE__ */ new Date();
  }
  if (timezone === "Etc/UTC") {
    return "UTC";
  }
  if (timezone === "Etc/GMT") {
    return "GMT";
  }
  if (timezone === "") {
    return "";
  }
  var _a2 = zoneAndRule(timezone, date2), zone = _a2.zone, rule = _a2.rule;
  var base = zone[2];
  if (base.indexOf("/") >= 0) {
    return base.split("/")[rule && +rule[6] ? 1 : 0];
  } else if (base.indexOf("%s") >= 0) {
    return base.replace("%s", !rule || rule[7] === "-" ? "" : rule[7]);
  } else if (base.indexOf("%z") >= 0) {
    var hours = -1 * Math.trunc(zone[0] / 60);
    var hoursPart = padNumber(hours, 2);
    var signPart = hours > 0 ? "+" : "";
    var minutes = Math.abs(Math.trunc(zone[0] % 60));
    var minutesPart = minutes === 0 ? "" : padNumber(minutes, 2);
    return base.replace("%z", "" + signPart + hoursPart + minutesPart);
  }
  return base;
};

// node_modules/@progress/kendo-date-math/dist/es/tz/offset.js
var offset = function(timezone, date2) {
  if (date2 === void 0) {
    date2 = /* @__PURE__ */ new Date();
  }
  if (timezone === "Etc/UTC" || timezone === "Etc/GMT") {
    return 0;
  }
  if (timezone === "") {
    return date2.getTimezoneOffset();
  }
  var _a2 = zoneAndRule(timezone, date2), rule = _a2.rule, zone = _a2.zone;
  return parseFloat(rule ? zone[0] - rule[6] : zone[0]);
};

// node_modules/@progress/kendo-date-math/dist/es/tz/to-local-date.js
function toLocalDate(date2) {
  return new Date(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate(), date2.getUTCHours(), date2.getUTCMinutes(), date2.getUTCSeconds(), date2.getUTCMilliseconds());
}

// node_modules/@progress/kendo-date-math/dist/es/tz/zoned-date.js
var addMinutes = function(date2, minutes) {
  return new Date(date2.getTime() + minutes * MS_PER_MINUTE);
};
var addHours = function(date2, hours) {
  return new Date(date2.getTime() + hours * MS_PER_HOUR);
};
var dayAbbr = [
  "Sun",
  "Mon",
  "Tue",
  "Wed",
  "Thu",
  "Fri",
  "Sat"
];
var monthAbbr = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var datePrefix = function(utcDate) {
  return dayAbbr[utcDate.getUTCDay()] + " " + monthAbbr[utcDate.getUTCMonth()];
};
function isZoneMissingHour(date2, timezone) {
  var currentOffset = offset(timezone, date2);
  var prevHour = addHours(date2, -1);
  var prevOffset = offset(timezone, prevHour);
  return currentOffset < prevOffset;
}
function shiftZoneMissingHour(utcDate, timezone) {
  var dstOffset = isZoneMissingHour(utcDate, timezone) ? 1 : 0;
  return addHours(utcDate, dstOffset);
}
function convertTimezoneUTC(utcLocal, fromTimezone, toTimezone) {
  if (fromTimezone === toTimezone) {
    return utcLocal;
  }
  var fromOffset = offset(fromTimezone, utcLocal);
  var toOffset = offset(toTimezone, utcLocal);
  var baseDiff = fromOffset - toOffset;
  var midDate = addMinutes(utcLocal, baseDiff);
  var midOffset = offset(toTimezone, midDate);
  var dstDiff = toOffset - midOffset;
  return addMinutes(utcLocal, baseDiff + dstDiff);
}
function formatOffset(tzOffset) {
  var sign = tzOffset <= 0 ? "+" : "-";
  var value = Math.abs(tzOffset);
  var hours = padNumber(Math.floor(value / 60));
  var minutes = padNumber(value % 60);
  return "GMT" + sign + hours + minutes;
}
var ZonedDate = (
  /** @class */
  function() {
    function ZonedDate2(utcDate, timezone) {
      this._utcDate = cloneDate(utcDate);
      this.timezone = timezone;
      var tzOffset = offset(timezone, utcDate);
      this.timezoneOffset = tzOffset;
      var localDate = shiftZoneMissingHour(utcDate, timezone);
      this._localDate = convertTimezoneUTC(localDate, timezone, "Etc/UTC");
    }
    Object.defineProperty(ZonedDate2.prototype, "cachedLocalDate", {
      /**
       * Returns a cached local date that denotes the exact time in the set timezone.
       *
       * @return Date - A local date that denotes the exact time in the set timezone.
       *
       * This property is an alternative to `toLocalDate()` that returns a cached value instead of cloning it.
       *
       * > Modifying the returned instance will corrupt the `ZonedDate` state.
       */
      get: function() {
        return this._localDate;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZonedDate2.prototype, "cachedUTCDate", {
      /**
       * Returns a cached `Date` instance with UTC date parts that are set to the local time in the set timezone.
       *
       * @returns Date - A `Date` with UTC date parts that are set to the local time in the set timezone.
       *
       * This property is an alternative to `toUTCDate()` that returns a cached value instead of cloning it.
       *
       * > Modifying the returned instance will corrupt the `ZonedDate` state.
       */
      get: function() {
        return this._utcDate;
      },
      enumerable: true,
      configurable: true
    });
    ZonedDate2.fromLocalDate = function(date2, timezone) {
      if (timezone === void 0) {
        timezone = "";
      }
      var utcDate = convertTimezoneUTC(date2, "Etc/UTC", timezone);
      var shiftZone = isZoneMissingHour(utcDate, timezone);
      var zoneOffset = offset(timezone, utcDate);
      var fixedOffset = 0;
      if (shiftZone) {
        fixedOffset = zoneOffset > 0 ? -1 : 1;
      }
      var adjDate = addHours(utcDate, fixedOffset);
      return ZonedDate2.fromUTCDate(adjDate, timezone);
    };
    ZonedDate2.fromUTCDate = function(utcDate, timezone) {
      if (timezone === void 0) {
        timezone = "";
      }
      return new ZonedDate2(utcDate, timezone);
    };
    ZonedDate2.prototype.toLocalDate = function() {
      return cloneDate(this._localDate);
    };
    ZonedDate2.prototype.toUTCDate = function() {
      return cloneDate(this._utcDate);
    };
    ZonedDate2.prototype.toTimezone = function(toTimezone) {
      if (this.timezone === toTimezone) {
        return this.clone();
      }
      var tzOffset = offset(this.timezone, this._utcDate);
      var date2 = addMinutes(this._utcDate, tzOffset);
      return ZonedDate2.fromLocalDate(date2, toTimezone);
    };
    ZonedDate2.prototype.clone = function() {
      return ZonedDate2.fromUTCDate(this._utcDate, this.timezone);
    };
    ZonedDate2.prototype.addDays = function(days) {
      var newDate = new Date(this._utcDate.getTime());
      newDate.setUTCDate(newDate.getUTCDate() + days);
      return ZonedDate2.fromUTCDate(newDate, this.timezone);
    };
    ZonedDate2.prototype.addTime = function(milliseconds) {
      var utcDate = new Date(this._utcDate.getTime());
      var utcMid = shiftZoneMissingHour(utcDate, this.timezone);
      utcMid.setTime(utcMid.getTime() + milliseconds);
      var utcResult = shiftZoneMissingHour(utcMid, this.timezone);
      return ZonedDate2.fromUTCDate(utcResult, this.timezone);
    };
    ZonedDate2.prototype.stripTime = function() {
      var date2 = this._utcDate;
      var ticks = Date.UTC(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate(), 0, 0, 0);
      return ZonedDate2.fromUTCDate(new Date(ticks), this.timezone);
    };
    ZonedDate2.prototype.getTime = function() {
      return this._localDate.getTime();
    };
    ZonedDate2.prototype.getTimezoneOffset = function() {
      return this.timezoneOffset;
    };
    ZonedDate2.prototype.getFullYear = function() {
      return this._utcDate.getUTCFullYear();
    };
    ZonedDate2.prototype.getMonth = function() {
      return this._utcDate.getUTCMonth();
    };
    ZonedDate2.prototype.getDate = function() {
      return this._utcDate.getUTCDate();
    };
    ZonedDate2.prototype.getDay = function() {
      return this._utcDate.getUTCDay();
    };
    ZonedDate2.prototype.getHours = function() {
      return this._utcDate.getUTCHours();
    };
    ZonedDate2.prototype.getMinutes = function() {
      return this._utcDate.getUTCMinutes();
    };
    ZonedDate2.prototype.getSeconds = function() {
      return this._utcDate.getUTCSeconds();
    };
    ZonedDate2.prototype.getMilliseconds = function() {
      return this._utcDate.getUTCMilliseconds();
    };
    ZonedDate2.prototype.getUTCDate = function() {
      return this._localDate.getUTCDate();
    };
    ZonedDate2.prototype.getUTCDay = function() {
      return this._localDate.getUTCDay();
    };
    ZonedDate2.prototype.getUTCFullYear = function() {
      return this._localDate.getUTCFullYear();
    };
    ZonedDate2.prototype.getUTCHours = function() {
      return this._localDate.getUTCHours();
    };
    ZonedDate2.prototype.getUTCMilliseconds = function() {
      return this._localDate.getUTCMilliseconds();
    };
    ZonedDate2.prototype.getUTCMinutes = function() {
      return this._localDate.getUTCMinutes();
    };
    ZonedDate2.prototype.getUTCMonth = function() {
      return this._localDate.getUTCMonth();
    };
    ZonedDate2.prototype.getUTCSeconds = function() {
      return this._localDate.getUTCSeconds();
    };
    ZonedDate2.prototype.setTime = function(time) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMilliseconds = function(ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMilliseconds = function(ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setSeconds = function(sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCSeconds = function(sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMinutes = function(min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMinutes = function(min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setHours = function(hours, min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCHours = function(hours, min, sec, ms) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setDate = function(date2) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCDate = function(date2) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setMonth = function(month, date2) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCMonth = function(month, date2) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setFullYear = function(year, month, date2) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.setUTCFullYear = function(year, month, date2) {
      throw new Error("Method not implemented.");
    };
    ZonedDate2.prototype.toISOString = function() {
      return this._localDate.toISOString();
    };
    ZonedDate2.prototype.toJSON = function() {
      return this._localDate.toJSON();
    };
    ZonedDate2.prototype.toString = function() {
      var dateString = datePrefix(this._utcDate);
      var timeString = this.toTimeString();
      return dateString + " " + this.getDate() + " " + this.getFullYear() + " " + timeString;
    };
    ZonedDate2.prototype.toDateString = function() {
      return toLocalDate(this._utcDate).toDateString();
    };
    ZonedDate2.prototype.toTimeString = function() {
      var hours = padNumber(this.getHours());
      var minutes = padNumber(this.getMinutes());
      var seconds = padNumber(this.getSeconds());
      var time = hours + ":" + minutes + ":" + seconds;
      var tzOffset = formatOffset(this.timezoneOffset);
      var abbrev = abbrTimezone(this.timezone, this._utcDate);
      if (abbrev) {
        abbrev = " (" + abbrev + ")";
      }
      return time + " " + tzOffset + abbrev;
    };
    ZonedDate2.prototype.toLocaleString = function(locales, options) {
      return this._localDate.toLocaleString(locales, options);
    };
    ZonedDate2.prototype.toLocaleDateString = function(locales, options) {
      return this._localDate.toLocaleDateString(locales, options);
    };
    ZonedDate2.prototype.toLocaleTimeString = function(locales, options) {
      return this._localDate.toLocaleTimeString(locales, options);
    };
    ZonedDate2.prototype.toUTCString = function() {
      return this.toTimezone("Etc/UTC").toString();
    };
    ZonedDate2.prototype[Symbol.toPrimitive] = function(hint) {
      if (hint === "string" || hint === "default") {
        return this.toString();
      }
      return this._localDate.getTime();
    };
    ZonedDate2.prototype.valueOf = function() {
      return this.getTime();
    };
    ZonedDate2.prototype.getVarDate = function() {
      throw new Error("Not implemented.");
    };
    ZonedDate2.prototype.format = function(_) {
      throw new Error("Not implemented.");
    };
    ZonedDate2.prototype.formatUTC = function(_) {
      throw new Error("Not implemented.");
    };
    return ZonedDate2;
  }()
);

// node_modules/@progress/kendo-date-math/dist/es/week-in-year.js
var moveDateToWeekStart = function(date2, weekStartDay) {
  if (weekStartDay !== Day.Monday) {
    return addDays(prevDayOfWeek(date2, weekStartDay), 4);
  }
  return addDays(date2, 4 - (date2.getDay() || 7));
};
var calcWeekInYear = function(date2, weekStartDay) {
  var firstWeekInYear = createDate(date2.getFullYear(), 0, 1, -6);
  var newDate = moveDateToWeekStart(date2, weekStartDay);
  var diffInMS = newDate.getTime() - firstWeekInYear.getTime();
  var days = Math.floor(diffInMS / MS_PER_DAY);
  return 1 + Math.floor(days / 7);
};
var weekInYear = function(date2, weekStartDay) {
  if (weekStartDay === void 0) {
    weekStartDay = Day.Monday;
  }
  date2 = getDate(date2);
  var prevWeekDate = addDays(date2, -7);
  var nextWeekDate = addDays(date2, 7);
  var weekNumber = calcWeekInYear(date2, weekStartDay);
  if (weekNumber === 0) {
    return calcWeekInYear(prevWeekDate, weekStartDay) + 1;
  }
  if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {
    return 1;
  }
  return weekNumber;
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/mask.js
var Mask = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mask2() {
      this.symbols = "";
      this.partMap = [];
    }
    return Mask2;
  }()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/constants.js
var Constants = {
  formatSeparator: "_",
  twoDigitYearMax: 68,
  defaultDateFormat: "d",
  defaultLocaleId: "en"
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/key.js
var Key = {
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  SPACE: " ",
  END: "End",
  HOME: "Home",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/utils.js
var padZero = function(length2) {
  return new Array(Math.max(length2, 0)).fill("0").join("");
};
var unpadZero = function(value) {
  return value.replace(/^0*/, "");
};
var approximateStringMatching = function(_a2) {
  var oldText = _a2.oldText, newText = _a2.newText, formatPattern = _a2.formatPattern, selectionStart = _a2.selectionStart, isInCaretMode = _a2.isInCaretMode, keyEvent = _a2.keyEvent;
  var oldIndex = selectionStart + oldText.length - newText.length;
  var oldTextSeparator = oldText[oldIndex];
  var oldSegmentText = oldText.substring(0, oldIndex);
  var newSegmentText = newText.substring(0, selectionStart);
  var diff = [];
  if (oldSegmentText === newSegmentText && selectionStart > 0) {
    diff.push([formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]);
    return diff;
  }
  if (oldSegmentText.indexOf(newSegmentText) === 0 && (isInCaretMode && (keyEvent.key === Key.DELETE || keyEvent.key === Key.BACKSPACE)) || oldSegmentText.indexOf(newSegmentText) === 0 && !isInCaretMode && (newSegmentText.length === 0 || formatPattern[newSegmentText.length - 1] !== formatPattern[newSegmentText.length])) {
    var deletedSymbol = "";
    if (!isInCaretMode && newSegmentText.length === 1) {
      diff.push([formatPattern[0], newSegmentText[0]]);
    }
    for (var i = newSegmentText.length; i < oldSegmentText.length; i++) {
      if (formatPattern[i] !== deletedSymbol && formatPattern[i] !== Constants.formatSeparator) {
        deletedSymbol = formatPattern[i];
        diff.push([deletedSymbol, ""]);
      }
    }
    return diff;
  }
  if (isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator) || !isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator)) {
    var symbol = formatPattern[0];
    for (var i = Math.max(0, oldSegmentText.length - 1); i < formatPattern.length; i++) {
      if (formatPattern[i] !== Constants.formatSeparator) {
        symbol = formatPattern[i];
        break;
      }
    }
    return [[symbol, newSegmentText[selectionStart - 1]]];
  }
  if (newSegmentText[newSegmentText.length - 1] === " " || newSegmentText[newSegmentText.length - 1] === oldTextSeparator && formatPattern[oldIndex] === "_") {
    return [[formatPattern[selectionStart - 1], Constants.formatSeparator]];
  }
  var result = [[formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]];
  return result;
};
var dateSymbolMap = function(map3, part) {
  map3[part.pattern[0]] = part.type;
  return map3;
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/utils.js
var dateSetter = function(method) {
  return function(date2, value) {
    var clone = cloneDate(date2);
    clone[method](value);
    return clone;
  };
};
var isPresent2 = function(value) {
  return value !== void 0 && value !== null;
};
var isDocumentAvailable2 = function() {
  return !!document;
};
var isNumber = function(value) {
  return isPresent2(value) && typeof value === "number" && !Number.isNaN(value);
};
var parseToInt = function(value) {
  return parseInt(value, 10);
};
var isParseableToInt = function(value) {
  return isNumber(parseToInt(value)) && /^[0-9]+$/.test(value);
};
var clamp = function(value, min, max) {
  return Math.min(max, Math.max(min, value));
};
var extend = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return Object.assign.apply(Object, args);
};
var isFunction = function(fn) {
  return typeof fn === "function";
};
var cropTwoDigitYear = function(date2) {
  if (!isPresent2(date2) || isNaN(date2.getTime())) {
    return 0;
  }
  return Number(date2.getFullYear().toString().slice(-2));
};
var setYears = dateSetter("setFullYear");
var millisecondDigitsInFormat = function(format) {
  var result = format && format.match(/S+(\1)/);
  return result ? result[0].length : 0;
};
var millisecondStepFor = function(digits) {
  return Math.pow(10, 3 - digits);
};
var areDatePartsEqualTo = function(date2, year, month, day, hour, minutes, seconds, milliseconds) {
  if (date2 && date2.getFullYear() === year && date2.getMonth() === month && date2.getDate() === day && date2.getHours() === hour && date2.getMinutes() === minutes && date2.getSeconds() === seconds && date2.getMilliseconds() === milliseconds) {
    return true;
  }
  return false;
};
var isValidDate = function(value) {
  return isPresent2(value) && value.getTime && isNumber(value.getTime());
};
var isIOS = function() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) || navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /Macintosh/i.test(navigator.userAgent);
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/dateobject.js
var MONTH_INDEX_FEBRUARY = 1;
var DEFAULT_LEAP_YEAR = 2e3;
var PREVIOUS_CENTURY_BASE = 1900;
var CURRENT_CENTURY_BASE = 2e3;
var SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;
var MONTH_PART_WITH_WORDS_THRESHOLD = 2;
var MONTH_SYMBOL = "M";
var JS_MONTH_OFFSET = 1;
var DateObject = (
  /** @class */
  function() {
    function DateObject2(_a2) {
      var intlService = _a2.intlService, formatPlaceholder = _a2.formatPlaceholder, format = _a2.format, _b = _a2.cycleTime, cycleTime = _b === void 0 ? false : _b, _c = _a2.twoDigitYearMax, twoDigitYearMax = _c === void 0 ? Constants.twoDigitYearMax : _c, _d = _a2.value, value = _d === void 0 ? null : _d, _e = _a2.autoCorrectParts, autoCorrectParts = _e === void 0 ? true : _e, _f = _a2.toggleDayPeriod, toggleDayPeriod = _f === void 0 ? false : _f, _g = _a2.autoSwitchParts, autoSwitchParts = _g === void 0 ? true : _g;
      this.year = true;
      this.month = true;
      this.date = true;
      this.hours = true;
      this.minutes = true;
      this.seconds = true;
      this.milliseconds = true;
      this.dayperiod = true;
      this.leadingZero = null;
      this.typedMonthPart = "";
      this.knownParts = "adHhmMsEyS";
      this.symbols = {
        "E": "E",
        "H": "H",
        "M": "M",
        "a": "a",
        "d": "d",
        "h": "h",
        "m": "m",
        "s": "s",
        "y": "y",
        "S": "S"
      };
      this._value = this.getDefaultDate();
      this.cycleTime = false;
      this._partiallyInvalidDate = {
        startDate: null,
        invalidDateParts: {
          "E": { value: null, date: null, startDateOffset: 0 },
          "H": { value: null, date: null, startDateOffset: 0 },
          "M": { value: null, date: null, startDateOffset: 0 },
          "a": { value: null, date: null, startDateOffset: 0 },
          "d": { value: null, date: null, startDateOffset: 0 },
          "h": { value: null, date: null, startDateOffset: 0 },
          "m": { value: null, date: null, startDateOffset: 0 },
          "s": { value: null, date: null, startDateOffset: 0 },
          "y": { value: null, date: null, startDateOffset: 0 },
          "S": { value: null, date: null, startDateOffset: 0 }
        }
      };
      this.setOptions({
        intlService,
        formatPlaceholder,
        format,
        cycleTime,
        twoDigitYearMax,
        value,
        autoCorrectParts,
        toggleDayPeriod,
        autoSwitchParts
      });
      if (!value) {
        this._value = this.getDefaultDate();
        var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
        for (var i = 0; i < sampleFormat.length; i++) {
          this.setExisting(sampleFormat[i], false);
        }
      } else {
        this._value = cloneDate(value);
      }
    }
    Object.defineProperty(DateObject2.prototype, "value", {
      get: function() {
        return this._value;
      },
      set: function(value) {
        if (value && !(value instanceof Date)) {
          return;
        }
        this._value = value;
        this.resetInvalidDate();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateObject2.prototype, "localeId", {
      get: function() {
        var localeId = Constants.defaultLocaleId;
        var cldrKeys = Object.keys(this.intl.cldr);
        for (var i = 0; i < cldrKeys.length; i++) {
          var key = cldrKeys[i];
          var value = this.intl.cldr[key];
          if (value.name && value.calendar && value.numbers && value.name !== Constants.defaultLocaleId) {
            localeId = value.name;
            break;
          }
        }
        return localeId;
      },
      enumerable: false,
      configurable: true
    });
    DateObject2.prototype.setOptions = function(options) {
      this.intl = options.intlService;
      this.formatPlaceholder = options.formatPlaceholder || "wide";
      this.format = options.format;
      this.cycleTime = options.cycleTime;
      this.monthNames = this.allFormattedMonths(this.localeId);
      this.dayPeriods = this.allDayPeriods(this.localeId);
      this.twoDigitYearMax = options.twoDigitYearMax;
      this.autoCorrectParts = options.autoCorrectParts;
      this.toggleDayPeriod = options.toggleDayPeriod;
      this.autoSwitchParts = options.autoSwitchParts;
    };
    DateObject2.prototype.setValue = function(value) {
      if (!value) {
        this._value = this.getDefaultDate();
        this.modifyExisting(false);
      } else if (!isEqual(value, this._value)) {
        this._value = cloneDate(value);
        this.modifyExisting(true);
      } else if (isEqual(value, this._value) && this.dayPeriods) {
        this.setExisting("a", true);
      }
      this.resetInvalidDate();
    };
    DateObject2.prototype.hasValue = function() {
      var _this = this;
      var pred = function(a, p) {
        return a || p.type !== "literal" && p.type !== "dayperiod" && _this.getExisting(p.pattern[0]);
      };
      return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);
    };
    DateObject2.prototype.getValue = function() {
      for (var i = 0; i < this.knownParts.length; i++) {
        if (!this.getExisting(this.knownParts[i])) {
          return null;
        }
      }
      return cloneDate(this.value);
    };
    DateObject2.prototype.createDefaultDate = function() {
      return createDate(DEFAULT_LEAP_YEAR, 0, 31);
    };
    DateObject2.prototype.getDefaultDate = function() {
      return getDate(this.createDefaultDate());
    };
    DateObject2.prototype.getFormattedDate = function(format) {
      return this.intl.formatDate(this.getValue(), format, this.localeId);
    };
    DateObject2.prototype.getTextAndFormat = function(customFormat) {
      if (customFormat === void 0) {
        customFormat = "";
      }
      var format = customFormat || this.format;
      var text = this.intl.formatDate(this.value, format, this.localeId);
      var mask = this.dateFormatString(this.value, format);
      if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {
        var partiallyInvalidText = "";
        var formattedDate = this.intl.formatDate(this.value, format, this.localeId);
        var formattedDates = this.getFormattedInvalidDates(format);
        for (var i = 0; i < formattedDate.length; i++) {
          var symbol = mask.symbols[i];
          if (mask.partMap[i].type === "literal") {
            partiallyInvalidText += text[i];
          } else if (this.getInvalidDatePartValue(symbol)) {
            var partsForSegment = this.getPartsForSegment(mask, i);
            if (symbol === "M") {
              var datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
              if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                partiallyInvalidText += formattedDates[symbol][i];
              } else {
                if (this.getInvalidDatePartValue(symbol)) {
                  var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                  partiallyInvalidText += formattedDatePart;
                  i += partsForSegment.length - 1;
                } else {
                  partiallyInvalidText += formattedDates[symbol][i];
                }
              }
            } else {
              if (this.getInvalidDatePartValue(symbol)) {
                var datePartText = this.getInvalidDatePartValue(symbol).toString();
                var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                partiallyInvalidText += formattedDatePart;
                i += partsForSegment.length - 1;
              } else {
                partiallyInvalidText += formattedDates[symbol][i];
              }
            }
          } else {
            partiallyInvalidText += text[i];
          }
        }
        text = partiallyInvalidText;
      }
      var result = this.merge(text, mask);
      return result;
    };
    DateObject2.prototype.getFormattedInvalidDates = function(customFormat) {
      var _this = this;
      if (customFormat === void 0) {
        customFormat = "";
      }
      var format = customFormat || this.format;
      var formattedDatesForSymbol = {
        "E": "",
        "H": "",
        "M": "",
        "a": "",
        "d": "",
        "h": "",
        "m": "",
        "s": "",
        "y": "",
        "S": ""
      };
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        var date2 = _this.getInvalidDatePart(key).date;
        if (date2) {
          var formattedInvalidDate = _this.intl.formatDate(date2, format, _this.localeId);
          formattedDatesForSymbol[key] = formattedInvalidDate;
        }
      });
      return formattedDatesForSymbol;
    };
    DateObject2.prototype.modifyExisting = function(value) {
      var sampleFormat = this.dateFormatString(this.value, this.format).symbols;
      for (var i = 0; i < sampleFormat.length; i++) {
        this.setExisting(sampleFormat[i], value);
      }
    };
    DateObject2.prototype.getExisting = function(symbol) {
      switch (symbol) {
        case "y":
          return this.year;
        case "M":
        case "L":
          return this.month;
        case "d":
          return this.date;
        case "E":
          return this.date && this.month && this.year;
        case "h":
        case "H":
          return this.hours;
        case "t":
        case "a":
          return this.dayperiod;
        case "m":
          return this.minutes;
        case "s":
          return this.seconds;
        case "S":
          return this.milliseconds;
        default:
          return true;
      }
    };
    DateObject2.prototype.setExisting = function(symbol, value) {
      switch (symbol) {
        case "y":
          this.year = value;
          if (value === false) {
            this._value.setFullYear(DEFAULT_LEAP_YEAR);
          }
          break;
        case "M":
          this.month = value;
          if (value === false) {
            if (this.autoCorrectParts) {
              this._value.setMonth(0);
            }
          }
          break;
        case "d":
          this.date = value;
          break;
        case "h":
        case "H":
          this.hours = value;
          break;
        case "t":
        case "a":
          this.dayperiod = value;
          break;
        case "m":
          this.minutes = value;
          break;
        case "s":
          this.seconds = value;
          break;
        case "S":
          this.milliseconds = value;
          break;
        default:
          break;
      }
      if (this.getValue()) {
        this.resetInvalidDate();
      }
    };
    DateObject2.prototype.modifyPart = function(symbol, offset3) {
      if (!isPresent2(symbol) || !isPresent2(offset3) || offset3 === 0) {
        return;
      }
      var newValue = cloneDate(this.value);
      var timeModified = false;
      var invalidDateFound;
      var isMonth = symbol === "M";
      var isDay = symbol === "d" || symbol === "E";
      var symbolExists = this.getExisting(symbol);
      if (!this.autoCorrectParts && (isDay || isMonth)) {
        var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
        var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
        var year = invalidDateParts.y.value || newValue.getFullYear();
        var month = invalidDateParts.M.value || newValue.getMonth();
        var day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
        var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
        var minutes = invalidDateParts.m.value || newValue.getMinutes();
        var seconds = invalidDateParts.s.value || newValue.getSeconds();
        var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
        switch (symbol) {
          case "y":
            year += offset3;
            break;
          case "M":
            month += offset3;
            break;
          case "d":
          case "E":
            day += offset3;
            break;
          default:
            break;
        }
        if (symbol === "M") {
          if (month < 0 || month > 11) {
            if (symbolExists) {
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return;
            }
          }
          if (!symbolExists) {
            if (month < 0) {
              month = clamp(11 + (month % 11 + 1), 0, 11);
            } else {
              var monthValue = isPresent2(invalidDatePartValue) ? month : (offset3 - JS_MONTH_OFFSET) % 12;
              month = clamp(monthValue, 0, 11);
            }
            month = clamp(month, 0, 11);
          }
          month = clamp(month, 0, 11);
        } else if (symbol === "d") {
          if (symbolExists) {
            if (day <= 0 || day > 31) {
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return;
            }
          } else if (!symbolExists) {
            if (isPresent2(invalidDatePartValue)) {
              if (day <= 0 || day > 31) {
                this.setExisting(symbol, false);
                this.resetInvalidDateSymbol(symbol);
                return;
              }
            }
            if (offset3 < 0) {
              var dayValue = isPresent2(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset3 % 31));
              day = clamp(dayValue, 1, 31);
            } else {
              var dayValue = isPresent2(invalidDatePartValue) ? day : offset3 % 31;
              day = clamp(dayValue, 1, 31);
            }
            day = clamp(day, 1, 31);
          }
        }
        var dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);
        var newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) : null;
        var dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);
        if (this.getValue() && areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {
          newValue = cloneDate(dateCandidate);
          this.markDatePartsAsExisting();
        } else if (isMonth && newValueCandidate) {
          if (newValueCandidate.getMonth() === month) {
            if (this.getExisting("d")) {
              if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
              } else {
                invalidDateFound = true;
                this.setInvalidDatePart(symbol, {
                  value: month,
                  date: cloneDate(newValueCandidate),
                  startDateOffset: offset3,
                  startDate: cloneDate(this.value)
                });
                this.setExisting(symbol, false);
              }
            } else if (dateCandidateExists) {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(dateCandidate);
              if (this.getExisting("M") && this.getExisting("y")) {
                this.setExisting("d", true);
                this.resetInvalidDateSymbol("d");
              }
            } else {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(newValueCandidate);
            }
          } else {
            invalidDateFound = true;
            this.setInvalidDatePart(symbol, {
              value: month,
              date: cloneDate(newValueCandidate),
              startDateOffset: offset3,
              startDate: cloneDate(this.value)
            });
            this.setExisting(symbol, false);
          }
        } else if (isDay && newValueCandidate) {
          if (newValueCandidate.getDate() === day) {
            if (this.getExisting("M")) {
              if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
              } else {
                invalidDateFound = true;
                this.setInvalidDatePart(symbol, {
                  value: day,
                  date: cloneDate(newValueCandidate),
                  startDateOffset: offset3,
                  startDate: cloneDate(this.value)
                });
                this.setExisting(symbol, false);
              }
            } else if (dateCandidateExists) {
              newValue = cloneDate(dateCandidate);
              this.resetInvalidDateSymbol(symbol);
              if (this.getExisting("d") && this.getExisting("y")) {
                this.setExisting("M", true);
                this.resetInvalidDateSymbol("M");
              }
            } else {
              this.resetInvalidDateSymbol(symbol);
              newValue = cloneDate(newValueCandidate);
            }
          } else {
            invalidDateFound = true;
            this.setInvalidDatePart(symbol, {
              value: day,
              date: cloneDate(this.value),
              startDateOffset: offset3,
              startDate: cloneDate(this.value)
            });
            this.setExisting(symbol, false);
          }
        }
      } else {
        var hours = newValue.getHours();
        switch (symbol) {
          case "y":
            newValue.setFullYear(newValue.getFullYear() + offset3);
            break;
          case "M":
            newValue = addMonths(this.value, offset3);
            break;
          case "d":
          case "E":
            newValue.setDate(newValue.getDate() + offset3);
            break;
          case "h":
          case "H":
            newValue.setHours(newValue.getHours() + offset3);
            timeModified = true;
            break;
          case "m":
            newValue.setMinutes(newValue.getMinutes() + offset3);
            timeModified = true;
            break;
          case "s":
            newValue.setSeconds(newValue.getSeconds() + offset3);
            timeModified = true;
            break;
          case "S":
            newValue.setMilliseconds(newValue.getMilliseconds() + offset3);
            break;
          case "a":
            if (this.toggleDayPeriod) {
              newValue.setHours(hours >= 12 ? hours - 12 : hours + 12);
            } else {
              newValue.setHours(newValue.getHours() + 12 * offset3);
            }
            timeModified = true;
            break;
          default:
            break;
        }
      }
      if (this.shouldNormalizeCentury()) {
        newValue = this.normalizeCentury(newValue);
      }
      if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {
      }
      if (!invalidDateFound) {
        this.setExisting(symbol, true);
        this._value = newValue;
        if (this.getValue()) {
          this.resetInvalidDate();
        }
      }
    };
    DateObject2.prototype.parsePart = function(_a2) {
      var symbol = _a2.symbol, currentChar = _a2.currentChar, resetSegmentValue = _a2.resetSegmentValue, cycleSegmentValue = _a2.cycleSegmentValue, rawInputValue = _a2.rawTextValue, isDeleting = _a2.isDeleting, originalFormat = _a2.originalFormat;
      var isInCaretMode = !cycleSegmentValue;
      var dateParts = this.dateFormatString(this.value, this.format);
      var datePartsLiterals = dateParts.partMap.filter(function(x) {
        return x.type === "literal";
      }).map(function(x, index) {
        return {
          datePartIndex: index,
          type: x.type,
          pattern: x.pattern,
          literal: ""
        };
      });
      var flatDateParts = dateParts.partMap.map(function(x) {
        return {
          type: x.type,
          pattern: x.pattern,
          text: ""
        };
      });
      for (var i = 0; i < datePartsLiterals.length; i++) {
        var datePart = datePartsLiterals[i];
        for (var j = 0; j < datePart.pattern.length; j++) {
          if (datePartsLiterals[i + j]) {
            datePartsLiterals[i + j].literal = datePart.pattern[j];
          }
        }
        i += datePart.pattern.length - 1;
      }
      for (var i = 0; i < flatDateParts.length; i++) {
        var datePart = flatDateParts[i];
        for (var j = 0; j < datePart.pattern.length; j++) {
          if (flatDateParts[i + j]) {
            flatDateParts[i + j].text = datePart.pattern[j];
          }
        }
        i += datePart.pattern.length - 1;
      }
      var shouldResetPart = isInCaretMode && symbol === "M" && dateParts.partMap.filter(function(x) {
        return x.type === "month";
      }).some(function(x) {
        return x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD;
      });
      var parseResult = {
        value: null,
        switchToNext: false,
        resetPart: shouldResetPart,
        hasInvalidDatePart: false
      };
      if (!currentChar) {
        if (isInCaretMode) {
          for (var i = 0; i < datePartsLiterals.length; i++) {
            var literal = datePartsLiterals[i].literal;
            var rawValueStartsWithLiteral = rawInputValue.startsWith(literal);
            var rawValueEndsWithLiteral = rawInputValue.endsWith(literal);
            var rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;
            if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {
              this.resetLeadingZero();
              this.setExisting(symbol, false);
              this.resetInvalidDateSymbol(symbol);
              return extend(parseResult, { value: null, switchToNext: false });
            }
          }
        } else {
          this.resetLeadingZero();
          this.setExisting(symbol, false);
          this.resetInvalidDateSymbol(symbol);
          return extend(parseResult, { value: null, switchToNext: false });
        }
      }
      var baseDate = this.intl.formatDate(this.value, this.format, this.localeId);
      var baseFormat = dateParts.symbols;
      var replaced = false;
      var prefix2 = "";
      var current3 = "";
      var datePartText = "";
      var basePrefix = "";
      var baseSuffix = "";
      var suffix2 = "";
      var convertedBaseFormat = "";
      for (var i = 0; i < flatDateParts.length; i++) {
        convertedBaseFormat += flatDateParts[i].text;
      }
      var hasFixedFormat = this.format === baseFormat || this.format === convertedBaseFormat || this.format === originalFormat || this.format.length === originalFormat.length;
      var datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);
      var datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);
      var segmentLength = datePartEndIndex - datePartStartIndex + 1;
      var formatToTextLengthDiff = originalFormat.length - rawInputValue.length;
      if (isInCaretMode || !isInCaretMode && !this.autoCorrectParts) {
        var segmentCharIndex = 0;
        for (var i = 0; i < baseDate.length; i++) {
          if (baseFormat[i] === symbol) {
            var existing = this.getExisting(symbol);
            if (symbol === "y") {
              if (!this.hasInvalidDatePart() && this.getExisting("y")) {
                current3 += baseDate[i];
              } else {
                var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
                if (isPresent2(invalidDatePartValue)) {
                  current3 += (invalidDatePartValue || "").toString()[segmentCharIndex] || "";
                  segmentCharIndex++;
                } else {
                  current3 += existing ? baseDate[i] : "0";
                }
              }
            } else {
              current3 += existing ? baseDate[i] : "0";
            }
            if (formatToTextLengthDiff > 0) {
              if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                datePartText += rawInputValue[i] || "";
              }
            } else {
              datePartText += rawInputValue[i] || "";
            }
            replaced = true;
          } else if (!replaced) {
            prefix2 += baseDate[i];
            basePrefix += baseDate[i];
          } else {
            suffix2 += baseDate[i];
            baseSuffix += baseDate[i];
          }
        }
        if (hasFixedFormat) {
          if (convertedBaseFormat.length < rawInputValue.length) {
            datePartText += currentChar;
          } else if (!isDeleting && originalFormat.length > rawInputValue.length) {
          }
          if (datePartText.length > segmentLength) {
            return extend(parseResult, { value: null, switchToNext: false });
          }
        }
        if (!hasFixedFormat || hasFixedFormat && !this.autoCorrectParts) {
          current3 = "";
          datePartText = "";
          prefix2 = "";
          suffix2 = "";
          replaced = false;
          var segmentCharIndex_1 = 0;
          for (var i = 0; i < originalFormat.length; i++) {
            if (originalFormat[i] === symbol) {
              var existing = this.getExisting(symbol);
              if (symbol === "y") {
                if (!this.hasInvalidDatePart() && this.getExisting("y")) {
                  current3 += baseDate[i];
                } else {
                  var invalidDatePartValue = this.getInvalidDatePartValue(symbol);
                  if (isPresent2(invalidDatePartValue)) {
                    current3 += (invalidDatePartValue || "").toString()[segmentCharIndex_1] || "";
                    segmentCharIndex_1++;
                  } else {
                    current3 += existing ? baseDate[i] : "0";
                  }
                }
              } else {
                current3 += existing ? baseDate[i] || "" : "0";
              }
              if (formatToTextLengthDiff > 0) {
                if (datePartText.length + formatToTextLengthDiff < segmentLength) {
                  datePartText += rawInputValue[i] || "";
                }
              } else {
                datePartText += rawInputValue[i] || "";
              }
              replaced = true;
            } else if (!replaced) {
              prefix2 += rawInputValue[i] || "";
            } else {
              suffix2 += rawInputValue[i - formatToTextLengthDiff] || "";
            }
          }
          if (originalFormat.length < rawInputValue.length) {
            datePartText += currentChar;
          }
        }
      }
      if (!isInCaretMode) {
        if (this.autoCorrectParts) {
          current3 = "";
          datePartText = "";
          prefix2 = "";
          suffix2 = "";
          replaced = false;
          for (var i = 0; i < baseDate.length; i++) {
            if (baseFormat[i] === symbol) {
              var existing = this.getExisting(symbol);
              current3 += existing ? baseDate[i] : "0";
              replaced = true;
            } else if (!replaced) {
              prefix2 += baseDate[i];
            } else {
              suffix2 += baseDate[i];
            }
          }
        } else {
          current3 = resetSegmentValue ? datePartText : current3;
        }
      }
      var parsedDate = null;
      var monthByChar = this.matchMonth(currentChar);
      var dayPeriod = this.matchDayPeriod(currentChar, symbol);
      var isZeroCurrentChar = currentChar === "0";
      var leadingZero = this.leadingZero || {};
      if (isZeroCurrentChar) {
        if (datePartText === "0") {
          datePartText = current3;
        }
        var valueNumber = parseToInt(resetSegmentValue ? currentChar : (isInCaretMode ? datePartText : current3) + currentChar);
        if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol) && symbol !== "a") {
          this.incrementLeadingZero(symbol);
        }
      } else {
        this.resetLeadingZero();
      }
      var partPattern = this.partPattern(dateParts.partMap, symbol);
      var patternValue = partPattern ? partPattern.pattern : null;
      var patternLength = this.patternLength(patternValue) || patternValue.length;
      if (isInCaretMode) {
        if (isDeleting && !datePartText) {
          this.setExisting(symbol, false);
          return extend(parseResult, { value: null, switchToNext: false });
        }
      }
      var currentMaxLength = current3.length - 3;
      var tryParse = true;
      var middle = isInCaretMode ? datePartText : current3;
      for (var i = Math.max(0, currentMaxLength); i <= current3.length; i++) {
        if (!tryParse) {
          break;
        }
        middle = resetSegmentValue ? currentChar : isInCaretMode ? datePartText : current3.substring(i) + currentChar;
        if (this.autoSwitchParts && symbol === "h" && current3.substring(i) === "12") {
          middle = middle.replace("12", "0");
        }
        if (isInCaretMode || !this.autoCorrectParts) {
          tryParse = false;
          middle = unpadZero(middle);
          middle = padZero(patternLength - middle.length) + middle;
        }
        var middleNumber = parseInt(middle, 10);
        var candidateDateString = prefix2 + middle + suffix2;
        parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);
        if (parsedDate && this.value && dateParts.partMap.every(function(x) {
          return x.type !== "year" && x.type !== "month" && x.type != "day";
        })) {
          parsedDate.setFullYear(this.value.getFullYear());
          parsedDate.setMonth(this.value.getMonth());
          parsedDate.setDate(this.value.getDate());
        }
        var autoCorrectedPrefixAndSuffix = false;
        if (isInCaretMode && !isValidDate(parsedDate)) {
          if (this.autoCorrectParts) {
            parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
            autoCorrectedPrefixAndSuffix = true;
          }
        }
        var isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || isInCaretMode && isDeleting && currentChar === "";
        if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {
          if (symbol === MONTH_SYMBOL && !monthByChar) {
            var monthNumber = middleNumber - JS_MONTH_OFFSET;
            if (monthNumber > -1 && monthNumber < 12) {
              parsedDate = cloneDate(this.value);
              parsedDate.setMonth(monthNumber);
              if (parsedDate.getMonth() !== monthNumber) {
                parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
              }
            }
          }
          if (symbol === "y") {
            parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);
            if ((isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) && this.date && parsedDate.getDate() !== this.value.getDate()) {
              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));
            }
          }
        }
        if (isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) {
          var peekResult = this.isPeekDateOverflowingDatePart({
            useBasePrefixAndSuffix: autoCorrectedPrefixAndSuffix,
            middle,
            patternValue,
            basePrefix,
            baseSuffix,
            prefix: prefix2,
            suffix: suffix2,
            symbol,
            patternLength,
            leadingZero
          });
          var switchToNext = peekResult.switchToNext;
          if (this.shouldNormalizeCentury()) {
            parsedDate = this.normalizeCentury(parsedDate);
          }
          if (symbol === "H" && parsedDate.getHours() >= 12) {
            this.setExisting("a", true);
          }
          this._value = parsedDate;
          this.setExisting(symbol, true);
          this.resetInvalidDateSymbol(symbol);
          if (!this.autoCorrectParts) {
            if (symbol === "M") {
              if (this.getExisting("M") && this.getExisting("y")) {
                this.setExisting("d", true);
                this.resetInvalidDateSymbol("d");
              }
            } else if (symbol === "d") {
              if (this.getExisting("d") && this.getExisting("y")) {
                this.setExisting("M", true);
                this.resetInvalidDateSymbol("M");
              }
            } else if (symbol === "y") {
              this.markDatePartsAsExisting();
            }
            if (!this.hasInvalidDatePart()) {
              this.markDatePartsAsExisting();
              if (!peekResult.peekedDate && peekResult.switchToNext && !this.autoCorrectParts) {
                if (symbol === "M") {
                } else if (symbol === "d") {
                  if (peekResult.parsedPeekedValue === 30 && this.value.getMonth() === MONTH_INDEX_FEBRUARY) {
                    switchToNext = false;
                  }
                }
              }
            }
          }
          return extend(parseResult, { value: this.value, switchToNext });
        }
      }
      if (monthByChar) {
        parsedDate = this.intl.parseDate(prefix2 + monthByChar + suffix2, this.format, this.localeId);
        if (parsedDate) {
          this._value = parsedDate;
          this.setExisting(symbol, true);
          return extend(parseResult, { value: this.value, switchToNext: false });
        }
      }
      if (dayPeriod) {
        parsedDate = this.intl.parseDate(prefix2 + dayPeriod + suffix2, this.format) || this.intl.parseDate(basePrefix + dayPeriod + baseSuffix, this.format);
        if (parsedDate) {
          this._value = parsedDate;
          this.setExisting(symbol, true);
          return extend(parseResult, { value: this.value, switchToNext: true });
        }
      }
      if (isZeroCurrentChar && symbol !== "a") {
        this.setExisting(symbol, false);
      }
      if (!this.autoCorrectParts) {
        var datePartValue = void 0;
        var textToParse = isInCaretMode ? datePartText : middle;
        var parsedValue = parseToInt(textToParse);
        if (isNumber(parsedValue) && isParseableToInt(textToParse)) {
          if (symbol === "d" && (parsedValue <= 0 || parsedValue > 31) || symbol === "M" && (parsedValue <= 0 || parsedValue > 11)) {
            if (isInCaretMode) {
              return extend(parseResult, {
                value: null,
                switchToNext: false
              });
            } else {
              textToParse = currentChar;
              parsedValue = parseToInt(textToParse);
            }
          }
          if (!isNumber(parsedValue) || !isParseableToInt(textToParse)) {
            return extend(parseResult, { value: null, switchToNext: false });
          }
          datePartValue = symbol === "M" ? parsedValue - JS_MONTH_OFFSET : parsedValue;
          var isYear = symbol === "y";
          var isMonth = symbol === "M";
          var isDay = symbol === "d";
          var newValue = cloneDate(this._value);
          var invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};
          var year = isYear ? datePartValue : invalidDateParts.y.value || newValue.getFullYear();
          var month = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();
          var day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();
          var hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();
          var minutes = invalidDateParts.m.value || newValue.getMinutes();
          var seconds = invalidDateParts.s.value || newValue.getSeconds();
          var milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();
          var dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);
          var dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);
          var newValueCandidate = isYear || isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isYear ? year : isMonth ? month : day) : null;
          var invalidDateFound = false;
          if (isMonth && newValueCandidate) {
            if (newValueCandidate.getMonth() === month) {
              if (this.getExisting("d")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: month,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(dateCandidate);
                if (this.getExisting("M") && this.getExisting("y")) {
                  this.setExisting("d", true);
                  this.resetInvalidDateSymbol("d");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: month,
                date: cloneDate(newValueCandidate),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          } else if (isDay && newValueCandidate) {
            if (newValueCandidate.getDate() === day) {
              if (this.getExisting("M")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: day,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                newValue = cloneDate(dateCandidate);
                this.resetInvalidDateSymbol(symbol);
                if (this.getExisting("d") && this.getExisting("y")) {
                  this.setExisting("M", true);
                  this.resetInvalidDateSymbol("M");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: day,
                date: cloneDate(this.value),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          } else if (isYear && newValueCandidate) {
            if (newValueCandidate.getFullYear() === year) {
              if (this.getExisting("d") && this.getExisting("M")) {
                if (dateCandidateExists) {
                  newValue = cloneDate(dateCandidate);
                  this.resetInvalidDateSymbol(symbol);
                } else {
                  invalidDateFound = true;
                  this.setInvalidDatePart(symbol, {
                    value: year,
                    date: cloneDate(newValueCandidate),
                    startDate: cloneDate(this.value)
                  });
                  this.setExisting(symbol, false);
                }
              } else if (dateCandidateExists) {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(dateCandidate);
                if (this.getExisting("M") && this.getExisting("d")) {
                  this.setExisting("y", true);
                  this.resetInvalidDateSymbol("y");
                }
              } else {
                this.resetInvalidDateSymbol(symbol);
                newValue = cloneDate(newValueCandidate);
              }
            } else {
              invalidDateFound = true;
              this.setInvalidDatePart(symbol, {
                value: year,
                date: cloneDate(newValueCandidate),
                startDate: cloneDate(this.value)
              });
              this.setExisting(symbol, false);
            }
          }
          if (!invalidDateFound) {
            this.setExisting(symbol, true);
            if (isInCaretMode && !isValidDate(parsedDate)) {
              var valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);
              if (isValidDate(valueCandidate)) {
                this._value = valueCandidate;
              }
            } else {
              this._value = newValue;
            }
            if (this.getValue()) {
              this.resetInvalidDate();
            }
          }
          var switchToNext = false;
          if (symbol === "M") {
            if (parsedValue >= 2 || textToParse.length >= 2) {
              switchToNext = true;
            } else {
              switchToNext = false;
            }
          } else {
            if (hasFixedFormat) {
              var peekDateSwitchToNext = this.isPeekDateOverflowingDatePart({
                useBasePrefixAndSuffix: !this.autoCorrectParts,
                middle,
                patternValue,
                basePrefix,
                baseSuffix,
                prefix: prefix2,
                suffix: suffix2,
                symbol,
                patternLength,
                leadingZero
              }).switchToNext;
              switchToNext = peekDateSwitchToNext;
            } else {
              switchToNext = textToParse.length > segmentLength;
            }
          }
          return extend(parseResult, {
            value: null,
            switchToNext,
            hasInvalidDatePart: invalidDateFound
          });
        }
      }
      return extend(parseResult, { value: null, switchToNext: false });
    };
    DateObject2.prototype.symbolMap = function(symbol) {
      return this.intl.splitDateFormat(this.format, this.localeId).reduce(dateSymbolMap, {})[symbol];
    };
    DateObject2.prototype.resetLeadingZero = function() {
      var hasLeadingZero = this.leadingZero !== null;
      this.setLeadingZero(null);
      return hasLeadingZero;
    };
    DateObject2.prototype.setLeadingZero = function(leadingZero) {
      this.leadingZero = leadingZero;
    };
    DateObject2.prototype.getLeadingZero = function() {
      return this.leadingZero || {};
    };
    DateObject2.prototype.normalizeCentury = function(date2) {
      if (!isPresent2(date2)) {
        return date2;
      }
      var twoDigitYear = cropTwoDigitYear(date2);
      var centuryBase = this.getNormalizedCenturyBase(twoDigitYear);
      var normalizedDate = setYears(date2, centuryBase + twoDigitYear);
      return normalizedDate;
    };
    DateObject2.prototype.incrementLeadingZero = function(symbol) {
      var leadingZero = this.leadingZero || {};
      leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;
      this.leadingZero = leadingZero;
    };
    DateObject2.prototype.isAbbrMonth = function(parts, symbol) {
      var pattern = this.partPattern(parts, symbol);
      return pattern.type === "month" && pattern.names;
    };
    DateObject2.prototype.partPattern = function(parts, symbol) {
      return parts.filter(function(part) {
        return part.pattern.indexOf(symbol) !== -1;
      })[0];
    };
    DateObject2.prototype.peek = function(value, pattern) {
      var peekValue = value.replace(/^0*/, "") + "0";
      return padZero(pattern.length - peekValue.length) + peekValue;
    };
    DateObject2.prototype.matchMonth = function(typedChar) {
      this.typedMonthPart += typedChar.toLowerCase();
      if (this.monthNames.length === 0) {
        return "";
      }
      while (this.typedMonthPart.length > 0) {
        for (var i = 0; i < this.monthNames.length; i++) {
          if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {
            return this.monthNames[i];
          }
        }
        var monthAsNum = parseInt(this.typedMonthPart, 10);
        if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {
          return this.monthNames[monthAsNum - 1];
        }
        this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);
      }
      return "";
    };
    DateObject2.prototype.matchDayPeriod = function(typedChar, symbol) {
      var lowerChart = typedChar.toLowerCase();
      if (symbol === "a" && this.dayPeriods) {
        if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {
          return this.dayPeriods.am;
        } else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {
          return this.dayPeriods.pm;
        }
      }
      return "";
    };
    DateObject2.prototype.allFormattedMonths = function(locale) {
      if (locale === void 0) {
        locale = "en";
      }
      var dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);
      for (var i = 0; i < dateFormatParts.length; i++) {
        if (dateFormatParts[i].type === "month" && dateFormatParts[i].names) {
          return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
        }
      }
      return [];
    };
    DateObject2.prototype.allDayPeriods = function(locale) {
      if (locale === void 0) {
        locale = "en";
      }
      var dateFormatParts = this.intl.splitDateFormat(this.format);
      for (var i = 0; i < dateFormatParts.length; i++) {
        if (dateFormatParts[i].type === "dayperiod" && dateFormatParts[i].names) {
          return this.intl.dateFormatNames(locale, dateFormatParts[i].names);
        }
      }
      return null;
    };
    DateObject2.prototype.patternLength = function(pattern) {
      if (pattern[0] === "y") {
        return 4;
      }
      if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {
        return 2;
      }
      return 0;
    };
    DateObject2.prototype.dateFormatString = function(date2, format) {
      var dateFormatParts = this.intl.splitDateFormat(format, this.localeId);
      var parts = [];
      var partMap = [];
      for (var i = 0; i < dateFormatParts.length; i++) {
        var partLength = this.intl.formatDate(date2, { pattern: dateFormatParts[i].pattern }, this.localeId).length;
        while (partLength > 0) {
          parts.push(this.symbols[dateFormatParts[i].pattern[0]] || Constants.formatSeparator);
          partMap.push(dateFormatParts[i]);
          partLength--;
        }
      }
      var returnValue = new Mask();
      returnValue.symbols = parts.join("");
      returnValue.partMap = partMap;
      return returnValue;
    };
    DateObject2.prototype.merge = function(text, mask) {
      var resultText = "";
      var resultFormat = "";
      var format = mask.symbols;
      var processTextSymbolsEnded = false;
      var ignoreFormatSymbolsCount = 0;
      var formattedDates = this.getFormattedInvalidDates(format);
      for (var formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {
        var partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);
        if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {
          if (this.autoCorrectParts) {
            resultText = text[formatSymbolIndex] + resultText;
          } else {
            if (text.length !== format.length) {
              if (processTextSymbolsEnded) {
                resultText = text[formatSymbolIndex] + resultText;
              } else if (ignoreFormatSymbolsCount > 0) {
                resultText = text[formatSymbolIndex] + resultText;
                ignoreFormatSymbolsCount--;
                if (ignoreFormatSymbolsCount <= 0) {
                  processTextSymbolsEnded = true;
                }
              } else {
                resultText = (text[formatSymbolIndex + text.length - format.length] || "") + resultText;
              }
            } else {
              resultText = text[formatSymbolIndex] + resultText;
            }
          }
          resultFormat = format[formatSymbolIndex] + resultFormat;
        } else {
          var symbol = format[formatSymbolIndex];
          var formatSymbolIndexModifier = 0;
          if (this.autoCorrectParts || !this.autoCorrectParts && !this.getInvalidDatePartValue(symbol)) {
            while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {
              formatSymbolIndex--;
            }
            formatSymbolIndex++;
          }
          if (this.leadingZero && this.leadingZero[symbol]) {
            resultText = "0" + resultText;
          } else {
            if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {
              var datePartText = this.getInvalidDatePartValue(symbol).toString();
              if (symbol === "M") {
                datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {
                  resultText = formattedDates[symbol][formatSymbolIndex] + resultText;
                } else {
                  datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();
                  var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                  resultText = formattedDatePart + resultText;
                  formatSymbolIndexModifier = partsForSegment.length - 1;
                  ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
                }
              } else {
                var formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;
                resultText = formattedDatePart + resultText;
                formatSymbolIndexModifier = partsForSegment.length - 1;
                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;
              }
            } else {
              resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;
            }
          }
          while (resultFormat.length < resultText.length) {
            resultFormat = format[formatSymbolIndex] + resultFormat;
          }
          if (formatSymbolIndexModifier !== 0) {
            formatSymbolIndex = formatSymbolIndex - formatSymbolIndexModifier + (text.length - format.length);
          }
        }
      }
      return { text: resultText, format: resultFormat };
    };
    DateObject2.prototype.dateFieldName = function(part) {
      var formatPlaceholder = this.formatPlaceholder || "wide";
      if (formatPlaceholder[part.type]) {
        return formatPlaceholder[part.type];
      }
      if (formatPlaceholder === "formatPattern") {
        return part.pattern;
      }
      return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));
    };
    DateObject2.prototype.getNormalizedCenturyBase = function(twoDigitYear) {
      return twoDigitYear > this.twoDigitYearMax ? PREVIOUS_CENTURY_BASE : CURRENT_CENTURY_BASE;
    };
    DateObject2.prototype.shouldNormalizeCentury = function() {
      return this.intl.splitDateFormat(this.format).some(function(part) {
        return part.pattern === "yy";
      });
    };
    DateObject2.prototype.resetInvalidDate = function() {
      var _this = this;
      this._partiallyInvalidDate.startDate = null;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        _this.resetInvalidDatePart(key);
      });
    };
    DateObject2.prototype.resetInvalidDateSymbol = function(symbol) {
      var _this = this;
      this.resetInvalidDatePart(symbol);
      var shouldResetInvalidDate = true;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        if (_this._partiallyInvalidDate.invalidDateParts[key] && isPresent2(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
          shouldResetInvalidDate = false;
        }
      });
      if (shouldResetInvalidDate) {
        this.resetInvalidDate();
      }
    };
    DateObject2.prototype.resetInvalidDatePart = function(symbol) {
      if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
        this._partiallyInvalidDate.invalidDateParts[symbol] = {
          value: null,
          date: null,
          startDateOffset: 0
        };
      }
    };
    DateObject2.prototype.getInvalidDatePart = function(symbol) {
      var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
      return invalidDatePart || {};
    };
    DateObject2.prototype.getInvalidDatePartValue = function(symbol) {
      var invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];
      return (invalidDatePart || {}).value;
    };
    DateObject2.prototype.setInvalidDatePart = function(symbol, _a2) {
      var _b = _a2.value, value = _b === void 0 ? null : _b, _c = _a2.date, date2 = _c === void 0 ? null : _c, _d = _a2.startDateOffset, startDateOffset = _d === void 0 ? 0 : _d, _e = _a2.startDate, startDate = _e === void 0 ? null : _e;
      if (this._partiallyInvalidDate.invalidDateParts[symbol]) {
        this._partiallyInvalidDate.invalidDateParts[symbol].value = value;
        this._partiallyInvalidDate.invalidDateParts[symbol].date = date2;
        this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;
        this._partiallyInvalidDate.startDate = startDate;
      }
    };
    DateObject2.prototype.hasInvalidDatePart = function() {
      var _this = this;
      var hasInvalidDatePart = false;
      Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(function(key) {
        if (_this._partiallyInvalidDate.invalidDateParts[key] && isPresent2(_this._partiallyInvalidDate.invalidDateParts[key].value)) {
          hasInvalidDatePart = true;
        }
      });
      return hasInvalidDatePart;
    };
    DateObject2.prototype.modifyDateSymbolWithOffset = function(date2, symbol, offset3) {
      var newValue = cloneDate(date2);
      var timeModified = false;
      switch (symbol) {
        case "y":
          newValue.setFullYear(newValue.getFullYear() + offset3);
          break;
        case "M":
          newValue = addMonths(this.value, offset3);
          break;
        case "d":
        case "E":
          newValue.setDate(newValue.getDate() + offset3);
          break;
        case "h":
        case "H":
          newValue.setHours(newValue.getHours() + offset3);
          timeModified = true;
          break;
        case "m":
          newValue.setMinutes(newValue.getMinutes() + offset3);
          timeModified = true;
          break;
        case "s":
          newValue.setSeconds(newValue.getSeconds() + offset3);
          timeModified = true;
          break;
        case "S":
          newValue.setMilliseconds(newValue.getMilliseconds() + offset3);
          break;
        case "a":
          newValue.setHours(newValue.getHours() + 12 * offset3);
          timeModified = true;
          break;
        default:
          break;
      }
      return {
        date: newValue,
        timeModified
      };
    };
    DateObject2.prototype.modifyDateSymbolWithValue = function(date2, symbol, value) {
      var newValue = cloneDate(date2);
      switch (symbol) {
        case "y":
          newValue.setFullYear(value);
          break;
        case "M":
          newValue = addMonths(date2, value - date2.getMonth());
          break;
        case "d":
        case "E":
          newValue.setDate(value);
          break;
        case "h":
        case "H":
          newValue.setHours(value);
          break;
        case "m":
          newValue.setMinutes(value);
          break;
        case "s":
          newValue.setSeconds(value);
          break;
        case "S":
          newValue.setMilliseconds(value);
          break;
        case "a":
          newValue.setHours(value);
          break;
        default:
          break;
      }
      return newValue;
    };
    DateObject2.prototype.markDatePartsAsExisting = function() {
      this.modifyExisting(true);
    };
    DateObject2.prototype.getPartsForSegment = function(mask, partIndex) {
      var segmentPart = mask.partMap[partIndex];
      var partsForSegment = [];
      for (var maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {
        var part = mask.partMap[maskPartIndex];
        if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
          partsForSegment.push(part);
        } else {
          break;
        }
      }
      for (var maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {
        var part = mask.partMap[maskPartIndex];
        if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {
          partsForSegment.unshift(part);
        } else {
          break;
        }
      }
      return partsForSegment;
    };
    DateObject2.prototype.isPeekDateOverflowingDatePart = function(_a2) {
      var useBasePrefixAndSuffix = _a2.useBasePrefixAndSuffix, middle = _a2.middle, patternValue = _a2.patternValue, basePrefix = _a2.basePrefix, baseSuffix = _a2.baseSuffix, prefix2 = _a2.prefix, suffix2 = _a2.suffix, symbol = _a2.symbol, patternLength = _a2.patternLength, leadingZero = _a2.leadingZero;
      var peekedValue = this.peek(middle, patternValue);
      var peekedDateString = useBasePrefixAndSuffix ? "".concat(basePrefix).concat(peekedValue).concat(baseSuffix) : "".concat(prefix2).concat(peekedValue).concat(suffix2);
      var peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);
      var leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;
      var patternSatisfied = leadingZeroOffset + unpadZero(middle).length >= patternLength;
      var parsedPeekedValue = parseToInt(peekedValue);
      var switchToNext = peekedDate === null || (leadingZero[symbol] ? patternValue.length <= middle.length : patternSatisfied);
      return {
        peekedDate,
        peekedDateString,
        peekedValue,
        parsedPeekedValue,
        switchToNext
      };
    };
    return DateObject2;
  }()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/keycode.js
var KeyCode = {
  BACKSPACE: 8,
  DELETE: 46,
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  SPACE: 32,
  END: 35,
  HOME: 36,
  PAGE_UP: 33,
  PAGE_DOWN: 34
};

// node_modules/@progress/kendo-dateinputs-common/dist/es/common/observable.js
var defaultOptions = {
  events: {}
};
var Observable2 = (
  /** @class */
  function() {
    function Observable3(options) {
      this.options = extend({}, defaultOptions, options);
    }
    Observable3.prototype.destroy = function() {
      this.options = {};
    };
    Observable3.prototype.trigger = function(eventName, args) {
      if (args === void 0) {
        args = {};
      }
      var eventData = {
        defaultPrevented: false,
        preventDefault: function() {
          eventData.defaultPrevented = true;
        }
      };
      if (isFunction(this.options.events[eventName])) {
        this.options.events[eventName](extend(eventData, args, {
          sender: this
        }));
        return eventData.defaultPrevented;
      }
      return false;
    };
    return Observable3;
  }()
);

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/interaction-mode.js
var DateInputInteractionMode;
(function(DateInputInteractionMode2) {
  DateInputInteractionMode2["None"] = "none";
  DateInputInteractionMode2["Caret"] = "caret";
  DateInputInteractionMode2["Selection"] = "selection";
})(DateInputInteractionMode || (DateInputInteractionMode = {}));

// node_modules/@progress/kendo-dateinputs-common/dist/es/dateinput/dateinput.js
var _a;
var DEFAULT_SEGMENT_STEP = 1;
var DRAG_START = "dragStart";
var DROP = "drop";
var TOUCH_START = "touchstart";
var MOUSE_DOWN = "mousedown";
var MOUSE_UP = "mouseup";
var CLICK = "click";
var INPUT = "input";
var KEY_DOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var PASTE = "paste";
var MOUSE_SCROLL = "DOMMouseScroll";
var MOUSE_WHEEL = "mousewheel";
var VALUE_CHANGE = "valueChange";
var INPUT_END = "inputEnd";
var BLUR_END = "blurEnd";
var FOCUS_END = "focusEnd";
var CHANGE = "change";
var defaultDateInputOptions = {
  format: "d",
  hasPlaceholder: false,
  placeholder: null,
  cycleTime: true,
  locale: null,
  steps: {
    millisecond: DEFAULT_SEGMENT_STEP,
    second: DEFAULT_SEGMENT_STEP,
    minute: DEFAULT_SEGMENT_STEP,
    hour: DEFAULT_SEGMENT_STEP,
    day: DEFAULT_SEGMENT_STEP,
    month: DEFAULT_SEGMENT_STEP,
    year: DEFAULT_SEGMENT_STEP
  },
  formatPlaceholder: null,
  events: (_a = {}, _a[VALUE_CHANGE] = null, _a[INPUT] = null, _a[INPUT_END] = null, _a[FOCUS] = null, _a[FOCUS_END] = null, _a[BLUR] = null, _a[BLUR_END] = null, _a[KEY_DOWN] = null, _a[MOUSE_WHEEL] = null, _a[CHANGE] = null, _a),
  selectNearestSegmentOnFocus: false,
  selectPreviousSegmentOnBackspace: false,
  enableMouseWheel: false,
  allowCaretMode: false,
  autoSwitchParts: true,
  autoSwitchKeys: [],
  twoDigitYearMax: Constants.twoDigitYearMax,
  autoCorrectParts: true,
  autoFill: false,
  toggleDayPeriod: false
};
var DateInput = (
  /** @class */
  function(_super) {
    __extends(DateInput2, _super);
    function DateInput2(element, options) {
      var _this = _super.call(this, options) || this;
      _this.dateObject = null;
      _this.currentText = "";
      _this.currentFormat = "";
      _this.interactionMode = DateInputInteractionMode.None;
      _this.previousElementSelection = { start: 0, end: 0 };
      _this.init(element, options);
      return _this;
    }
    Object.defineProperty(DateInput2.prototype, "value", {
      get: function() {
        return this.dateObject && this.dateObject.getValue();
      },
      enumerable: false,
      configurable: true
    });
    DateInput2.prototype.init = function(element, options) {
      var dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);
      if (!isValidDate(dateValue)) {
        dateValue = null;
      }
      this.element = element;
      this.options = extend({}, defaultDateInputOptions, options, { steps: __assign(__assign({}, defaultDateInputOptions.steps), options.steps) });
      this.intl = this.options.intlService;
      this.dateObject = this.createDateObject();
      this.dateObject.setValue(dateValue);
      this.setTextAndFormat();
      this.bindEvents();
      this.resetSegmentValue = true;
      this.interactionMode = DateInputInteractionMode.None;
      this.forceUpdate();
    };
    DateInput2.prototype.destroy = function() {
      this.unbindEvents();
      this.dateObject = null;
      _super.prototype.destroy.call(this);
    };
    DateInput2.prototype.bindEvents = function() {
      this.onElementDragStart = this.onElementDragStart.bind(this);
      this.element.addEventListener(DRAG_START, this.onElementDragStart);
      this.onElementDrop = this.onElementDrop.bind(this);
      this.element.addEventListener(DROP, this.onElementDrop);
      this.onElementClick = this.onElementClick.bind(this);
      this.element.addEventListener(CLICK, this.onElementClick);
      this.onElementMouseDown = this.onElementMouseDown.bind(this);
      this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);
      this.element.addEventListener(TOUCH_START, this.onElementMouseDown);
      this.onElementMouseUp = this.onElementMouseUp.bind(this);
      this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);
      this.onElementInput = this.onElementInput.bind(this);
      this.element.addEventListener(INPUT, this.onElementInput);
      this.onElementKeyDown = this.onElementKeyDown.bind(this);
      this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);
      this.onElementFocus = this.onElementFocus.bind(this);
      this.element.addEventListener(FOCUS, this.onElementFocus);
      this.onElementBlur = this.onElementBlur.bind(this);
      this.element.addEventListener(BLUR, this.onElementBlur);
      this.onElementChange = this.onElementChange.bind(this);
      this.element.addEventListener(CHANGE, this.onElementChange);
      this.onElementPaste = this.onElementPaste.bind(this);
      this.element.addEventListener(PASTE, this.onElementPaste);
      this.onElementMouseWheel = this.onElementMouseWheel.bind(this);
      this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
      this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput2.prototype.unbindEvents = function() {
      this.element.removeEventListener(DRAG_START, this.onElementDragStart);
      this.element.removeEventListener(DROP, this.onElementDrop);
      this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);
      this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);
      this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);
      this.element.removeEventListener(CLICK, this.onElementClick);
      this.element.removeEventListener(INPUT, this.onElementInput);
      this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);
      this.element.removeEventListener(FOCUS, this.onElementFocus);
      this.element.removeEventListener(BLUR, this.onElementBlur);
      this.element.removeEventListener(CHANGE, this.onElementChange);
      this.element.removeEventListener(PASTE, this.onElementPaste);
      this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);
      this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);
    };
    DateInput2.prototype.setOptions = function(options, refresh) {
      if (refresh === void 0) {
        refresh = false;
      }
      this.options = extend({}, this.options, options, { steps: __assign(__assign({}, defaultDateInputOptions.steps), options.steps) });
      this.setDateObjectOptions();
      if (refresh) {
        this.unbindEvents();
        this.init(this.element, this.options);
      }
    };
    DateInput2.prototype.setDateObjectOptions = function() {
      if (this.dateObject) {
        var newOptions = this.getDateObjectOptions();
        this.dateObject.setOptions(newOptions);
      }
    };
    DateInput2.prototype.resetLocale = function() {
      this.unbindEvents();
      this.init(this.element, this.options);
    };
    DateInput2.prototype.isInCaretMode = function() {
      return this.interactionMode === DateInputInteractionMode.Caret;
    };
    DateInput2.prototype.focus = function() {
      this.element.focus();
      if (this.options.selectNearestSegmentOnFocus) {
        this.selectNearestSegment(0);
      }
    };
    DateInput2.prototype.onElementDragStart = function(e) {
      e.preventDefault();
    };
    DateInput2.prototype.onElementDrop = function(e) {
      e.preventDefault();
    };
    DateInput2.prototype.onElementMouseDown = function() {
      this.mouseDownStarted = true;
      this.focusedPriorToMouseDown = this.isActive;
    };
    DateInput2.prototype.onElementMouseUp = function(e) {
      this.mouseDownStarted = false;
      e.preventDefault();
    };
    DateInput2.prototype.onElementClick = function(e) {
      this.mouseDownStarted = false;
      this.switchedPartOnPreviousKeyAction = false;
      var selection = this.selection;
      if (this.isInCaretMode()) {
        this.forceUpdate();
      }
      if (e.detail === 3) {
      } else {
        if (this.isActive && this.options.selectNearestSegmentOnFocus) {
          var selectionPresent = this.element.selectionStart !== this.element.selectionEnd;
          var placeholderToggled = isPresent2(this.options.placeholder) && !this.dateObject.hasValue() && !this.focusedPriorToMouseDown;
          var selectFirstSegment = !selectionPresent && placeholderToggled;
          var index = selectFirstSegment ? 0 : this.caret()[0];
          this.selectNearestSegment(index);
        } else {
          this.setSelection(this.selectionByIndex(selection.start));
        }
      }
    };
    DateInput2.prototype.onElementInput = function(e) {
      this.triggerInput({ event: e });
      var oldElementValue = this.elementValue;
      if (!this.element || !this.dateObject) {
        return;
      }
      var switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;
      if (this.isPasteInProgress) {
        if (this.options.allowCaretMode) {
          this.resetSegmentValue = false;
        }
        this.updateOnPaste(e);
        this.isPasteInProgress = false;
        return;
      }
      var keyDownEvent = this.keyDownEvent || {};
      var isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;
      var isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;
      var originalInteractionMode = this.interactionMode;
      if (this.options.allowCaretMode && originalInteractionMode !== DateInputInteractionMode.Caret && !isDeleteKey && !isBackspaceKey) {
        this.resetSegmentValue = true;
      }
      if (this.options.allowCaretMode) {
        this.interactionMode = DateInputInteractionMode.Caret;
      } else {
        this.interactionMode = DateInputInteractionMode.Selection;
      }
      var hasCaret = this.isInCaretMode();
      if (hasCaret && this.keyDownEvent.key === Key.SPACE) {
        this.restorePreviousInputEventState();
        return;
      }
      var oldExistingDateValue = this.dateObject && this.dateObject.getValue();
      var oldDateValue = this.dateObject ? this.dateObject.value : null;
      var _a2 = this.dateObject.getTextAndFormat(), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      var oldText = "";
      if (hasCaret) {
        if (isBackspaceKey || isDeleteKey) {
          oldText = this.previousElementValue;
        } else if (originalInteractionMode === DateInputInteractionMode.Caret) {
          oldText = this.previousElementValue;
        } else {
          oldText = currentText;
        }
      } else {
        oldText = currentText;
      }
      var newText = this.elementValue;
      var diff = approximateStringMatching({
        oldText,
        newText,
        formatPattern: this.currentFormat,
        selectionStart: this.selection.start,
        isInCaretMode: hasCaret,
        keyEvent: this.keyDownEvent
      });
      if (diff && diff.length && diff[0] && diff[0][1] !== Constants.formatSeparator) {
        this.switchedPartOnPreviousKeyAction = false;
      }
      if (hasCaret && (!diff || diff.length === 0)) {
        this.restorePreviousInputEventState();
        return;
      } else if (hasCaret && diff.length === 1) {
        if (!diff[0] || !diff[0][0]) {
          this.restorePreviousInputEventState();
          return;
        } else if (hasCaret && diff[0] && (diff[0][0] === Constants.formatSeparator || diff[0][1] === Constants.formatSeparator)) {
          this.restorePreviousInputEventState();
          return;
        }
      }
      var navigationOnly = diff.length === 1 && diff[0][1] === Constants.formatSeparator;
      var parsePartsResults = [];
      var switchPart = false;
      var error2 = null;
      if (!navigationOnly) {
        for (var i = 0; i < diff.length; i++) {
          var parsePartResult = this.dateObject.parsePart({
            symbol: diff[i][0],
            currentChar: diff[i][1],
            resetSegmentValue: this.resetSegmentValue,
            cycleSegmentValue: !this.isInCaretMode(),
            rawTextValue: this.element.value,
            isDeleting: isBackspaceKey || isDeleteKey,
            originalFormat: this.currentFormat
          });
          parsePartsResults.push(parsePartResult);
          if (!parsePartResult.value) {
            error2 = { type: "parse" };
          }
          switchPart = parsePartResult.switchToNext;
        }
      }
      if (!this.options.autoSwitchParts) {
        switchPart = false;
      }
      this.resetSegmentValue = false;
      var hasFixedFormat = this.options.format === this.currentFormat || // all not fixed formats are 1 symbol, e.g. "d"
      isPresent2(this.options.format) && this.options.format.length > 1;
      var lastParseResult = parsePartsResults[parsePartsResults.length - 1];
      var lastParseResultHasNoValue = lastParseResult && !isPresent2(lastParseResult.value);
      var parsingFailedOnDelete = hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue;
      var resetPart = lastParseResult ? lastParseResult.resetPart : false;
      var newExistingDateValue = this.dateObject.getValue();
      var hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);
      var newDateValue = this.dateObject.value;
      var symbolForSelection;
      var currentSelection = this.selection;
      if (hasCaret) {
        var diffChar = diff && diff.length > 0 ? diff[0][0] : null;
        var hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];
        if (diff.length && diff[0][0] !== Constants.formatSeparator) {
          if (switchPart) {
            this.forceUpdateWithSelection();
            this.switchDateSegment(1);
          } else if (resetPart) {
            symbolForSelection = this.currentFormat[currentSelection.start];
            if (symbolForSelection) {
              this.forceUpdate();
              this.setSelection(this.selectionBySymbol(symbolForSelection));
            } else {
              this.restorePreviousInputEventState();
            }
          } else if (parsingFailedOnDelete) {
            this.forceUpdate();
            if (diff.length && diff[0][0] !== Constants.formatSeparator) {
              this.setSelection(this.selectionBySymbol(diff[0][0]));
            }
          } else if (lastParseResultHasNoValue) {
            if (e.data === "0" && hasLeadingZero) {
            } else if (isPresent2(oldExistingDateValue) && !isPresent2(newExistingDateValue)) {
              this.restorePreviousInputEventState();
            } else if (!isPresent2(oldExistingDateValue) && isPresent2(newExistingDateValue)) {
              this.forceUpdateWithSelection();
            } else if (isPresent2(oldExistingDateValue) && isPresent2(newExistingDateValue)) {
              if (hasExistingDateValueChanged) {
                this.forceUpdateWithSelection();
              } else {
                this.restorePreviousInputEventState();
              }
            } else if (!isPresent2(oldExistingDateValue) && !isPresent2(newExistingDateValue)) {
              this.forceUpdateWithSelection();
            } else if (oldDateValue !== newDateValue) {
            } else {
              this.restorePreviousInputEventState();
            }
          } else if (!lastParseResultHasNoValue) {
            if (!hasFixedFormat) {
              this.forceUpdateWithSelection();
            }
          }
        } else {
          if (!this.options.autoSwitchParts && diff[0][1] === Constants.formatSeparator) {
          } else {
            this.setSelection(this.selectionBySymbol(diff[0][0]));
          }
        }
      } else if (!hasCaret) {
        this.forceUpdate();
        if (diff.length && diff[0][0] !== Constants.formatSeparator) {
          this.setSelection(this.selectionBySymbol(diff[0][0]));
        }
        if (this.options.autoSwitchParts) {
          if (navigationOnly) {
            this.resetSegmentValue = true;
            if (!switchedPartOnPreviousKeyAction) {
              this.switchDateSegment(1);
            }
            this.switchedPartOnPreviousKeyAction = true;
          } else if (switchPart) {
            this.switchDateSegment(1);
            this.switchedPartOnPreviousKeyAction = true;
          }
        } else {
          if (lastParseResult && lastParseResult.switchToNext) {
            this.resetSegmentValue = true;
          } else if (navigationOnly) {
            this.resetSegmentValue = true;
            if (!switchedPartOnPreviousKeyAction) {
              this.switchDateSegment(1);
            }
            this.switchedPartOnPreviousKeyAction = true;
          }
        }
        if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {
          this.switchDateSegment(-1);
        }
      }
      this.tryTriggerValueChange({
        oldValue: oldExistingDateValue,
        event: e
      });
      this.triggerInputEnd({ event: e, error: error2, oldElementValue, newElementValue: this.elementValue });
      if (hasCaret) {
        this.setTextAndFormat();
      }
    };
    DateInput2.prototype.onElementFocus = function(e) {
      if (this.triggerFocus({ event: e })) {
        return;
      }
      this.isActive = true;
      this.interactionMode = DateInputInteractionMode.None;
      this.switchedPartOnPreviousKeyAction = false;
      this.refreshElementValue();
      if (!this.mouseDownStarted) {
        this.caret(0, this.elementValue.length);
      }
      this.mouseDownStarted = false;
      this.triggerFocusEnd({ event: e });
    };
    DateInput2.prototype.onElementBlur = function(e) {
      this.resetSegmentValue = true;
      this.isActive = false;
      if (this.triggerBlur({ event: e })) {
        return;
      }
      if (this.options.autoFill) {
        this.autoFill();
      }
      this.interactionMode = DateInputInteractionMode.None;
      this.switchedPartOnPreviousKeyAction = false;
      this.refreshElementValue();
      this.triggerBlurEnd({ event: e });
    };
    DateInput2.prototype.onElementChange = function(e) {
      this.triggerChange({ event: e });
    };
    DateInput2.prototype.onElementKeyDown = function(e) {
      if (this.triggerKeyDown({ event: e })) {
        return;
      }
      var _a2 = this.selection, start = _a2.start, end2 = _a2.end;
      var event2 = e;
      this.keyDownEvent = e;
      this.previousElementValue = this.element.value;
      this.previousElementSelection = { start, end: end2 };
      if (this.keyEventMatchesAutoSwitchKeys(e)) {
        var isTabKey = e.keyCode === KeyCode.TAB;
        if (isTabKey) {
          var _b = this.selection, selectionStart = _b.start, selectionEnd = _b.end;
          if (e.shiftKey && isTabKey) {
            this.switchDateSegment(-1);
          } else {
            this.switchDateSegment(1);
          }
          if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {
            e.preventDefault();
            return;
          }
        } else {
          e.preventDefault();
          this.switchDateSegment(1);
          return;
        }
      }
      var symbol = this.currentFormat[this.selection.start];
      var step = this.getStepFromSymbol(symbol);
      var shouldPreventDefault = false;
      var oldElementValue = this.elementValue;
      if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {
        return;
      }
      switch (e.keyCode) {
        case KeyCode.ARROW_LEFT:
          this.switchDateSegment(-1);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_UP:
          this.modifyDateSegmentValue(step, symbol, event2);
          if (oldElementValue !== this.elementValue) {
            this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue });
          }
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_RIGHT:
          this.switchDateSegment(1);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ARROW_DOWN:
          this.modifyDateSegmentValue(-step, symbol, event2);
          if (oldElementValue !== this.elementValue) {
            this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue });
          }
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          break;
        case KeyCode.ENTER:
          break;
        case KeyCode.HOME:
          this.selectNearestSegment(0);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          this.resetSegmentValue = true;
          break;
        case KeyCode.END:
          this.selectNearestSegment(this.elementValue.length);
          shouldPreventDefault = true;
          this.switchedPartOnPreviousKeyAction = false;
          this.resetSegmentValue = true;
          break;
        default:
          return;
      }
      if (shouldPreventDefault) {
        e.preventDefault();
      }
    };
    DateInput2.prototype.onElementPaste = function() {
      this.isPasteInProgress = true;
    };
    DateInput2.prototype.onElementMouseWheel = function(e) {
      var oldElementValue = this.elementValue;
      if (!this.options.enableMouseWheel || this.triggerMouseWheel({ event: e })) {
        return;
      }
      if (!this.isActive) {
        return;
      }
      var event2 = e;
      if (event2.shiftKey) {
        this.switchDateSegment((event2.wheelDelta || -event2.detail) > 0 ? -1 : 1);
      } else {
        this.modifyDateSegmentValue((event2.wheelDelta || -event2.detail) > 0 ? 1 : -1);
      }
      event2.returnValue = false;
      if (event2.preventDefault) {
        event2.preventDefault();
      }
      if (oldElementValue !== this.elementValue) {
        this.triggerInputEnd({ event: e, error: null, newElementValue: this.elementValue, oldElementValue });
      }
    };
    DateInput2.prototype.updateOnPaste = function(e) {
      var value = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;
      if (isPresent2(value) && this.dateObject.shouldNormalizeCentury()) {
        value = this.dateObject.normalizeCentury(value);
      }
      var oldDateObjectValue = this.dateObject && this.dateObject.getValue();
      this.writeValue(value);
      this.tryTriggerValueChange({
        oldValue: oldDateObjectValue,
        event: e
      });
    };
    Object.defineProperty(DateInput2.prototype, "elementValue", {
      get: function() {
        return (this.element || {}).value || "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "inputFormat", {
      get: function() {
        if (!this.options.format) {
          return Constants.defaultDateFormat;
        }
        if (typeof this.options.format === "string") {
          return this.options.format;
        } else {
          return this.options.format.inputFormat;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "displayFormat", {
      get: function() {
        if (!this.options.format) {
          return Constants.defaultDateFormat;
        }
        if (typeof this.options.format === "string") {
          return this.options.format;
        } else {
          return this.options.format.displayFormat;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DateInput2.prototype, "selection", {
      get: function() {
        var returnValue = { start: 0, end: 0 };
        if (this.element !== null && this.element.selectionStart !== void 0) {
          returnValue = {
            start: this.element.selectionStart,
            end: this.element.selectionEnd
          };
        }
        return returnValue;
      },
      enumerable: false,
      configurable: true
    });
    DateInput2.prototype.setSelection = function(selection) {
      if (this.element && document.activeElement === this.element) {
        this.element.setSelectionRange(selection.start, selection.end);
        if (isDocumentAvailable2() && isIOS()) {
          this.element.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
        if (selection.start !== selection.end) {
          this.interactionMode = DateInputInteractionMode.Selection;
        }
      }
    };
    DateInput2.prototype.selectionBySymbol = function(symbol) {
      var start = -1;
      var end2 = 0;
      for (var i = 0; i < this.currentFormat.length; i++) {
        if (this.currentFormat[i] === symbol) {
          end2 = i + 1;
          if (start === -1) {
            start = i;
          }
        }
      }
      if (start < 0) {
        start = 0;
      }
      if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {
        if (this.currentFormat.length < this.currentText.length) {
          end2 += this.currentText.length - this.currentFormat.length;
        } else {
          end2 = Math.max(0, end2 - (this.currentFormat.length - this.currentText.length));
        }
      }
      return { start, end: end2 };
    };
    DateInput2.prototype.selectionByIndex = function(index) {
      var selection = { start: index, end: index };
      for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
        if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {
          selection = this.selectionBySymbol(this.currentFormat[i]);
          break;
        }
        if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {
          selection = this.selectionBySymbol(this.currentFormat[j]);
          break;
        }
      }
      return selection;
    };
    DateInput2.prototype.switchDateSegment = function(offset3) {
      var selection = this.selection;
      if (this.isInCaretMode()) {
        var start = selection.start;
        var currentSymbol = this.currentFormat[start - 1];
        var symbol = "";
        var symbolCandidate = "";
        if (offset3 < 0) {
          for (var i = start + offset3; i >= 0; i--) {
            symbolCandidate = this.currentFormat[i];
            if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {
              start = i;
              symbol = symbolCandidate;
              break;
            }
          }
        } else {
          for (var i = start + offset3; i < this.currentFormat.length; i++) {
            symbolCandidate = this.currentFormat[i];
            if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {
              start = i;
              symbol = symbolCandidate;
              break;
            }
          }
        }
        if (symbol) {
          this.forceUpdate();
          this.setSelection(this.selectionBySymbol(symbol));
          this.interactionMode = DateInputInteractionMode.Selection;
          return;
        }
      }
      this.interactionMode = DateInputInteractionMode.None;
      var _a2 = this.selection, selectionStart = _a2.start, selectionEnd = _a2.end;
      if (selectionStart < selectionEnd && this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {
        this.setSelection(this.selectionByIndex(offset3 > 0 ? selectionStart : selectionEnd - 1));
        this.resetSegmentValue = true;
        this.interactionMode = DateInputInteractionMode.None;
        return;
      }
      var previousFormatSymbol = this.currentFormat[selectionStart];
      var a = selectionStart + offset3;
      while (a > 0 && a < this.currentFormat.length) {
        if (this.currentFormat[a] !== previousFormatSymbol && this.currentFormat[a] !== Constants.formatSeparator) {
          break;
        }
        a += offset3;
      }
      if (this.currentFormat[a] === Constants.formatSeparator) {
        return;
      }
      var b = a;
      while (b >= 0 && b < this.currentFormat.length) {
        if (this.currentFormat[b] !== this.currentFormat[a]) {
          break;
        }
        b += offset3;
      }
      if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {
        this.setSelection({ start: b + 1, end: a + 1 });
        this.resetSegmentValue = true;
      } else if (a < b && (a !== selectionStart || b !== selectionEnd)) {
        this.setSelection({ start: a, end: b });
        this.resetSegmentValue = true;
      }
      this.interactionMode = DateInputInteractionMode.None;
    };
    DateInput2.prototype.modifyDateSegmentValue = function(offset3, symbol, event2) {
      if (symbol === void 0) {
        symbol = "";
      }
      if (event2 === void 0) {
        event2 = {};
      }
      if (!this.dateObject || this.options.readonly) {
        return;
      }
      var oldValue = this.value;
      var step = DEFAULT_SEGMENT_STEP;
      var caret = this.caret();
      symbol = symbol || this.currentFormat[caret[0]];
      if (symbol === "S" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {
        var msDigits = millisecondDigitsInFormat(this.inputFormat);
        step = millisecondStepFor(msDigits);
      }
      this.dateObject.modifyPart(symbol, step * offset3);
      this.tryTriggerValueChange({
        oldValue,
        event: event2
      });
      this.forceUpdate();
      this.setSelection(this.selectionBySymbol(symbol));
    };
    DateInput2.prototype.tryTriggerValueChange = function(args) {
      if (args === void 0) {
        args = { oldValue: null, event: {} };
      }
      if (!isEqual(this.value, args.oldValue)) {
        return this.triggerValueChange(args);
      }
    };
    DateInput2.prototype.triggerValueChange = function(args) {
      if (args === void 0) {
        args = { oldValue: null, event: {} };
      }
      return this.trigger(VALUE_CHANGE, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerInput = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(INPUT, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerInputEnd = function(args) {
      if (args === void 0) {
        args = { event: {}, error: null, oldElementValue: "", newElementValue: "" };
      }
      return this.trigger(INPUT_END, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerFocus = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(FOCUS, extend({}, args));
    };
    DateInput2.prototype.triggerFocusEnd = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(FOCUS_END, extend({}, args));
    };
    DateInput2.prototype.triggerBlur = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(BLUR, extend({}, args));
    };
    DateInput2.prototype.triggerBlurEnd = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(BLUR_END, extend({}, args));
    };
    DateInput2.prototype.triggerChange = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(CHANGE, extend(args, {
        value: this.value
      }));
    };
    DateInput2.prototype.triggerKeyDown = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(KEY_DOWN, extend({}, args));
    };
    DateInput2.prototype.triggerMouseWheel = function(args) {
      if (args === void 0) {
        args = { event: {} };
      }
      return this.trigger(MOUSE_WHEEL, extend({}, args));
    };
    DateInput2.prototype.forceUpdate = function() {
      this.setTextAndFormat();
      this.refreshElementValue();
    };
    DateInput2.prototype.forceUpdateWithSelection = function() {
      var _a2 = this.selection, start = _a2.start, end2 = _a2.end;
      var elementValueLength = this.elementValue.length;
      this.forceUpdate();
      var selectionOffset = this.elementValue.length - elementValueLength;
      this.setSelection({
        start: start + selectionOffset,
        end: end2 + selectionOffset
      });
    };
    DateInput2.prototype.setTextAndFormat = function() {
      var _a2 = this.dateObject.getTextAndFormat(), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      this.currentText = currentText;
    };
    DateInput2.prototype.setElementValue = function(value) {
      this.element.value = value;
    };
    DateInput2.prototype.getStepFromSymbol = function(symbol) {
      switch (symbol) {
        case "S":
          return Number(this.options.steps.millisecond);
        case "s":
          return Number(this.options.steps.second);
        case "m":
          return Number(this.options.steps.minute);
        case "h":
        case "H":
          return Number(this.options.steps.hour);
        case "M":
          return Number(this.options.steps.month);
        case "d":
        case "E":
          return Number(this.options.steps.day);
        case "y":
          return Number(this.options.steps.year);
        default:
          return DEFAULT_SEGMENT_STEP;
      }
    };
    DateInput2.prototype.restorePreviousInputEventState = function() {
      this.restorePreviousElementValue();
      this.restorePreviousElementSelection();
    };
    DateInput2.prototype.restorePreviousElementValue = function() {
      this.setElementValue(this.previousElementValue || "");
    };
    DateInput2.prototype.restorePreviousElementSelection = function() {
      var _a2 = this.previousElementSelection, start = _a2.start, end2 = _a2.end;
      this.setSelection({ start: start || 0, end: end2 || 0 });
    };
    DateInput2.prototype.writeValue = function(value) {
      this.verifyValue(value);
      this.dateObject = this.getDateObject(value);
      this.refreshElementValue();
    };
    DateInput2.prototype.verifyValue = function(value) {
      if (value && !isValidDate(value)) {
        throw new Error("The 'value' should be a valid JavaScript Date instance.");
      }
    };
    DateInput2.prototype.refreshElementValue = function() {
      var element = this.element;
      var format = this.isActive ? this.inputFormat : this.displayFormat;
      var _a2 = this.dateObject.getTextAndFormat(format), currentText = _a2.text, currentFormat = _a2.format;
      this.currentFormat = currentFormat;
      this.currentText = currentText;
      var hasPlaceholder = this.options.hasPlaceholder || isPresent2(this.options.placeholder);
      var showPlaceholder = !this.isActive && hasPlaceholder && !this.dateObject.hasValue();
      if (hasPlaceholder && isPresent2(this.options.placeholder)) {
        element.placeholder = this.options.placeholder;
      }
      var newElementValue = showPlaceholder ? "" : currentText;
      this.previousElementValue = this.elementValue;
      this.setElementValue(newElementValue);
    };
    DateInput2.prototype.caret = function(start, end2) {
      if (end2 === void 0) {
        end2 = start;
      }
      var isPosition = start !== void 0;
      var returnValue = [start, start];
      var element = this.element;
      if (isPosition && (this.options.disabled || this.options.readonly)) {
        return void 0;
      }
      try {
        if (element.selectionStart !== void 0) {
          if (isPosition) {
            if (isDocumentAvailable2() && document.activeElement !== element) {
              element.focus();
            }
            element.setSelectionRange(start, end2);
          }
          returnValue = [element.selectionStart, element.selectionEnd];
        }
      } catch (e) {
        returnValue = [];
      }
      return returnValue;
    };
    DateInput2.prototype.selectNearestSegment = function(index) {
      for (var i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {
        if (i < this.currentFormat.length && this.currentFormat[i] !== "_") {
          this.selectDateSegment(this.currentFormat[i]);
          return;
        }
        if (j >= 0 && this.currentFormat[j] !== "_") {
          this.selectDateSegment(this.currentFormat[j]);
          return;
        }
      }
    };
    DateInput2.prototype.selectDateSegment = function(symbol) {
      var begin = -1;
      var end2 = 0;
      for (var i = 0; i < this.currentFormat.length; i++) {
        if (this.currentFormat[i] === symbol) {
          end2 = i + 1;
          if (begin === -1) {
            begin = i;
          }
        }
      }
      if (begin < 0) {
        begin = 0;
      }
      this.caret(0, 0);
      this.caret(begin, end2);
    };
    DateInput2.prototype.getDateObject = function(value) {
      var leadingZero = (this.dateObject || {}).leadingZero;
      this.options.value = value;
      var dateObject = this.createDateObject();
      dateObject.setLeadingZero(this.isActive ? leadingZero : null);
      return dateObject;
    };
    DateInput2.prototype.createDateObject = function() {
      var defaultOptions2 = this.getDateObjectOptions();
      var dateObject = new DateObject(extend({}, defaultOptions2));
      return dateObject;
    };
    DateInput2.prototype.getDateObjectOptions = function() {
      var newOptions = {
        intlService: this.options.intlService,
        formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : "formatPattern",
        format: this.inputFormat,
        cycleTime: this.options.cycleTime,
        twoDigitYearMax: this.options.twoDigitYearMax,
        autoCorrectParts: this.options.autoCorrectParts,
        value: this.options.value,
        toggleDayPeriod: this.options.toggleDayPeriod,
        autoSwitchParts: this.options.autoSwitchParts
      };
      return newOptions;
    };
    DateInput2.prototype.keyEventMatchesAutoSwitchKeys = function(keyObject) {
      var autoSwitchKeys = (this.options.autoSwitchKeys || []).map(function(x) {
        return x.toString().toLowerCase().trim();
      });
      if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 || autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 || autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {
        return true;
      }
      return false;
    };
    DateInput2.prototype.autoFill = function() {
      var dateObject = this.dateObject;
      var currentDate = /* @__PURE__ */ new Date();
      var day, month, year, hours, minutes, seconds;
      if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {
        year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(), month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(), day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(), hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(), minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(), seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();
        dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));
        this.refreshElementValue();
        this.triggerValueChange();
      }
    };
    return DateInput2;
  }(Observable2)
);

// node_modules/@progress/kendo-angular-dateinputs/fesm2022/progress-kendo-angular-dateinputs.mjs
var _c02 = ["kendoCalendarView", ""];
var _c12 = (a0, a1) => ({
  $implicit: a0,
  cellContext: a1
});
function ViewComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 3);
    ɵɵtext(1, " ");
    ɵɵelementEnd();
  }
}
function ViewComponent_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 4)(1, "th", 5);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-hidden", ctx_r0.ariaHidden);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r0.colSpan);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r0.getWeekNumber(ctx_r0.firstDate(row_r3)), " ");
  }
}
function ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template(rf, ctx) {
}
function ViewComponent_tr_3_ng_template_1_td_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 9);
    ɵɵlistener("click", function ViewComponent_tr_3_ng_template_1_td_0_Template_td_click_0_listener() {
      ɵɵrestoreView(_r2);
      const row_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleWeekNumberClick(row_r3));
    });
    ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_td_0_ng_template_1_Template, 1, 1, "ng-template", 6)(2, ViewComponent_tr_3_ng_template_1_td_0_ng_template_2_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.weekNumberTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.weekNumberTemplateRef)("ngTemplateOutlet", ctx_r0.weekNumberTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(4, _c12, ctx_r0.firstDate(row_r3), ctx_r0.getWeekNumberContext(row_r3)));
  }
}
function ViewComponent_tr_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ViewComponent_tr_3_ng_template_1_td_0_Template, 3, 7, "td", 8);
  }
  if (rf & 2) {
    const row_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    const emptyCell_r4 = ɵɵreference(1);
    ɵɵproperty("ngIf", ctx_r0.firstDate(row_r3))("ngIfElse", emptyCell_r4);
  }
}
function ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const cell_r5 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate(cell_r5.formattedValue);
  }
}
function ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template(rf, ctx) {
}
function ViewComponent_tr_3_ng_container_2_td_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ViewComponent_tr_3_ng_container_2_td_1_3_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const cell_r5 = ɵɵnextContext(2).$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c12, cell_r5.value, cell_r5));
  }
}
function ViewComponent_tr_3_ng_container_2_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 12)(1, "span", 13);
    ɵɵtemplate(2, ViewComponent_tr_3_ng_container_2_td_1_ng_template_2_Template, 1, 1, "ng-template", 6)(3, ViewComponent_tr_3_ng_container_2_td_1_3_Template, 1, 5, null, 14);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const cell_r5 = ctx_r5.$implicit;
    const cellIndex_r7 = ctx_r5.index;
    const rowIndex_r8 = ɵɵnextContext().index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.getStyles(cell_r5))("title", cell_r5.title);
    ɵɵattribute("id", cell_r5.id)("data-cell-index", ctx_r0.tableCellIndex(rowIndex_r8, cellIndex_r7))("aria-selected", cell_r5.isSelected || cell_r5.isRangeStart || cell_r5.isRangeMid || cell_r5.isRangeEnd)("aria-disabled", cell_r5.isDisabled)("aria-label", ctx_r0.getMonthLabel(cell_r5.value));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.templateRef);
  }
}
function ViewComponent_tr_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ViewComponent_tr_3_ng_container_2_td_1_Template, 4, 9, "td", 11);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const cell_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    const emptyCell_r4 = ɵɵreference(1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.shouldRenderCellContent(cell_r5))("ngIfElse", emptyCell_r4);
  }
}
function ViewComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 4);
    ɵɵtemplate(1, ViewComponent_tr_3_ng_template_1_Template, 1, 2, "ng-template", 6)(2, ViewComponent_tr_3_ng_container_2_Template, 2, 2, "ng-container", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.weekNumber);
    ɵɵadvance();
    ɵɵproperty("kForOf", row_r3);
  }
}
var _c22 = (a0) => ({
  date: a0,
  className: "k-pointer-events-none"
});
var _c32 = (a0) => ({
  date: a0
});
function HorizontalViewListComponent_ng_template_0_caption_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "caption", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r3 = ɵɵnextContext().date;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getCaptionTitle(date_r3));
  }
}
function HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const name_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("aria-label", ctx_r1.wideWeekNames[i_r5]);
    ɵɵadvance();
    ɵɵtextInterpolate(name_r4);
  }
}
function HorizontalViewListComponent_ng_template_0_thead_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 8)(1, "tr", 9);
    ɵɵtemplate(2, HorizontalViewListComponent_ng_template_0_thead_2_th_2_Template, 2, 2, "th", 10);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.weekNames);
  }
}
function HorizontalViewListComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 3);
    ɵɵlistener("focus", function HorizontalViewListComponent_ng_template_0_Template_table_focus_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleClassicCalendarFocus());
    })("blur", function HorizontalViewListComponent_ng_template_0_Template_table_blur_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleClassicCalendarBlur($event));
    });
    ɵɵtemplate(1, HorizontalViewListComponent_ng_template_0_caption_1_Template, 2, 1, "caption", 4)(2, HorizontalViewListComponent_ng_template_0_thead_2_Template, 3, 1, "thead", 5);
    ɵɵelementStart(3, "tbody", 6);
    ɵɵlistener("cellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellClick_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellClick.emit($event));
    })("weekNumberCellClick", function HorizontalViewListComponent_ng_template_0_Template_tbody_weekNumberCellClick_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.weekNumberCellClick.emit($event));
    })("cellEnter", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellEnter_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellEnter.emit($event));
    })("cellLeave", function HorizontalViewListComponent_ng_template_0_Template_tbody_cellLeave_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.cellLeave.emit($event));
    })("focusedCellId", function HorizontalViewListComponent_ng_template_0_Template_tbody_focusedCellId_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focusedCellChange.emit($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const date_r3 = ctx.date;
    const class_r6 = ctx.className;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", class_r6);
    ɵɵattribute("role", ctx_r1.views >= 2 ? "none" : "grid")("aria-labelledby", ctx_r1.id)("aria-activedescendant", ctx_r1.getActiveDescendant)("tabindex", ctx_r1.getTabIndex);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showViewHeader);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isMonthView());
    ɵɵadvance();
    ɵɵproperty("allowReverse", ctx_r1.allowReverse)("showOtherMonthDays", ctx_r1.showOtherMonthDays)("activeView", ctx_r1.activeView)("isActive", ctx_r1.isActive)("min", ctx_r1.min)("max", ctx_r1.max)("cellUID", ctx_r1.cellUID)("focusedDate", ctx_r1.focusedDate)("selectedDates", ctx_r1.selectedDates)("selectionRange", ctx_r1.selectionRange)("activeRangeEnd", ctx_r1.activeRangeEnd)("weekNumber", ctx_r1.weekNumber)("templateRef", ctx_r1.cellTemplateRef)("weekNumberTemplateRef", ctx_r1.weekNumberTemplateRef)("viewDate", date_r3);
  }
}
function HorizontalViewListComponent_2_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_2_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c22, ctx_r1.nextAnimationDate));
  }
}
function HorizontalViewListComponent_3_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_3_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const date_r8 = ctx.$implicit;
    ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c32, date_r8));
  }
}
function HorizontalViewListComponent_4_ng_template_0_Template(rf, ctx) {
}
function HorizontalViewListComponent_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HorizontalViewListComponent_4_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const tableTemplate_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r7)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c22, ctx_r1.prevAnimationDate));
  }
}
var _c42 = (a0, a1, a2) => ({
  title: a0,
  activeView: a1,
  date: a2
});
var _c52 = (a0) => ({
  click: a0
});
var _c6 = (a0, a1, a2) => ({
  $implicit: a0,
  activeView: a1,
  date: a2
});
function HeaderComponent_0_ng_template_0_Template(rf, ctx) {
}
function HeaderComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, HeaderComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.headerTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c42, ctx_r0.title, ctx_r0.activeViewValue, ctx_r0.currentDate));
  }
}
function HeaderComponent_ng_template_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function HeaderComponent_ng_template_1_ng_template_2_Template(rf, ctx) {
}
function HeaderComponent_ng_template_1_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵlistener("click", function HeaderComponent_ng_template_1_button_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.prevButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("svgIcon", ctx_r0.chevronLeftIcon)("disabled", ctx_r0.isPrevDisabled)("title", ctx_r0.prevButtonTitle);
    ɵɵattribute("aria-disabled", ctx_r0.isPrevDisabled);
  }
}
function HeaderComponent_ng_template_1_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function HeaderComponent_ng_template_1_button_8_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.nextButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r0.size)("svgIcon", ctx_r0.chevronRightIcon)("disabled", ctx_r0.isNextDisabled)("title", ctx_r0.nextButtonTitle);
    ɵɵattribute("aria-disabled", ctx_r0.isNextDisabled);
  }
}
function HeaderComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 3);
    ɵɵtemplate(1, HeaderComponent_ng_template_1_ng_template_1_Template, 1, 1, "ng-template", 4)(2, HeaderComponent_ng_template_1_ng_template_2_Template, 0, 0, "ng-template", 5);
    ɵɵelementEnd();
    ɵɵelement(3, "span", 6);
    ɵɵelementStart(4, "span", 7);
    ɵɵtemplate(5, HeaderComponent_ng_template_1_button_5_Template, 1, 5, "button", 8);
    ɵɵelementStart(6, "button", 9);
    ɵɵtext(7);
    ɵɵelementEnd();
    ɵɵtemplate(8, HeaderComponent_ng_template_1_button_8_Template, 1, 5, "button", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.id)("size", ctx_r0.size)("disabled", !ctx_r0.navigate)("kendoEventsOutsideAngular", ɵɵpureFunction1(17, _c52, ctx_r0.handleNavigation))("title", ctx_r0.parentViewButtonTitle)("scope", ctx_r0);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.titleTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.titleTemplateRef)("ngTemplateOutlet", ctx_r0.titleTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction3(19, _c6, ctx_r0.title, ctx_r0.activeViewValue, ctx_r0.currentDate));
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.showNavigationButtons);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r0.size)("disabled", !ctx_r0.todayAvailable)("kendoEventsOutsideAngular", ɵɵpureFunction1(23, _c52, ctx_r0.handleTodayClick))("scope", ctx_r0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.todayMessage, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showNavigationButtons);
  }
}
var _c7 = (a0, a1) => ({
  activeView: a0,
  date: a1
});
function FooterComponent_0_ng_template_0_Template(rf, ctx) {
}
function FooterComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FooterComponent_0_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.footerTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c7, ctx_r0.activeViewValue, ctx_r0.currentDate));
  }
}
function FooterComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.intl.formatDate(ctx_r0.getToday(), "D"), " ");
  }
}
function MultiViewCalendarComponent_kendo_calendar_header_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar-header", 4);
    ɵɵlistener("todayButtonClick", function MultiViewCalendarComponent_kendo_calendar_header_1_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleTodayButtonClick({
        selectedDates: [$event],
        focusedDate: $event
      }));
    })("prevButtonClick", function MultiViewCalendarComponent_kendo_calendar_header_1_Template_kendo_calendar_header_prevButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateView(ctx_r1.prevView));
    })("nextButtonClick", function MultiViewCalendarComponent_kendo_calendar_header_1_Template_kendo_calendar_header_nextButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateView(ctx_r1.nextView));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("activeView", ctx_r1.activeViewEnum)("currentDate", ctx_r1.activeDate)("size", ctx_r1.size)("min", ctx_r1.min)("max", ctx_r1.max)("id", ctx_r1.headerId)("rangeLength", ctx_r1.views)("titleTemplateRef", ctx_r1.headerTitleTemplateRef == null ? null : ctx_r1.headerTitleTemplateRef.templateRef)("headerTemplateRef", ctx_r1.headerTemplateRef == null ? null : ctx_r1.headerTemplateRef.templateRef)("isPrevDisabled", ctx_r1.isPrevDisabled)("isNextDisabled", ctx_r1.isNextDisabled)("showNavigationButtons", true)("orientation", ctx_r1.orientation);
  }
}
function MultiViewCalendarComponent_kendo_calendar_footer_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-calendar-footer", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("footerTemplateRef", ctx_r1.footerTemplateRef == null ? null : ctx_r1.footerTemplateRef.templateRef)("activeViewValue", ctx_r1.activeView)("currentDate", ctx_r1.activeDate);
  }
}
var _c8 = ["*"];
var _c9 = ["list"];
function NavigationComponent_li_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const date_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r2.service.navigationTitle(date_r2));
  }
}
function NavigationComponent_li_4_ng_template_3_Template(rf, ctx) {
}
function NavigationComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li")(1, "span");
    ɵɵtemplate(2, NavigationComponent_li_4_ng_template_2_Template, 1, 1, "ng-template", 5)(3, NavigationComponent_li_4_ng_template_3_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const date_r2 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("data-date-index", index_r4);
    ɵɵadvance();
    ɵɵclassProp("k-calendar-navigation-marker", ctx_r2.service.isRangeStart(date_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.templateRef)("ngTemplateOutlet", ctx_r2.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(7, _c6, ctx_r2.service.navigationTitle(date_r2), ctx_r2.activeViewValue, date_r2));
  }
}
function ViewListComponent_table_1_th_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const name_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵattribute("aria-label", ctx_r3.wideWeekNames[i_r3]);
    ɵɵadvance();
    ɵɵtextInterpolate(name_r2);
  }
}
function ViewListComponent_table_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "table", 8)(1, "thead", 9)(2, "tr", 10);
    ɵɵtemplate(3, ViewListComponent_table_1_th_3_Template, 2, 2, "th", 11);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵstyleProp("table-layout", "auto");
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r3.weekNames);
  }
}
function ViewListComponent_col_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
}
function ViewListComponent_tbody_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tbody", 13);
    ɵɵlistener("cellClick", function ViewListComponent_tbody_7_Template_tbody_cellClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.cellClick.emit($event));
    })("weekNumberCellClick", function ViewListComponent_tbody_7_Template_tbody_weekNumberCellClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.weekNumberCellClick.emit($event));
    })("focusedCellId", function ViewListComponent_tbody_7_Template_tbody_focusedCellId_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.focusedCellChange.emit($event));
    })("cellEnter", function ViewListComponent_tbody_7_Template_tbody_cellEnter_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.cellEnter.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const date_r6 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("allowReverse", ctx_r3.allowReverse)("activeRangeEnd", ctx_r3.activeRangeEnd)("selectionRange", ctx_r3.selectionRange)("showOtherMonthDays", ctx_r3.showOtherMonthDays)("headerTitle", ctx_r3.headerTitle)("activeView", ctx_r3.activeView)("isActive", ctx_r3.isActive)("min", ctx_r3.min)("max", ctx_r3.max)("cellUID", ctx_r3.cellUID)("focusedDate", ctx_r3.focusedDate)("selectedDates", ctx_r3.selectedDates)("weekNumber", ctx_r3.weekNumber)("templateRef", ctx_r3.cellTemplateRef)("weekNumberTemplateRef", ctx_r3.weekNumberTemplateRef)("viewDate", date_r6);
  }
}
function ViewListComponent_kendo_calendar_footer_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-calendar-footer", 14);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("footerTemplateRef", ctx_r3.footerTemplateRef)("activeViewValue", ctx_r3.activeViewValue)("currentDate", ctx_r3.activeDate);
  }
}
function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar-navigation", 6);
    ɵɵlistener("valueChange", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_valueChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.handleNavigation($event));
    })("pageChange", function CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template_kendo_calendar_navigation_pageChange_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onPageChange());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("activeView", ctx_r2.activeViewEnum)("focusedDate", ctx_r2.focusedDate)("min", ctx_r2.min)("max", ctx_r2.max)("templateRef", ctx_r2.navigationItemTemplateRef == null ? null : ctx_r2.navigationItemTemplateRef.templateRef);
  }
}
function CalendarComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CalendarComponent_ng_container_1_kendo_calendar_navigation_1_Template, 1, 5, "kendo-calendar-navigation", 3);
    ɵɵelementStart(2, "kendo-calendar-viewlist", 4);
    ɵɵlistener("todayButtonClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_todayButtonClick_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleDateChange({
        selectedDates: [$event],
        focusedDate: $event
      }));
    })("cellClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_cellClick_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleCellClick($event));
    })("weekNumberCellClick", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_weekNumberCellClick_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleWeekNumberClick($event));
    })("activeDateChange", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_activeDateChange_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleActiveDateChange($event));
    })("pageChange", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_pageChange_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onPageChange());
    })("focusCalendar", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_focusCalendar_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleFocus());
    })("blurCalendar", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_blurCalendar_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("cellEnter", function CalendarComponent_ng_container_1_Template_kendo_calendar_viewlist_cellEnter_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onCellEnter($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "kendo-resize-sensor", 5);
    ɵɵlistener("resize", function CalendarComponent_ng_container_1_Template_kendo_resize_sensor_resize_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onResize());
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_11_0;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.navigation);
    ɵɵadvance();
    ɵɵproperty("activeView", ctx_r2.activeViewEnum)("allowReverse", ctx_r2.allowReverse)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("activeRangeEnd", ctx_r2.activeRangeEnd)("selectionRange", ctx_r2.selectionRange)("size", ctx_r2.size)("isActive", ctx_r2.isActive)("id", ctx_r2.headerId)("weekDaysFormat", ctx_r2.weekDaysFormat)("cellTemplateRef", (tmp_11_0 = ctx_r2.activeCellTemplate()) == null ? null : tmp_11_0.templateRef)("headerTitleTemplateRef", ctx_r2.headerTitleTemplateRef == null ? null : ctx_r2.headerTitleTemplateRef.templateRef)("headerTemplateRef", ctx_r2.headerTemplateRef == null ? null : ctx_r2.headerTemplateRef.templateRef)("showFooter", ctx_r2.footer)("footerTemplateRef", ctx_r2.footerTemplateRef == null ? null : ctx_r2.footerTemplateRef.templateRef)("weekNumberTemplateRef", ctx_r2.weekNumberTemplateRef == null ? null : ctx_r2.weekNumberTemplateRef.templateRef)("cellUID", ctx_r2.cellUID)("min", ctx_r2.min)("max", ctx_r2.max)("focusedDate", ctx_r2.focusedDate)("weekNumber", ctx_r2.weekNumber)("selectedDates", ctx_r2.selectedDates)("tabIndex", ctx_r2.tabIndex)("disabled", ctx_r2.disabled);
  }
}
function CalendarComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "kendo-multiviewcalendar", 7, 0);
    ɵɵlistener("onClosePopup", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_onClosePopup_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closePopup.emit());
    })("activeViewChange", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_activeViewChange_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleActiveViewChange($event));
    })("navigate", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_navigate_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleNavigate($event));
    })("valueChange", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_valueChange_1_listener($event) {
      ɵɵrestoreView(_r4);
      const multiviewcalendar_r5 = ɵɵreference(2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleMultiViewCalendarValueChange($event, multiviewcalendar_r5.focusedDate));
    })("focusCalendar", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_focusCalendar_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleFocus());
    })("blur", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_blur_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("blurEvent", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_blurEvent_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleBlur($event));
    })("keydown", function CalendarComponent_ng_container_2_Template_kendo_multiviewcalendar_keydown_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleMultiViewCalendarKeydown($event));
    });
    ɵɵelement(3, "kendo-multiviewcalendar-messages", 8);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("views", 1)("min", ctx_r2.min)("max", ctx_r2.max)("size", ctx_r2.size)("id", ctx_r2.id)("activeRangeEnd", ctx_r2.activeRangeEnd)("selectionRange", ctx_r2.selectionRange)("allowReverse", ctx_r2.allowReverse)("disabled", ctx_r2.disabled)("isActive", ctx_r2.isActive)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("tabIndex", ctx_r2.tabIndex)("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("topView", ctx_r2.topView)("weekDaysFormat", ctx_r2.weekDaysFormat)("weekNumber", ctx_r2.weekNumber)("animateNavigation", ctx_r2.animateNavigation)("cellTemplate", ctx_r2.activeCellTemplate())("monthCellTemplate", ctx_r2.monthCellTemplateRef)("yearCellTemplate", ctx_r2.yearCellTemplateRef)("decadeCellTemplate", ctx_r2.decadeCellTemplateRef)("centuryCellTemplate", ctx_r2.centuryCellTemplateRef)("headerTitleTemplate", ctx_r2.headerTitleTemplateRef)("headerTemplate", ctx_r2.headerTemplateRef)("footerTemplate", ctx_r2.footerTemplateRef)("footer", ctx_r2.footer)("weekNumberTemplate", ctx_r2.weekNumberTemplateRef)("focusedDate", ctx_r2.focusedDate)("selection", ctx_r2.selection)("value", ctx_r2.value)("disabledDates", ctx_r2.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r2.localization.get("today"))("prevButtonTitle", ctx_r2.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r2.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r2.localization.get("parentViewButtonTitle"));
  }
}
var _c10 = ["dateInput"];
var _c11 = ["spinup"];
var _c122 = ["spindown"];
var _c13 = (a0, a1) => ({
  dragstart: a0,
  drop: a1
});
function DateInputComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 7);
    ɵɵlistener("click", function DateInputComponent_span_3_Template_span_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.resetInput());
    })("mousedown", function DateInputComponent_span_3_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r1.localization.get("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function DateInputComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵlistener("mousedown", function DateInputComponent_span_4_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelementStart(1, "button", 10, 1);
    ɵɵlistener("mousedown", function DateInputComponent_span_4_Template_button_mousedown_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.Up);
    })("mouseleave", function DateInputComponent_span_4_Template_button_mouseleave_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.None);
    })("click", function DateInputComponent_span_4_Template_button_click_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleButtonClick(1));
    });
    ɵɵelement(3, "kendo-icon-wrapper", 11);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 12, 2);
    ɵɵlistener("click", function DateInputComponent_span_4_Template_button_click_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleButtonClick(-1));
    })("mousedown", function DateInputComponent_span_4_Template_button_mousedown_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.Down);
    })("mouseleave", function DateInputComponent_span_4_Template_button_mouseleave_4_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.arrowDirection = ctx_r1.arrow.None);
    });
    ɵɵelement(6, "kendo-icon-wrapper", 13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Up);
    ɵɵproperty("title", ctx_r1.localization.get("increment"));
    ɵɵattribute("aria-label", ctx_r1.localization.get("increment"));
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.caretAltUpIcon);
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.arrow.Down);
    ɵɵproperty("title", ctx_r1.localization.get("decrement"));
    ɵɵattribute("aria-label", ctx_r1.localization.get("decrement"));
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.caretAltDownIcon);
  }
}
var _c14 = ["container"];
var _c15 = ["popupTemplate"];
var _c16 = ["toggleButton"];
var _c17 = ["actionSheet"];
var _c18 = (a0, a1) => ({
  click: a0,
  mousedown: a1
});
var _c19 = (a0, a1) => ({
  "k-adaptive-actionsheet": true,
  "k-actionsheet-fullscreen": a0,
  "k-actionsheet-bottom": a1
});
var _c20 = (a0) => ({
  height: a0
});
var _c21 = (a0) => ({
  keydown: a0
});
function DatePickerComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DatePickerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DatePickerComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 15);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const calendarTemplate_r2 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", calendarTemplate_r2);
  }
}
function DatePickerComponent_kendo_resize_sensor_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 16);
    ɵɵlistener("resize", function DatePickerComponent_kendo_resize_sensor_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onResize());
    });
    ɵɵelementEnd();
  }
}
function DatePickerComponent_ng_template_14_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveTitle);
  }
}
function DatePickerComponent_ng_template_14_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveSubtitle);
  }
}
function DatePickerComponent_ng_template_14_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DatePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "div", 18)(2, "div", 19);
    ɵɵtemplate(3, DatePickerComponent_ng_template_14_div_3_Template, 2, 1, "div", 20)(4, DatePickerComponent_ng_template_14_div_4_Template, 2, 1, "div", 21);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 22)(6, "button", 23);
    ɵɵlistener("click", function DatePickerComponent_ng_template_14_Template_button_click_6_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(7, "div", 24);
    ɵɵtemplate(8, DatePickerComponent_ng_template_14_ng_container_8_Template, 1, 0, "ng-container", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const calendarTemplate_r2 = ɵɵreference(16);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r3.adaptiveTitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.adaptiveSubtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r3.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r3.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", calendarTemplate_r2);
  }
}
function DatePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-calendar", 27, 6);
    ɵɵlistener("closePopup", function DatePickerComponent_ng_template_15_Template_kendo_calendar_closePopup_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    })("valueChange", function DatePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleChange(ctx_r3.mergeTime($event)));
    });
    ɵɵelement(2, "kendo-calendar-messages", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("type", ctx_r3.calendarType)("size", ctx_r3.isAdaptive ? "large" : ctx_r3.size)("min", ctx_r3.min)("max", ctx_r3.max)("weekDaysFormat", ctx_r3.weekDaysFormat)("navigation", ctx_r3.navigation)("animateNavigation", ctx_r3.animateCalendarNavigation)("activeView", ctx_r3.activeView)("bottomView", ctx_r3.bottomView)("showOtherMonthDays", ctx_r3.showOtherMonthDays)("topView", ctx_r3.topView)("weekNumber", ctx_r3.weekNumber)("cellTemplate", ctx_r3.cellTemplate)("monthCellTemplate", ctx_r3.monthCellTemplate)("yearCellTemplate", ctx_r3.yearCellTemplate)("decadeCellTemplate", ctx_r3.decadeCellTemplate)("centuryCellTemplate", ctx_r3.centuryCellTemplate)("weekNumberTemplate", ctx_r3.weekNumberTemplate)("headerTitleTemplate", ctx_r3.headerTitleTemplate)("headerTemplate", ctx_r3.headerTemplate)("footerTemplate", ctx_r3.footerTemplate)("footer", ctx_r3.footer)("navigationItemTemplate", ctx_r3.navigationItemTemplate)("focusedDate", ctx_r3.focusedDate)("value", ctx_r3.value)("kendoEventsOutsideAngular", ɵɵpureFunction1(32, _c21, ctx_r3.handleKeydown))("scope", ctx_r3)("disabledDates", ctx_r3.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r3.localization.get("today"))("prevButtonTitle", ctx_r3.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r3.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r3.localization.get("parentViewButtonTitle"));
  }
}
function TimeListComponent_li_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const index_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("data-timelist-item-index", index_r2)("role", "option")("aria-selected", index_r2 === ctx_r2.currentSelectedIndex);
    ɵɵadvance(2);
    ɵɵtextInterpolate(item_r1.text);
  }
}
var _c222 = ["accept"];
var _c23 = ["cancel"];
var _c24 = ["now"];
var _c25 = ["listWrapper"];
var _c26 = (a0, a1, a2, a3) => ({
  click: a0,
  focus: a1,
  blur: a2,
  keydown: a3
});
var _c27 = (a0, a1) => ({
  focus: a0,
  blur: a1
});
function TimeSelectorComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 12, 0);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c26, ctx_r0.handleNow, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("nowLabel"))("aria-label", ctx_r0.localization.get("nowLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("now"));
  }
}
function TimeSelectorComponent_ng_template_7_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 15, 1)(2, "span", 6);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "kendo-timelist", 16);
    ɵɵtwoWayListener("valueChange", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_valueChange_4_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.current, $event) || (ctx_r0.current = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("tabOutLastPart", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_tabOutLastPart_4_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.tabOutLastPart.emit());
    })("tabOutFirstPart", function TimeSelectorComponent_ng_template_7_div_0_Template_kendo_timelist_tabOutFirstPart_4_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.tabOutFirstPart.emit());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const part_r4 = ctx_r2.$implicit;
    const idx_r5 = ctx_r2.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.intl.dateFieldName(part_r4));
    ɵɵadvance();
    ɵɵproperty("isLast", idx_r5 === ctx_r0.dateFormatParts.length - 1)("isFirst", idx_r5 === 0)("min", ctx_r0.min)("max", ctx_r0.max)("part", part_r4)("step", ctx_r0.partStep(part_r4))("disabled", ctx_r0.disabled);
    ɵɵtwoWayProperty("value", ctx_r0.current);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(12, _c27, ctx_r0.handleListFocus, ctx_r0.handleBlur))("scope", ctx_r0);
    ɵɵattribute("data-timelist-index", idx_r5);
  }
}
function TimeSelectorComponent_ng_template_7_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const part_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", part_r4.pattern, " ");
  }
}
function TimeSelectorComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimeSelectorComponent_ng_template_7_div_0_Template, 5, 15, "div", 13)(1, TimeSelectorComponent_ng_template_7_div_1_Template, 2, 1, "div", 14);
  }
  if (rf & 2) {
    const part_r4 = ctx.$implicit;
    ɵɵproperty("ngIf", part_r4.type !== "literal");
    ɵɵadvance();
    ɵɵproperty("ngIf", part_r4.type === "literal");
  }
}
function TimeSelectorComponent_div_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 21, 2);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c26, ctx_r0.handleAccept, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("acceptLabel"))("aria-label", ctx_r0.localization.get("acceptLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("accept"));
  }
}
function TimeSelectorComponent_div_8_button_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 22, 3);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(6, _c26, ctx_r0.handleReject, ctx_r0.handleFocus, ctx_r0.handleBlur, ctx_r0.handleTabOut))("scope", ctx_r0)("disabled", ctx_r0.disabled);
    ɵɵattribute("title", ctx_r0.localization.get("cancelLabel"))("aria-label", ctx_r0.localization.get("cancelLabel"));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.localization.get("cancel"));
  }
}
function TimeSelectorComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵtemplate(1, TimeSelectorComponent_div_8_button_1_Template, 3, 11, "button", 19)(2, TimeSelectorComponent_div_8_button_2_Template, 3, 11, "button", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.setButton);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.cancelButton);
  }
}
var _c28 = (a0, a1) => ({
  keydown: a0,
  mousedown: a1
});
function TimePickerComponent_ng_template_7_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TimePickerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TimePickerComponent_ng_template_7_ng_container_0_Template, 1, 0, "ng-container", 15);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const timeSelectorTemplate_r2 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", timeSelectorTemplate_r2);
  }
}
function TimePickerComponent_kendo_resize_sensor_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 16);
    ɵɵlistener("resize", function TimePickerComponent_kendo_resize_sensor_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onResize());
    });
    ɵɵelementEnd();
  }
}
function TimePickerComponent_ng_template_14_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveTitle);
  }
}
function TimePickerComponent_ng_template_14_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 29);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.adaptiveSubtitle);
  }
}
function TimePickerComponent_ng_template_14_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function TimePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "div", 18)(2, "div", 19);
    ɵɵtemplate(3, TimePickerComponent_ng_template_14_div_3_Template, 2, 1, "div", 20)(4, TimePickerComponent_ng_template_14_div_4_Template, 2, 1, "div", 21);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 22)(6, "button", 23);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_6_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.show = false);
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(7, "div", 24);
    ɵɵtemplate(8, TimePickerComponent_ng_template_14_ng_container_8_Template, 1, 0, "ng-container", 15);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 25)(10, "button", 26);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_10_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleReject());
    });
    ɵɵtext(11);
    ɵɵelementEnd();
    ɵɵelementStart(12, "button", 27);
    ɵɵlistener("click", function TimePickerComponent_ng_template_14_Template_button_click_12_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleActionSheetAccept());
    });
    ɵɵtext(13);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const timeSelectorTemplate_r2 = ɵɵreference(16);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r3.adaptiveTitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.adaptiveSubtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r3.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r3.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", timeSelectorTemplate_r2);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r3.localization.get("cancelLabel"))("aria-label", ctx_r3.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.localization.get("cancel"), " ");
    ɵɵadvance();
    ɵɵattribute("title", ctx_r3.localization.get("acceptLabel"))("aria-label", ctx_r3.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.localization.get("accept"), " ");
  }
}
function TimePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-timeselector", 30, 6);
    ɵɵlistener("valueChange", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleChange($event));
    })("valueReject", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_valueReject_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.handleReject());
    })("tabOutLastPart", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutLastPart_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutLastPart());
    })("tabOutFirstPart", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutFirstPart_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutFirstPart());
    })("tabOutNow", function TimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutNow_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onTabOutNow());
    });
    ɵɵelement(2, "kendo-timeselector-messages", 31);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("k-timeselector-lg", ctx_r3.isAdaptive);
    ɵɵproperty("cancelButton", ctx_r3.cancelButton && !ctx_r3.isAdaptive)("setButton", !ctx_r3.isAdaptive)("nowButton", ctx_r3.nowButton)("format", ctx_r3.format)("min", ctx_r3.min)("max", ctx_r3.max)("steps", ctx_r3.steps)("value", ctx_r3.value)("isAdaptiveEnabled", ctx_r3.isAdaptiveModeEnabled)("kendoEventsOutsideAngular", ɵɵpureFunction2(24, _c28, ctx_r3.handleKeydown, ctx_r3.handleMousedown))("scope", ctx_r3);
    ɵɵadvance(2);
    ɵɵproperty("acceptLabel", ctx_r3.localization.get("acceptLabel"))("accept", ctx_r3.localization.get("accept"))("cancelLabel", ctx_r3.localization.get("cancelLabel"))("cancel", ctx_r3.localization.get("cancel"))("nowLabel", ctx_r3.localization.get("nowLabel"))("now", ctx_r3.localization.get("now"))("hour", ctx_r3.localization.get("hour"))("minute", ctx_r3.localization.get("minute"))("second", ctx_r3.localization.get("second"))("millisecond", ctx_r3.localization.get("millisecond"))("dayperiod", ctx_r3.localization.get("dayperiod"));
  }
}
var _c29 = (a0, a1) => ({
  mousedown: a0,
  click: a1
});
var _c30 = (a0, a1) => ({
  "k-datetime-wrap-md": a0,
  "k-datetime-wrap-lg": a1
});
var _c31 = (a0, a1) => ({
  mousedown: a0,
  keydown: a1
});
var _c322 = (a0, a1) => ({
  focusin: a0,
  focusout: a1
});
var _c33 = (a0, a1) => ({
  click: a0,
  "keydown.shift.tab": a1
});
var _c34 = (a0, a1) => ({
  click: a0,
  "keydown.tab": a1
});
var _c35 = (a0) => ({
  transitionend: a0
});
var _c36 = (a0) => ({
  "k-timeselector-lg": a0
});
var _c37 = (a0, a1, a2) => ({
  click: a0,
  "keydown.tab": a1,
  "keydown.shift.tab": a2
});
function DateTimePickerComponent_kendo_icon_wrapper_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.calendarIcon);
  }
}
function DateTimePickerComponent_kendo_icon_wrapper_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.clockIcon);
  }
}
function DateTimePickerComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DateTimePickerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DateTimePickerComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 18);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const dateTimeTemplate_r3 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", dateTimeTemplate_r3);
  }
}
function DateTimePickerComponent_kendo_resize_sensor_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 19);
    ɵɵlistener("resize", function DateTimePickerComponent_kendo_resize_sensor_11_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function DateTimePickerComponent_ng_template_14_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 31);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.adaptiveTitle);
  }
}
function DateTimePickerComponent_ng_template_14_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 32);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.adaptiveSubtitle);
  }
}
function DateTimePickerComponent_ng_template_14_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DateTimePickerComponent_ng_template_14_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 33);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_button_10_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleCancel());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("title", ctx_r1.localization.get("cancelLabel"))("aria-label", ctx_r1.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("cancel"), " ");
  }
}
function DateTimePickerComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "div", 21)(2, "div", 22);
    ɵɵtemplate(3, DateTimePickerComponent_ng_template_14_div_3_Template, 2, 1, "div", 23)(4, DateTimePickerComponent_ng_template_14_div_4_Template, 2, 1, "div", 24);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 25)(6, "button", 26);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_Template_button_click_6_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleActionSheet(false));
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(7, "div", 27);
    ɵɵtemplate(8, DateTimePickerComponent_ng_template_14_ng_container_8_Template, 1, 0, "ng-container", 18);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 28);
    ɵɵtemplate(10, DateTimePickerComponent_ng_template_14_button_10_Template, 2, 3, "button", 29);
    ɵɵelementStart(11, "button", 30);
    ɵɵlistener("click", function DateTimePickerComponent_ng_template_14_Template_button_click_11_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleAccept());
    });
    ɵɵtext(12);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const dateTimeTemplate_r3 = ɵɵreference(16);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.adaptiveTitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.adaptiveSubtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r1.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", dateTimeTemplate_r3);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.cancelButton);
    ɵɵadvance();
    ɵɵproperty("disabled", !ctx_r1.calendarValue);
    ɵɵattribute("title", ctx_r1.localization.get("acceptLabel"))("aria-label", ctx_r1.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("accept"), " ");
  }
}
function DateTimePickerComponent_ng_template_15_div_16_button_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 50);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction3(5, _c37, ctx_r1.handleCancel, ctx_r1.handleTab, ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("title", ctx_r1.localization.get("cancelLabel"))("aria-label", ctx_r1.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("cancel"), " ");
  }
}
function DateTimePickerComponent_ng_template_15_div_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 47)(1, "button", 48);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, DateTimePickerComponent_ng_template_15_div_16_button_3_Template, 2, 9, "button", 49);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(9, _c322, ctx_r1.handleFocus, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance();
    ɵɵproperty("disabled", !ctx_r1.calendarValue)("kendoEventsOutsideAngular", ɵɵpureFunction3(12, _c37, ctx_r1.handleAccept, ctx_r1.handleTab, ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("title", ctx_r1.localization.get("acceptLabel"))("aria-label", ctx_r1.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("accept"), " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.cancelButton);
  }
}
function DateTimePickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 34)(1, "div", 35)(2, "div", 36)(3, "button", 37);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "button", 38);
    ɵɵtext(6);
    ɵɵelementEnd()()();
    ɵɵelementStart(7, "div", 39, 5)(9, "div", 40)(10, "kendo-calendar", 41, 6);
    ɵɵtwoWayListener("valueChange", function DateTimePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_10_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.calendarValue, $event) || (ctx_r1.calendarValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("valueChange", function DateTimePickerComponent_ng_template_15_Template_kendo_calendar_valueChange_10_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleCalendarValueChange());
    });
    ɵɵelement(12, "kendo-calendar-messages", 42);
    ɵɵelementEnd()();
    ɵɵelementStart(13, "div", 43)(14, "kendo-timeselector", 44);
    ɵɵlistener("tabOutLastPart", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutLastPart_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutLastPart());
    })("tabOutFirstPart", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutFirstPart_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutFirstPart());
    })("tabOutNow", function DateTimePickerComponent_ng_template_15_Template_kendo_timeselector_tabOutNow_14_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabOutNow());
    });
    ɵɵelement(15, "kendo-timeselector-messages", 45);
    ɵɵelementEnd()()();
    ɵɵtemplate(16, DateTimePickerComponent_ng_template_15_div_16_Template, 4, 16, "div", 46);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dateTimeSelector_r8 = ɵɵreference(8);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate1("k-datetime-wrap k-", ctx_r1.activeTab, "-tab");
    ɵɵproperty("ngClass", ɵɵpureFunction2(79, _c30, !ctx_r1.isAdaptive, ctx_r1.isAdaptive))("kendoEventsOutsideAngular", ɵɵpureFunction2(82, _c31, ctx_r1.preventMouseDown, ctx_r1.handleKeyDown))("scope", ctx_r1);
    ɵɵadvance();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(85, _c322, ctx_r1.handleFocus, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance(2);
    ɵɵclassProp("k-selected", ctx_r1.activeTab === "date");
    ɵɵproperty("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("kendoEventsOutsideAngular", ɵɵpureFunction2(88, _c33, ctx_r1.changeActiveTab.bind(ctx_r1, "date"), ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("aria-pressed", ctx_r1.activeTab === "date" ? "true" : "false")("title", ctx_r1.localization.get("dateTabLabel"))("aria-label", ctx_r1.localization.get("dateTabLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("dateTab"), " ");
    ɵɵadvance();
    ɵɵclassProp("k-selected", ctx_r1.activeTab === "time");
    ɵɵproperty("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("kendoEventsOutsideAngular", ɵɵpureFunction2(91, _c34, ctx_r1.changeActiveTab.bind(ctx_r1, "time"), ctx_r1.handleTab))("scope", ctx_r1);
    ɵɵattribute("aria-pressed", ctx_r1.activeTab === "time" ? "true" : "false")("title", ctx_r1.localization.get("timeTabLabel"))("aria-label", ctx_r1.localization.get("timeTabLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.localization.get("timeTab"), " ");
    ɵɵadvance();
    ɵɵstyleProp("transition", ctx_r1.tabSwitchTransition);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(94, _c35, ctx_r1.handleTabChangeTransitionEnd.bind(ctx_r1, dateTimeSelector_r8)));
    ɵɵadvance(3);
    ɵɵproperty("focusedDate", ctx_r1.focusedDate)("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size);
    ɵɵtwoWayProperty("value", ctx_r1.calendarValue);
    ɵɵproperty("type", ctx_r1.calendarType)("min", ctx_r1.calendarMin)("max", ctx_r1.calendarMax)("weekDaysFormat", ctx_r1.weekDaysFormat)("weekNumber", ctx_r1.weekNumber)("navigation", false)("animateNavigation", ctx_r1.animateCalendarNavigation)("showOtherMonthDays", ctx_r1.showOtherMonthDays)("cellTemplate", ctx_r1.cellTemplate)("monthCellTemplate", ctx_r1.monthCellTemplate)("yearCellTemplate", ctx_r1.yearCellTemplate)("decadeCellTemplate", ctx_r1.decadeCellTemplate)("centuryCellTemplate", ctx_r1.centuryCellTemplate)("weekNumberTemplate", ctx_r1.weekNumberTemplate)("headerTitleTemplate", ctx_r1.headerTitleTemplate)("headerTemplate", ctx_r1.headerTemplate)("footerTemplate", ctx_r1.footerTemplate)("footer", ctx_r1.footer)("disabled", ctx_r1.disableCalendar)("disabledDates", ctx_r1.disabledDates);
    ɵɵadvance(2);
    ɵɵproperty("today", ctx_r1.localization.get("today"))("prevButtonTitle", ctx_r1.localization.get("prevButtonTitle"))("nextButtonTitle", ctx_r1.localization.get("nextButtonTitle"))("parentViewButtonTitle", ctx_r1.localization.get("parentViewButtonTitle"));
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(96, _c36, ctx_r1.isAdaptive))("value", ctx_r1.value)("format", ctx_r1.timeSelectorFormat)("min", ctx_r1.timeSelectorMin)("max", ctx_r1.timeSelectorMax)("setButton", false)("cancelButton", false)("steps", ctx_r1.steps)("disabled", ctx_r1.disableTimeSelector)("isAdaptiveEnabled", ctx_r1.isAdaptiveModeEnabled)("isDateTimePicker", true);
    ɵɵadvance();
    ɵɵproperty("acceptLabel", ctx_r1.localization.get("acceptLabel"))("accept", ctx_r1.localization.get("accept"))("cancelLabel", ctx_r1.localization.get("cancelLabel"))("cancel", ctx_r1.localization.get("cancel"))("nowLabel", ctx_r1.localization.get("nowLabel"))("now", ctx_r1.localization.get("now"))("hour", ctx_r1.localization.get("hour"))("minute", ctx_r1.localization.get("minute"))("second", ctx_r1.localization.get("second"))("millisecond", ctx_r1.localization.get("millisecond"))("dayperiod", ctx_r1.localization.get("dayperiod"));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isAdaptive);
  }
}
var _c38 = ["defaultTemplate"];
function DateRangePopupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-multiviewcalendar", 6);
    ɵɵlistener("onClosePopup", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onClosePopup_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closePopup($event));
    })("onTabPress", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onTabPress_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleTab($event));
    })("onShiftTabPress", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_onShiftTabPress_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleShiftTab($event));
    })("rangeSelectionChange", function DateRangePopupComponent_ng_template_3_Template_kendo_multiviewcalendar_rangeSelectionChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onRangeSelectionChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("animateNavigation", ctx_r2.animateNavigation)("disabled", ctx_r2.disabled)("views", ctx_r2.views)("weekNumber", ctx_r2.weekNumber)("topView", ctx_r2.topView)("disabledDates", ctx_r2.disabledDates)("min", ctx_r2.min)("max", ctx_r2.max)("showCalendarHeader", ctx_r2.showCalendarHeader)("focusedDate", ctx_r2.focusedDate)("allowReverse", ctx_r2.allowReverse)("showViewHeader", ctx_r2.showViewHeader)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("size", ctx_r2.size)("value", ctx_r2.dateRangeService.selectionRange);
  }
}
function DateRangePopupComponent_ng_template_7_kendo_resize_sensor_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 21);
    ɵɵlistener("resize", function DateRangePopupComponent_ng_template_7_kendo_resize_sensor_0_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onResize());
    });
    ɵɵelementEnd();
  }
}
function DateRangePopupComponent_ng_template_7_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.adaptiveTitle);
  }
}
function DateRangePopupComponent_ng_template_7_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 23);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.adaptiveSubtitle);
  }
}
function DateRangePopupComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵtemplate(0, DateRangePopupComponent_ng_template_7_kendo_resize_sensor_0_Template, 1, 0, "kendo-resize-sensor", 7);
    ɵɵelementStart(1, "div", 8)(2, "div", 9)(3, "div", 10);
    ɵɵtemplate(4, DateRangePopupComponent_ng_template_7_div_4_Template, 2, 1, "div", 11)(5, DateRangePopupComponent_ng_template_7_div_5_Template, 2, 1, "div", 12);
    ɵɵelementEnd();
    ɵɵelementStart(6, "div", 13)(7, "button", 14);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_7_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleAccept());
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(8, "div", 15)(9, "div", 16)(10, "kendo-multiviewcalendar", 17);
    ɵɵlistener("rangeSelectionChange", function DateRangePopupComponent_ng_template_7_Template_kendo_multiviewcalendar_rangeSelectionChange_10_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onRangeSelectionChange($event));
    });
    ɵɵelementEnd()()();
    ɵɵelementStart(11, "div", 18)(12, "button", 19);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.show = false);
    });
    ɵɵtext(13);
    ɵɵelementEnd();
    ɵɵelementStart(14, "button", 20);
    ɵɵlistener("click", function DateRangePopupComponent_ng_template_7_Template_button_click_14_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleAccept());
    });
    ɵɵtext(15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r2.isAdaptiveModeEnabled);
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r2.adaptiveTitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.adaptiveSubtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r2.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r2.localization.get("adaptiveCloseButtonTitle"));
    ɵɵadvance(3);
    ɵɵproperty("animateNavigation", ctx_r2.animateNavigation)("disabled", ctx_r2.disabled)("views", ctx_r2.views)("weekNumber", ctx_r2.weekNumber)("disabledDates", ctx_r2.disabledDates)("activeView", ctx_r2.activeView)("bottomView", ctx_r2.bottomView)("topView", ctx_r2.topView)("min", ctx_r2.min)("max", ctx_r2.max)("showCalendarHeader", ctx_r2.showCalendarHeader)("focusedDate", ctx_r2.focusedDate)("allowReverse", ctx_r2.allowReverse)("showViewHeader", ctx_r2.showViewHeader)("showOtherMonthDays", ctx_r2.showOtherMonthDays)("focusedDate", ctx_r2.dateRangeService.focusedDate)("value", ctx_r2.dateRangeService.selectionRange);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r2.localization.get("cancelLabel"))("aria-label", ctx_r2.localization.get("cancelLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.localization.get("cancel"), " ");
    ɵɵadvance();
    ɵɵattribute("title", ctx_r2.localization.get("acceptLabel"))("aria-label", ctx_r2.localization.get("acceptLabel"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.localization.get("accept"), " ");
  }
}
function DateRangeComponent_kendo_daterange_popup_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-daterange-popup", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r0.size);
  }
}
var packageMetadata2 = {
  name: "@progress/kendo-angular-dateinputs",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1749540135,
  version: "19.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var Action;
(function(Action2) {
  Action2[Action2["Left"] = 0] = "Left";
  Action2[Action2["Right"] = 1] = "Right";
  Action2[Action2["Up"] = 2] = "Up";
  Action2[Action2["Down"] = 3] = "Down";
  Action2[Action2["PrevView"] = 4] = "PrevView";
  Action2[Action2["NextView"] = 5] = "NextView";
  Action2[Action2["FirstInView"] = 6] = "FirstInView";
  Action2[Action2["LastInView"] = 7] = "LastInView";
  Action2[Action2["LowerView"] = 8] = "LowerView";
  Action2[Action2["UpperView"] = 9] = "UpperView";
})(Action || (Action = {}));
var EMPTY_SELECTIONRANGE = {
  start: null,
  end: null
};
var MIDNIGHT_DATE = new Date(1980, 0, 1);
var MIN_DATE = new Date(1900, 0, 1);
var MAX_DATE = new Date(2099, 11, 31);
var MIN_TIME = new Date(1980, 0, 1);
var MAX_TIME = new Date(1980, 0, 1, 23, 59, 59);
var requiresZoneOnBlur = (ngControl) => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === "blur");
var preventDefault = (args) => args.preventDefault();
var currentFocusTarget = (blurArgs) => blurArgs.relatedTarget || document.activeElement;
var isPresent3 = (value) => value !== void 0 && value !== null;
var isNullOrDate = (value) => value === null || value instanceof Date;
var isNumberArray = (value) => Array.isArray(value) && value.length > 0 && value.every((item) => typeof item === "number");
var isDateArray = (value) => Array.isArray(value) && value.length > 0 && value.every((item) => item instanceof Date);
var isArrowWithShiftPressed = (args) => args.shiftKey && (args.keyCode === Keys2.ArrowRight || args.keyCode === Keys2.ArrowLeft || args.keyCode === Keys2.ArrowDown || args.keyCode === Keys2.ArrowUp);
var Keys2;
(function(Keys3) {
  Keys3[Keys3["ArrowDown"] = 40] = "ArrowDown";
  Keys3[Keys3["ArrowLeft"] = 37] = "ArrowLeft";
  Keys3[Keys3["ArrowRight"] = 39] = "ArrowRight";
  Keys3[Keys3["ArrowUp"] = 38] = "ArrowUp";
})(Keys2 || (Keys2 = {}));
var selectors = {
  infiniteCalendarTable: ".k-content .k-calendar-table",
  multiViewCalendarTable: ".k-calendar-table"
};
var attributeNames = {
  ariaActiveDescendant: "aria-activedescendant",
  ariaControls: "aria-controls",
  ariaExpanded: "aria-expanded",
  ariaHasPopup: "aria-haspopup",
  valueNow: "aria-valuenow",
  valuetext: "aria-valuetext",
  ariaInvalid: "aria-invalid"
};
var isSet = (value) => value !== null && value !== void 0;
var setter = (method) => (date2, value) => {
  const clone = cloneDate(date2);
  clone[method](value);
  return clone;
};
var setTime = (origin, candidate) => {
  const date2 = cloneDate(origin);
  date2.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
  return date2;
};
var getTimeInMilliseconds = (candidate) => {
  const hoursInMilliseconds = candidate.getHours() * MS_PER_HOUR;
  const minutesInMilliseconds = candidate.getMinutes() * MS_PER_MINUTE;
  const secondsInMilliseconds = candidate.getSeconds() * 1e3;
  return hoursInMilliseconds + minutesInMilliseconds + secondsInMilliseconds + candidate.getMilliseconds();
};
var normalizeTimes = (candidate, min, max) => {
  return {
    candidateValue: setTime(MIDNIGHT_DATE, candidate),
    maxValue: addDays(setTime(MIDNIGHT_DATE, max), getTimeInMilliseconds(min) < getTimeInMilliseconds(max) ? 0 : 1),
    minValue: setTime(MIDNIGHT_DATE, min)
  };
};
var setYears2 = setter("setFullYear");
var setHours$1 = setter("setHours");
var setMinutes = setter("setMinutes");
var setSeconds = setter("setSeconds");
var setMilliseconds = setter("setMilliseconds");
var range = (start, end2, step = 1) => {
  const result = [];
  for (let i = start; i < end2; i = i + step) {
    result.push(i);
  }
  return result;
};
var isInRange = (candidate, min, max) => !candidate || !(min && min > candidate || max && max < candidate);
var isInTimeRange = (candidate, min, max) => {
  if (!candidate || !min || !max) {
    return true;
  }
  const {
    candidateValue,
    minValue,
    maxValue
  } = normalizeTimes(candidate, min, max);
  return minValue <= candidateValue && candidateValue <= maxValue;
};
var isValidRange = (min, max) => !isSet(min) || !isSet(max) || min <= max;
var dateInRange = (candidate, min, max) => {
  if (!candidate) {
    return candidate;
  }
  if (min && candidate < min) {
    return cloneDate(min);
  }
  if (max && candidate > max) {
    return cloneDate(max);
  }
  return candidate;
};
var timeInRange = (candidate, min, max) => {
  if (!candidate || !min || !max) {
    return candidate;
  }
  const {
    candidateValue,
    minValue,
    maxValue
  } = normalizeTimes(candidate, min, max);
  if (candidateValue < minValue) {
    return setTime(candidate, min);
  }
  if (candidateValue > maxValue) {
    return setTime(candidate, max);
  }
  return candidate;
};
var getNow = () => /* @__PURE__ */ new Date();
var getToday = () => getDate(/* @__PURE__ */ new Date());
var noop$2 = (_) => {
};
var isWindowAvailable = () => {
  return typeof window !== "undefined";
};
var stringifyClassObject = (classes) => {
  const pushToAcc = (acc, cls) => classes[cls] ? acc.concat(cls) : acc;
  return Object.keys(classes).reduce(pushToAcc, []).join(" ");
};
var shiftWeekNames = (names, offset3) => names.slice(offset3).concat(names.slice(0, offset3));
var domContainerFactory = (type) => (children2, classes = "", styles = {}) => {
  const container = document.createElement(type);
  container.className = classes;
  Object.keys(styles).map((key) => container.style[key] = styles[key]);
  if (typeof children2 === "string") {
    container.innerHTML = children2 || "";
  } else {
    (children2 || []).forEach((child) => child && container.appendChild(child));
  }
  return container;
};
var hasChange = (changes, field) => changes[field] !== void 0;
var hasExistingValue = (changes, field) => changes[field] && changes[field].currentValue !== void 0 && changes[field].currentValue !== null;
var last = (list2 = []) => list2 && list2[list2.length - 1];
var isInSelectionRange = (value, selectionRange) => {
  const {
    start,
    end: end2
  } = selectionRange || EMPTY_SELECTIONRANGE;
  if (!start || !end2) {
    return false;
  }
  return start < value && value < end2;
};
var either = (value1, value2) => value1 || value2;
var clampRange = (value) => ({
  start: value,
  end: value
});
var isEqualRange = (initial, updated) => {
  const {
    start: initialStart,
    end: initialEnd
  } = initial || EMPTY_SELECTIONRANGE;
  const {
    start: updatedStart,
    end: updatedEnd
  } = updated || EMPTY_SELECTIONRANGE;
  return isEqual(initialStart, updatedStart) && isEqual(initialEnd, updatedEnd);
};
var areDatesEqual = (first, second) => {
  first = first || [];
  second = second || [];
  return first.length === second.length && first.every((date2, index) => isEqual(date2, second[index]));
};
var sortDates = (dates) => {
  return dates.filter((date2) => isPresent3(date2)).sort((a, b) => a.getTime() - b.getTime());
};
var mergeDateAndTime = (date2, time) => {
  if (!(date2 && time)) {
    return null;
  }
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
};
var lastMillisecondOfDate = (date2) => {
  if (!date2) {
    return null;
  }
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
};
var disabledDatesInRange = (start, end2, isDateDisabled) => {
  if (!(start && end2 && isDateDisabled) || start > end2) {
    return [];
  }
  const dates = [];
  let current3 = start;
  while (current3 <= end2) {
    if (isDateDisabled(current3)) {
      dates.push(current3);
    }
    current3 = addDays(current3, 1);
  }
  return dates;
};
var isTabExitingCalendar = (calendarType, focusedElement, shiftKey) => {
  if (!isPresent3(focusedElement)) {
    return false;
  }
  return calendarType === "infinite" || // infinte calendar is always exited on first tab keydown
  calendarType === "classic" && shiftKey && focusedElement.classList.contains("k-calendar-table") || // exited on main calendar element focused and back-tab
  !shiftKey && focusedElement.classList.contains("k-calendar-table");
};
var getSizeClass = (component, size) => {
  const SIZE_CLASSES = {
    "small": `k-${component}-sm`,
    "medium": `k-${component}-md`,
    "large": `k-${component}-lg`
  };
  return SIZE_CLASSES[size];
};
var getRoundedClass = (rounded) => {
  const ROUNDED_CLASSES = {
    "small": "k-rounded-sm",
    "medium": "k-rounded-md",
    "large": "k-rounded-lg",
    "full": "k-rounded-full"
  };
  return ROUNDED_CLASSES[rounded];
};
var getFillModeClass = (component, fillMode) => {
  const FILLMODE_CLASSES = {
    "solid": `k-${component}-solid`,
    "flat": `k-${component}-flat`,
    "outline": `k-${component}-outline`
  };
  return FILLMODE_CLASSES[fillMode];
};
var DEFAULT_ROUNDED = "medium";
var DEFAULT_SIZE2 = "medium";
var DEFAULT_FILL_MODE = "solid";
var EMPTY_DATA$3 = [[]];
var CELLS_LENGTH$3 = 4;
var ROWS_LENGTH$3 = 3;
var upStep$1 = (year) => {
  const decadeOfCentury = Number(year.toString().slice(-2, -1));
  if (decadeOfCentury < 2) {
    return -2;
  }
  if (decadeOfCentury < 4) {
    return -6;
  }
  return -4;
};
var downStep$1 = (year) => {
  const decadeOfCentury = Number(year.toString().slice(-2, -1));
  if (decadeOfCentury > 7) {
    return 2;
  }
  if (decadeOfCentury > 5) {
    return 6;
  }
  return 4;
};
var ACTIONS$3 = {
  [Action.Left]: (date2) => addDecades(date2, -1),
  [Action.Up]: (date2) => addDecades(date2, upStep$1(date2.getFullYear())),
  [Action.Right]: (date2) => addDecades(date2, 1),
  [Action.Down]: (date2) => addDecades(date2, downStep$1(date2.getFullYear())),
  [Action.PrevView]: (date2) => addCenturies(date2, -1),
  [Action.NextView]: (date2) => addCenturies(date2, 1),
  [Action.FirstInView]: (date2) => firstDecadeOfCentury(date2),
  [Action.LastInView]: (date2) => lastDecadeOfCentury(date2)
};
var CenturyViewService = class _CenturyViewService {
  addToDate(min, skip3) {
    return addCenturies(min, skip3);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addCenturies(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$3;
    }
    const cells = range(0, CELLS_LENGTH$3);
    const firstDate = firstDecadeOfCentury(viewDate);
    const lastDate = lastDecadeOfCentury(viewDate);
    const lastYearOfCentury = lastYearOfDecade(lastDate).getFullYear() + 1;
    const today = getToday();
    return range(0, ROWS_LENGTH$3).map((rowOffset) => {
      const baseDate = addDecades(firstDate, rowOffset * CELLS_LENGTH$3);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addDecades(baseDate, cellOffset), min, max);
        const nextCentury = cellDate.getFullYear() >= lastYearOfCentury;
        if (!this.isInRange(cellDate, min, max) || nextCentury) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date2) => this.isEqual(cellDate, date2)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return firstYearOfDecade(candidate).getFullYear() === firstYearOfDecade(expected).getFullYear();
  }
  isInArray(date2, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date2.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 99;
  }
  isInRange(candidate, min, max) {
    const year = firstYearOfDecade(candidate).getFullYear();
    const aboveMin = !min || firstYearOfDecade(min).getFullYear() <= year;
    const belowMax = !max || year <= firstYearOfDecade(max).getFullYear();
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date2) {
    if (!date2) {
      return date2;
    }
    const firstYear = firstYearOfDecade(firstDecadeOfCentury(date2));
    return createDate(firstYear.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date2) {
    const decade = lastDecadeOfCentury(date2);
    const year = lastYearOfDecade(decade);
    const month = lastMonthOfYear(year);
    return lastDayOfMonth(month);
  }
  isRangeStart(value) {
    return value.getFullYear() % 1e3 === 0;
  }
  move(value, action) {
    const modifier = ACTIONS$3[action];
    if (!modifier) {
      return value;
    }
    return modifier(value);
  }
  cellTitle(value) {
    return firstYearOfDecade(value).getFullYear().toString();
  }
  navigationTitle(value) {
    return value ? firstDecadeOfCentury(value).getFullYear().toString() : "";
  }
  title(value) {
    if (!value) {
      return "";
    }
    return `${firstDecadeOfCentury(value).getFullYear()} - ${lastDecadeOfCentury(value).getFullYear()}`;
  }
  rowLength() {
    return CELLS_LENGTH$3;
  }
  skip(value, min) {
    return durationInCenturies(min, value);
  }
  total(min, max) {
    return durationInCenturies(min, max) + 1;
  }
  value(current3) {
    return current3 ? firstYearOfDecade(current3).getFullYear().toString() : "";
  }
  viewDate(date2, max, viewsCount = 1) {
    const viewsInRange = this.total(date2, max);
    if (viewsInRange < viewsCount) {
      const centuriesToSubtract = viewsCount - viewsInRange;
      return addCenturies(date2, -1 * centuriesToSubtract);
    }
    return date2;
  }
  dateRange = (start, end2) => {
    if (!isPresent3(start) || !isPresent3(end2)) {
      return [];
    }
    const result = [];
    let current3 = start;
    while (current3 <= end2) {
      result.push(current3);
      current3 = addDecades(current3, 1);
    }
    return result;
  };
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function CenturyViewService_Factory(t) {
    return new (t || _CenturyViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CenturyViewService,
    factory: _CenturyViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CenturyViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var EMPTY_DATA$2 = [[]];
var CELLS_LENGTH$2 = 4;
var ROWS_LENGTH$2 = 3;
var upStep = (year) => {
  const yearOfDecade = Number(year.toString().slice(-1));
  if (yearOfDecade < 2) {
    return -2;
  }
  if (yearOfDecade < 4) {
    return -6;
  }
  return -4;
};
var downStep = (year) => {
  const yearOfDecade = Number(year.toString().slice(-1));
  if (yearOfDecade > 7) {
    return 2;
  }
  if (yearOfDecade > 5) {
    return 6;
  }
  return 4;
};
var ACTIONS$2 = {
  [Action.Left]: (date2) => addYears(date2, -1),
  [Action.Up]: (date2) => addYears(date2, upStep(date2.getFullYear())),
  [Action.Right]: (date2) => addYears(date2, 1),
  [Action.Down]: (date2) => addYears(date2, downStep(date2.getFullYear())),
  [Action.PrevView]: (date2) => addDecades(date2, -1),
  [Action.NextView]: (date2) => addDecades(date2, 1),
  [Action.FirstInView]: (date2) => firstYearOfDecade(date2),
  [Action.LastInView]: (date2) => lastYearOfDecade(date2)
};
var DecadeViewService = class _DecadeViewService {
  addToDate(min, skip3) {
    return addDecades(min, skip3);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addDecades(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$2;
    }
    const cells = range(0, CELLS_LENGTH$2);
    const firstDate = firstYearOfDecade(viewDate);
    const lastDate = lastYearOfDecade(viewDate);
    const today = getToday();
    return range(0, ROWS_LENGTH$2).map((rowOffset) => {
      const baseDate = addYears(firstDate, rowOffset * CELLS_LENGTH$2);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addYears(baseDate, cellOffset), min, max);
        const nextDecade = cellDate.getFullYear() > lastDate.getFullYear();
        if (!this.isInRange(cellDate, min, max) || nextDecade) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date2) => this.isEqual(cellDate, date2)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return candidate.getFullYear() === expected.getFullYear();
  }
  isInArray(date2, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date2.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear() + 9;
  }
  isInRange(candidate, min, max) {
    const year = candidate.getFullYear();
    const aboveMin = !min || min.getFullYear() <= year;
    const belowMax = !max || year <= max.getFullYear();
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date2) {
    if (!date2) {
      return date2;
    }
    const firstYear = firstYearOfDecade(date2);
    return createDate(firstYear.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date2) {
    const year = lastYearOfDecade(date2);
    const month = lastMonthOfYear(year);
    return lastDayOfMonth(month);
  }
  isRangeStart(value) {
    return value.getFullYear() % 100 === 0;
  }
  move(value, action) {
    const modifier = ACTIONS$2[action];
    if (!modifier) {
      return value;
    }
    return modifier(value);
  }
  cellTitle(value) {
    return value.getFullYear().toString();
  }
  navigationTitle(value) {
    return value ? firstYearOfDecade(value).getFullYear().toString() : "";
  }
  title(value) {
    if (!value) {
      return "";
    }
    return `${firstYearOfDecade(value).getFullYear()} - ${lastYearOfDecade(value).getFullYear()}`;
  }
  rowLength() {
    return CELLS_LENGTH$2;
  }
  skip(value, min) {
    return durationInDecades(min, value);
  }
  total(min, max) {
    return durationInDecades(min, max) + 1;
  }
  value(current3) {
    return current3 ? current3.getFullYear().toString() : "";
  }
  viewDate(date2, max, viewsCount = 1) {
    const viewsInRange = this.total(date2, max);
    if (viewsInRange < viewsCount) {
      const decadesToSubtract = viewsCount - viewsInRange;
      return addDecades(date2, -1 * decadesToSubtract);
    }
    return date2;
  }
  dateRange = (start, end2) => {
    if (!isPresent3(start) || !isPresent3(end2)) {
      return [];
    }
    const result = [];
    let current3 = start;
    while (current3 <= end2) {
      result.push(current3);
      current3 = addYears(current3, 1);
    }
    return result;
  };
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function DecadeViewService_Factory(t) {
    return new (t || _DecadeViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DecadeViewService,
    factory: _DecadeViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var EMPTY_DATA$1 = [[]];
var CELLS_LENGTH$1 = 7;
var ROWS_LENGTH$1 = 6;
var ACTIONS$1 = {
  [Action.Left]: (date2) => addDays(date2, -1),
  [Action.Up]: (date2) => addWeeks(date2, -1),
  [Action.Right]: (date2) => addDays(date2, 1),
  [Action.Down]: (date2) => addWeeks(date2, 1),
  [Action.PrevView]: (date2) => addMonths(date2, -1),
  [Action.NextView]: (date2) => addMonths(date2, 1),
  [Action.FirstInView]: (date2) => firstDayOfMonth(date2),
  [Action.LastInView]: (date2) => lastDayOfMonth(date2)
};
var MonthViewService = class _MonthViewService {
  _intlService;
  constructor(_intlService) {
    this._intlService = _intlService;
  }
  addToDate(min, skip3) {
    return addMonths(min, skip3);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addMonths(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      isDateDisabled = () => false,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA$1;
    }
    const firstMonthDate = firstDayOfMonth(viewDate);
    const firstMonthDay = getDate(firstMonthDate);
    const lastMonthDate = lastDayOfMonth(viewDate);
    const lastMonthDay = getDate(lastMonthDate);
    const backward = -1;
    const date2 = dayOfWeek(firstMonthDate, this._intlService.firstDay(), backward);
    const cells = range(0, CELLS_LENGTH$1);
    const today = getToday();
    return range(0, ROWS_LENGTH$1).map((rowOffset) => {
      const baseDate = addDays(date2, rowOffset * CELLS_LENGTH$1);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addDays(baseDate, cellOffset), min, max);
        const cellDay = getDate(cellDate);
        const otherMonth = cellDay < firstMonthDay || cellDay > lastMonthDay;
        const outOfRange = cellDate < min || cellDate > max;
        if (outOfRange) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: this.value(cellDate),
          id: `${cellUID}${otherMonth ? cellDate.getTime() + "1" : cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date3) => this.isEqual(cellDate, date3)),
          isWeekend: this.isWeekend(cellDate),
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstMonthDate),
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastMonthDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          isDisabled: isDateDisabled(cellDate),
          isOtherMonth: otherMonth,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return getDate(candidate).getTime() === getDate(expected).getTime();
  }
  isInArray(date2, dates) {
    if (dates.length === 0) {
      return false;
    }
    const lowerBound = this.beginningOfPeriod(dates[0]);
    const upperBound = this.beginningOfPeriod(addMonths(dates[dates.length - 1], 1));
    return lowerBound <= date2 && date2 < upperBound;
  }
  isInRange(candidate, min, max) {
    const value = getDate(candidate);
    const aboveMin = !min || getDate(min) <= value;
    const belowMax = !max || value <= getDate(max);
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date2) {
    if (!date2) {
      return date2;
    }
    return createDate(date2.getFullYear(), date2.getMonth(), 1);
  }
  lastDayOfPeriod(date2) {
    return lastDayOfMonth(date2);
  }
  isRangeStart(value) {
    return !value.getMonth();
  }
  move(value, action) {
    const modifier = ACTIONS$1[action];
    if (!modifier) {
      return value;
    }
    return modifier(value);
  }
  cellTitle(value) {
    return this._intlService.formatDate(value, "D");
  }
  navigationTitle(value) {
    if (!value) {
      return "";
    }
    return this.isRangeStart(value) ? value.getFullYear().toString() : this.abbrMonthNames()[value.getMonth()];
  }
  title(current3) {
    return `${this.wideMonthNames()[current3.getMonth()]} ${current3.getFullYear()}`;
  }
  rowLength(options = {}) {
    return CELLS_LENGTH$1 + (options.prependCell ? 1 : 0);
  }
  skip(value, min) {
    return durationInMonths(min, value);
  }
  total(min, max) {
    return durationInMonths(min, max) + 1;
  }
  value(current3) {
    return current3 ? current3.getDate().toString() : "";
  }
  viewDate(date2, max, viewsCount = 1) {
    const viewsInRange = this.total(date2, max);
    if (viewsInRange < viewsCount) {
      const monthsToSubtract = viewsCount - viewsInRange;
      return addMonths(date2, -1 * monthsToSubtract);
    }
    return date2;
  }
  isWeekend(date2) {
    const {
      start,
      end: end2
    } = this._intlService.weekendRange();
    const day = date2.getDay();
    if (end2 < start) {
      return day <= end2 || start <= day;
    }
    return start <= day && day <= end2;
  }
  dateRange = (start, end2) => {
    if (!isPresent3(start) || !isPresent3(end2)) {
      return [];
    }
    const result = [];
    let current3 = start;
    while (current3 <= end2) {
      result.push(current3);
      current3 = addDays(current3, 1);
    }
    return result;
  };
  abbrMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "abbreviated",
      type: "months"
    });
  }
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  wideMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "wide",
      type: "months"
    });
  }
  static ɵfac = function MonthViewService_Factory(t) {
    return new (t || _MonthViewService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MonthViewService,
    factory: _MonthViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var EMPTY_DATA = [[]];
var CELLS_LENGTH = 4;
var ROWS_LENGTH = 3;
var ACTIONS = {
  [Action.Left]: (date2) => addMonths(date2, -1),
  [Action.Up]: (date2) => addMonths(date2, -4),
  [Action.Right]: (date2) => addMonths(date2, 1),
  [Action.Down]: (date2) => addMonths(date2, 4),
  [Action.PrevView]: (date2) => addYears(date2, -1),
  [Action.NextView]: (date2) => addYears(date2, 1),
  [Action.FirstInView]: (date2) => firstMonthOfYear(date2),
  [Action.LastInView]: (date2) => lastMonthOfYear(date2)
};
var YearViewService = class _YearViewService {
  _intlService;
  constructor(_intlService) {
    this._intlService = _intlService;
  }
  addToDate(min, skip3) {
    return addYears(min, skip3);
  }
  datesList(start, count2) {
    return range(0, count2).map((i) => addYears(start, i));
  }
  data(options) {
    const {
      cellUID,
      focusedDate,
      isActiveView,
      max,
      min,
      selectedDates,
      selectionRange = EMPTY_SELECTIONRANGE,
      viewDate,
      allowReverse
    } = options;
    if (!viewDate) {
      return EMPTY_DATA;
    }
    const months = this.abbrMonthNames();
    const firstDate = firstMonthOfYear(viewDate);
    const lastDate = lastMonthOfYear(viewDate);
    const currentYear = firstDate.getFullYear();
    const cells = range(0, CELLS_LENGTH);
    const today = getToday();
    return range(0, ROWS_LENGTH).map((rowOffset) => {
      const baseDate = addMonths(firstDate, rowOffset * CELLS_LENGTH);
      return cells.map((cellOffset) => {
        const cellDate = this.normalize(addMonths(baseDate, cellOffset), min, max);
        const changedYear = currentYear < cellDate.getFullYear();
        if (!this.isInRange(cellDate, min, max) || changedYear) {
          return null;
        }
        let isRangeStart = false;
        let isRangeEnd = false;
        if (allowReverse) {
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start <= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end <= selectionRange.start) {
            isRangeStart = true;
          }
          if (this.isEqual(cellDate, selectionRange.start) && selectionRange.start >= selectionRange.end || this.isEqual(cellDate, selectionRange.end) && selectionRange.end >= selectionRange.start) {
            isRangeEnd = true;
          }
        } else {
          isRangeStart = this.isEqual(cellDate, selectionRange.start);
          isRangeEnd = this.isEqual(cellDate, selectionRange.end);
        }
        const isInMiddle = !isRangeStart && !isRangeEnd;
        let isRangeMid;
        if (allowReverse) {
          isRangeMid = isInMiddle && (isInSelectionRange(cellDate, selectionRange) || isInSelectionRange(cellDate, {
            start: selectionRange.end,
            end: selectionRange.start
          }));
        } else {
          isRangeMid = isInMiddle && isInSelectionRange(cellDate, selectionRange);
        }
        return {
          formattedValue: months[cellDate.getMonth()],
          id: `${cellUID}${cellDate.getTime()}`,
          isFocused: this.isEqual(cellDate, focusedDate),
          isSelected: isActiveView && selectedDates.some((date2) => this.isEqual(cellDate, date2)),
          isWeekend: false,
          isRangeStart,
          isRangeMid,
          isRangeEnd,
          isRangeSplitEnd: isRangeMid && this.isEqual(cellDate, lastDate),
          isRangeSplitStart: isRangeMid && this.isEqual(cellDate, firstDate),
          isToday: this.isEqual(cellDate, today),
          title: this.cellTitle(cellDate),
          value: cellDate,
          allowReverse
        };
      });
    });
  }
  isEqual(candidate, expected) {
    if (!candidate || !expected) {
      return false;
    }
    return candidate.getFullYear() === expected.getFullYear() && candidate.getMonth() === expected.getMonth();
  }
  isInArray(date2, dates) {
    if (!dates.length) {
      return false;
    }
    const year = date2.getFullYear();
    return dates[0].getFullYear() <= year && year <= dates[dates.length - 1].getFullYear();
  }
  isInRange(candidate, min, max) {
    const candidateValue = createDate(candidate.getFullYear(), candidate.getMonth(), 1);
    const aboveMin = !min || createDate(min.getFullYear(), min.getMonth(), 1) <= candidateValue;
    const belowMax = !max || candidateValue <= createDate(max.getFullYear(), max.getMonth(), 1);
    return aboveMin && belowMax;
  }
  beginningOfPeriod(date2) {
    if (!date2) {
      return date2;
    }
    return createDate(date2.getFullYear(), 0, 1);
  }
  lastDayOfPeriod(date2) {
    const month = lastMonthOfYear(date2);
    return lastDayOfMonth(month);
  }
  isRangeStart(value) {
    return value.getFullYear() % 10 === 0;
  }
  move(value, action) {
    const modifier = ACTIONS[action];
    if (!modifier) {
      return value;
    }
    return modifier(value);
  }
  cellTitle(value) {
    return `${value.getFullYear()} ${this.value(value)}`;
  }
  navigationTitle(value) {
    return this.title(value);
  }
  title(current3) {
    return current3 ? current3.getFullYear().toString() : "";
  }
  rowLength() {
    return CELLS_LENGTH;
  }
  skip(value, min) {
    return durationInYears(min, value);
  }
  total(min, max) {
    return durationInYears(min, max) + 1;
  }
  value(current3) {
    return current3 ? this.abbrMonthNames()[current3.getMonth()] : "";
  }
  viewDate(date2, max, viewsCount = 1) {
    const viewsInRange = this.total(date2, max);
    if (viewsInRange < viewsCount) {
      const yearsToSubtract = viewsCount - viewsInRange;
      return addYears(date2, -1 * yearsToSubtract);
    }
    return date2;
  }
  dateRange = (start, end2) => {
    if (!isPresent3(start) || !isPresent3(end2)) {
      return [];
    }
    const result = [];
    let current3 = start;
    while (current3 <= end2) {
      result.push(current3);
      current3 = addMonths(current3, 1);
    }
    return result;
  };
  abbrMonthNames() {
    return this._intlService.dateFormatNames({
      nameType: "abbreviated",
      type: "months"
    });
  }
  normalize(cellDate, min, max) {
    if (cellDate < min && this.isEqual(cellDate, min)) {
      return cloneDate(min);
    }
    if (cellDate > max && this.isEqual(cellDate, max)) {
      return cloneDate(max);
    }
    return cellDate;
  }
  static ɵfac = function YearViewService_Factory(t) {
    return new (t || _YearViewService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _YearViewService,
    factory: _YearViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var CalendarViewEnum;
(function(CalendarViewEnum2) {
  CalendarViewEnum2[CalendarViewEnum2["month"] = 0] = "month";
  CalendarViewEnum2[CalendarViewEnum2["year"] = 1] = "year";
  CalendarViewEnum2[CalendarViewEnum2["decade"] = 2] = "decade";
  CalendarViewEnum2[CalendarViewEnum2["century"] = 3] = "century";
})(CalendarViewEnum || (CalendarViewEnum = {}));
var services$1 = {
  [CalendarViewEnum.month]: MonthViewService,
  [CalendarViewEnum.year]: YearViewService,
  [CalendarViewEnum.decade]: DecadeViewService,
  [CalendarViewEnum.century]: CenturyViewService
};
var viewOffset = (view2, offset3) => {
  const candidate = CalendarViewEnum[CalendarViewEnum[view2 + offset3]];
  return candidate !== void 0 ? candidate : view2;
};
var nextCalendarId = 0;
var BusViewService = class _BusViewService {
  injector;
  viewChanged = new EventEmitter();
  bottom = CalendarViewEnum.month;
  top = CalendarViewEnum.century;
  calendarId;
  constructor(injector) {
    this.injector = injector;
    this.calendarId = nextCalendarId++;
  }
  configure(bottom, top) {
    this.bottom = bottom;
    this.top = top;
  }
  service(view2) {
    const serviceType = services$1[view2];
    return serviceType ? this.injector.get(serviceType) : null;
  }
  moveDown(view2) {
    this.move(view2, -1);
  }
  moveUp(view2) {
    this.move(view2, 1);
  }
  moveToBottom(activeView) {
    if (activeView === this.bottom) {
      return;
    }
    this.viewChanged.emit({
      view: this.bottom
    });
  }
  canMoveDown(view2) {
    return this.bottom < view2;
  }
  canMoveUp(view2) {
    return view2 < this.top;
  }
  clamp(view2) {
    if (view2 < this.bottom) {
      return this.bottom;
    }
    if (view2 > this.top) {
      return this.top;
    }
    return view2;
  }
  move(view2, offset3) {
    const candidate = this.clamp(viewOffset(view2, offset3));
    if (candidate === view2) {
      return;
    }
    this.viewChanged.emit({
      view: candidate
    });
  }
  static ɵfac = function BusViewService_Factory(t) {
    return new (t || _BusViewService)(ɵɵinject(Injector));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BusViewService,
    factory: _BusViewService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BusViewService, [{
    type: Injectable
  }], function() {
    return [{
      type: Injector
    }];
  }, null);
})();
var KForOfContext = class {
  $implicit;
  kForOf;
  index;
  count;
  constructor($implicit, kForOf, index, count2) {
    this.$implicit = $implicit;
    this.kForOf = kForOf;
    this.index = index;
    this.count = count2;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
};
var KForOf = class _KForOf {
  _viewContainer;
  _template;
  _differs;
  kForOf;
  kForTrackBy;
  _differ = null;
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
  }
  set kForTemplate(value) {
    if (value) {
      this._template = value;
    }
  }
  ngOnChanges(changes) {
    if ("kForOf" in changes) {
      const value = changes["kForOf"].currentValue;
      if (this._differ || !value) {
        return;
      }
      try {
        this._differ = this._differs.find(value).create(this.kForTrackBy);
      } catch (e) {
        throw new Error(`Cannot find a differ supporting object '${value}' of type '${getTypeNameForDebugging(value)}'.`);
      }
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this.kForOf);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _applyChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    const viewContainerLength = this._viewContainer.length;
    const dataLength = this.kForOf.length;
    const tuples = {};
    changes.forEachOperation((record, _, currentIndex) => {
      if (currentIndex !== null) {
        tuples[currentIndex] = record.item;
      }
    });
    for (let i = viewContainerLength; i < dataLength; i++) {
      this._viewContainer.createEmbeddedView(this._template, new KForOfContext(null, this.kForOf, -1, -1), i);
    }
    for (let i = this._viewContainer.length; i > dataLength; i--) {
      this._viewContainer.remove(i - 1);
    }
    for (let i = 0; i < this._viewContainer.length; i++) {
      const view2 = this._viewContainer.get(i);
      view2.context.index = i;
      view2.context.count = length;
      view2.context.$implicit = tuples[i] || null;
    }
  }
  static ɵfac = function KForOf_Factory(t) {
    return new (t || _KForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _KForOf,
    selectors: [["", "kFor", "", "kForOf", ""]],
    inputs: {
      kForOf: "kForOf",
      kForTrackBy: "kForTrackBy",
      kForTemplate: "kForTemplate"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KForOf, [{
    type: Directive,
    args: [{
      selector: "[kFor][kForOf]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: TemplateRef
    }, {
      type: IterableDiffers
    }];
  }, {
    kForOf: [{
      type: Input
    }],
    kForTrackBy: [{
      type: Input
    }],
    kForTemplate: [{
      type: Input
    }]
  });
})();
function getTypeNameForDebugging(type) {
  return type.name || typeof type;
}
var noop$1 = () => false;
var DISABLED_DATES_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/disabled-dates/";
var DisabledDatesService = class _DisabledDatesService {
  /**
   * Emits every time the `isDateDisabled` method changes.
   */
  changes = new Subject();
  /**
   * Based on the user-defined `disabledDates` input evaluates if the date is disabled.
   * If not set, returns `false`.
   */
  isDateDisabled = noop$1;
  /**
   * Configures the `isDateDisabled` function.
   *
   * * If a function is provided, uses it as-is and passes each date to it for evaluation.
   * The time part is set to `midnight`.
   * * If a `Date[]` is provided, creates a function that checks the targeted date against
   * the listed dates and, if the targeted date is listed, marks it as disabled.
   * * If a `Day[]` is provided, creates a function that evaluates the provided days of the
   * week as disabled.
   */
  initialize(disabledDates) {
    if (typeof disabledDates === "function") {
      this.isDateDisabled = (date2) => disabledDates(getDate(date2));
    } else if (isNumberArray(disabledDates)) {
      const disabledWeekDays = new Set(disabledDates);
      this.isDateDisabled = (date2) => disabledWeekDays.has(date2.getDay());
    } else if (isDateArray(disabledDates)) {
      const normalizedDisabledDates = new Set(disabledDates.map((date2) => getDate(date2).getTime()));
      this.isDateDisabled = (date2) => normalizedDisabledDates.has(getDate(date2).getTime());
    } else {
      this.isDateDisabled = noop$1;
      this.notifyInvalidInput(disabledDates);
    }
    this.notifyServiceChange();
  }
  notifyInvalidInput(disabledDates) {
    if (isPresent3(disabledDates) && isDevMode()) {
      throw new Error(`The 'disabledDates' value should be a function, a Day array or a Date array. Check ${DISABLED_DATES_DOC_LINK} for more information.`);
    }
  }
  notifyServiceChange() {
    this.changes.next();
  }
  static ɵfac = function DisabledDatesService_Factory(t) {
    return new (t || _DisabledDatesService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DisabledDatesService,
    factory: _DisabledDatesService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisabledDatesService, [{
    type: Injectable
  }], null, null);
})();
var closestInScope = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var closest2 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var ViewComponent = class _ViewComponent {
  bus;
  intl;
  cdr;
  element;
  zone;
  renderer;
  disabledDatesService;
  allowReverse;
  showOtherMonthDays;
  direction = "vertical";
  isActive = true;
  activeView;
  cellUID;
  focusedDate;
  viewDate;
  activeRangeEnd;
  selectionRange;
  min;
  max;
  selectedDates = [];
  get weekNumber() {
    return this.showWeekNumbers && this.activeView === CalendarViewEnum.month;
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  viewIndex;
  templateRef;
  weekNumberTemplateRef;
  headerTitle;
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  cellEnter = new EventEmitter();
  cellLeave = new EventEmitter();
  focusedCellId = new EventEmitter();
  get ariaHidden() {
    return this.headerTitle === this.title ? null : true;
  }
  colSpan = 0;
  data;
  service;
  title;
  subscriptions = new Subscription();
  showWeekNumbers;
  domEvents = [];
  currentCellIndex;
  constructor(bus, intl, cdr, element, zone, renderer, disabledDatesService) {
    this.bus = bus;
    this.intl = intl;
    this.cdr = cdr;
    this.element = element;
    this.zone = zone;
    this.renderer = renderer;
    this.disabledDatesService = disabledDatesService;
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.disabledDatesChange.bind(this)));
  }
  ngOnInit() {
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.colSpan = this.service.rowLength({
      prependCell: this.weekNumber
    });
    this.title = this.service.title(this.viewDate);
    this.updateData();
    if (changes.activeView) {
      this.currentCellIndex = null;
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.domEvents.forEach((unsubscribeCallback) => unsubscribeCallback());
  }
  isHorizontal() {
    return this.direction === "horizontal";
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  shouldRenderCellContent(cellCtx) {
    return isPresent3(cellCtx) && (!cellCtx.isOtherMonth || cellCtx.isOtherMonth && this.showOtherMonthDays);
  }
  firstDate(rowCtx) {
    const ctx = this.firstWeekDateContext(rowCtx);
    return ctx ? ctx.value : null;
  }
  getWeekNumber(date2) {
    if (!this.weekNumber) {
      return null;
    }
    return weekInYear(date2, this.intl.firstDay());
  }
  getWeekNumberContext(rowCtx) {
    const ctx = this.firstWeekDateContext(rowCtx);
    if (!this.weekNumber || !ctx) {
      return null;
    }
    const weekNumber = weekInYear(ctx.value, this.intl.firstDay()).toString();
    return {
      formattedValue: weekNumber,
      id: null,
      isFocused: false,
      isSelected: false,
      isWeekend: false,
      title: weekNumber,
      value: cloneDate(ctx.value)
    };
  }
  getStyles(context) {
    if (!context.isOtherMonth && this.isActive && context.isFocused) {
      this.focusedCellId.emit(context.id);
    }
    const {
      isRangeEnd,
      isRangeStart
    } = context;
    const isEndActive = this.activeRangeEnd === "end" && isRangeEnd;
    const isStartActive = this.activeRangeEnd === "start" && isRangeStart;
    return stringifyClassObject({
      "k-range-end": !context.isOtherMonth && isRangeEnd,
      "k-range-mid": !context.isOtherMonth && context.isRangeMid,
      "k-range-split-end": !context.isOtherMonth && context.isRangeSplitEnd,
      "k-range-split-start": !context.isOtherMonth && context.isRangeSplitStart,
      "k-range-start": !context.isOtherMonth && isRangeStart,
      "k-active": isStartActive || isEndActive,
      "k-focus": !context.isOtherMonth && this.isActive && context.isFocused,
      "k-selected": !context.isOtherMonth && (context.isSelected || isRangeStart || isRangeEnd),
      "k-today": !context.isOtherMonth && context.isToday,
      "k-weekend": context.isWeekend,
      "k-disabled": context.isDisabled,
      "k-other-month": context.isOtherMonth
    });
  }
  tableCellIndex(rowIndex, cellIndex) {
    return `${rowIndex}:${cellIndex}`;
  }
  handleWeekNumberClick(week) {
    const availableDates = week.filter((day) => day).map((item) => item.value).filter((date2) => !this.disabledDatesService.isDateDisabled(date2));
    this.weekNumberCellClick.emit(availableDates);
  }
  getMonthLabel(date2) {
    return this.activeView === 1 ? this.intl.formatDate(date2, "MMMM") : null;
  }
  firstWeekDateContext(rowCtx) {
    if (!this.weekNumber) {
      return null;
    }
    let idx2 = 0;
    let ctx = this.shouldRenderCellContent(rowCtx[idx2]) ? rowCtx[idx2] : null;
    while (!ctx && idx2 < rowCtx.length) {
      const cellCtx = rowCtx[++idx2];
      ctx = this.shouldRenderCellContent(cellCtx) ? cellCtx : null;
    }
    return ctx;
  }
  updateData() {
    const time = last(this.selectedDates) || getToday();
    const viewDate = setTime(this.viewDate, time);
    this.data = this.service.data({
      cellUID: this.cellUID,
      focusedDate: this.focusedDate,
      isActiveView: !this.bus.canMoveDown(this.activeView),
      max: this.max,
      min: this.min,
      selectedDates: this.selectedDates,
      selectionRange: this.selectionRange,
      viewDate,
      isDateDisabled: this.disabledDatesService.isDateDisabled,
      direction: this.direction,
      allowReverse: this.allowReverse
    });
  }
  intlChange() {
    this.updateData();
    this.cdr.markForCheck();
  }
  disabledDatesChange() {
    this.updateData();
    this.cdr.markForCheck();
  }
  bindEvents() {
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "mouseover", this.cellMouseoverHandler.bind(this)), this.renderer.listen(element, "mouseleave", this.mouseLeaveHandler.bind(this)), this.renderer.listen(element, "click", this.clickHandler.bind(this)));
  }
  clickHandler(args) {
    const cell2 = this.closestCell(args);
    if (!cell2) {
      return;
    }
    const index = cell2.getAttribute("data-cell-index");
    const cellContext = this.cellByIndex(index);
    if (!cellContext.isDisabled) {
      const {
        ctrlKey,
        metaKey,
        shiftKey
      } = args;
      this.cellClick.emit({
        date: cellContext.value,
        modifiers: {
          ctrlKey,
          metaKey,
          shiftKey
        }
      });
    }
  }
  mouseLeaveHandler() {
    if (this.currentCellIndex) {
      this.emitCellLeave();
    }
  }
  cellMouseoverHandler(args) {
    const cell2 = this.closestCell(args);
    if (cell2) {
      const index = cell2.getAttribute("data-cell-index");
      if (this.currentCellIndex && this.currentCellIndex !== index) {
        this.emitCellLeave();
      }
      const value = this.cellByIndex(index).value;
      this.cellEnter.emit(value);
      this.currentCellIndex = index;
    } else if (this.currentCellIndex) {
      this.emitCellLeave();
    }
  }
  closestCell(eventArgs) {
    return closestInScope(eventArgs.target, (node) => node.hasAttribute("data-cell-index"), this.element.nativeElement);
  }
  emitCellLeave() {
    const item = this.cellByIndex(this.currentCellIndex);
    if (item) {
      this.cellLeave.emit(item.value);
    }
    this.currentCellIndex = null;
  }
  cellByIndex(index) {
    const [rowIndex, cellIndex] = index.split(":");
    return this.data[rowIndex][cellIndex];
  }
  static ɵfac = function ViewComponent_Factory(t) {
    return new (t || _ViewComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DisabledDatesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ViewComponent,
    selectors: [["", "kendoCalendarView", ""]],
    inputs: {
      allowReverse: "allowReverse",
      showOtherMonthDays: "showOtherMonthDays",
      direction: "direction",
      isActive: "isActive",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      viewDate: "viewDate",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      min: "min",
      max: "max",
      selectedDates: "selectedDates",
      weekNumber: "weekNumber",
      viewIndex: "viewIndex",
      templateRef: "templateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      headerTitle: "headerTitle"
    },
    outputs: {
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      focusedCellId: "focusedCellId"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c02,
    decls: 4,
    vars: 2,
    consts: [["emptyCell", ""], ["class", "k-calendar-tr", "role", "row", 4, "ngIf"], ["class", "k-calendar-tr", "role", "row", 4, "kFor", "kForOf"], ["role", "gridcell", 1, "k-empty", "k-calendar-td"], ["role", "row", 1, "k-calendar-tr"], ["scope", "col", 1, "k-calendar-caption", 3, "colSpan"], [3, "ngIf"], [4, "kFor", "kForOf"], ["class", "k-alt k-calendar-td", "role", "gridcell", 3, "click", 4, "ngIf", "ngIfElse"], ["role", "gridcell", 1, "k-alt", "k-calendar-td", 3, "click"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "k-calendar-td", "role", "gridcell", 3, "ngClass", "title", 4, "ngIf", "ngIfElse"], ["role", "gridcell", 1, "k-calendar-td", 3, "ngClass", "title"], [1, "k-link"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function ViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ViewComponent_ng_template_0_Template, 2, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, ViewComponent_tr_2_Template, 3, 3, "tr", 1)(3, ViewComponent_tr_3_Template, 3, 2, "tr", 2);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.isHorizontal());
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.data);
      }
    },
    dependencies: [NgIf, KForOf, NgTemplateOutlet, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line
      selector: "[kendoCalendarView]",
      template: `
    <ng-template #emptyCell><td class="k-empty k-calendar-td" role="gridcell">&nbsp;</td></ng-template>
    <tr *ngIf="!isHorizontal()" class="k-calendar-tr" role="row" [attr.aria-hidden]="ariaHidden"><th class="k-calendar-caption" scope="col" [colSpan]="colSpan">{{title}}</th></tr>
    <tr *kFor="let row of data; let rowIndex = index" class="k-calendar-tr" role="row">
        <ng-template [ngIf]="weekNumber">
            <td
                class="k-alt k-calendar-td"
                role="gridcell"
                *ngIf="firstDate(row); else emptyCell"
                (click)="handleWeekNumberClick(row)"
            >
                <ng-template [ngIf]="!weekNumberTemplateRef">
                    {{getWeekNumber(firstDate(row))}}
                </ng-template>
                <ng-template
                    [ngIf]="weekNumberTemplateRef"
                    [ngTemplateOutlet]="weekNumberTemplateRef"
                    [ngTemplateOutletContext]="{
                        $implicit: firstDate(row),
                        cellContext: getWeekNumberContext(row)
                    }"
                ></ng-template>
            </td>
        </ng-template>
        <ng-container *kFor="let cell of row; let cellIndex = index">
            <td class="k-calendar-td"
                *ngIf="shouldRenderCellContent(cell); else emptyCell"
                role="gridcell"
                [attr.id]="cell.id"
                [attr.data-cell-index]="tableCellIndex(rowIndex, cellIndex)"
                [attr.aria-selected]="cell.isSelected || cell.isRangeStart || cell.isRangeMid || cell.isRangeEnd"
                [attr.aria-disabled]="cell.isDisabled"
                [attr.aria-label]="getMonthLabel(cell.value)"
                [ngClass]="getStyles(cell)"
                [title]="cell.title"
            >
                <span class="k-link">
                    <ng-template [ngIf]="!templateRef">{{cell.formattedValue}}</ng-template>
                    <ng-template
                        *ngIf="templateRef"
                        [ngTemplateOutlet]="templateRef"
                        [ngTemplateOutletContext]="{ $implicit: cell.value, cellContext: cell }"
                    ></ng-template>
                </span>
            </td>
        </ng-container>
    </tr>
  `,
      standalone: true,
      imports: [NgIf, KForOf, NgTemplateOutlet, NgClass]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DisabledDatesService
    }];
  }, {
    allowReverse: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    direction: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    viewDate: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    viewIndex: [{
      type: Input
    }],
    templateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    headerTitle: [{
      type: Input
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    focusedCellId: [{
      type: Output
    }]
  });
})();
var DEFAULT_VIEWS_LENGTH = 2;
var HorizontalViewListComponent = class _HorizontalViewListComponent {
  bus;
  intl;
  cdr;
  element;
  renderer;
  handleMultiViewCalendarFocus() {
    this.focusCalendar.emit();
  }
  handleMultiViewCalendarBlur(event2) {
    this.blurCalendar.emit(event2);
  }
  /**
   * Needed for the MultiViewCalendar used in the Scheduler Year view
   */
  showOtherMonthDays = true;
  cellTemplateRef;
  weekNumberTemplateRef;
  allowReverse;
  activeRangeEnd;
  activeView = CalendarViewEnum.month;
  cellUID;
  focusedDate;
  isActive = true;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  selectionRange;
  selectedDates = [];
  views = DEFAULT_VIEWS_LENGTH;
  showViewHeader = false;
  animateNavigation = false;
  orientation = "horizontal";
  activeDescendant;
  tabIndex = 0;
  disabled = false;
  id;
  weekDaysFormat = "short";
  get weekNumber() {
    return this.showWeekNumbers && this.isMonthView();
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  cellEnter = new EventEmitter();
  cellLeave = new EventEmitter();
  activeDateChange = new EventEmitter();
  focusCalendar = new EventEmitter();
  blurCalendar = new EventEmitter();
  focusedCellChange = new EventEmitter();
  getComponentClass = true;
  get horizontalHostClass() {
    return this.orientation === "horizontal";
  }
  get verticalHostClass() {
    return this.orientation === "vertical";
  }
  get getComponentMonthClass() {
    return this.activeView === CalendarViewEnum.month;
  }
  get getComponentYearClass() {
    return this.activeView === CalendarViewEnum.year;
  }
  get getComponentDecadeClass() {
    return this.activeView === CalendarViewEnum.decade;
  }
  get getComponentCenturyClass() {
    return this.activeView === CalendarViewEnum.century;
  }
  get role() {
    return this.views >= 2 ? "grid" : null;
  }
  get tabindex() {
    return this.views >= 2 ? "0" : null;
  }
  get getActiveDescendant() {
    return this.views === 1 ? this.activeDescendant : null;
  }
  get getTabIndex() {
    return this.disabled || this.views >= 2 ? null : this.tabIndex;
  }
  service;
  weekNames = [];
  wideWeekNames = [];
  activeDate;
  dates = [];
  skip;
  total;
  nextAnimationDate;
  prevAnimationDate;
  showWeekNumbers;
  intlSubscription;
  animation;
  constructor(bus, intl, cdr, element, renderer) {
    this.bus = bus;
    this.intl = intl;
    this.cdr = cdr;
    this.element = element;
    this.renderer = renderer;
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.initService();
    if (this.weekNames.length === 0 || changes.weekNumber) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
      this.wideWeekNames = this.getWeekNames("wide");
    }
    if (changes.weekDaysFormat && this.weekNames.length !== 0 && !changes.weekNumber) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
    }
    if (!this.service) {
      return;
    }
    this.views = this.views || DEFAULT_VIEWS_LENGTH;
    const focusedDate = this.focusedDate;
    const viewDate = this.clampDate(this.service.viewDate(focusedDate, this.max, this.views));
    this.skip = this.service.skip(viewDate, this.min);
    this.total = this.service.total(this.min, this.max);
    const activeViewChanged = hasChange(changes, "activeView");
    const viewsHasChanged = this.views > 0 && hasChange(changes, "views");
    if (activeViewChanged || !this.isInDates(focusedDate) || viewsHasChanged || !this.activeDate) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
      this.activeDate = cloneDate(this.dates[0]);
      this.activeDateChange.emit(this.activeDate);
    }
    this.setAriaActivedescendant();
    if (this.views >= 2) {
      this.renderer.setAttribute(this.element.nativeElement, "tabindex", this.tabIndex.toString());
    }
  }
  ngOnDestroy() {
    this.intlSubscription.unsubscribe();
  }
  initService() {
    this.service = this.bus.service(this.activeView);
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  getCaptionTitle(date2) {
    return this.service.title(date2);
  }
  handleClassicCalendarFocus() {
    this.focusCalendar.emit();
  }
  handleClassicCalendarBlur(event2) {
    this.blurCalendar.emit(event2);
  }
  animateView(action) {
    const container = this.element.nativeElement;
    const table2 = container.querySelector("table");
    const initialContainerWidth = parseFloat(getComputedStyle(container).width);
    const tableWidth = parseFloat(getComputedStyle(table2).width);
    this.renderer.setStyle(container, "width", `${initialContainerWidth}px`);
    this.renderer.setStyle(container, "overflow", "visible");
    if (action === Action.NextView) {
      this.nextAnimationDate = cloneDate(this.dates[0]);
    } else {
      this.prevAnimationDate = cloneDate(this.dates[this.dates.length - 1]);
    }
    this.cdr.detectChanges();
    container.querySelectorAll("table").forEach((table3) => {
      this.renderer.setStyle(table3, "width", `${tableWidth}px`);
    });
    const tabRect = table2.getBoundingClientRect();
    const containerGap = parseFloat(getComputedStyle(container).columnGap);
    const start = action === Action.NextView ? "translateX(0)" : `translateX(-${tabRect.width + containerGap}px)`;
    const end2 = action === Action.NextView ? `translateX(-${tabRect.width + containerGap}px)` : "translateX(0)";
    if (!this.animation) {
      this.animation = container.animate([{
        transform: start
      }, {
        transform: end2
      }], {
        duration: 500,
        easing: "ease-out"
      });
      this.animation.oncancel = this.animation.onfinish = () => {
        this.renderer.removeStyle(container, "width");
        this.renderer.removeStyle(container, "overflow");
        container.querySelectorAll("table").forEach((table3) => {
          this.renderer.removeStyle(table3, "width");
        });
        this.animation = null;
        this.nextAnimationDate = null;
        this.prevAnimationDate = null;
        this.cdr.detectChanges();
      };
    } else {
      this.animation.cancel();
    }
  }
  navigate(action) {
    if (this.animateNavigation && isDocumentAvailable() && isPresent3(this.element.nativeElement.animate)) {
      this.animateView(action);
    }
    const candidate = this.move(action);
    const list2 = this.service.datesList(candidate, this.getTake(this.skip));
    if (this.isListInRange(list2)) {
      this.dates = list2;
    }
    this.activeDate = cloneDate(this.dates[0]);
    this.focusedDate = cloneDate(candidate);
    this.cdr.markForCheck();
    this.activeDateChange.emit(this.activeDate);
    return cloneDate(candidate);
  }
  canNavigate(action) {
    if (!this.service) {
      return false;
    }
    return this.isListInRange(this.service.datesList(this.move(action), this.getTake(this.skip)));
  }
  getWeekNames(type) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType: type,
      type: "days"
    }), this.intl.firstDay());
    return this.weekNumber ? [""].concat(weekNames) : weekNames;
  }
  intlChange() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    this.cdr.markForCheck();
  }
  clampDate(value) {
    return dateInRange(value, this.min, this.max);
  }
  move(action) {
    return this.service.move(this.dates[0] || this.focusedDate, action);
  }
  isListInRange(list2) {
    const lowerBound = this.service.beginningOfPeriod(this.min);
    const upperBound = this.service.beginningOfPeriod(this.service.addToDate(this.max, 1));
    return lowerBound <= list2[0] && list2[list2.length - 1] < upperBound;
  }
  isInDates(value) {
    return this.service.isInArray(value, this.dates);
  }
  getTake(skip3) {
    return Math.min(this.total - skip3, this.views);
  }
  setAriaActivedescendant() {
    if (this.views >= 2) {
      this.renderer.setAttribute(this.element.nativeElement, attributeNames.ariaActiveDescendant, this.activeDescendant);
    }
  }
  static ɵfac = function HorizontalViewListComponent_Factory(t) {
    return new (t || _HorizontalViewListComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HorizontalViewListComponent,
    selectors: [["kendo-calendar-horizontal"]],
    hostVars: 20,
    hostBindings: function HorizontalViewListComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function HorizontalViewListComponent_focus_HostBindingHandler() {
          return ctx.handleMultiViewCalendarFocus();
        })("blur", function HorizontalViewListComponent_blur_HostBindingHandler($event) {
          return ctx.handleMultiViewCalendarBlur($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex);
        ɵɵclassProp("k-calendar-view", ctx.getComponentClass)("k-align-items-start", ctx.getComponentClass)("k-justify-content-center", ctx.getComponentClass)("k-hstack", ctx.horizontalHostClass)("k-vstack", ctx.verticalHostClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      cellTemplateRef: "cellTemplateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      allowReverse: "allowReverse",
      activeRangeEnd: "activeRangeEnd",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      isActive: "isActive",
      min: "min",
      max: "max",
      selectionRange: "selectionRange",
      selectedDates: "selectedDates",
      views: "views",
      showViewHeader: "showViewHeader",
      animateNavigation: "animateNavigation",
      orientation: "orientation",
      activeDescendant: "activeDescendant",
      tabIndex: "tabIndex",
      disabled: "disabled",
      id: "id",
      weekDaysFormat: "weekDaysFormat",
      weekNumber: "weekNumber"
    },
    outputs: {
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      activeDateChange: "activeDateChange",
      focusCalendar: "focusCalendar",
      blurCalendar: "blurCalendar",
      focusedCellChange: "focusedCellChange"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 5,
    vars: 3,
    consts: [["tableTemplate", ""], [4, "ngIf"], [4, "kFor", "kForOf"], [1, "k-calendar-table", 3, "focus", "blur", "ngClass"], ["class", "k-calendar-caption", 4, "ngIf"], ["class", "k-calendar-thead", "role", "rowgroup", 4, "ngIf"], ["kendoCalendarView", "", "role", "rowgroup", "direction", "horizontal", 1, "k-calendar-tbody", 3, "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave", "focusedCellId", "allowReverse", "showOtherMonthDays", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "selectionRange", "activeRangeEnd", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate"], [1, "k-calendar-caption"], ["role", "rowgroup", 1, "k-calendar-thead"], ["role", "row", 1, "k-calendar-tr"], ["class", "k-calendar-th", "scope", "col", "role", "columnheader", 4, "ngFor", "ngForOf"], ["scope", "col", "role", "columnheader", 1, "k-calendar-th"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function HorizontalViewListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, HorizontalViewListComponent_ng_template_0_Template, 4, 22, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, HorizontalViewListComponent_2_Template, 1, 4, null, 1)(3, HorizontalViewListComponent_3_Template, 1, 4, null, 2)(4, HorizontalViewListComponent_4_Template, 1, 4, null, 1);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.nextAnimationDate);
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.dates);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prevAnimationDate);
      }
    },
    dependencies: [NgClass, NgIf, NgForOf, ViewComponent, NgTemplateOutlet, KForOf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HorizontalViewListComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-horizontal",
      template: `
        <ng-template #tableTemplate let-date="date" let-class="className">
            <table
                [attr.role]="views >= 2 ? 'none' : 'grid'"
                class="k-calendar-table"
                [ngClass]="class"
                [attr.aria-labelledby]="id"
                [attr.aria-activedescendant]="getActiveDescendant"
                [attr.tabindex]="getTabIndex"
                (focus)="handleClassicCalendarFocus()"
                (blur)="handleClassicCalendarBlur($event)"
            >
                <caption *ngIf="showViewHeader" class="k-calendar-caption">{{ getCaptionTitle(date) }}</caption>
                <thead *ngIf="isMonthView()" class="k-calendar-thead" role="rowgroup">
                    <tr class="k-calendar-tr" role="row">
                        <th *ngFor="let name of weekNames; let i = index;"
                        class="k-calendar-th"
                        scope="col"
                        [attr.aria-label]="wideWeekNames[i]"
                        role="columnheader"
                        >{{name}}</th>
                    </tr>
                </thead>
                <tbody
                    class="k-calendar-tbody"
                    kendoCalendarView
                    [allowReverse]="allowReverse"
                    [showOtherMonthDays]="showOtherMonthDays"
                    role="rowgroup"
                    direction="horizontal"
                    [activeView]="activeView"
                    [isActive]="isActive"
                    [min]="min"
                    [max]="max"
                    [cellUID]="cellUID"
                    [focusedDate]="focusedDate"
                    [selectedDates]="selectedDates"
                    [selectionRange]="selectionRange"
                    [activeRangeEnd]="activeRangeEnd"
                    [weekNumber]="weekNumber"
                    [templateRef]="cellTemplateRef"
                    [weekNumberTemplateRef]="weekNumberTemplateRef"
                    [viewDate]="date"
                    (cellClick)="cellClick.emit($event)"
                    (weekNumberCellClick)="weekNumberCellClick.emit($event)"
                    (cellEnter)="cellEnter.emit($event)"
                    (cellLeave)="cellLeave.emit($event)"
                    (focusedCellId)="focusedCellChange.emit($event)"
                >
                </tbody>
            </table>
        </ng-template>

        <!-- When Next is clicked a placeholder table is rendered before the Main Table -->
        <ng-template
            *ngIf="nextAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: nextAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>

        <ng-template
            *kFor="let date of dates"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: date
            }"
        >
        </ng-template>

        <!-- When Prev is clicked a placeholder table is rendered after the Main Table -->
        <ng-template
            *ngIf="prevAnimationDate"
            [ngTemplateOutlet]="tableTemplate"
            [ngTemplateOutletContext]="{
                date: prevAnimationDate,
                className: 'k-pointer-events-none'
            }"
        >
        </ng-template>
    `,
      standalone: true,
      imports: [NgClass, NgIf, NgForOf, ViewComponent, NgTemplateOutlet, KForOf]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    handleMultiViewCalendarFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    handleMultiViewCalendarBlur: [{
      type: HostListener,
      args: ["blur", ["$event"]]
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    cellTemplateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    activeDescendant: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    activeDateChange: [{
      type: Output
    }],
    focusCalendar: [{
      type: Output
    }],
    blurCalendar: [{
      type: Output
    }],
    focusedCellChange: [{
      type: Output
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-view"]
    }, {
      type: HostBinding,
      args: ["class.k-align-items-start"]
    }, {
      type: HostBinding,
      args: ["class.k-justify-content-center"]
    }],
    horizontalHostClass: [{
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    verticalHostClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }],
    getComponentMonthClass: [{
      type: HostBinding,
      args: ["class.k-calendar-monthview"]
    }],
    getComponentYearClass: [{
      type: HostBinding,
      args: ["class.k-calendar-yearview"]
    }],
    getComponentDecadeClass: [{
      type: HostBinding,
      args: ["class.k-calendar-decadeview"]
    }],
    getComponentCenturyClass: [{
      type: HostBinding,
      args: ["class.k-calendar-centuryview"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }]
  });
})();
var HeaderComponent = class _HeaderComponent {
  bus;
  cdr;
  localization;
  intl;
  disabledDatesService;
  /**
   * @hidden
   */
  chevronRightIcon = chevronRightIcon;
  /**
   * @hidden
   */
  chevronLeftIcon = chevronLeftIcon;
  navigate = true;
  todayAvailable = true;
  activeViewValue;
  todayMessage;
  title;
  prevButtonTitle;
  nextButtonTitle;
  parentViewButtonTitle;
  activeView;
  currentDate;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  rangeLength = 1;
  titleTemplateRef;
  headerTemplateRef;
  isPrevDisabled = true;
  isNextDisabled = true;
  showNavigationButtons = false;
  orientation = "horizontal";
  id;
  size;
  todayButtonClick = new EventEmitter();
  prevButtonClick = new EventEmitter();
  nextButtonClick = new EventEmitter();
  getComponentClass = true;
  get verticalHostClass() {
    return this.orientation === "vertical";
  }
  subscriptions = new Subscription();
  constructor(bus, cdr, localization, intl, disabledDatesService) {
    this.bus = bus;
    this.cdr = cdr;
    this.localization = localization;
    this.intl = intl;
    this.disabledDatesService = disabledDatesService;
  }
  ngOnInit() {
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
    this.subscriptions.add(this.disabledDatesService.changes.subscribe(this.setTodayAvailability.bind(this)));
  }
  ngOnChanges() {
    const service = this.bus.service(this.activeView);
    if (!service) {
      return;
    }
    this.activeViewValue = CalendarViewEnum[this.activeView];
    this.todayMessage = this.localization.get("today");
    this.parentViewButtonTitle = this.localization.get("parentViewButtonTitle");
    this.setTodayAvailability();
    this.navigate = this.bus.canMoveUp(this.activeView);
    this.title = this.getTitle();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  handleTodayClick() {
    if (!this.todayAvailable) {
      return;
    }
    this.bus.moveToBottom(this.activeView);
    this.todayButtonClick.emit(dateInRange(getToday(), this.min, this.max));
  }
  handleNavigation() {
    if (!this.navigate) {
      return;
    }
    this.bus.moveUp(this.activeView);
  }
  isDisabled() {
    return this.navigate ? null : "";
  }
  intlChange() {
    if (this.currentDate && this.bus.service(this.activeView)) {
      this.title = this.getTitle();
      this.cdr.markForCheck();
    }
  }
  l10nChange() {
    this.prevButtonTitle = this.localization.get("prevButtonTitle");
    this.nextButtonTitle = this.localization.get("nextButtonTitle");
    this.parentViewButtonTitle = this.localization.get("parentViewButtonTitle");
    this.todayMessage = this.localization.get("today");
    this.cdr.markForCheck();
  }
  getTitle() {
    if (!this.currentDate) {
      return "";
    }
    const service = this.bus.service(this.activeView);
    const take2 = this.rangeLength - 1;
    const title = service.title(this.currentDate);
    const nextDate = service.addToDate(this.currentDate, take2);
    if (take2 < 1 || !service.isInRange(nextDate, this.min, this.max)) {
      return title;
    }
    return `${title} - ${service.title(nextDate)}`;
  }
  setTodayAvailability() {
    const today = getToday();
    const isTodayInRange = isInRange(today, getDate(this.min), getDate(this.max));
    const isDisabled = this.disabledDatesService.isDateDisabled(today);
    this.todayAvailable = isTodayInRange && !isDisabled;
    this.cdr.markForCheck();
  }
  static ɵfac = function HeaderComponent_Factory(t) {
    return new (t || _HeaderComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(DisabledDatesService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HeaderComponent,
    selectors: [["kendo-calendar-header"]],
    hostVars: 4,
    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-header", ctx.getComponentClass)("k-vstack", ctx.verticalHostClass);
      }
    },
    inputs: {
      activeView: "activeView",
      currentDate: "currentDate",
      min: "min",
      max: "max",
      rangeLength: "rangeLength",
      titleTemplateRef: "titleTemplateRef",
      headerTemplateRef: "headerTemplateRef",
      isPrevDisabled: "isPrevDisabled",
      isNextDisabled: "isNextDisabled",
      showNavigationButtons: "showNavigationButtons",
      orientation: "orientation",
      id: "id",
      size: "size"
    },
    outputs: {
      todayButtonClick: "todayButtonClick",
      prevButtonClick: "prevButtonClick",
      nextButtonClick: "nextButtonClick"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 2,
    consts: [["defaultRendering", ""], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", "role", "button", "type", "button", "fillMode", "flat", "themeColor", "primary", "tabindex", "-1", 1, "k-calendar-title", 3, "id", "size", "disabled", "kendoEventsOutsideAngular", "title", "scope"], [3, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-spacer"], [1, "k-calendar-nav"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-left", "tabindex", "-1", "type", "button", "class", "k-calendar-nav-prev", 3, "size", "svgIcon", "disabled", "title", "click", 4, "ngIf"], ["kendoButton", "", "fillMode", "flat", "role", "link", "type", "button", 1, "k-calendar-nav-today", 3, "size", "disabled", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-right", "class", "k-calendar-nav-next", "tabindex", "-1", "type", "button", 3, "size", "svgIcon", "disabled", "title", "click", 4, "ngIf"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-left", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-prev", 3, "click", "size", "svgIcon", "disabled", "title"], ["kendoButton", "", "fillMode", "flat", "icon", "chevron-right", "tabindex", "-1", "type", "button", 1, "k-calendar-nav-next", 3, "click", "size", "svgIcon", "disabled", "title"]],
    template: function HeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, HeaderComponent_0_Template, 1, 6, null, 1)(1, HeaderComponent_ng_template_1_Template, 9, 25, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const defaultRendering_r4 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.headerTemplateRef)("ngIfElse", defaultRendering_r4);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, ButtonComponent, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderComponent, [{
    type: Component,
    args: [{
      selector: "kendo-calendar-header",
      template: `
    <ng-template *ngIf="headerTemplateRef; else defaultRendering" 
                [ngTemplateOutlet]="headerTemplateRef"
                [ngTemplateOutletContext]="{ title: title, activeView: activeViewValue, date: currentDate }">
    </ng-template>
    <ng-template #defaultRendering>
        <button 
            kendoButton
            class="k-calendar-title"
            role="button"
            [id]="id"
            type="button"
            fillMode="flat"
            [size]="size"
            themeColor="primary"
            tabindex="-1"
            [disabled]="!navigate"
            [kendoEventsOutsideAngular]="{
                click: handleNavigation
            }"
            [title]="parentViewButtonTitle"
            [scope]="this">
            <ng-template [ngIf]="!titleTemplateRef">{{title}}</ng-template>
            <ng-template
                [ngIf]="titleTemplateRef"
                [ngTemplateOutlet]="titleTemplateRef"
                [ngTemplateOutletContext]="{ $implicit: title, activeView: activeViewValue, date: currentDate }"
            ></ng-template>
        </button>
        <span class="k-spacer"></span>
        <span class="k-calendar-nav">
            <button
                *ngIf="showNavigationButtons"
                kendoButton
                fillMode="flat"
                [size]="size"
                [svgIcon]="chevronLeftIcon"
                icon="chevron-left"
                tabindex="-1"
                type="button"
                class="k-calendar-nav-prev"
                [attr.aria-disabled]="isPrevDisabled"
                [disabled]="isPrevDisabled"
                [title]="prevButtonTitle"
                (click)="prevButtonClick.emit()"
            >
            </button>
            <button
                kendoButton
                class="k-calendar-nav-today"
                fillMode="flat"
                role="link"
                [size]="size"
                [disabled]="!todayAvailable"
                [kendoEventsOutsideAngular]="{
                    click: handleTodayClick
                }"
                [scope]="this"
                type="button"
            >
                {{ todayMessage }}
            </button>
            <button
                *ngIf="showNavigationButtons"
                kendoButton
                fillMode="flat"
                [size]="size"
                [svgIcon]="chevronRightIcon"
                icon="chevron-right"
                class="k-calendar-nav-next"
                tabindex="-1"
                type="button"
                [attr.aria-disabled]="isNextDisabled"
                [disabled]="isNextDisabled"
                [title]="nextButtonTitle"
                (click)="nextButtonClick.emit()"
            >
            </button>
        </span>
    </ng-template>
`,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, ButtonComponent, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: IntlService
    }, {
      type: DisabledDatesService
    }];
  }, {
    activeView: [{
      type: Input
    }],
    currentDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeLength: [{
      type: Input
    }],
    titleTemplateRef: [{
      type: Input
    }],
    headerTemplateRef: [{
      type: Input
    }],
    isPrevDisabled: [{
      type: Input
    }],
    isNextDisabled: [{
      type: Input
    }],
    showNavigationButtons: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    todayButtonClick: [{
      type: Output
    }],
    prevButtonClick: [{
      type: Output
    }],
    nextButtonClick: [{
      type: Output
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-header"]
    }],
    verticalHostClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }]
  });
})();
var SelectionService = class _SelectionService {
  bus;
  constructor(bus) {
    this.bus = bus;
  }
  lastClicked;
  performSelection(args) {
    let {
      date: date2,
      modifiers,
      selectionMode,
      activeViewEnum,
      rangePivot
    } = args;
    let selectedDates = args.selectedDates.slice();
    if (selectionMode === "multiple") {
      if (modifiers.ctrlKey || modifiers.metaKey) {
        if (this.isDateSelected(selectedDates, date2)) {
          selectedDates = selectedDates.filter((item) => !isEqual(item, date2));
        } else {
          selectedDates.push(date2);
        }
        rangePivot = date2;
      } else if (modifiers.shiftKey) {
        const [start, end2] = sortDates([rangePivot || date2, date2]);
        selectedDates = this.bus.service(activeViewEnum).dateRange(start, end2);
        rangePivot = date2 > selectedDates[0] ? selectedDates[0] : last(selectedDates);
        if (modifiers.anyArrow) {
          const [start2, end3] = sortDates([this.lastClicked || date2, date2]);
          selectedDates = this.bus.service(0).dateRange(start2, end3);
        }
      } else {
        selectedDates = [date2];
        rangePivot = date2;
      }
    } else {
      selectedDates = [date2];
      rangePivot = date2;
    }
    return {
      selectedDates,
      rangePivot
    };
  }
  isDateSelected(selectedDates, date2) {
    return selectedDates.some((item) => isEqual(item, date2));
  }
  static ɵfac = function SelectionService_Factory(t) {
    return new (t || _SelectionService)(ɵɵinject(BusViewService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService, [{
    type: Injectable
  }], function() {
    return [{
      type: BusViewService
    }];
  }, null);
})();
var CellTemplateDirective = class _CellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CellTemplateDirective_Factory(t) {
    return new (t || _CellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CellTemplateDirective,
    selectors: [["", "kendoCalendarCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var MonthCellTemplateDirective = class _MonthCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function MonthCellTemplateDirective_Factory(t) {
    return new (t || _MonthCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MonthCellTemplateDirective,
    selectors: [["", "kendoCalendarMonthCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarMonthCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var YearCellTemplateDirective = class _YearCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function YearCellTemplateDirective_Factory(t) {
    return new (t || _YearCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _YearCellTemplateDirective,
    selectors: [["", "kendoCalendarYearCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarYearCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var DecadeCellTemplateDirective = class _DecadeCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DecadeCellTemplateDirective_Factory(t) {
    return new (t || _DecadeCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DecadeCellTemplateDirective,
    selectors: [["", "kendoCalendarDecadeCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarDecadeCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var CenturyCellTemplateDirective = class _CenturyCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CenturyCellTemplateDirective_Factory(t) {
    return new (t || _CenturyCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CenturyCellTemplateDirective,
    selectors: [["", "kendoCalendarCenturyCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CenturyCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarCenturyCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var WeekNumberCellTemplateDirective = class _WeekNumberCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function WeekNumberCellTemplateDirective_Factory(t) {
    return new (t || _WeekNumberCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _WeekNumberCellTemplateDirective,
    selectors: [["", "kendoCalendarWeekNumberCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekNumberCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarWeekNumberCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var HeaderTitleTemplateDirective = class _HeaderTitleTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTitleTemplateDirective_Factory(t) {
    return new (t || _HeaderTitleTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTitleTemplateDirective,
    selectors: [["", "kendoCalendarHeaderTitleTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTitleTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarHeaderTitleTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
function handleRangeSelection(date2, selectionRange, activeRangeEnd, allowReverse = false) {
  if (activeRangeEnd === "start" && selectionRange.start?.getTime() === date2?.getTime() && (allowReverse && !selectionRange.end || !allowReverse) || activeRangeEnd === "end" && selectionRange.end?.getTime() === date2?.getTime()) {
    return {
      activeRangeEnd,
      selectionRange
    };
  }
  if (allowReverse) {
    if (activeRangeEnd === "start" && selectionRange.start?.getTime() !== date2?.getTime()) {
      selectionRange.start = date2;
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "end" && selectionRange.end?.getTime() !== date2?.getTime()) {
      selectionRange.end = date2;
      activeRangeEnd = "start";
    }
  }
  if (!allowReverse) {
    if (activeRangeEnd === "start" && date2 > selectionRange.end || activeRangeEnd === "end" && date2 < selectionRange.start) {
      selectionRange = {
        start: date2,
        end: null
      };
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "start" && date2 <= selectionRange.end) {
      selectionRange.start = date2;
      activeRangeEnd = "end";
    } else if (activeRangeEnd === "end" && date2 >= selectionRange.start && date2.getTime() !== selectionRange.end?.getTime()) {
      selectionRange.end = date2;
      activeRangeEnd = "start";
    }
  }
  return {
    activeRangeEnd,
    selectionRange
  };
}
var minValidator = (minValue) => {
  return (control) => {
    const err = {
      minError: {
        minValue,
        value: control.value
      }
    };
    if (!minValue || !control.value) {
      return null;
    }
    return control.value < minValue ? err : null;
  };
};
var maxValidator = (maxValue) => {
  return (control) => {
    const err = {
      maxError: {
        maxValue,
        value: control.value
      }
    };
    if (!maxValue || !control.value) {
      return null;
    }
    return control.value > maxValue ? err : null;
  };
};
var noop = () => null;
var disabledDatesRangeValidator = (isDateDisabled) => {
  if (!isPresent3(isDateDisabled)) {
    return noop;
  }
  return (selectedRange) => {
    const isRangeComplete = isPresent3(selectedRange) && isPresent3(selectedRange.start) && isPresent3(selectedRange.end);
    if (!isRangeComplete || selectedRange.start > selectedRange.end) {
      return null;
    }
    const disabledDates = disabledDatesInRange(selectedRange.start, selectedRange.end, isDateDisabled);
    const error2 = {
      disabledDatesInRange: disabledDates
    };
    return disabledDates.length ? error2 : null;
  };
};
var KEY_TO_ACTION = {
  "33": Action.PrevView,
  "34": Action.NextView,
  "35": Action.LastInView,
  "36": Action.FirstInView,
  "37": Action.Left,
  "38": Action.Up,
  "39": Action.Right,
  "40": Action.Down,
  "meta+38": Action.UpperView,
  "meta+40": Action.LowerView
};
var NavigationService = class _NavigationService {
  bus;
  constructor(bus) {
    this.bus = bus;
  }
  action(event2) {
    const action = `${event2.ctrlKey || event2.metaKey ? "meta+" : ""}${event2.keyCode}`;
    return KEY_TO_ACTION[action];
  }
  move(value, action, activeView) {
    const service = this.bus.service(activeView);
    if (!service) {
      return value;
    }
    if (action === Action.UpperView && this.bus.canMoveUp(activeView)) {
      this.bus.moveUp(activeView);
      return value;
    }
    if (action === Action.LowerView && this.bus.canMoveDown(activeView)) {
      this.bus.moveDown(activeView);
      return value;
    }
    return service.move(value, action);
  }
  static ɵfac = function NavigationService_Factory(t) {
    return new (t || _NavigationService)(ɵɵinject(BusViewService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: BusViewService
    }];
  }, null);
})();
var HeaderTemplateDirective = class _HeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTemplateDirective_Factory(t) {
    return new (t || _HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTemplateDirective,
    selectors: [["", "kendoCalendarHeaderTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FooterTemplateDirective = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(t) {
    return new (t || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoCalendarFooterTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FooterComponent = class _FooterComponent {
  intl;
  showFooter = true;
  footerTemplateRef;
  activeViewValue;
  currentDate;
  getToday = getToday;
  constructor(intl) {
    this.intl = intl;
  }
  static ɵfac = function FooterComponent_Factory(t) {
    return new (t || _FooterComponent)(ɵɵdirectiveInject(IntlService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FooterComponent,
    selectors: [["kendo-calendar-footer"]],
    hostVars: 2,
    hostBindings: function FooterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-footer", ctx.showFooter);
      }
    },
    inputs: {
      footerTemplateRef: "footerTemplateRef",
      activeViewValue: "activeViewValue",
      currentDate: "currentDate"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 3,
    vars: 2,
    consts: [["defaultRendering", ""], [4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoButton", "", "fillMode", "flat", "themeColor", "primary", "type", "button", "tabindex", "-1", 1, "k-calendar-nav-today"]],
    template: function FooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, FooterComponent_0_Template, 1, 5, null, 1)(1, FooterComponent_ng_template_1_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const defaultRendering_r2 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.footerTemplateRef)("ngIfElse", defaultRendering_r2);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-calendar-footer",
      template: `
    <ng-template *ngIf="footerTemplateRef; else defaultRendering"
        [ngTemplateOutlet]="footerTemplateRef"
        [ngTemplateOutletContext]="{ activeView: activeViewValue, date: currentDate }">
    </ng-template>
    <ng-template #defaultRendering>
        <button kendoButton
            fillMode="flat"
            themeColor="primary"
            class="k-calendar-nav-today"
            type="button"
            tabindex="-1">
                {{intl.formatDate(getToday(), 'D')}}
        </button>
    </ng-template>
  `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet, ButtonComponent]
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, {
    showFooter: [{
      type: HostBinding,
      args: ["class.k-calendar-footer"]
    }],
    footerTemplateRef: [{
      type: Input
    }],
    activeViewValue: [{
      type: Input
    }],
    currentDate: [{
      type: Input
    }]
  });
})();
var Messages2 = class _Messages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the MultiViewCalendar.
   */
  today;
  /**
   * The title of the **Prev** button in the header of the MultiViewCalendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the MultiViewCalendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the MultiViewCalendar.
   */
  parentViewButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(t) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(t || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendo-multiview-calendar-messages-base"]],
    inputs: {
      today: "today",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages2, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-multiview-calendar-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }]
  });
})();
var MultiViewCalendarLocalizedMessagesDirective = class _MultiViewCalendarLocalizedMessagesDirective extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function MultiViewCalendarLocalizedMessagesDirective_Factory(t) {
    return new (t || _MultiViewCalendarLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiViewCalendarLocalizedMessagesDirective,
    selectors: [["", "kendoMultiViewCalendarLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _MultiViewCalendarLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => MultiViewCalendarLocalizedMessagesDirective)
      }],
      selector: "[kendoMultiViewCalendarLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var BOTTOM_VIEW_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview";
var TOP_VIEW_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview";
var MIN_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min";
var MAX_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max";
var VALUE_DOC_LINK$5 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json";
var RANGE_CALENDAR_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MultiViewCalendarComponent)
};
var RANGE_CALENDAR_RANGE_VALIDATORS = {
  multi: true,
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MultiViewCalendarComponent)
};
var MultiViewCalendarComponent = class _MultiViewCalendarComponent {
  bus;
  element;
  navigator;
  renderer;
  cdr;
  zone;
  disabledDatesService;
  selectionService;
  /**
   * Displays the days that fall out of the current month ([see example]({% slug viewoptions_multiviewcalendar %}#toc-displaying-other-month-days)).
   * @default true
   */
  showOtherMonthDays = true;
  /**
   * @hidden
   *
   * Determines whether to display the calendar header.
   */
  showCalendarHeader = true;
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE2;
    this.renderer.removeClass(this.element.nativeElement, getSizeClass("calendar", this.size));
    if (newSize !== "none") {
      this.renderer.addClass(this.element.nativeElement, getSizeClass("calendar", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  _size = DEFAULT_SIZE2;
  /**
   * @hidden
   */
  id;
  /**
   * Sets or gets the `focusedDate` property of the Calendar and
   * defines the focused date of the component
   * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.
   */
  set focusedDate(focusedDate) {
    this._focusedDate = focusedDate || getToday();
  }
  get focusedDate() {
    return this._focusedDate;
  }
  /**
   * Toggles the visibility of the footer.
   * @default false
   */
  footer = false;
  /**
   * @hidden
   */
  get headerId() {
    return this.id + "header-";
  }
  /**
   * @hidden
   */
  get multiViewCalendarHeaderIdLabel() {
    return this.views >= 2 ? this.id + "header-" : null;
  }
  /**
  * @hidden
  */
  get calendarHeaderIdLabel() {
    return this.views === 1 ? this.id + "header-" : null;
  }
  /**
   * Sets or gets the `min` property of the Calendar and
   * defines the minimum allowed date value.
   * By default, the `min` value is `1900-1-1`.
   */
  set min(min) {
    this._min = min || new Date(MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Sets or gets the `max` property of the Calendar and
   * defines the maximum allowed date value.
   * By default, the `max` value is `2099-12-31`.
   */
  set max(max) {
    this._max = max || new Date(MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form.
   *
   * @default false
   */
  rangeValidation = false;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example](slug:disabled_dates_multiviewcalendar)).
   */
  disabledDatesRangeValidation = false;
  /**
   * Sets the Calendar selection mode
   * ([see example]({% slug selection_multiviewcalendar %})).
   *
   * The available values are:
   * * `single` (default)
   * * `multiple`
   * * `range`
   */
  set selection(_selection) {
    this.selectionSetter = true;
    this._selection = _selection;
  }
  get selection() {
    return this._selection;
  }
  _selection = "single";
  /**
   * Allows reverse selection when using `range` selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
      instance when in `single` selection mode, an array of valid JavaScript Date instances when in `multiple` selection mode, or
      an object of type `SelectionRange` when in `range` selection mode.
   */
  set value(candidate) {
    this.valueSetter = true;
    this._value = candidate;
  }
  get value() {
    return this._value;
  }
  /**
   * Sets or gets the `disabled` property of the Calendar and
   * determines whether the component is active
   * ([see example]({% slug disabled_multiviewcalendar %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiviewcalendar#toc-managing-the-multiviewcalendar-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets or gets the `tabindex` property of the Calendar. Based on the
   * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
   * it determines whether the component is focusable.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * @hidden
   */
  isActive = false;
  /**
   * Sets the dates of the MultiViewCalendar that will be disabled
   * ([see example]({% slug disabled_dates_multiviewcalendar %})).
   */
  set disabledDates(value) {
    this.disabledDatesService.initialize(value);
  }
  /**
   * Defines the active view that the Calendar initially renders
   * ([see example]({% slug viewoptions_multiviewcalendar %})).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost view, to which the user can navigate
   * ([see example](slug:viewdepth_multiviewcalendar)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost view, to which the user can navigate.
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Determines whether to display a header for every view (for example the month name).
   */
  showViewHeader = false;
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).
   */
  weekNumber = false;
  /**
   * Specify, which end of the defined selection range should be marked as active.
   *
   * > Value will be ignored if the selection range is undefined.
   * > If range selection is used then the default value is 'start'.
   */
  set activeRangeEnd(_activeRangeEnd) {
    this._activeRangeEnd = _activeRangeEnd;
  }
  get activeRangeEnd() {
    return this.selection === "range" && !this._activeRangeEnd ? "start" : this._activeRangeEnd;
  }
  /**
   * Sets or gets the `selectionRange` property of the Calendar and
   * defines the selection range of the component
   * ([see example](slug:selection_multiviewcalendar#toc-range-selection)).
   * > We recommend using the `value` property as it now supports `range` selection.
   */
  set selectionRange(range2) {
    this._selectionRange = range2;
    if (this.disabledDatesRangeValidation) {
      this.onValidatorChange();
    }
  }
  get selectionRange() {
    return this._selectionRange;
  }
  /**
   * Sets or gets the `views` property of the Calendar and
   * defines the number of rendered months.
   */
  views = 2;
  /**
   * Specifies the orientation of the MultiViewCalendar.
   *
   * The available values are:
   * * `horizontal` (default)
   * * `vertical`
   */
  orientation = "horizontal";
  /**
   * Fires when the active view is changed
   * ([see example](slug:events_multiviewcalendar)).
   */
  activeViewChange = new EventEmitter();
  /**
   * Fires when navigating in the currently active view
   * ([see example](slug:events_multiviewcalendar)).
   */
  navigate = new EventEmitter();
  /**
   * Fires when a view cell is entered
   * ([see example](slug:events_multiviewcalendar)).
   */
  cellEnter = new EventEmitter();
  /**
   * Fires when a view cell is leaved
   * ([see example](slug:events_multiviewcalendar)).
   */
  cellLeave = new EventEmitter();
  /**
   * Fires when the value is changed
   * ([see example](slug:events_multiviewcalendar)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   * Fires when the range selection changes.
   */
  rangeSelectionChange = new EventEmitter();
  /**
   * Fires each time the MultiViewCalendar gets blurred
   * ([see example](slug:events_multiviewcalendar)).
   */
  blurEvent = new EventEmitter();
  /**
   * Fires each time the MultiViewCalendar gets focused
   * ([see example](slug:events_multiviewcalendar)).
   */
  focusEvent = new EventEmitter();
  /**
   * @hidden
   */
  focusCalendar = new EventEmitter();
  /**
   * @hidden
   */
  onClosePopup = new EventEmitter();
  /**
   * @hidden
   */
  onTabPress = new EventEmitter();
  /**
   * @hidden
   */
  onShiftTabPress = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a cell template declaration.
   * Ignored if a `[cellTemplate]` value is explicitly provided.
   */
  cellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set cellTemplateRef(template) {
    this._cellTemplateRef = template;
  }
  get cellTemplateRef() {
    return this._cellTemplateRef || this.cellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a month cell template declaration.
   * Ignored if a `[monthCellTemplate]` value is explicitly provided.
   */
  monthCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each month cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set monthCellTemplateRef(template) {
    this._monthCellTemplateRef = template;
  }
  get monthCellTemplateRef() {
    return this._monthCellTemplateRef || this.monthCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a year cell template declaration.
   * Ignored if a `[yearCellTemplate]` value is explicitly provided.
   */
  yearCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each year cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set yearCellTemplateRef(template) {
    this._yearCellTemplateRef = template;
  }
  get yearCellTemplateRef() {
    return this._yearCellTemplateRef || this.yearCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a decade cell template declaration.
   * Ignored if a `[decadeCellTemplate]` value is explicitly provided.
   */
  decadeCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each decade cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set decadeCellTemplateRef(template) {
    this._decadeCellTemplateRef = template;
  }
  get decadeCellTemplateRef() {
    return this._decadeCellTemplateRef || this.decadeCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a century cell template declaration.
   * Ignored if a `[centuryCellTemplate]` value is explicitly provided.
   */
  centuryCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each century cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set centuryCellTemplateRef(template) {
    this._centuryCellTemplateRef = template;
  }
  get centuryCellTemplateRef() {
    return this._centuryCellTemplateRef || this.centuryCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a week number cell template declaration.
   * Ignored if a `[weekNumberTemplate]` value is explicitly provided.
   */
  weekNumberTemplate;
  /**
   * @hidden
   *
   * Defines the template for the week cell.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set weekNumberTemplateRef(template) {
    this._weekNumberTemplateRef = template;
  }
  get weekNumberTemplateRef() {
    return this._weekNumberTemplateRef || this.weekNumberTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a header title template declaration.
   * Ignored if a `[headerTitleTemplate]` value is explicitly provided.
   */
  headerTitleTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   */
  headerTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   */
  footerTemplate;
  /**
   * @hidden
   *
   * Defines the template for the Calendar footer.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set footerTemplateRef(template) {
    this._footerTemplateRef = template;
  }
  get footerTemplateRef() {
    return this._footerTemplateRef || this.footerTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the header title.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set headerTitleTemplateRef(template) {
    this._headerTitleTemplateRef = template;
  }
  get headerTitleTemplateRef() {
    return this._headerTitleTemplateRef || this.headerTitleTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the Calendar header.
   * Takes precedence over nested templates in the KendoMultiViewCalendar tag.
   */
  set headerTemplateRef(template) {
    this._headerTemplateRef = template;
  }
  get headerTemplateRef() {
    return this._headerTemplateRef || this.headerTemplate;
  }
  headerElement;
  viewList;
  cellUID = guid();
  isHovered = false;
  activeDate;
  isPrevDisabled = true;
  isNextDisabled = true;
  prevView = Action.PrevView;
  nextView = Action.NextView;
  selectedDates = [];
  rangePivot;
  shouldHoverWhenNoStart = false;
  canHover = false;
  changes = {};
  valueSetter = false;
  selectionSetter = false;
  _min = new Date(MIN_DATE);
  _max = new Date(MAX_DATE);
  _focusedDate = getToday();
  _value;
  _selectionRange = {
    start: null,
    end: null
  };
  _activeRangeEnd;
  resolvedPromise = Promise.resolve();
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesRangeValidateFn = noop$2;
  subscriptions = new Subscription();
  _cellTemplateRef;
  _monthCellTemplateRef;
  _yearCellTemplateRef;
  _decadeCellTemplateRef;
  _centuryCellTemplateRef;
  _weekNumberTemplateRef;
  _headerTitleTemplateRef;
  _headerTemplateRef;
  _footerTemplateRef;
  get activeViewEnum() {
    const activeView = CalendarViewEnum[this.activeView];
    return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
  }
  get bottomViewEnum() {
    return CalendarViewEnum[this.bottomView];
  }
  get topViewEnum() {
    return CalendarViewEnum[this.topView];
  }
  get widgetId() {
    return this.views >= 2 ? this.id : null;
  }
  get ariaDisabled() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  get ariaActivedescendant() {
    return this.cellUID + this.focusedDate.getTime();
  }
  /**
   * @hidden
   */
  handleFocusout(event2) {
    const relatedTarget = event2.relatedTarget;
    if (!this.element.nativeElement.contains(relatedTarget)) {
      const isClassicCalendar = this.views === 1;
      isClassicCalendar ? this.blurEvent.emit(event2) : this.blurEvent.emit();
      this.onControlTouched();
    }
    this.isActive = false;
    this.isHovered = false;
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.isActive = true;
    const isClassicCalendar = this.views === 1;
    isClassicCalendar ? this.focusCalendar.emit() : this.focusEvent.emit();
    this.focusEvent.emit();
  }
  /**
   * @hidden
   */
  handleMouseEnter() {
    this.isHovered = true;
  }
  /**
   * @hidden
   */
  handleMouseLeave() {
    this.isHovered = false;
    this.setRangeSelectionToValue();
  }
  /**
   * @hidden
   */
  handleMousedown(event2) {
    event2.preventDefault();
  }
  /**
   * @hidden
   */
  handleClick() {
    if (this.isActive) {
      return;
    }
    this.focus();
  }
  /**
   * @hidden
   */
  keydown(event2) {
    const arrowUpOrDownKeyPressed = [Keys.ArrowUp, Keys.ArrowDown].indexOf(event2.keyCode) !== -1;
    const ctrlKey = event2.ctrlKey || event2.metaKey;
    const onArrowRightAndControl = event2.keyCode === Keys.ArrowRight && ctrlKey;
    const onArrowLeftAndControl = event2.keyCode === Keys.ArrowLeft && ctrlKey;
    const onTKeyPress = event2.keyCode === Keys.KeyT;
    const onEnterKeyPress = event2.keyCode === Keys.Enter;
    const onArrowUpPress = event2.keyCode === Keys.ArrowUp;
    const altKey = event2.altKey;
    const escKey = event2.keyCode === Keys.Escape;
    const tabKeyPress = event2.keyCode === Keys.Tab;
    const shiftKeyPress = event2.shiftKey;
    if (onArrowRightAndControl) {
      event2.preventDefault();
      this.navigateView(this.nextView);
      return;
    } else if (onArrowLeftAndControl) {
      event2.preventDefault();
      this.navigateView(this.prevView);
      return;
    } else if (ctrlKey && arrowUpOrDownKeyPressed) {
      event2.preventDefault();
    } else if (onTKeyPress) {
      this.focusedDate = getToday();
      this.bus.moveToBottom(this.activeViewEnum);
      this.updateButtonState();
      return;
    } else if (onEnterKeyPress) {
      if (this.selection !== "range") {
        this.selectionService.lastClicked = this.focusedDate;
        this.performSelection(this.focusedDate, event2);
      } else {
        this.performRangeSelection(this.focusedDate);
      }
    }
    if (this.views >= 2) {
      if (escKey || altKey && onArrowUpPress) {
        this.onClosePopup.emit(event2);
      } else if (tabKeyPress && shiftKeyPress) {
        this.onShiftTabPress.emit(event2);
      } else if (tabKeyPress && !shiftKeyPress) {
        this.onTabPress.emit(event2);
      }
    }
    const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(event2), this.activeViewEnum), this.min, this.max);
    if (isEqual(this.focusedDate, candidate)) {
      return;
    }
    this.focusedDate = candidate;
    event2.preventDefault();
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
    if (!isSameView) {
      this.emitNavigate(this.focusedDate);
      this.updateButtonState();
    }
    if (isArrowWithShiftPressed(event2) && this.selection !== "range") {
      event2["anyArrow"] = true;
      this.performSelection(this.focusedDate, event2);
    }
  }
  constructor(bus, element, navigator2, renderer, cdr, zone, disabledDatesService, selectionService) {
    this.bus = bus;
    this.element = element;
    this.navigator = navigator2;
    this.renderer = renderer;
    this.cdr = cdr;
    this.zone = zone;
    this.disabledDatesService = disabledDatesService;
    this.selectionService = selectionService;
    this.id = `kendo-multiviewcalendarid-${this.bus.calendarId}-`;
  }
  ngOnInit() {
    this.setClasses(this.element.nativeElement);
    this.subscriptions.add(this.bus.viewChanged.subscribe(({
      view: view2
    }) => {
      this.activeView = CalendarViewEnum[view2];
      this.activeViewChange.emit(this.activeView);
      this.cdr.detectChanges();
      this.updateButtonState();
    }));
  }
  ngOnChanges(changes) {
    this.changes = changes;
    this.verifyChanges();
    this.bus.configure(this.bottomViewEnum, this.topViewEnum);
  }
  ngDoCheck() {
    if (this.valueSetter || this.selectionSetter) {
      if (this.selection === "range" && (this.value?.start || this.value?.end) && this.focusedDate.getTime() !== this.value.start?.getTime() && this.focusedDate.getTime() !== this.value.end?.getTime()) {
        this.focusedDate = this.value.start || this.value.end || getToday();
      }
      this.setValue(this.value);
      this.valueSetter = false;
      this.selectionSetter = false;
    }
    if (hasExistingValue(this.changes, "focusedDate")) {
      const focusedDate = this.changes.focusedDate.currentValue;
      this.focusedDate = dateInRange(focusedDate, this.min, this.max);
    }
    if (this.changes.min || this.changes.max || this.changes.rangeValidation || this.changes.disabledDates || this.changes.disabledDatesRangeValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesRangeValidateFn = this.disabledDatesRangeValidation ? disabledDatesRangeValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.onValidatorChange();
    }
    if (this.changes.min || this.changes.max || this.changes.focusedDate || this.changes.activeView || this.changes.value) {
      this.updateButtonState();
    }
    this.changes = {};
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  ngAfterViewInit() {
    this.updateButtonState();
  }
  /**
   * Focuses the host element of the Calendar.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="multiviewcalendar.focus()">Focus calendar</button>
   *  <kendo-multiviewcalendar #multiviewcalendar></kendo-multiviewcalendar>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.querySelector(".k-calendar-view").focus({
      preventScroll: true
    });
  }
  /**
   * Blurs the Calendar component.
   */
  blur() {
    if (!this.element) {
      return;
    }
    const activeElement = this.views >= 2 ? this.element.nativeElement.querySelector(".k-calendar-view") : this.element.nativeElement.querySelector(".k-calendar-table");
    activeElement.blur();
  }
  /**
   * @hidden
   */
  handleDateChange(args) {
    const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
    const availableDates = args.selectedDates.filter((date2) => !this.disabledDatesService.isDateDisabled(date2));
    this.focusedDate = args.focusedDate || this.focusedDate;
    const sameDates = !canNavigateDown && areDatesEqual(availableDates, this.selectedDates);
    if (sameDates && !canNavigateDown && this.selection === "single") {
      this.onClosePopup.emit();
    }
    if (this.disabled || sameDates) {
      return;
    }
    if (canNavigateDown) {
      this.bus.moveDown(this.activeViewEnum);
      return;
    }
    if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
      return;
    }
    if (this.selection === "range") {
      return;
    }
    this.selectedDates = availableDates.map((date2) => cloneDate(date2));
    this.value = this.parseSelectionToValue(availableDates);
    this.onControlChange(this.parseSelectionToValue(availableDates));
    this.valueChange.emit(this.parseSelectionToValue(availableDates));
  }
  /**
   * @hidden
   */
  onCellEnter(cellEnter, date2) {
    this.emitCellEvent(cellEnter, date2);
    if (this.selection === "range" && (this.canHover || this.shouldHoverWhenNoStart)) {
      this.zone.run(() => {
        if (this.canHover && !this.shouldHoverWhenNoStart) {
          if (this.allowReverse) {
            if (this.activeRangeEnd === "end" && this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: date2
              };
            }
            if (this.activeRangeEnd === "start" && this.selectionRange.end) {
              this.selectionRange = {
                start: date2,
                end: this.selectionRange.end
              };
            }
          } else {
            if (this.activeRangeEnd === "end" && this.selectionRange.start && date2 >= this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: date2
              };
            }
            if (this.selectionRange.start && date2 < this.selectionRange.start) {
              this.selectionRange = {
                start: this.selectionRange.start,
                end: null
              };
            }
          }
        } else if (this.shouldHoverWhenNoStart && date2 <= this.selectionRange.end) {
          this.selectionRange = {
            start: date2,
            end: this.selectionRange.end
          };
        } else {
          this.selectionRange = {
            start: null,
            end: this.selectionRange.end
          };
        }
      });
    }
  }
  /**
   * @hidden
   */
  handleTodayButtonClick(args) {
    const todayDate = args.focusedDate;
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(todayDate, this.viewList.dates);
    const isBottomView = !this.bus.canMoveDown(this.activeViewEnum);
    if (!isSameView && isBottomView) {
      this.emitNavigate(todayDate);
      this.updateButtonState();
    }
    this.handleDateChange(args);
  }
  /**
   * @hidden
   */
  setActiveDate(date2) {
    this.activeDate = cloneDate(date2);
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  writeValue(candidate) {
    this.verifyValue(candidate);
    this.value = candidate;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesRangeValidateFn(this.selectionRange);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  activeCellTemplate() {
    switch (this.activeViewEnum) {
      case CalendarViewEnum.month:
        return this.monthCellTemplateRef || this.cellTemplateRef;
      case CalendarViewEnum.year:
        return this.yearCellTemplateRef;
      case CalendarViewEnum.decade:
        return this.decadeCellTemplateRef;
      case CalendarViewEnum.century:
        return this.centuryCellTemplateRef;
      default:
        return null;
    }
  }
  /**
   * @hidden
   */
  navigateView(action) {
    this.focusedDate = this.viewList.navigate(action);
    this.updateButtonState();
    this.emitNavigate(this.focusedDate);
  }
  /**
   * @hidden
   */
  emitNavigate(focusedDate) {
    const activeView = CalendarViewEnum[this.activeViewEnum];
    this.navigate.emit({
      activeView,
      focusedDate
    });
  }
  /**
   * @hidden
   */
  emitCellEvent(emitter, args) {
    if (hasObservers(emitter)) {
      this.zone.run(() => {
        emitter.emit(args);
      });
    }
  }
  /**
   * @hidden
   */
  handleCellClick({
    date: date2,
    modifiers
  }) {
    if (this.selection === "range" && this.activeViewEnum === CalendarViewEnum[this.bottomView]) {
      this.performRangeSelection(date2);
    } else {
      this.selectionService.lastClicked = date2;
      this.performSelection(date2, modifiers);
    }
    const isSameView = this.bus.service(this.activeViewEnum).isInArray(this.focusedDate, this.viewList.dates);
    if (!isSameView) {
      this.emitNavigate(this.focusedDate);
      this.updateButtonState();
    }
  }
  /**
   * @hidden
   */
  handleWeekNumberClick(dates) {
    if (this.selection === "single") {
      return;
    }
    this.zone.run(() => {
      if (this.selection === "multiple") {
        this.handleDateChange({
          selectedDates: dates,
          focusedDate: last(dates)
        });
      }
      if (this.selection === "range") {
        this.activeRangeEnd = "start";
        const shouldEmitValueChange = this.selectionRange.start?.getTime() !== dates[0].getTime() || this.selectionRange.end?.getTime() !== last(dates).getTime();
        this.selectionRange.start = dates[0];
        this.selectionRange.end = last(dates);
        this.value = this.selectionRange;
        if (shouldEmitValueChange) {
          this.valueChange.emit(this.value);
        }
      }
    });
  }
  setClasses(element) {
    this.renderer.addClass(element, "k-calendar");
    this.renderer.addClass(element, getSizeClass("calendar", this.size));
    if (this.views >= 2) {
      this.renderer.addClass(element, "k-calendar-range");
    }
  }
  verifyChanges() {
    if (!isDevMode()) {
      return;
    }
    if (this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$3} and ${MAX_DOC_LINK$3}.`);
    }
    if (this.bottomViewEnum > this.topViewEnum) {
      throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK$1} and ${TOP_VIEW_DOC_LINK$1}.`);
    }
  }
  verifyValue(candidate) {
    if (!isDevMode()) {
      return;
    }
    if (this.selection === "single" && candidate && !isNullOrDate(candidate)) {
      throw new Error(`When using 'single' selection the 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
    } else if (this.selection === "multiple" && candidate) {
      if (Array.isArray(candidate)) {
        const onlyDates = candidate.every((value) => value instanceof Date);
        if (!onlyDates) {
          throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
        }
      }
      if (Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
        throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
      }
    } else if (this.selection === "range" && candidate && !(isNullOrDate(candidate["start"]) && isNullOrDate(candidate["end"]))) {
      throw new Error(`The 'value' should be an object with start and end dates. Check ${VALUE_DOC_LINK$5} for possible resolution.`);
    }
  }
  updateButtonState() {
    this.resolvedPromise.then(() => {
      this.cdr.detectChanges();
      this.isPrevDisabled = !this.viewList.canNavigate(this.prevView);
      this.isNextDisabled = !this.viewList.canNavigate(this.nextView);
      this.cdr.markForCheck();
    });
  }
  parseSelectionToValue(selection) {
    selection = selection || [];
    return this.selection === "single" ? cloneDate(last(selection)) : selection.map((date2) => cloneDate(date2));
  }
  setValue(candidate) {
    this.verifyValue(candidate);
    if (candidate === null) {
      this._value = null;
      this.selectedDates = [];
    } else if (Array.isArray(candidate)) {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = candidate.filter((date2) => isPresent3(date2)).map((element) => cloneDate(element));
    } else if (isObject(candidate) && Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = {
        start: null,
        end: null
      };
      this._value.start = candidate.start instanceof Date ? cloneDate(candidate.start) : null;
      this._value.end = candidate.end instanceof Date ? cloneDate(candidate.end) : null;
      this.selectionRange = Object.assign({}, this._value);
      if (this._value?.start && !this._value?.end) {
        this.activeRangeEnd = "end";
        this.canHover = true;
      }
      if (this._value?.end && !this._value?.start) {
        this.activeRangeEnd = "start";
        this.canHover = true;
      }
      if (this._value?.end && this._value?.start) {
        this.canHover = false;
      }
    } else {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = cloneDate(candidate);
    }
    if (this.selection !== "range") {
      const selection = [].concat(candidate).filter((date2) => isPresent3(date2)).map((date2) => cloneDate(date2));
      if (!areDatesEqual(selection, this.selectedDates)) {
        const lastSelected = last(selection);
        this.rangePivot = cloneDate(lastSelected);
        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
        this.selectedDates = selection;
      }
    }
  }
  setRangeSelectionToValue() {
    if (this.selection === "range" && this.value) {
      this.selectionRange = this.value;
      this.cdr.markForCheck();
    }
  }
  performRangeSelection(date2) {
    this.focusedDate = date2;
    const clonedRangeSelection = Object.assign({}, this.selectionRange);
    const emitValueChange = this.activeRangeEnd === "start" && this.value?.start?.getTime() !== date2?.getTime() || this.activeRangeEnd === "end" && this.value?.end?.getTime() !== date2?.getTime();
    this.zone.run(() => {
      const rangeSelection = handleRangeSelection(date2, clonedRangeSelection, this.activeRangeEnd, this.allowReverse);
      this.activeRangeEnd = rangeSelection.activeRangeEnd;
      if (this.canHover && rangeSelection.activeRangeEnd === "end" && rangeSelection.selectionRange.end?.getTime() === date2.getTime()) {
        this.activeRangeEnd = "start";
        rangeSelection.activeRangeEnd = "start";
      }
      this.canHover = this.activeRangeEnd === "end" && rangeSelection.selectionRange.start && !rangeSelection.selectionRange.end;
      if (emitValueChange && (this.value?.start?.getTime() !== rangeSelection.selectionRange?.start?.getTime() || this.value?.end?.getTime() !== rangeSelection.selectionRange?.end?.getTime())) {
        this.value = rangeSelection.selectionRange;
        this.valueChange.emit(this.value);
        this.rangeSelectionChange.emit(rangeSelection);
      }
      this.cdr.markForCheck();
    });
  }
  performSelection(date2, selectionModifiers) {
    const selection = this.selectionService.performSelection({
      date: date2,
      modifiers: selectionModifiers,
      selectionMode: this.selection,
      activeViewEnum: this.activeViewEnum,
      rangePivot: this.rangePivot,
      selectedDates: this.selectedDates
    });
    this.rangePivot = selection.rangePivot;
    this.handleDateChange({
      selectedDates: selection.selectedDates,
      focusedDate: date2
    });
  }
  static ɵfac = function MultiViewCalendarComponent_Factory(t) {
    return new (t || _MultiViewCalendarComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(SelectionService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiViewCalendarComponent,
    selectors: [["kendo-multiviewcalendar"]],
    contentQueries: function MultiViewCalendarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    viewQuery: function MultiViewCalendarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(HeaderComponent, 5, ElementRef);
        ɵɵviewQuery(HorizontalViewListComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewList = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function MultiViewCalendarComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("mouseenter", function MultiViewCalendarComponent_mouseenter_HostBindingHandler() {
          return ctx.handleMouseEnter();
        })("mouseleave", function MultiViewCalendarComponent_mouseleave_HostBindingHandler() {
          return ctx.handleMouseLeave();
        })("mousedown", function MultiViewCalendarComponent_mousedown_HostBindingHandler($event) {
          return ctx.handleMousedown($event);
        })("click", function MultiViewCalendarComponent_click_HostBindingHandler() {
          return ctx.handleClick();
        })("keydown", function MultiViewCalendarComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("id", ctx.widgetId)("aria-disabled", ctx.ariaDisabled);
        ɵɵclassProp("k-disabled", ctx.ariaDisabled);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      showCalendarHeader: "showCalendarHeader",
      size: "size",
      id: "id",
      focusedDate: "focusedDate",
      footer: "footer",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      disabledDatesRangeValidation: "disabledDatesRangeValidation",
      selection: "selection",
      allowReverse: "allowReverse",
      value: "value",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      weekDaysFormat: "weekDaysFormat",
      isActive: "isActive",
      disabledDates: "disabledDates",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      showViewHeader: "showViewHeader",
      animateNavigation: "animateNavigation",
      weekNumber: "weekNumber",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      views: "views",
      orientation: "orientation",
      cellTemplateRef: [InputFlags.None, "cellTemplate", "cellTemplateRef"],
      monthCellTemplateRef: [InputFlags.None, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [InputFlags.None, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [InputFlags.None, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [InputFlags.None, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [InputFlags.None, "weekNumberTemplate", "weekNumberTemplateRef"],
      footerTemplateRef: [InputFlags.None, "footerTemplate", "footerTemplateRef"],
      headerTitleTemplateRef: [InputFlags.None, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [InputFlags.None, "headerTemplate", "headerTemplateRef"]
    },
    outputs: {
      activeViewChange: "activeViewChange",
      navigate: "navigate",
      cellEnter: "cellEnter",
      cellLeave: "cellLeave",
      valueChange: "valueChange",
      rangeSelectionChange: "rangeSelectionChange",
      blurEvent: "blur",
      focusEvent: "focus",
      focusCalendar: "focusCalendar",
      onClosePopup: "onClosePopup",
      onTabPress: "onTabPress",
      onShiftTabPress: "onShiftTabPress"
    },
    exportAs: ["kendo-multiviewcalendar"],
    standalone: true,
    features: [ɵɵProvidersFeature([BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multiviewcalendar"
    }, NavigationService, SelectionService]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 4,
    vars: 26,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_0 = goog.getMsg("Today");
        i18n_0 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.multiviewcalendar.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_1 = goog.getMsg("Navigate to previous view");
        i18n_1 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar:Navigate to previous view`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_2 = goog.getMsg("Navigate to next view");
        i18n_2 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar:Navigate to next view`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_3 = goog.getMsg("Navigate to parent view");
        i18n_3 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.multiviewcalendar.parentViewButtonTitle|The title of the parent view button in the Multiview calendar header:Navigate to parent view`;
      }
      return [["kendoMultiViewCalendarLocalizedMessages", "", "today", i18n_0, "prevButtonTitle", i18n_1, "nextButtonTitle", i18n_2, "parentViewButtonTitle", i18n_3], [3, "activeView", "currentDate", "size", "min", "max", "id", "rangeLength", "titleTemplateRef", "headerTemplateRef", "isPrevDisabled", "isNextDisabled", "showNavigationButtons", "orientation", "todayButtonClick", "prevButtonClick", "nextButtonClick", 4, "ngIf"], [3, "cellClick", "weekNumberCellClick", "cellEnter", "cellLeave", "activeDateChange", "focusCalendar", "blurCalendar", "showOtherMonthDays", "allowReverse", "id", "activeView", "activeDescendant", "isActive", "cellTemplateRef", "weekNumberTemplateRef", "cellUID", "weekDaysFormat", "views", "min", "max", "focusedDate", "animateNavigation", "showViewHeader", "weekNumber", "activeRangeEnd", "selectionRange", "selectedDates", "orientation", "tabIndex", "disabled"], [3, "footerTemplateRef", "activeViewValue", "currentDate", 4, "ngIf"], [3, "todayButtonClick", "prevButtonClick", "nextButtonClick", "activeView", "currentDate", "size", "min", "max", "id", "rangeLength", "titleTemplateRef", "headerTemplateRef", "isPrevDisabled", "isNextDisabled", "showNavigationButtons", "orientation"], [3, "footerTemplateRef", "activeViewValue", "currentDate"]];
    },
    template: function MultiViewCalendarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵtemplate(1, MultiViewCalendarComponent_kendo_calendar_header_1_Template, 1, 13, "kendo-calendar-header", 1);
        ɵɵelementStart(2, "kendo-calendar-horizontal", 2);
        ɵɵlistener("cellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellClick_2_listener($event) {
          return ctx.handleCellClick($event);
        })("weekNumberCellClick", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_weekNumberCellClick_2_listener($event) {
          return ctx.handleWeekNumberClick($event);
        })("cellEnter", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellEnter_2_listener($event) {
          return ctx.onCellEnter(ctx.cellEnter, $event);
        })("cellLeave", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_cellLeave_2_listener($event) {
          return ctx.emitCellEvent(ctx.cellLeave, $event);
        })("activeDateChange", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_activeDateChange_2_listener($event) {
          return ctx.setActiveDate($event);
        })("focusCalendar", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_focusCalendar_2_listener() {
          return ctx.handleFocus();
        })("blurCalendar", function MultiViewCalendarComponent_Template_kendo_calendar_horizontal_blurCalendar_2_listener($event) {
          return ctx.handleFocusout($event);
        });
        ɵɵelementEnd();
        ɵɵtemplate(3, MultiViewCalendarComponent_kendo_calendar_footer_3_Template, 1, 3, "kendo-calendar-footer", 3);
      }
      if (rf & 2) {
        let tmp_7_0;
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showCalendarHeader);
        ɵɵadvance();
        ɵɵproperty("showOtherMonthDays", ctx.showOtherMonthDays)("allowReverse", ctx.allowReverse)("id", ctx.calendarHeaderIdLabel)("activeView", ctx.activeViewEnum)("activeDescendant", ctx.ariaActivedescendant)("isActive", ctx.isActive || ctx.isHovered)("cellTemplateRef", (tmp_7_0 = ctx.activeCellTemplate()) == null ? null : tmp_7_0.templateRef)("weekNumberTemplateRef", ctx.weekNumberTemplateRef == null ? null : ctx.weekNumberTemplateRef.templateRef)("cellUID", ctx.cellUID)("weekDaysFormat", ctx.weekDaysFormat)("views", ctx.views)("min", ctx.min)("max", ctx.max)("focusedDate", ctx.focusedDate)("animateNavigation", ctx.animateNavigation)("showViewHeader", ctx.showViewHeader)("weekNumber", ctx.weekNumber)("activeRangeEnd", ctx.activeRangeEnd)("selectionRange", ctx.selectionRange)("selectedDates", ctx.selectedDates)("orientation", ctx.orientation)("tabIndex", ctx.tabIndex)("disabled", ctx.disabled);
        ɵɵattribute("aria-labelledby", ctx.multiViewCalendarHeaderIdLabel);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.footer);
      }
    },
    dependencies: [MultiViewCalendarLocalizedMessagesDirective, NgIf, HeaderComponent, HorizontalViewListComponent, FooterComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-multiviewcalendar",
      providers: [BusViewService, RANGE_CALENDAR_VALUE_ACCESSOR, RANGE_CALENDAR_RANGE_VALIDATORS, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multiviewcalendar"
      }, NavigationService, SelectionService],
      selector: "kendo-multiviewcalendar",
      template: `
    <ng-container kendoMultiViewCalendarLocalizedMessages
        i18n-today="kendo.multiviewcalendar.today|The label for the today button in the calendar header"
        today="Today"

        i18n-prevButtonTitle="kendo.multiviewcalendar.prevButtonTitle|The label for the previous button in the Multiview calendar"
        prevButtonTitle="Navigate to previous view"

        i18n-nextButtonTitle="kendo.multiviewcalendar.nextButtonTitle|The label for the next button in the Multiview calendar"
        nextButtonTitle="Navigate to next view"

        i18n-parentViewButtonTitle="kendo.multiviewcalendar.parentViewButtonTitle|The title of the parent view button in the Multiview calendar header"
        parentViewButtonTitle="Navigate to parent view"
    >
    </ng-container>
    <kendo-calendar-header
        *ngIf="showCalendarHeader"
        [activeView]="activeViewEnum"
        [currentDate]="activeDate"
        [size]="size"
        [min]="min"
        [max]="max"
        [id]="headerId"
        [rangeLength]="views"
        [titleTemplateRef]="headerTitleTemplateRef?.templateRef"
        [headerTemplateRef]="headerTemplateRef?.templateRef"
        [isPrevDisabled]="isPrevDisabled"
        [isNextDisabled]="isNextDisabled"
        [showNavigationButtons]="true"
        [orientation]="orientation"
        (todayButtonClick)="handleTodayButtonClick({ selectedDates: [$event], focusedDate: $event })"
        (prevButtonClick)="navigateView(prevView)"
        (nextButtonClick)="navigateView(nextView)"
    >
    </kendo-calendar-header>
    <kendo-calendar-horizontal
        [showOtherMonthDays]="showOtherMonthDays"
        [allowReverse]="allowReverse"
        [id]="calendarHeaderIdLabel"
        [attr.aria-labelledby]="multiViewCalendarHeaderIdLabel"
        [activeView]="activeViewEnum"
        [activeDescendant]="ariaActivedescendant"
        [isActive]="isActive || isHovered"
        [cellTemplateRef]="activeCellTemplate()?.templateRef"
        [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
        [cellUID]="cellUID"
        [weekDaysFormat]="weekDaysFormat"
        [views]="views"
        [min]="min"
        [max]="max"
        [focusedDate]="focusedDate"
        [animateNavigation]="animateNavigation"
        [showViewHeader]="showViewHeader"
        [weekNumber]="weekNumber"
        [activeRangeEnd]="activeRangeEnd"
        [selectionRange]="selectionRange"
        [selectedDates]="selectedDates"
        [orientation]="orientation"
        [tabIndex]="tabIndex"
        [disabled]="disabled"
        (cellClick)="handleCellClick($event)"
        (weekNumberCellClick)="handleWeekNumberClick($event)"
        (cellEnter)="onCellEnter(cellEnter, $event)"
        (cellLeave)="emitCellEvent(cellLeave, $event)"
        (activeDateChange)="setActiveDate($event)"
        (focusCalendar)="handleFocus()"
        (blurCalendar)="handleFocusout($event)"
    >
    </kendo-calendar-horizontal>
    <kendo-calendar-footer
        *ngIf="footer"
        [footerTemplateRef]="footerTemplateRef?.templateRef"
        [activeViewValue]="activeView"
        [currentDate]="activeDate">
    </kendo-calendar-footer>
  `,
      standalone: true,
      imports: [MultiViewCalendarLocalizedMessagesDirective, NgIf, HeaderComponent, HorizontalViewListComponent, FooterComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: ElementRef
    }, {
      type: NavigationService
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: DisabledDatesService
    }, {
      type: SelectionService
    }];
  }, {
    showOtherMonthDays: [{
      type: Input
    }],
    showCalendarHeader: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesRangeValidation: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    activeViewChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    cellEnter: [{
      type: Output
    }],
    cellLeave: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    rangeSelectionChange: [{
      type: Output
    }],
    blurEvent: [{
      type: Output,
      args: ["blur"]
    }],
    focusEvent: [{
      type: Output,
      args: ["focus"]
    }],
    focusCalendar: [{
      type: Output
    }],
    onClosePopup: [{
      type: Output
    }],
    onTabPress: [{
      type: Output
    }],
    onShiftTabPress: [{
      type: Output
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    headerElement: [{
      type: ViewChild,
      args: [HeaderComponent, {
        static: false,
        read: ElementRef
      }]
    }],
    viewList: [{
      type: ViewChild,
      args: [HorizontalViewListComponent, {
        static: false
      }]
    }],
    widgetId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    handleMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    handleMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }],
    handleMousedown: [{
      type: HostListener,
      args: ["mousedown", ["$event"]]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click"]
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var div$1 = domContainerFactory("div");
var ul$1 = domContainerFactory("ul");
var li$1 = domContainerFactory("li");
var td = domContainerFactory("td");
var th = domContainerFactory("th");
var tr = domContainerFactory("tr");
var tbody = domContainerFactory("tbody");
var thead = domContainerFactory("thead");
var table = domContainerFactory("table");
var monthHeader = () => div$1(`
            <span class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-calendar-title">March 2017</span>
            <span class="k-spacer"></span>
            <span class="k-calendar-nav">
                <button class="k-calendar-nav-today k-button k-button-md k-button-flat k-button-flat-base k-rounded-md">TODAY</button>
            </span>
        `, "k-calendar-header");
var monthWeekHeader = () => table([thead([tr([th("MO", "k-calendar-th")], "k-calendar-tr")], "k-calendar-thead")], "k-calendar-weekdays k-calendar-table");
var repeat = (count2, mapper) => new Array(count2).fill("1").map(mapper);
var content = (rows, cells = 1) => table([tbody([tr([th("1", "k-calendar-th")], "k-calendar-tr")].concat(repeat(rows, () => tr(repeat(cells, (c) => td(`<span class="k-link">${c}</span>`, "k-calendar-td")), "k-calendar-tr"))), "k-calendar-tbody")], "k-calendar-table");
var scrollable$1 = (children2) => div$1(children2, "k-flex k-content k-scrollable");
var view = (contentElement, className, renderWeekHeader) => div$1([monthHeader(), renderWeekHeader ? monthWeekHeader() : null, scrollable$1([contentElement, contentElement])], className, {
  left: "-10000px",
  position: "absolute"
});
var navigationList = /* @__PURE__ */ (() => {
  let navElement;
  return () => {
    if (!isDocumentAvailable) {
      return null;
    }
    if (!navElement) {
      navElement = div$1([scrollable$1([ul$1([li$1("<span>FEB</span>")])])], "k-calendar-navigation", {
        left: "0px",
        position: "absolute"
      });
    }
    return navElement;
  };
})();
var viewFactory = ({
  cells,
  rows
}, className, renderWeekHeader) => {
  let viewElement;
  return () => {
    if (!isDocumentAvailable) {
      return null;
    }
    if (!viewElement) {
      viewElement = view(content(rows, cells), className, renderWeekHeader);
    }
    return viewElement;
  };
};
var getScrollable = (element) => element.querySelector(".k-scrollable");
var horizontal = (element) => {
  const scrollableElement = getScrollable(element);
  scrollableElement.classList.add("k-scrollable-horizontal");
  return element;
};
var monthView = viewFactory({
  cells: 7,
  rows: 6
}, "k-vstack k-calendar-view k-calendar-monthview", true);
var yearView = viewFactory({
  cells: 4,
  rows: 3
}, "k-vstack k-calendar-view k-calendar-yearview", false);
var decadeView = viewFactory({
  cells: 4,
  rows: 3
}, "k-vstack k-calendar-view k-calendar-decadeview", false);
var horzMonthView = () => horizontal(monthView());
var horzYearView = () => horizontal(yearView());
var horzDecadeView = () => horizontal(decadeView());
var height = (element) => parseFloat(window.getComputedStyle(element).height) || element.offsetHeight;
var width = (element) => {
  const styles = window.getComputedStyle(element);
  const computed = parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
  return computed || element.offsetWidth;
};
var getBody = (element) => element.querySelector("tbody");
var CalendarDOMService = class _CalendarDOMService {
  //heights
  calendarHeight;
  headerHeight;
  monthViewHeight;
  yearViewHeight;
  decadeViewHeight;
  centuryViewHeight;
  navigationItemHeight;
  scrollableContentHeight;
  scrollableYearContentHeight;
  //widths
  calendarWidth;
  monthViewWidth;
  yearViewWidth;
  decadeViewWidth;
  centuryViewWidth;
  scrollableContentWidth;
  hostContainer;
  ensureHeights() {
    if (this.calendarHeight !== void 0) {
      return;
    }
    this.calculateHeights();
  }
  calculateHeights(container) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.hostContainer = container;
    this.batch(monthView(), (contentElement) => {
      const viewElement = getBody(contentElement);
      this.calendarHeight = height(contentElement);
      this.monthViewHeight = height(viewElement);
      this.headerHeight = height(viewElement.children[0]);
      this.scrollableContentHeight = height(getScrollable(contentElement));
    });
    this.batch(horzMonthView(), (contentElement) => {
      const viewElement = getBody(contentElement);
      this.calendarWidth = width(contentElement);
      this.monthViewWidth = width(viewElement);
      this.scrollableContentWidth = width(getScrollable(contentElement));
    });
    this.batch(yearView(), (contentElement) => {
      this.yearViewHeight = height(getBody(contentElement));
      this.scrollableYearContentHeight = height(getScrollable(contentElement));
    });
    this.batch(horzYearView(), (contentElement) => {
      this.yearViewWidth = width(getBody(contentElement));
    });
    this.batch(decadeView(), (contentElement) => {
      this.decadeViewHeight = height(getBody(contentElement));
      this.centuryViewHeight = this.decadeViewHeight;
    });
    this.batch(horzDecadeView(), (contentElement) => {
      this.decadeViewWidth = width(getBody(contentElement));
      this.centuryViewWidth = this.decadeViewWidth;
    });
    this.batch(navigationList(), (contentElement) => {
      this.navigationItemHeight = height(contentElement.querySelector("li"));
    });
  }
  viewHeight(viewType) {
    return this.viewDimension(viewType, "height");
  }
  viewWidth(viewType) {
    return this.viewDimension(viewType, "width");
  }
  viewDimension(viewType, dimension) {
    const viewProp = dimension === "height" ? "ViewHeight" : "ViewWidth";
    switch (viewType) {
      case CalendarViewEnum.month:
        return this[`month${viewProp}`];
      case CalendarViewEnum.year:
        return this[`year${viewProp}`];
      case CalendarViewEnum.decade:
        return this[`decade${viewProp}`];
      case CalendarViewEnum.century:
        return this[`century${viewProp}`];
      default:
        return 1;
    }
  }
  batch(contentElement, action) {
    if (!isPresent3(this.hostContainer)) {
      return;
    }
    const hostClone = this.hostContainer.cloneNode();
    document.body.appendChild(hostClone);
    try {
      const appendedContent = hostClone.appendChild(contentElement);
      action(appendedContent);
    } finally {
      document.body.removeChild(hostClone);
    }
  }
  static ɵfac = function CalendarDOMService_Factory(t) {
    return new (t || _CalendarDOMService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CalendarDOMService,
    factory: _CalendarDOMService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDOMService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var update = (arr, idx2, value) => [...arr.slice(0, idx2 + 1), ...arr.slice(idx2 + 1).map((x) => x + value)];
var RowHeightService = class {
  total;
  rowHeight;
  detailRowHeight;
  offsets = [];
  heights = [];
  constructor(total = 0, rowHeight, detailRowHeight) {
    this.total = total;
    this.rowHeight = rowHeight;
    this.detailRowHeight = detailRowHeight;
    let agg = 0;
    for (let idx2 = 0; idx2 < total; idx2++) {
      this.offsets.push(agg);
      agg += rowHeight;
      this.heights.push(rowHeight);
    }
  }
  height(rowIndex) {
    return this.heights[rowIndex];
  }
  expandDetail(rowIndex) {
    if (this.height(rowIndex) === this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight);
    }
  }
  collapseDetail(rowIndex) {
    if (this.height(rowIndex) > this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
    }
  }
  index(position2) {
    if (position2 < 0) {
      return void 0;
    }
    const result = this.offsets.reduce((prev, current3, idx2) => {
      if (prev !== void 0) {
        return prev;
      } else if (current3 === position2) {
        return idx2;
      } else if (current3 > position2) {
        return idx2 - 1;
      }
      return void 0;
    }, void 0);
    return result === void 0 ? this.total - 1 : result;
  }
  offset(rowIndex) {
    return this.offsets[rowIndex];
  }
  totalHeight() {
    return this.heights.reduce((prev, curr) => prev + curr, 0);
  }
  updateRowHeight(rowIndex, value) {
    this.heights[rowIndex] += value;
    this.offsets = update(this.offsets, rowIndex, value);
  }
};
var normalize2 = (x) => Math.max(x, 0);
var ScrollAction = class {
  offset;
  constructor(offset3) {
    this.offset = offset3;
  }
};
var PageAction = class {
  skip;
  constructor(skip3) {
    this.skip = skip3;
  }
};
var ScrollerService = class {
  scrollObservable;
  direction;
  firstLoaded = 0;
  lastLoaded;
  lastScroll;
  take;
  total;
  rowHeightService;
  scrollSubscription;
  subscription;
  bottomOffset = 0;
  topOffset = 0;
  constructor(scrollObservable) {
    this.scrollObservable = scrollObservable;
  }
  create(rowHeightService, skip3, take2, total, topOffset = 0, bottomOffset = 0, direction = "vertical") {
    this.rowHeightService = rowHeightService;
    this.firstLoaded = skip3;
    this.lastLoaded = skip3 + take2;
    this.take = take2;
    this.total = total;
    this.lastScroll = 0;
    this.topOffset = topOffset;
    this.bottomOffset = bottomOffset;
    this.direction = direction;
    const subject = new ReplaySubject(2);
    const offsetBufferRows = this.rowsForHeight(topOffset);
    const skipWithOffset = normalize2(skip3 - offsetBufferRows);
    subject.next(new ScrollAction(this.rowOffset(skipWithOffset)));
    if (offsetBufferRows) {
      subject.next(new PageAction(skipWithOffset));
    }
    this.subscription = new Observable((observer) => {
      this.unsubscribe();
      this.scrollSubscription = this.scrollObservable.subscribe((x) => this.onScroll(x, observer));
    }).subscribe((x) => subject.next(x));
    return subject;
  }
  destroy() {
    this.unsubscribe();
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  onScroll({
    scrollLeft,
    scrollTop,
    offsetHeight,
    offsetWidth: offsetWidth2
  }, observer) {
    const scrollPosition = this.direction === "vertical" ? scrollTop : scrollLeft;
    const offsetSize = this.direction === "vertical" ? offsetHeight : offsetWidth2;
    if (this.lastScroll === scrollPosition) {
      return;
    }
    const up = this.lastScroll >= scrollPosition;
    this.lastScroll = scrollPosition;
    const firstItemIndex = this.rowHeightService.index(normalize2(scrollPosition - this.topOffset));
    const lastItemIndex = this.rowHeightService.index(normalize2(scrollPosition + offsetSize - this.bottomOffset));
    if (!up && lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
      this.firstLoaded = firstItemIndex;
      observer.next(new ScrollAction(this.rowOffset(firstItemIndex)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction(this.firstLoaded));
    }
    if (up && firstItemIndex <= this.firstLoaded) {
      const nonVisibleBuffer = Math.floor(this.take * 0.3);
      this.firstLoaded = normalize2(firstItemIndex - nonVisibleBuffer);
      observer.next(new ScrollAction(this.rowOffset(this.firstLoaded)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction(this.firstLoaded));
    }
  }
  rowOffset(index) {
    return this.rowHeightService.offset(index) + this.topOffset;
  }
  rowsForHeight(height2) {
    return Math.ceil(height2 / this.rowHeightService.height(0));
  }
  unsubscribe() {
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
      this.scrollSubscription = null;
    }
  }
};
var SCROLLER_FACTORY_TOKEN = new InjectionToken("dateinputs-scroll-service-factory");
function DEFAULT_SCROLLER_FACTORY(observable) {
  return new ScrollerService(observable);
}
var ScrollDirection;
(function(ScrollDirection2) {
  ScrollDirection2[ScrollDirection2["Backward"] = 0] = "Backward";
  ScrollDirection2[ScrollDirection2["Forward"] = 1] = "Forward";
})(ScrollDirection || (ScrollDirection = {}));
var FRAME_DURATION = 17;
var scrollModifiers = {
  [ScrollDirection.Forward]: (step) => (value) => value + step,
  [ScrollDirection.Backward]: (step) => (value) => value - step
};
var scrollNormalizers = {
  [ScrollDirection.Forward]: (end2) => (value) => Math.min(value, end2),
  [ScrollDirection.Backward]: (end2) => (value) => Math.max(value, end2)
};
var scrollValidators = {
  [ScrollDirection.Forward]: (end2) => (start) => start < end2,
  [ScrollDirection.Backward]: (end2) => (start) => start > end2
};
var differenceToScroll = (scrollTop, staticOffset, maxScrollDifference) => {
  return Math.min(Math.abs(staticOffset - scrollTop), maxScrollDifference);
};
var VirtualizationComponent = class _VirtualizationComponent {
  container;
  renderer;
  zone;
  scrollBarWidthService;
  direction = "vertical";
  itemHeight = 1;
  itemWidth = 1;
  topOffset = 0;
  bottomOffset = 0;
  maxScrollDifference = 100;
  scrollOffsetSize = 0;
  scrollDuration = 150;
  skip;
  take;
  total;
  activeIndexChange = new EventEmitter();
  pageChange = new EventEmitter();
  scrollChange = new EventEmitter();
  wrapperClasses = true;
  get horizontalClass() {
    return this.direction === "horizontal";
  }
  totalSize;
  get totalVertexLength() {
    const value = `${this.totalSize}px`;
    return this.direction === "vertical" ? {
      height: value
    } : {
      width: value
    };
  }
  get containerOffsetSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "offsetHeight" : "offsetWidth");
  }
  get containerScrollSize() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollHeight" : "scrollWidth");
  }
  get containerScrollPosition() {
    return this.getContainerProperty(this.direction === "vertical" ? "scrollTop" : "scrollLeft");
  }
  lastActiveIndex;
  resolvedPromise = Promise.resolve(null);
  scroller;
  rowHeightService;
  dispatcher = new Subject();
  scrollSubscription;
  containerScrollSubscription;
  animationSubscription;
  constructor(scrollerFactory, container, renderer, zone, scrollBarWidthService) {
    this.container = container;
    this.renderer = renderer;
    this.zone = zone;
    this.scrollBarWidthService = scrollBarWidthService;
    this.scroller = scrollerFactory(this.dispatcher);
  }
  ngOnChanges(changes) {
    if (changes.direction || changes.take || changes.total) {
      this.initServices();
      this.totalSize = this.rowHeightService.totalHeight() + this.bottomOffset;
    }
  }
  ngOnInit() {
    if (!this.rowHeightService) {
      this.rowHeightService = this.createRowHeightService();
    }
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => {
      this.containerScrollSubscription = this.scroll$().pipe(map((event2) => event2.target)).subscribe((t) => {
        this.dispatcher.next(t);
        this.emitActiveIndex();
      });
    });
  }
  ngOnDestroy() {
    if (this.containerScrollSubscription) {
      this.containerScrollSubscription.unsubscribe();
    }
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
    if (this.animationSubscription) {
      this.animationSubscription.unsubscribe();
    }
  }
  getContainerProperty(propertyName) {
    return this.container.nativeElement[propertyName];
  }
  activeIndex() {
    return this.itemIndex(Math.ceil(this.containerScrollPosition));
  }
  itemIndex(offset3) {
    return this.rowHeightService.index(offset3);
  }
  itemOffset(index) {
    return this.rowHeightService.offset(index);
  }
  isIndexVisible(index) {
    if (!this.rowHeightService) {
      return false;
    }
    const containerTop = this.containerScrollPosition;
    const containerBottom = containerTop + this.containerOffsetSize;
    const top = this.rowHeightService.offset(index);
    const bottom = top + this.rowHeightService.height(index);
    return top >= containerTop && bottom <= containerBottom;
  }
  isListScrolled(index) {
    return this.containerScrollPosition !== this.rowHeightService.offset(index);
  }
  scrollTo(value) {
    const scrollProperty = this.direction === "vertical" ? "scrollTop" : "scrollLeft";
    this.renderer.setProperty(this.container.nativeElement, scrollProperty, value);
  }
  scrollToIndex(index) {
    this.zone.runOutsideAngular(() => {
      this.resolvedPromise.then(() => {
        this.scrollTo(this.rowHeightService.offset(index));
      });
    });
  }
  scrollToBottom() {
    this.scrollTo(this.totalSize);
  }
  animateToIndex(index) {
    if (this.animationSubscription) {
      this.animationSubscription.unsubscribe();
    }
    const indexOffset = this.rowHeightService.offset(index);
    const direction = this.getContainerScrollDirection(indexOffset);
    const {
      start,
      end: end2
    } = this.scrollRange(indexOffset, direction);
    if (start === end2) {
      return;
    }
    const step = this.scrollStep(start, end2);
    const modifyScroll = scrollModifiers[direction](step);
    const normalizeScroll = scrollNormalizers[direction](end2);
    const isScrollValid = scrollValidators[direction](modifyScroll(end2));
    this.zone.runOutsideAngular(() => {
      this.animationSubscription = combineLatest(of(start), interval(0, animationFrameScheduler)).pipe(map((stream) => stream[0]), scan(modifyScroll), takeWhile(isScrollValid), map(normalizeScroll)).subscribe((x) => this.scrollTo(x));
    });
  }
  scrollRange(indexOffset, direction) {
    const containerScroll = this.containerScrollPosition;
    if (parseInt(indexOffset, 10) === parseInt(containerScroll, 10)) {
      return {
        start: indexOffset,
        end: indexOffset
      };
    }
    const maxScroll = this.containerMaxScroll();
    const sign = direction === ScrollDirection.Backward ? 1 : -1;
    const difference = differenceToScroll(containerScroll, indexOffset, this.maxScrollDifference);
    const end2 = Math.min(indexOffset, maxScroll);
    const start = Math.min(Math.max(end2 + sign * difference, 0), maxScroll);
    return {
      start,
      end: end2
    };
  }
  scrollStep(start, end2) {
    return Math.abs(end2 - start) / (this.scrollDuration / FRAME_DURATION);
  }
  scroll$() {
    return isDocumentAvailable() ? fromEvent(this.container.nativeElement, "scroll") : EMPTY;
  }
  initServices() {
    this.rowHeightService = this.createRowHeightService();
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
    this.scrollSubscription = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total, this.topOffset, this.scrollOffsetSize, this.direction).subscribe((x) => {
      if (x instanceof PageAction) {
        this.pageChange.emit(x);
      } else {
        this.scrollChange.emit(x);
      }
    });
  }
  createRowHeightService() {
    const dimension = this.direction === "vertical" ? this.itemHeight : this.itemWidth;
    return new RowHeightService(this.total, dimension, 0);
  }
  emitActiveIndex() {
    const index = this.rowHeightService.index(this.containerScrollPosition - this.topOffset);
    if (this.lastActiveIndex !== index) {
      this.lastActiveIndex = index;
      this.activeIndexChange.emit(index);
    }
  }
  containerMaxScroll() {
    return this.containerScrollSize - this.containerOffsetSize;
  }
  getContainerScrollDirection(indexOffset) {
    return indexOffset < this.containerScrollPosition ? ScrollDirection.Backward : ScrollDirection.Forward;
  }
  static ɵfac = function VirtualizationComponent_Factory(t) {
    return new (t || _VirtualizationComponent)(ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ScrollbarWidthService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _VirtualizationComponent,
    selectors: [["kendo-virtualization"]],
    hostVars: 8,
    hostBindings: function VirtualizationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-flex", ctx.wrapperClasses)("k-content", ctx.wrapperClasses)("k-scrollable", ctx.wrapperClasses)("k-scrollable-horizontal", ctx.horizontalClass);
      }
    },
    inputs: {
      direction: "direction",
      itemHeight: "itemHeight",
      itemWidth: "itemWidth",
      topOffset: "topOffset",
      bottomOffset: "bottomOffset",
      maxScrollDifference: "maxScrollDifference",
      scrollOffsetSize: "scrollOffsetSize",
      scrollDuration: "scrollDuration",
      skip: "skip",
      take: "take",
      total: "total"
    },
    outputs: {
      activeIndexChange: "activeIndexChange",
      pageChange: "pageChange",
      scrollChange: "scrollChange"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: SCROLLER_FACTORY_TOKEN,
      useValue: DEFAULT_SCROLLER_FACTORY
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    ngContentSelectors: _c8,
    decls: 2,
    vars: 3,
    consts: [[1, "k-scrollable-placeholder", 3, "ngStyle"]],
    template: function VirtualizationComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵelement(1, "div", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-scrollable-horizontal-placeholder", ctx.direction === "horizontal");
        ɵɵproperty("ngStyle", ctx.totalVertexLength);
      }
    },
    dependencies: [NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VirtualizationComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SCROLLER_FACTORY_TOKEN,
        useValue: DEFAULT_SCROLLER_FACTORY
      }],
      selector: "kendo-virtualization",
      template: `
    <ng-content></ng-content>
    <div
        class="k-scrollable-placeholder"
        [class.k-scrollable-horizontal-placeholder]="direction === 'horizontal'"
        [ngStyle]="totalVertexLength"
    ></div>
  `,
      standalone: true,
      imports: [NgStyle]
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [SCROLLER_FACTORY_TOKEN]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ScrollbarWidthService
    }];
  }, {
    direction: [{
      type: Input
    }],
    itemHeight: [{
      type: Input
    }],
    itemWidth: [{
      type: Input
    }],
    topOffset: [{
      type: Input
    }],
    bottomOffset: [{
      type: Input
    }],
    maxScrollDifference: [{
      type: Input
    }],
    scrollOffsetSize: [{
      type: Input
    }],
    scrollDuration: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    take: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    activeIndexChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    scrollChange: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-flex"]
    }, {
      type: HostBinding,
      args: ["class.k-content"]
    }, {
      type: HostBinding,
      args: ["class.k-scrollable"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-scrollable-horizontal"]
    }]
  });
})();
var ITEMS_COUNT = 30;
var NavigationComponent = class _NavigationComponent {
  bus;
  dom;
  intl;
  cdr;
  renderer;
  activeView;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  focusedDate = /* @__PURE__ */ new Date();
  templateRef;
  valueChange = new EventEmitter();
  pageChange = new EventEmitter();
  virtualization;
  list;
  get getComponentClass() {
    return true;
  }
  activeViewValue;
  service;
  dates = [];
  style;
  take = ITEMS_COUNT;
  skip;
  total;
  itemHeight;
  topOffset;
  bottomOffset;
  maxViewHeight;
  indexToScroll = -1;
  intlSubscription;
  constructor(bus, dom, intl, cdr, renderer) {
    this.bus = bus;
    this.dom = dom;
    this.intl = intl;
    this.cdr = cdr;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.dom.ensureHeights();
    const calendarHeight = this.dom.calendarHeight;
    this.itemHeight = this.dom.navigationItemHeight;
    this.maxViewHeight = this.dom.monthViewHeight;
    this.topOffset = (calendarHeight - this.itemHeight) / 2;
    this.bottomOffset = calendarHeight - this.itemHeight;
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.activeViewValue = CalendarViewEnum[this.activeView];
    const viewDate = dateInRange(this.focusedDate, this.min, this.max);
    const total = this.service.total(this.min, this.max);
    const totalChanged = this.total && this.total !== total;
    this.skip = this.service.skip(viewDate, this.min);
    this.total = total;
    if (totalChanged || !this.service.isInArray(viewDate, this.dates)) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
    }
    if (!!changes.focusedDate || totalChanged) {
      this.indexToScroll = this.service.skip(this.focusedDate, this.min);
    }
  }
  ngOnDestroy() {
    if (this.intlSubscription) {
      this.intlSubscription.unsubscribe();
    }
  }
  ngAfterViewInit() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  ngAfterViewChecked() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  onPageChange({
    skip: skip3
  }) {
    this.dates = this.service.datesList(this.service.addToDate(this.min, skip3), this.getTake(skip3));
    this.pageChange.emit();
  }
  scrollChange({
    offset: offset3
  }) {
    const el = this.list.nativeElement;
    const translate = `translateY(${offset3}px)`;
    this.renderer.setStyle(el, "transform", translate);
    this.renderer.setStyle(el, "-ms-transform", translate);
  }
  handleDateChange(args) {
    const item = closestInScope(args.target, (node) => node.hasAttribute("data-date-index"), this.list.nativeElement);
    if (item) {
      const index = parseInt(item.getAttribute("data-date-index"), 10);
      const candidate = this.dates[index];
      this.valueChange.emit(cloneDate(candidate));
    }
  }
  getTake(skip3) {
    return Math.min(this.total - skip3, this.take);
  }
  intlChange() {
    if (this.activeView === CalendarViewEnum.month) {
      this.cdr.markForCheck();
    }
  }
  static ɵfac = function NavigationComponent_Factory(t) {
    return new (t || _NavigationComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NavigationComponent,
    selectors: [["kendo-calendar-navigation"]],
    viewQuery: function NavigationComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 5);
        ɵɵviewQuery(_c9, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function NavigationComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-calendar-navigation", ctx.getComponentClass);
      }
    },
    inputs: {
      activeView: "activeView",
      min: "min",
      max: "max",
      focusedDate: "focusedDate",
      templateRef: "templateRef"
    },
    outputs: {
      valueChange: "valueChange",
      pageChange: "pageChange"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 5,
    vars: 12,
    consts: [["list", ""], [1, "k-calendar-navigation-highlight"], [3, "pageChange", "scrollChange", "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "maxScrollDifference"], [1, "k-reset", 3, "kendoEventsOutsideAngular", "scope"], [4, "kFor", "kForOf"], [3, "ngIf"], [3, "ngIf", "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function NavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelement(0, "span", 1);
        ɵɵelementStart(1, "kendo-virtualization", 2);
        ɵɵlistener("pageChange", function NavigationComponent_Template_kendo_virtualization_pageChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPageChange($event));
        })("scrollChange", function NavigationComponent_Template_kendo_virtualization_scrollChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.scrollChange($event));
        });
        ɵɵelementStart(2, "ul", 3, 0);
        ɵɵtemplate(4, NavigationComponent_li_4_Template, 4, 11, "li", 4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.itemHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset)("maxScrollDifference", ctx.maxViewHeight);
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(10, _c52, ctx.handleDateChange))("scope", ctx);
        ɵɵadvance(2);
        ɵɵproperty("kForOf", ctx.dates);
      }
    },
    dependencies: [VirtualizationComponent, EventsOutsideAngularDirective, KForOf, NgIf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-navigation",
      template: `
    <span class="k-calendar-navigation-highlight"></span>
    <kendo-virtualization
        [skip]="skip"
        [take]="take"
        [total]="total"
        [itemHeight]="itemHeight"
        [topOffset]="topOffset"
        [bottomOffset]="bottomOffset"
        [maxScrollDifference]="maxViewHeight"
        (pageChange)="onPageChange($event)"
        (scrollChange)="scrollChange($event)"
    >
        <ul #list class="k-reset" [kendoEventsOutsideAngular]="{ click: handleDateChange }" [scope]="this">
            <li *kFor="let date of dates; let index=index" [attr.data-date-index]="index">
                <span [class.k-calendar-navigation-marker]="service.isRangeStart(date)">
                    <ng-template [ngIf]="!templateRef">{{service.navigationTitle(date)}}</ng-template>
                    <ng-template
                        [ngIf]="templateRef"
                        [ngTemplateOutlet]="templateRef"
                        [ngTemplateOutletContext]="{ $implicit: service.navigationTitle(date), activeView: activeViewValue, date: date }"
                    ></ng-template>
                </span>
            </li>
        </ul>
    </kendo-virtualization>
  `,
      standalone: true,
      imports: [VirtualizationComponent, EventsOutsideAngularDirective, KForOf, NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: CalendarDOMService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    activeView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    templateRef: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: false
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-calendar-navigation"]
    }]
  });
})();
var VIEWS_COUNT = 5;
var isEqualMonthYear = (date1, date2) => date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth();
var ViewListComponent = class _ViewListComponent {
  bus;
  cdr;
  intl;
  dom;
  renderer;
  allowReverse;
  cellTemplateRef;
  weekNumberTemplateRef;
  headerTitleTemplateRef;
  headerTemplateRef;
  footerTemplateRef;
  showOtherMonthDays;
  activeView;
  cellUID;
  focusedDate;
  isActive = true;
  min = new Date(MIN_DATE);
  max = new Date(MAX_DATE);
  selectedDates = [];
  tabIndex = 0;
  disabled = false;
  id;
  showFooter = false;
  weekDaysFormat = "short";
  activeRangeEnd;
  selectionRange;
  size;
  get weekNumber() {
    return this.showWeekNumbers && this.isMonthView();
  }
  set weekNumber(showWeekNumbers) {
    this.showWeekNumbers = showWeekNumbers;
  }
  cellEnter = new EventEmitter();
  cellClick = new EventEmitter();
  weekNumberCellClick = new EventEmitter();
  activeDateChange = new EventEmitter();
  todayButtonClick = new EventEmitter();
  pageChange = new EventEmitter();
  focusCalendar = new EventEmitter();
  blurCalendar = new EventEmitter();
  focusedCellChange = new EventEmitter();
  virtualization;
  headerComponent;
  get headerTitle() {
    return this.headerComponent?.title;
  }
  list;
  getComponentClass = true;
  get getComponentMonthClass() {
    return this.activeView === CalendarViewEnum.month;
  }
  get getComponentYearClass() {
    return this.activeView === CalendarViewEnum.year;
  }
  get getComponentDecadeClass() {
    return this.activeView === CalendarViewEnum.decade;
  }
  get getComponentCenturyClass() {
    return this.activeView === CalendarViewEnum.century;
  }
  get activeViewValue() {
    return CalendarViewEnum[this.activeView];
  }
  service;
  activeDate;
  dates = [];
  cols = [];
  weekNames = [];
  wideWeekNames = [];
  take = VIEWS_COUNT;
  skip;
  total;
  bottomOffset;
  viewHeight;
  viewOffset;
  animateToIndex = true;
  indexToScroll = -1;
  showWeekNumbers;
  minViewsToRender = 1;
  intlSubscription;
  constructor(bus, cdr, intl, dom, renderer) {
    this.bus = bus;
    this.cdr = cdr;
    this.intl = intl;
    this.dom = dom;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    this.bottomOffset = this.getBottomOffset();
    this.viewOffset = -1 * this.dom.headerHeight;
    this.viewHeight = this.dom.viewHeight(this.activeView);
    this.intlSubscription = this.intl.changes.subscribe(this.intlChange.bind(this));
  }
  ngOnChanges(changes) {
    this.service = this.bus.service(this.activeView);
    if (!this.service) {
      return;
    }
    this.cols = new Array(this.service.rowLength({
      prependCell: this.weekNumber
    })).fill("");
    this.weekNames = hasChange(changes, "weekNumber") && this.weekNumber ? this.getWeekNames(this.weekDaysFormat) : this.weekNames;
    if (hasChange(changes, "weekDaysFormat") && !hasChange(changes, "weekNumber")) {
      this.weekNames = this.getWeekNames(this.weekDaysFormat);
    }
    this.wideWeekNames = hasChange(changes, "weekNumber") && this.weekNumber ? this.getWeekNames("wide") : this.weekNames;
    const activeViewChanged = hasChange(changes, "activeView");
    const focusedDate = this.focusedDate;
    const viewDate = dateInRange(this.service.viewDate(focusedDate, this.max, this.minViewsToRender), this.min, this.max);
    const total = this.service.total(this.min, this.max);
    const totalChanged = this.total && this.total !== total;
    const generateDates = totalChanged || !this.service.isInArray(focusedDate, this.dates);
    this.skip = this.service.skip(viewDate, this.min);
    this.total = total;
    this.animateToIndex = !activeViewChanged;
    this.bottomOffset = this.getBottomOffset();
    this.viewHeight = this.dom.viewHeight(this.activeView);
    if (generateDates) {
      this.dates = this.service.datesList(viewDate, this.getTake(this.skip));
    }
    if (!isEqualMonthYear(this.activeDate, focusedDate)) {
      this.activeDate = cloneDate(focusedDate);
    }
    const updateIndex = hasChange(changes, "focusedDate") || activeViewChanged;
    if (generateDates || updateIndex || this.virtualization.isIndexVisible(this.skip)) {
      this.indexToScroll = this.service.skip(focusedDate, this.min);
    }
  }
  ngOnDestroy() {
    if (this.intlSubscription) {
      this.intlSubscription.unsubscribe();
    }
  }
  ngAfterViewInit() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization.scrollToIndex(this.indexToScroll);
    this.indexToScroll = -1;
  }
  ngAfterViewChecked() {
    if (this.indexToScroll === -1) {
      return;
    }
    this.virtualization[this.animateToIndex ? "animateToIndex" : "scrollToIndex"](this.indexToScroll);
    this.animateToIndex = true;
    this.indexToScroll = -1;
  }
  onPageChange({
    skip: skip3
  }) {
    this.dates = this.service.datesList(this.service.addToDate(this.min, skip3), this.getTake(skip3));
    this.pageChange.emit();
  }
  scrollChange({
    offset: offset3
  }) {
    const el = this.list.nativeElement;
    const translate = `translateY(${offset3}px)`;
    this.renderer.setStyle(el, "transform", translate);
    this.renderer.setStyle(el, "-ms-transform", translate);
  }
  setActiveDate(index) {
    const candidate = this.service.addToDate(this.min, index);
    this.activeDate = candidate;
    this.activeDateChange.emit(candidate);
    this.cdr.detectChanges();
  }
  isMonthView() {
    return this.activeView === CalendarViewEnum.month;
  }
  isScrolled() {
    return this.virtualization.isListScrolled(this.service.skip(this.focusedDate, this.min));
  }
  getTabIndex() {
    return this.disabled ? null : this.tabIndex;
  }
  getBottomOffset() {
    return this.getScrollableHeight() - this.dom.viewHeight(this.activeView);
  }
  getScrollableHeight() {
    return this.activeView === CalendarViewEnum.month ? this.dom.scrollableContentHeight : this.dom.scrollableYearContentHeight;
  }
  getTake(skip3) {
    return Math.min(this.total - skip3, this.take);
  }
  getWeekNames(nameType) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType,
      type: "days"
    }), this.intl.firstDay());
    return this.weekNumber ? [""].concat(weekNames) : weekNames;
  }
  intlChange() {
    this.weekNames = this.getWeekNames(this.weekDaysFormat);
    this.wideWeekNames = this.getWeekNames("wide");
    if (this.isMonthView()) {
      this.cdr.markForCheck();
    }
  }
  static ɵfac = function ViewListComponent_Factory(t) {
    return new (t || _ViewListComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ViewListComponent,
    selectors: [["kendo-calendar-viewlist"]],
    viewQuery: function ViewListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 5);
        ɵɵviewQuery(HeaderComponent, 5);
        ɵɵviewQuery(_c9, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
      }
    },
    hostVars: 12,
    hostBindings: function ViewListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-vstack", ctx.getComponentClass)("k-calendar-view", ctx.getComponentClass)("k-calendar-monthview", ctx.getComponentMonthClass)("k-calendar-yearview", ctx.getComponentYearClass)("k-calendar-decadeview", ctx.getComponentDecadeClass)("k-calendar-centuryview", ctx.getComponentCenturyClass);
      }
    },
    inputs: {
      allowReverse: "allowReverse",
      cellTemplateRef: "cellTemplateRef",
      weekNumberTemplateRef: "weekNumberTemplateRef",
      headerTitleTemplateRef: "headerTitleTemplateRef",
      headerTemplateRef: "headerTemplateRef",
      footerTemplateRef: "footerTemplateRef",
      showOtherMonthDays: "showOtherMonthDays",
      activeView: "activeView",
      cellUID: "cellUID",
      focusedDate: "focusedDate",
      isActive: "isActive",
      min: "min",
      max: "max",
      selectedDates: "selectedDates",
      tabIndex: "tabIndex",
      disabled: "disabled",
      id: "id",
      showFooter: "showFooter",
      weekDaysFormat: "weekDaysFormat",
      activeRangeEnd: "activeRangeEnd",
      selectionRange: "selectionRange",
      size: "size",
      weekNumber: "weekNumber"
    },
    outputs: {
      cellEnter: "cellEnter",
      cellClick: "cellClick",
      weekNumberCellClick: "weekNumberCellClick",
      activeDateChange: "activeDateChange",
      todayButtonClick: "todayButtonClick",
      pageChange: "pageChange",
      focusCalendar: "focusCalendar",
      blurCalendar: "blurCalendar",
      focusedCellChange: "focusedCellChange"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 9,
    vars: 23,
    consts: [["list", ""], [3, "todayButtonClick", "currentDate", "size", "min", "max", "id", "activeView", "titleTemplateRef", "headerTemplateRef"], ["class", "k-calendar-weekdays k-calendar-table", 3, "table-layout", 4, "ngIf"], [3, "pageChange", "scrollChange", "activeIndexChange", "tabindex", "skip", "take", "total", "itemHeight", "topOffset", "bottomOffset", "scrollOffsetSize", "maxScrollDifference"], ["role", "grid", 1, "k-calendar-table", 3, "focus", "blur"], [4, "ngFor", "ngForOf"], ["class", "k-calendar-tbody", "kendoCalendarView", "", "role", "rowgroup", 3, "allowReverse", "activeRangeEnd", "selectionRange", "showOtherMonthDays", "headerTitle", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate", "cellClick", "weekNumberCellClick", "focusedCellId", "cellEnter", 4, "kFor", "kForOf"], [3, "footerTemplateRef", "activeViewValue", "currentDate", 4, "ngIf"], [1, "k-calendar-weekdays", "k-calendar-table"], [1, "k-calendar-thead"], [1, "k-calendar-tr"], ["class", "k-calendar-th", "scope", "col", "role", "columnheader", 4, "ngFor", "ngForOf"], ["scope", "col", "role", "columnheader", 1, "k-calendar-th"], ["kendoCalendarView", "", "role", "rowgroup", 1, "k-calendar-tbody", 3, "cellClick", "weekNumberCellClick", "focusedCellId", "cellEnter", "allowReverse", "activeRangeEnd", "selectionRange", "showOtherMonthDays", "headerTitle", "activeView", "isActive", "min", "max", "cellUID", "focusedDate", "selectedDates", "weekNumber", "templateRef", "weekNumberTemplateRef", "viewDate"], [3, "footerTemplateRef", "activeViewValue", "currentDate"]],
    template: function ViewListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-calendar-header", 1);
        ɵɵlistener("todayButtonClick", function ViewListComponent_Template_kendo_calendar_header_todayButtonClick_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.todayButtonClick.emit($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(1, ViewListComponent_table_1_Template, 4, 3, "table", 2);
        ɵɵelementStart(2, "kendo-virtualization", 3);
        ɵɵlistener("pageChange", function ViewListComponent_Template_kendo_virtualization_pageChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPageChange($event));
        })("scrollChange", function ViewListComponent_Template_kendo_virtualization_scrollChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.scrollChange($event));
        })("activeIndexChange", function ViewListComponent_Template_kendo_virtualization_activeIndexChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.setActiveDate($event));
        });
        ɵɵelementStart(3, "table", 4, 0);
        ɵɵlistener("focus", function ViewListComponent_Template_table_focus_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.focusCalendar.emit());
        })("blur", function ViewListComponent_Template_table_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.blurCalendar.emit($event));
        });
        ɵɵelementStart(5, "colgroup");
        ɵɵtemplate(6, ViewListComponent_col_6_Template, 1, 0, "col", 5);
        ɵɵelementEnd();
        ɵɵtemplate(7, ViewListComponent_tbody_7_Template, 1, 16, "tbody", 6);
        ɵɵelementEnd()();
        ɵɵtemplate(8, ViewListComponent_kendo_calendar_footer_8_Template, 1, 3, "kendo-calendar-footer", 7);
      }
      if (rf & 2) {
        ɵɵproperty("currentDate", ctx.activeDate)("size", ctx.size)("min", ctx.min)("max", ctx.max)("id", ctx.id)("activeView", ctx.activeView)("titleTemplateRef", ctx.headerTitleTemplateRef)("headerTemplateRef", ctx.headerTemplateRef);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isMonthView());
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("skip", ctx.skip)("take", ctx.take)("total", ctx.total)("itemHeight", ctx.viewHeight)("topOffset", ctx.viewOffset)("bottomOffset", ctx.bottomOffset)("scrollOffsetSize", ctx.viewOffset)("maxScrollDifference", ctx.viewHeight);
        ɵɵadvance();
        ɵɵattribute("tabindex", ctx.getTabIndex())("aria-labelledby", ctx.id);
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.cols);
        ɵɵadvance();
        ɵɵproperty("kForOf", ctx.dates);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showFooter);
      }
    },
    dependencies: [HeaderComponent, NgIf, NgForOf, VirtualizationComponent, KForOf, ViewComponent, FooterComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewListComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-calendar-viewlist",
      template: `
    <kendo-calendar-header
        [currentDate]="activeDate"
        [size]="size"
        [min]="min"
        [max]="max"
        [id]="id"
        [activeView]="activeView"
        [titleTemplateRef]="headerTitleTemplateRef"
        [headerTemplateRef]="headerTemplateRef"
        (todayButtonClick)="todayButtonClick.emit($event)"
    >
    </kendo-calendar-header>
    <table class="k-calendar-weekdays k-calendar-table" [style.table-layout]="'auto'" *ngIf="isMonthView()">
        <thead class="k-calendar-thead">
            <tr class="k-calendar-tr">
                <th class="k-calendar-th" *ngFor="let name of weekNames; let i = index;" scope="col" [attr.aria-label]="wideWeekNames[i]" role="columnheader">{{name}}</th>
            </tr>
        </thead>
    </table>
    <kendo-virtualization
        [tabindex]="-1"
        [skip]="skip"
        [take]="take"
        [total]="total"
        [itemHeight]="viewHeight"
        [topOffset]="viewOffset"
        [bottomOffset]="bottomOffset"
        [scrollOffsetSize]="viewOffset"
        [maxScrollDifference]="viewHeight"
        (pageChange)="onPageChange($event)"
        (scrollChange)="scrollChange($event)"
        (activeIndexChange)="setActiveDate($event)"
        >
        <table
            #list
            role="grid"
            class="k-calendar-table"
            [attr.tabindex]="getTabIndex()"
            [attr.aria-labelledby]="id"
            (focus)="focusCalendar.emit()"
            (blur)="blurCalendar.emit($event)"
        >
            <colgroup><col *ngFor="let _ of cols" /></colgroup>

            <tbody class="k-calendar-tbody"
                   *kFor="let date of dates"
                   kendoCalendarView
                   [allowReverse]="allowReverse"
                   [activeRangeEnd]="activeRangeEnd"
                   [selectionRange]="selectionRange"
                   [showOtherMonthDays]="showOtherMonthDays"
                   [headerTitle]="headerTitle"
                   role="rowgroup"
                   [activeView]="activeView"
                   [isActive]="isActive"
                   [min]="min" [max]="max"
                   [cellUID]="cellUID"
                   [focusedDate]="focusedDate"
                   [selectedDates]="selectedDates"
                   [weekNumber]="weekNumber"
                   [templateRef]="cellTemplateRef"
                   [weekNumberTemplateRef]="weekNumberTemplateRef"
                   [viewDate]="date"
                   (cellClick)="cellClick.emit($event)"
                   (weekNumberCellClick)="weekNumberCellClick.emit($event)"
                   (focusedCellId)="focusedCellChange.emit($event)"
                   (cellEnter)="cellEnter.emit($event)"
            ></tbody>
        </table>
    </kendo-virtualization>
    <kendo-calendar-footer
        *ngIf="showFooter"
        [footerTemplateRef]="footerTemplateRef"
        [activeViewValue]="activeViewValue"
        [currentDate]="activeDate">
    </kendo-calendar-footer>
  `,
      standalone: true,
      imports: [HeaderComponent, NgIf, NgForOf, VirtualizationComponent, KForOf, ViewComponent, FooterComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: ChangeDetectorRef
    }, {
      type: IntlService
    }, {
      type: CalendarDOMService
    }, {
      type: Renderer2
    }];
  }, {
    allowReverse: [{
      type: Input
    }],
    cellTemplateRef: [{
      type: Input
    }],
    weekNumberTemplateRef: [{
      type: Input
    }],
    headerTitleTemplateRef: [{
      type: Input
    }],
    headerTemplateRef: [{
      type: Input
    }],
    footerTemplateRef: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    cellUID: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    cellEnter: [{
      type: Output
    }],
    cellClick: [{
      type: Output
    }],
    weekNumberCellClick: [{
      type: Output
    }],
    activeDateChange: [{
      type: Output
    }],
    todayButtonClick: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    focusCalendar: [{
      type: Output
    }],
    blurCalendar: [{
      type: Output
    }],
    focusedCellChange: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: false
      }]
    }],
    headerComponent: [{
      type: ViewChild,
      args: [HeaderComponent, {
        static: false
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    getComponentClass: [{
      type: HostBinding,
      args: ["class.k-vstack"]
    }, {
      type: HostBinding,
      args: ["class.k-calendar-view"]
    }],
    getComponentMonthClass: [{
      type: HostBinding,
      args: ["class.k-calendar-monthview"]
    }],
    getComponentYearClass: [{
      type: HostBinding,
      args: ["class.k-calendar-yearview"]
    }],
    getComponentDecadeClass: [{
      type: HostBinding,
      args: ["class.k-calendar-decadeview"]
    }],
    getComponentCenturyClass: [{
      type: HostBinding,
      args: ["class.k-calendar-centuryview"]
    }]
  });
})();
var divideByMagnitude = (magnitude) => (x) => Math.floor(x / magnitude);
var powerByMagnitude = (magnitude) => (x) => x * magnitude;
var ScrollSyncService = class _ScrollSyncService {
  dom;
  zone;
  divideByMagnitude;
  powerByMagnitude;
  navSubscription;
  viewSubscription;
  navigator;
  view;
  constructor(dom, zone) {
    this.dom = dom;
    this.zone = zone;
  }
  configure(activeView) {
    const magnitude = Math.max(this.dom.viewHeight(activeView) / this.dom.navigationItemHeight, 1);
    this.divideByMagnitude = divideByMagnitude(magnitude);
    this.powerByMagnitude = powerByMagnitude(magnitude);
  }
  sync(navigator2, view2) {
    this.unsubscribe();
    if (!navigator2 || !view2) {
      return;
    }
    this.navigator = navigator2;
    this.view = view2;
    this.zone.runOutsideAngular(() => {
      let navScrolled, monthScrolled;
      this.navSubscription = navigator2.scroll$().subscribe((e) => {
        if (monthScrolled) {
          monthScrolled = false;
          return;
        }
        navScrolled = true;
        this.scrollSiblingOf(e.target);
      });
      this.viewSubscription = view2.scroll$().subscribe((e) => {
        if (navScrolled) {
          navScrolled = false;
          return;
        }
        monthScrolled = true;
        this.scrollSiblingOf(e.target);
      });
    });
  }
  scrollSiblingOf(scrolledElement) {
    const component = this.siblingComponent(scrolledElement);
    const scrollTop = this.calculateScroll(component, scrolledElement.scrollTop);
    component.scrollTo(scrollTop);
  }
  siblingComponent(scrollableElement) {
    return this.navigator.container.nativeElement === scrollableElement ? this.view : this.navigator;
  }
  calculateScroll(component, scrollTop) {
    const modifier = component === this.navigator ? this.divideByMagnitude : this.powerByMagnitude;
    return modifier(scrollTop);
  }
  destroy() {
    this.unsubscribe();
  }
  unsubscribe() {
    if (this.navSubscription) {
      this.navSubscription.unsubscribe();
    }
    if (this.viewSubscription) {
      this.viewSubscription.unsubscribe();
    }
  }
  static ɵfac = function ScrollSyncService_Factory(t) {
    return new (t || _ScrollSyncService)(ɵɵinject(CalendarDOMService), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollSyncService,
    factory: _ScrollSyncService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollSyncService, [{
    type: Injectable
  }], function() {
    return [{
      type: CalendarDOMService
    }, {
      type: NgZone
    }];
  }, null);
})();
var NavigationItemTemplateDirective = class _NavigationItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NavigationItemTemplateDirective_Factory(t) {
    return new (t || _NavigationItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NavigationItemTemplateDirective,
    selectors: [["", "kendoCalendarNavigationItemTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoCalendarNavigationItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var PickerService = class {
  onFocus = new EventEmitter();
  onBlur = new EventEmitter();
  sameDateSelected = new EventEmitter();
  dateCompletenessChange = new EventEmitter();
  calendar;
  input;
  timeSelector;
};
var MultiViewCalendarCustomMessagesComponent = class _MultiViewCalendarCustomMessagesComponent extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function MultiViewCalendarCustomMessagesComponent_Factory(t) {
    return new (t || _MultiViewCalendarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiViewCalendarCustomMessagesComponent,
    selectors: [["kendo-multiviewcalendar-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _MultiViewCalendarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function MultiViewCalendarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => MultiViewCalendarCustomMessagesComponent)
      }],
      selector: "kendo-multiviewcalendar-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var CalendarMessages = class _CalendarMessages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCalendarMessages_BaseFactory;
    return function CalendarMessages_Factory(t) {
      return (ɵCalendarMessages_BaseFactory || (ɵCalendarMessages_BaseFactory = ɵɵgetInheritedFactory(_CalendarMessages)))(t || _CalendarMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CalendarMessages,
    selectors: [["kendo-calendar-messages-base"]],
    inputs: {
      today: "today",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-calendar-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }]
  });
})();
var CalendarLocalizedMessagesDirective = class _CalendarLocalizedMessagesDirective extends CalendarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function CalendarLocalizedMessagesDirective_Factory(t) {
    return new (t || _CalendarLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CalendarLocalizedMessagesDirective,
    selectors: [["", "kendoCalendarLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: CalendarMessages,
      useExisting: forwardRef(() => _CalendarLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: CalendarMessages,
        useExisting: forwardRef(() => CalendarLocalizedMessagesDirective)
      }],
      selector: "[kendoCalendarLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var BOTTOM_VIEW_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-bottomview";
var TOP_VIEW_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-topview";
var MIN_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-min";
var MAX_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/CalendarComponent/#toc-max";
var VALUE_DOC_LINK$4 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/calendar/#toc-using-with-json";
var virtualizationProp = (x) => x ? x.virtualization : null;
var CALENDAR_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CalendarComponent)
};
var CALENDAR_RANGE_VALIDATORS = {
  multi: true,
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CalendarComponent)
};
var KENDO_INPUT_PROVIDER = {
  provide: KendoInput,
  useExisting: forwardRef(() => CalendarComponent)
};
var CalendarComponent = class _CalendarComponent {
  bus;
  dom;
  element;
  navigator;
  renderer;
  cdr;
  ngZone;
  injector;
  scrollSyncService;
  disabledDatesService;
  localization;
  selectionService;
  pickerService;
  /**
   * Displays the days that fall out of the current month ([see example]({% slug viewoptions_calendar %}#toc-displaying-other-month-days)).
   * The default values per Calendar type are:
   * - `infinite` - false
   * - `classic` - true
   */
  set showOtherMonthDays(_showOtherMonthDays) {
    this._showOtherMonthDays = _showOtherMonthDays;
  }
  get showOtherMonthDays() {
    if (this._showOtherMonthDays === void 0) {
      return this.type === "classic";
    }
    return this._showOtherMonthDays;
  }
  _showOtherMonthDays;
  /**
   * @hidden
   */
  id;
  /**
   * @hidden
   */
  get popupId() {
    return `kendo-popup-${this.bus.calendarId}`;
  }
  /**
   * Sets or gets the `focusedDate` property of the Calendar and
   * defines the focused date of the component
   * ([see example]({% slug dates_calendar %}#toc-focused-dates)).
   *
   * > If the Calendar is out of the min or max range, it normalizes the defined `focusedDate`.
   */
  set focusedDate(focusedDate) {
    if (this.activeViewDate && !isEqual(this._focusedDate, focusedDate)) {
      const service = this.bus.service(this.activeViewEnum);
      const lastDayInPeriod = service.lastDayOfPeriod(this.activeViewDate);
      const isFocusedDateInRange = service.isInRange(focusedDate, this.activeViewDate, lastDayInPeriod);
      if (!isFocusedDateInRange) {
        this.emitNavigate(focusedDate);
      }
    }
    this._focusedDate = focusedDate || getToday();
    this.setAriaActivedescendant();
  }
  get focusedDate() {
    if (this._focusedDate > this.max) {
      return this.max;
    }
    if (this._focusedDate < this.min) {
      return this.min;
    }
    return this._focusedDate;
  }
  /**
   * @hidden
   */
  get headerId() {
    return this.id + "-header";
  }
  /**
   * Sets or gets the `min` property of the Calendar and
   * defines the minimum allowed date value
   * ([see example]({% slug dateranges_calendar %})).
   * By default, the `min` value is `1900-1-1`.
   */
  set min(min) {
    this._min = min || new Date(MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Sets or gets the `max` property of the Calendar and
   * defines the maximum allowed date value
   * ([see example]({% slug dateranges_calendar %})).
   * By default, the `max` value is `2099-12-31`.
   */
  set max(max) {
    this._max = max || new Date(MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form.
   *
   * @default false
   */
  rangeValidation = false;
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Toggles the visibility of the footer.
   * @default false
   */
  footer = false;
  /**
   * Sets the Calendar selection mode
   * ([see example]({% slug selection_calendar %})).
   *
   * The available values are:
   * * `single` (default)
   * * `multiple`
   * * `range`
   */
  set selection(_selection) {
    this._selection = _selection;
    this.selectionSetter = true;
  }
  get selection() {
    return this._selection;
  }
  _selection = "single";
  /**
   * Allows reverse selection when using `range` selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Sets or gets the `value` property of the Calendar and defines the selected value of the component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance when in `single` selection mode, an array of valid JavaScript Date instances when in `multiple` selection mode, or an object of type `SelectionRange` when in `range` selection mode.
   */
  set value(candidate) {
    this.valueSetter = true;
    this._value = candidate;
  }
  get value() {
    return this._value;
  }
  /**
   * Sets or gets the `disabled` property of the Calendar and
   * determines whether the component is active
   * ([see example]({% slug disabled_calendar %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_calendar#toc-managing-the-calendar-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets or gets the `tabindex` property of the Calendar. Based on the
   * [HTML `tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) behavior,
   * it determines whether the component is focusable.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the dates of the Calendar that will be disabled
   * ([see example]({% slug disabled_dates_calendar %})).
   */
  set disabledDates(value) {
    this.disabledDatesService.initialize(value);
    this._disabledDates = value;
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Sets or gets the `navigation` property of the Calendar
   * and determines whether the navigation side-bar will be displayed
   * ([see example]({% slug sidebar_calendar %})).
   * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   */
  navigation = true;
  /**
   * Defines the active view that the Calendar initially renders
   * ([see example]({% slug viewoptions_calendar %})).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost view to which the user can navigate
   * ([see example](slug:viewdepth_calendar)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost view to which the user can navigate
   * ([see example](slug:viewdepth_calendar)).
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Specifies the Calendar type.
   *
   * The possible values are:
   * - `infinite` (default)
   * - `classic`
   *
   */
  set type(type) {
    this.renderer.removeClass(this.element.nativeElement, `k-calendar-${this.type}`);
    if (type === "infinite") {
      this.renderer.addClass(this.element.nativeElement, `k-calendar-${type}`);
    }
    this._type = type;
  }
  get type() {
    return this._type;
  }
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   * Applies to the [`classic`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_calendar %})).
   */
  weekNumber = false;
  /**
   * @hidden
   */
  closePopup = new EventEmitter();
  /**
   * Fires when the active view is changed
   * ([see example](slug:events_calendar)).
   */
  activeViewChange = new EventEmitter();
  /**
   * Fires when navigating in the currently active view
   * ([see example](slug:events_calendar)).
   */
  navigate = new EventEmitter();
  /**
   * Fires when the active view date is changed
   * ([see example](slug:events_calendar)).
   * Applies to the [`infinite`]({% slug api_dateinputs_calendarcomponent %}#toc-type) Calendar only.
   */
  activeViewDateChange = new EventEmitter();
  /**
   * Fires each time the Calendar gets blurred
   * ([see example](slug:events_calendar)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the Calendar gets focused
   * ([see example](slug:events_calendar)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the value is changed
   * ([see example](slug:events_calendar)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a cell template declaration.
   * Ignored if a `[cellTemplate]` value is explicitly provided.
   */
  cellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set cellTemplateRef(template) {
    this._cellTemplateRef = template;
  }
  get cellTemplateRef() {
    return this._cellTemplateRef || this.cellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a month cell template declaration.
   * Ignored if a `[monthCellTemplate]` value is explicitly provided.
   */
  monthCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each month cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set monthCellTemplateRef(template) {
    this._monthCellTemplateRef = template;
  }
  get monthCellTemplateRef() {
    return this._monthCellTemplateRef || this.monthCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a year cell template declaration.
   * Ignored if a `[yearCellTemplate]` value is explicitly provided.
   */
  yearCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each year cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set yearCellTemplateRef(template) {
    this._yearCellTemplateRef = template;
  }
  get yearCellTemplateRef() {
    return this._yearCellTemplateRef || this.yearCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a decade cell template declaration.
   * Ignored if a `[decadeCellTemplate]` value is explicitly provided.
   */
  decadeCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each decade cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set decadeCellTemplateRef(template) {
    this._decadeCellTemplateRef = template;
  }
  get decadeCellTemplateRef() {
    return this._decadeCellTemplateRef || this.decadeCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a century cell template declaration.
   * Ignored if a `[centuryCellTemplate]` value is explicitly provided.
   */
  centuryCellTemplate;
  /**
   * @hidden
   *
   * Defines the template for each century cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set centuryCellTemplateRef(template) {
    this._centuryCellTemplateRef = template;
  }
  get centuryCellTemplateRef() {
    return this._centuryCellTemplateRef || this.centuryCellTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a week number cell template declaration.
   * Ignored if a `[weekNumberTemplate]` value is explicitly provided.
   */
  weekNumberTemplate;
  /**
   * @hidden
   *
   * Defines the template for the week cell.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set weekNumberTemplateRef(template) {
    this._weekNumberTemplateRef = template;
  }
  get weekNumberTemplateRef() {
    return this._weekNumberTemplateRef || this.weekNumberTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a header title template declaration.
   * Ignored if a `[headerTitleTemplate]` value is explicitly provided.
   */
  headerTitleTemplate;
  /**
   * @hidden
   *
   * Queries the template for a header template declaration.
   * Ignored if a `[headerTemplate]` value is explicitly provided.
   */
  headerTemplate;
  /**
   * @hidden
   *
   * Queries the template for a footer template declaration.
   * Ignored if a `[footerTemplate]` value is explicitly provided.
   */
  footerTemplate;
  /**
   * @hidden
   *
   * Defines the template for the header title.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set headerTitleTemplateRef(template) {
    this._headerTitleTemplateRef = template;
  }
  get headerTitleTemplateRef() {
    return this._headerTitleTemplateRef || this.headerTitleTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the header.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set headerTemplateRef(template) {
    this._headerTemplateRef = template;
  }
  get headerTemplateRef() {
    return this._headerTemplateRef || this.headerTemplate;
  }
  /**
   * @hidden
   *
   * Defines the template for the footer.
   */
  set footerTemplateRef(template) {
    this._footerTemplateRef = template;
  }
  get footerTemplateRef() {
    return this._footerTemplateRef || this.footerTemplate;
  }
  /**
   * @hidden
   *
   * Queries the template for a navigation item template declaration.
   * Ignored if a `[navigationItemTemplate]` value is explicitly provided.
   */
  navigationItemTemplate;
  /**
   * @hidden
   *
   * Defines the template for the navigation item.
   * Takes precedence over nested templates in the KendoCalendar tag.
   */
  set navigationItemTemplateRef(template) {
    this._navigationItemTemplateRef = template;
  }
  get navigationItemTemplateRef() {
    return this._navigationItemTemplateRef || this.navigationItemTemplate;
  }
  /**
   * @hidden
   *
   * TODO: Make visible when true sizing of all calendar elements is implemented
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this._size = size;
  }
  get size() {
    return this._size;
  }
  _size = DEFAULT_SIZE2;
  /**
   * Specify, which end of the defined selection range should be marked as active.
   *
   * > Value will be ignored if the selection range is undefined.
   * > If range selection is used then the default value is 'start'.
   */
  set activeRangeEnd(_activeRangeEnd) {
    this._activeRangeEnd = _activeRangeEnd;
  }
  get activeRangeEnd() {
    return this._activeRangeEnd;
  }
  _activeRangeEnd = "start";
  navigationView;
  monthView;
  multiViewCalendar;
  isActive = false;
  cellUID = guid();
  selectionRange = {
    start: null,
    end: null
  };
  selectedDates = [];
  rangePivot;
  _disabledDates;
  _min = new Date(MIN_DATE);
  _max = new Date(MAX_DATE);
  _focusedDate = getToday();
  _value;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  changes = {};
  valueSetter = false;
  selectionSetter = false;
  syncNavigation = true;
  viewChangeSubscription;
  _type = "infinite";
  _cellTemplateRef;
  _monthCellTemplateRef;
  _yearCellTemplateRef;
  _decadeCellTemplateRef;
  _centuryCellTemplateRef;
  _weekNumberTemplateRef;
  _headerTitleTemplateRef;
  _headerTemplateRef;
  _footerTemplateRef;
  _navigationItemTemplateRef;
  get activeViewEnum() {
    const activeView = CalendarViewEnum[this.activeView];
    return activeView < this.bottomViewEnum ? this.bottomViewEnum : activeView;
  }
  get bottomViewEnum() {
    return CalendarViewEnum[this.bottomView];
  }
  get topViewEnum() {
    return CalendarViewEnum[this.topView];
  }
  get widgetId() {
    return this.id;
  }
  get ariaDisabled() {
    return this.type === "classic" ? void 0 : this.disabled;
  }
  domEvents = [];
  control;
  pageChangeSubscription;
  resolvedPromise = Promise.resolve(null);
  destroyed = false;
  localizationChangeSubscription;
  activeViewDate;
  currentlyFocusedElement;
  canHover = false;
  constructor(bus, dom, element, navigator2, renderer, cdr, ngZone, injector, scrollSyncService, disabledDatesService, localization, selectionService, pickerService) {
    this.bus = bus;
    this.dom = dom;
    this.element = element;
    this.navigator = navigator2;
    this.renderer = renderer;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
    this.scrollSyncService = scrollSyncService;
    this.disabledDatesService = disabledDatesService;
    this.localization = localization;
    this.selectionService = selectionService;
    this.pickerService = pickerService;
    validatePackage(packageMetadata2);
    this.id = `kendo-calendarid-${this.bus.calendarId}`;
    if (this.pickerService) {
      this.pickerService.calendar = this;
    }
  }
  ngOnInit() {
    this.setClasses(this.element.nativeElement);
    if (this.type === "infinite") {
      this.dom.calculateHeights(this.element.nativeElement);
      this.scrollSyncService.configure(this.activeViewEnum);
    }
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.viewChangeSubscription = this.bus.viewChanged.subscribe(({
      view: view2
    }) => this.handleActiveViewChange(CalendarViewEnum[view2]));
    this.control = this.injector.get(NgControl, null);
    if (this.element) {
      this.ngZone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnChanges(changes) {
    this.changes = changes;
    this.verifyChanges();
    this.bus.configure(this.bottomViewEnum, this.topViewEnum);
    this.scrollSyncService.configure(this.activeViewEnum);
  }
  ngDoCheck() {
    if (this.valueSetter || this.selectionSetter) {
      if (this.selection === "range" && (this.value?.start || this.value?.end) && this.focusedDate.getTime() !== this.value.start?.getTime() && this.focusedDate.getTime() !== this.value.end?.getTime()) {
        this.focusedDate = this.value.start || this.value.end || getToday();
      }
      this.setValue(this.value);
      this.valueSetter = false;
      this.selectionSetter = false;
    }
    if (hasExistingValue(this.changes, "focusedDate")) {
      const focusedDate = this.changes.focusedDate.currentValue;
      this.focusedDate = dateInRange(focusedDate, this.min, this.max);
    }
    if (this.changes.navigation) {
      this.syncNavigation = true;
    }
    if (this.changes.min || this.changes.max || this.changes.rangeValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.onValidatorChange();
    }
    this.changes = {};
  }
  ngAfterViewInit() {
    this.setAriaActivedescendant();
    if (this.size !== "none") {
      const element = this.type === "infinite" ? this.element : this.multiViewCalendar.element;
      this.renderer.removeClass(element.nativeElement, getSizeClass("calendar", this.size));
      this.renderer.addClass(element.nativeElement, getSizeClass("calendar", this.size));
    }
  }
  ngAfterViewChecked() {
    if (!this.syncNavigation) {
      return;
    }
    this.syncNavigation = false;
    this.scrollSyncService.sync(virtualizationProp(this.navigationView), virtualizationProp(this.monthView));
  }
  ngOnDestroy() {
    this.scrollSyncService.destroy();
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    if (this.pickerService) {
      this.pickerService.calendar = null;
    }
    if (this.viewChangeSubscription) {
      this.viewChangeSubscription.unsubscribe();
    }
    if (this.pageChangeSubscription) {
      this.pageChangeSubscription.unsubscribe();
    }
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    this.destroyed = true;
  }
  /**
   * @hidden
   */
  onCellEnter(date2) {
    if (this.selection === "range" && this.canHover) {
      this.ngZone.run(() => {
        if (this.allowReverse) {
          if (this.activeRangeEnd === "end" && this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: date2
            };
          }
          if (this.activeRangeEnd === "start" && this.selectionRange.end) {
            this.selectionRange = {
              start: date2,
              end: this.selectionRange.end
            };
          }
        } else {
          if (this.activeRangeEnd === "end" && this.selectionRange.start && date2 >= this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: date2
            };
          }
          if (this.selectionRange.start && date2 < this.selectionRange.start) {
            this.selectionRange = {
              start: this.selectionRange.start,
              end: null
            };
          }
        }
      });
    }
  }
  /**
   * @hidden
   */
  onResize() {
    this.focusedDate = new Date(this.focusedDate);
    this.cdr.detectChanges();
  }
  /**
   * Focuses the Calendar by making the table.k-calendar-table element active.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="calendar.focus()">Focus calendar</button>
   *  <kendo-calendar #calendar></kendo-calendar>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.currentlyFocusedElement = this.type === "infinite" ? this.element?.nativeElement.querySelector(selectors.infiniteCalendarTable) : this.currentlyFocusedElement = this.element?.nativeElement.querySelector(selectors.multiViewCalendarTable);
    this.currentlyFocusedElement?.focus();
  }
  /**
   * Blurs the Calendar component.
   */
  blur() {
    const blurTarget = this.type === "infinite" ? this.currentlyFocusedElement : this.multiViewCalendar;
    if (isPresent3(blurTarget)) {
      blurTarget.blur();
    }
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.element.nativeElement));
  }
  /**
   * @hidden
   */
  handleNavigation(candidate) {
    if (this.disabled) {
      return;
    }
    const focusTarget = candidate ? new Date(cloneDate(candidate).setDate(1)) : this.focusedDate;
    this.focusedDate = dateInRange(focusTarget, this.min, this.max);
    this.detectChanges();
  }
  /**
   * @hidden
   */
  onPageChange() {
    if (!NgZone.isInAngularZone()) {
      if (this.pageChangeSubscription) {
        this.pageChangeSubscription.unsubscribe();
      }
      this.pageChangeSubscription = from(this.resolvedPromise).subscribe(() => {
        this.detectChanges();
      });
    }
  }
  /**
   * @hidden
   */
  handleMultiViewCalendarValueChange(value, focusedDate) {
    if (this.selection === "range") {
      this.valueChange.emit(value);
    } else {
      const selectedDates = Array.isArray(value) ? value : [value];
      this.handleDateChange({
        selectedDates,
        focusedDate
      });
    }
  }
  /**
   * @hidden
   */
  handleDateChange(args) {
    const selectedDates = Array.isArray(args.selectedDates) ? args.selectedDates : [args.selectedDates];
    const canNavigateDown = this.bus.canMoveDown(this.activeViewEnum);
    const availableDates = selectedDates.filter((date2) => !this.disabledDatesService.isDateDisabled(date2));
    this.focusedDate = args.focusedDate || this.focusedDate;
    if (this.disabled) {
      return;
    }
    if (!canNavigateDown && areDatesEqual(availableDates, this.selectedDates)) {
      this.emitSameDate();
      return;
    }
    if (canNavigateDown) {
      this.bus.moveDown(this.activeViewEnum);
      return;
    }
    if (this.disabledDatesService.isDateDisabled(this.focusedDate)) {
      return;
    }
    if (this.selection === "range") {
      return;
    }
    this.ngZone.run(() => {
      this.selectedDates = availableDates.map((date2) => cloneDate(date2));
      this.value = this.parseSelectionToValue(availableDates);
      this.onControlChange(this.parseSelectionToValue(availableDates));
      this.valueChange.emit(this.parseSelectionToValue(availableDates));
      this.cdr.markForCheck();
    });
  }
  /**
   * @hidden
   */
  writeValue(candidate) {
    this.verifyValue(candidate);
    this.value = candidate;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  activeCellTemplate() {
    switch (this.activeViewEnum) {
      case CalendarViewEnum.month:
        return this.monthCellTemplateRef || this.cellTemplateRef;
      case CalendarViewEnum.year:
        return this.yearCellTemplateRef;
      case CalendarViewEnum.decade:
        return this.decadeCellTemplateRef;
      case CalendarViewEnum.century:
        return this.centuryCellTemplateRef;
      default:
        return null;
    }
  }
  /**
   * @hidden
   */
  handleNavigate(event2) {
    this.focusedDate = event2.focusedDate;
    this.activeView = event2.activeView;
    this.emitNavigate(this.focusedDate);
  }
  /**
   * @hidden
   */
  emitNavigate(focusedDate) {
    const activeView = CalendarViewEnum[this.activeViewEnum];
    this.navigate.emit({
      activeView,
      focusedDate
    });
  }
  /**
   * @hidden
   */
  emitEvent(emitter, args) {
    if (hasObservers(emitter)) {
      this.ngZone.run(() => {
        emitter.emit(args);
      });
    }
  }
  /**
   * @hidden
   */
  handleActiveDateChange(date2) {
    this.activeViewDate = date2;
    this.emitEvent(this.activeViewDateChange, date2);
  }
  /**
   * @hidden
   */
  handleActiveViewChange(view2) {
    this.activeView = view2;
    this.emitEvent(this.activeViewChange, view2);
    if (this.type === "infinite") {
      this.scrollSyncService.configure(this.activeViewEnum);
    }
    this.detectChanges();
  }
  /**
   * @hidden
   */
  handleCellClick({
    date: date2,
    modifiers
  }) {
    this.focus();
    if (this.selection === "range" && this.activeViewEnum === CalendarViewEnum[this.bottomView]) {
      this.performRangeSelection(date2);
    } else {
      this.selectionService.lastClicked = date2;
      this.performSelection(date2, modifiers);
    }
  }
  /**
   * @hidden
   */
  handleWeekNumberClick(dates) {
    if (this.selection === "single") {
      return;
    }
    this.ngZone.run(() => {
      if (this.selection === "multiple") {
        this.handleDateChange({
          selectedDates: dates,
          focusedDate: last(dates)
        });
      }
      if (this.selection === "range") {
        this.canHover = false;
        this.activeRangeEnd = "start";
        const shouldEmitValueChange = this.selectionRange.start?.getTime() !== dates[0].getTime() || this.selectionRange.end?.getTime() !== last(dates).getTime();
        this.value = {
          start: dates[0],
          end: last(dates)
        };
        if (shouldEmitValueChange) {
          this.valueChange.emit(this.value);
        }
      }
    });
  }
  /**
   * @hidden
   */
  handleBlur(args) {
    if (this.element.nativeElement.contains(args.relatedTarget)) {
      return;
    }
    this.isActive = false;
    if (!this.pickerService && requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.onControlTouched();
        this.emitBlur(args);
        this.cdr.markForCheck();
      });
    } else {
      this.emitBlur(args);
      this.detectChanges();
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.isActive = true;
    if (!NgZone.isInAngularZone()) {
      this.detectChanges();
    }
    this.emitFocus();
  }
  /**
   * @hidden
   */
  handleMultiViewCalendarKeydown(args) {
    if (isPresent3(this.pickerService) && args.keyCode === Keys.Enter) {
      args.preventDefault();
    }
  }
  setClasses(element) {
    this.renderer.removeClass(element, `k-calendar-${this.type}`);
    if (this.type === "infinite") {
      this.renderer.addClass(element, "k-calendar");
      this.renderer.addClass(element, `k-calendar-${this.type}`);
    }
  }
  verifyChanges() {
    if (!isDevMode()) {
      return;
    }
    if (this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$2} and ${MAX_DOC_LINK$2}.`);
    }
    if (this.bottomViewEnum > this.topViewEnum) {
      throw new Error(`The topView should be greater than bottomView. See ${BOTTOM_VIEW_DOC_LINK} and ${TOP_VIEW_DOC_LINK}.`);
    }
  }
  verifyValue(candidate) {
    if (!isDevMode()) {
      return;
    }
    if (this.selection === "single" && candidate && !isNullOrDate(candidate)) {
      throw new Error(`When using 'single' selection the 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
    } else if (this.selection === "multiple" && candidate) {
      if (Array.isArray(candidate)) {
        const onlyDates = candidate.every((value) => value instanceof Date);
        if (!onlyDates) {
          throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
        }
      }
      if (Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
        throw new Error(`When using 'multiple' selection the 'value' should be an array of valid JavaScript Date instances. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
      }
    } else if (this.selection === "range" && candidate && !(isNullOrDate(candidate["start"]) && isNullOrDate(candidate["end"]))) {
      throw new Error(`The 'value' should be an object with start and end dates. Check ${VALUE_DOC_LINK$4} for possible resolution.`);
    }
  }
  bindEvents() {
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "focus", this.handleFocus.bind(this)), this.renderer.listen(element, "mousedown", preventDefault), this.renderer.listen(element, "click", this.handleComponentClick.bind(this)), this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)), this.renderer.listen(element, "mouseleave", this.setRangeSelectionToValue.bind(this)));
  }
  setRangeSelectionToValue() {
    if (this.selection === "range" && this.type === "infinite" && this.value) {
      this.ngZone.run(() => {
        this.selectionRange = this.value;
        this.cdr.markForCheck();
      });
    }
  }
  emitBlur(args) {
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
    this.onBlur.emit();
  }
  emitFocus() {
    if (this.pickerService) {
      this.pickerService.onFocus.emit();
    }
    this.onFocus.emit();
  }
  handleComponentClick() {
    if (!this.isActive) {
      if (this.type === "infinite" && this.monthView.isScrolled()) {
        this.focusedDate = cloneDate(this.focusedDate);
        this.detectChanges();
      }
      this.focus();
    }
  }
  handleKeydown(args) {
    if (this.type === "infinite") {
      const ctrlKey = args.ctrlKey || args.metaKey;
      const arrowKeyPressed = [Keys.ArrowUp, Keys.ArrowRight, Keys.ArrowDown, Keys.ArrowLeft].indexOf(args.keyCode) !== -1;
      const reserveKeyCommandsForPicker = isPresent3(this.pickerService) && arrowKeyPressed && args.altKey;
      if (reserveKeyCommandsForPicker) {
        return;
      }
      if (ctrlKey && arrowKeyPressed) {
        args.preventDefault();
      }
      const preventSubmitInDatePicker = isPresent3(this.pickerService) && args.keyCode === Keys.Enter;
      if (preventSubmitInDatePicker) {
        args.preventDefault();
      }
      const candidate = dateInRange(this.navigator.move(this.focusedDate, this.navigator.action(args), this.activeViewEnum), this.min, this.max);
      if (!isEqual(this.focusedDate, candidate)) {
        this.focusedDate = candidate;
        this.detectChanges();
        args.preventDefault();
      }
      if (args.keyCode === Keys.Enter) {
        this.selectionService.lastClicked = this.focusedDate;
        if (this.selection !== "range") {
          this.performSelection(this.focusedDate, args);
        } else {
          this.performRangeSelection(this.focusedDate);
        }
      }
      if (args.keyCode === Keys.KeyT) {
        this.focusToday();
      }
      if (isArrowWithShiftPressed(args) && this.selection !== "range") {
        args.anyArrow = true;
        this.performSelection(this.focusedDate, args);
      }
    }
  }
  focusToday() {
    this.focusedDate = getToday();
    this.bus.moveToBottom(this.activeViewEnum);
    this.cdr.detectChanges();
  }
  detectChanges() {
    if (!this.destroyed) {
      this.cdr.detectChanges();
    }
  }
  emitSameDate() {
    if (this.pickerService) {
      this.pickerService.sameDateSelected.emit();
    }
  }
  setAriaActivedescendant() {
    const infiniteCalendarTable = this.element.nativeElement?.querySelector(selectors.infiniteCalendarTable);
    const activedescendantHandledByInnerMultiViewCalendar = !isPresent3(infiniteCalendarTable) || this.type === "classic" && !infiniteCalendarTable.hasAttribute(attributeNames.ariaActiveDescendant);
    if (activedescendantHandledByInnerMultiViewCalendar) {
      return;
    }
    if (this.type === "classic") {
      this.renderer.removeAttribute(infiniteCalendarTable, attributeNames.ariaActiveDescendant);
      return;
    }
    const focusedCellId = this.cellUID + this.focusedDate.getTime();
    this.renderer.setAttribute(infiniteCalendarTable, attributeNames.ariaActiveDescendant, focusedCellId);
  }
  parseSelectionToValue(selection) {
    selection = selection || [];
    return this.selection === "single" ? cloneDate(last(selection)) : selection.map((date2) => cloneDate(date2));
  }
  setValue(candidate) {
    this.verifyValue(candidate);
    if (candidate === null) {
      this._value = null;
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
    } else if (Array.isArray(candidate)) {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = candidate.filter((date2) => isPresent3(date2)).map((element) => cloneDate(element));
    } else if (isObject(candidate) && Object.keys(candidate).find((k) => k === "start") && Object.keys(candidate).find((k) => k === "end")) {
      this.selectedDates = [];
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = {
        start: null,
        end: null
      };
      this._value.start = candidate.start instanceof Date ? cloneDate(candidate.start) : null;
      this._value.end = candidate.end instanceof Date ? cloneDate(candidate.end) : null;
      this.selectionRange = Object.assign({}, this._value);
      if (this._value?.start && !this._value?.end) {
        this.activeRangeEnd = "end";
        this.canHover = true;
      }
      if (this._value?.end && !this._value?.start) {
        this.activeRangeEnd = "start";
        this.canHover = true;
      }
      if (this._value?.end && this._value?.start) {
        this.canHover = false;
      }
    } else {
      this.selectionRange = {
        start: null,
        end: null
      };
      this._value = cloneDate(candidate);
    }
    if (this.selection !== "range") {
      const selection = [].concat(candidate).filter((date2) => isPresent3(date2)).map((date2) => cloneDate(date2));
      if (!areDatesEqual(selection, this.selectedDates)) {
        const lastSelected = last(selection);
        this.rangePivot = cloneDate(lastSelected);
        this.focusedDate = cloneDate(lastSelected) || this.focusedDate;
        this.selectedDates = selection;
      }
    }
  }
  performRangeSelection(date2) {
    this.focusedDate = date2;
    const clonedRangeSelection = Object.assign({}, this.selectionRange);
    const emitValueChange = this.activeRangeEnd === "start" && this.value?.start?.getTime() !== date2?.getTime() || this.activeRangeEnd === "end" && this.value?.end?.getTime() !== date2?.getTime();
    this.ngZone.run(() => {
      const rangeSelection = handleRangeSelection(date2, clonedRangeSelection, this.activeRangeEnd, this.allowReverse);
      this.activeRangeEnd = rangeSelection.activeRangeEnd;
      if (this.canHover && rangeSelection.activeRangeEnd === "end" && rangeSelection.selectionRange.end?.getTime() === date2.getTime()) {
        this.activeRangeEnd = "start";
        rangeSelection.activeRangeEnd = "start";
      }
      this.canHover = this.activeRangeEnd === "end" && rangeSelection.selectionRange.start && !rangeSelection.selectionRange.end;
      if (emitValueChange && (this.value?.start?.getTime() !== rangeSelection.selectionRange?.start?.getTime() || this.value?.end?.getTime() !== rangeSelection.selectionRange?.end?.getTime())) {
        this.value = rangeSelection.selectionRange;
        this.valueChange.emit(this.value);
      }
      this.cdr.markForCheck();
    });
  }
  performSelection(date2, selectionModifiers) {
    const selection = this.selectionService.performSelection({
      date: date2,
      modifiers: selectionModifiers,
      selectionMode: this.selection,
      activeViewEnum: this.activeViewEnum,
      rangePivot: this.rangePivot,
      selectedDates: this.selectedDates
    });
    this.rangePivot = selection.rangePivot;
    this.handleDateChange({
      selectedDates: selection.selectedDates,
      focusedDate: date2
    });
  }
  static ɵfac = function CalendarComponent_Factory(t) {
    return new (t || _CalendarComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(CalendarDOMService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ScrollSyncService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CalendarComponent,
    selectors: [["kendo-calendar"]],
    contentQueries: function CalendarComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
      }
    },
    viewQuery: function CalendarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(NavigationComponent, 5);
        ɵɵviewQuery(ViewListComponent, 5);
        ɵɵviewQuery(MultiViewCalendarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthView = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiViewCalendar = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function CalendarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.widgetId)("aria-disabled", ctx.ariaDisabled);
        ɵɵclassProp("k-week-number", ctx.weekNumber)("k-disabled", ctx.ariaDisabled);
      }
    },
    inputs: {
      showOtherMonthDays: "showOtherMonthDays",
      id: "id",
      focusedDate: "focusedDate",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      weekDaysFormat: "weekDaysFormat",
      footer: "footer",
      selection: "selection",
      allowReverse: "allowReverse",
      value: "value",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      disabledDates: "disabledDates",
      navigation: "navigation",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      type: "type",
      animateNavigation: "animateNavigation",
      weekNumber: "weekNumber",
      cellTemplateRef: [InputFlags.None, "cellTemplate", "cellTemplateRef"],
      monthCellTemplateRef: [InputFlags.None, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [InputFlags.None, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [InputFlags.None, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [InputFlags.None, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [InputFlags.None, "weekNumberTemplate", "weekNumberTemplateRef"],
      headerTitleTemplateRef: [InputFlags.None, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [InputFlags.None, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [InputFlags.None, "footerTemplate", "footerTemplateRef"],
      navigationItemTemplateRef: [InputFlags.None, "navigationItemTemplate", "navigationItemTemplateRef"],
      size: "size",
      activeRangeEnd: "activeRangeEnd"
    },
    outputs: {
      closePopup: "closePopup",
      activeViewChange: "activeViewChange",
      navigate: "navigate",
      activeViewDateChange: "activeViewDateChange",
      onBlur: "blur",
      onFocus: "focus",
      valueChange: "valueChange"
    },
    exportAs: ["kendo-calendar"],
    standalone: true,
    features: [ɵɵProvidersFeature([BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.calendar"
    }, NavigationService, ScrollSyncService, SelectionService]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 2,
    consts: () => {
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_4 = goog.getMsg("Today");
        i18n_4 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.calendar.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_5 = goog.getMsg("Navigate to previous view");
        i18n_5 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_6 = goog.getMsg("Navigate to next view");
        i18n_6 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_7 = goog.getMsg("Navigate to parent view");
        i18n_7 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.calendar.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      return [["multiviewcalendar", ""], ["kendoCalendarLocalizedMessages", "", "today", i18n_4, "prevButtonTitle", i18n_5, "nextButtonTitle", i18n_6, "parentViewButtonTitle", i18n_7], [4, "ngIf"], [3, "activeView", "focusedDate", "min", "max", "templateRef", "valueChange", "pageChange", 4, "ngIf"], [3, "todayButtonClick", "cellClick", "weekNumberCellClick", "activeDateChange", "pageChange", "focusCalendar", "blurCalendar", "cellEnter", "activeView", "allowReverse", "showOtherMonthDays", "activeRangeEnd", "selectionRange", "size", "isActive", "id", "weekDaysFormat", "cellTemplateRef", "headerTitleTemplateRef", "headerTemplateRef", "showFooter", "footerTemplateRef", "weekNumberTemplateRef", "cellUID", "min", "max", "focusedDate", "weekNumber", "selectedDates", "tabIndex", "disabled"], [3, "resize"], [3, "valueChange", "pageChange", "activeView", "focusedDate", "min", "max", "templateRef"], [3, "onClosePopup", "activeViewChange", "navigate", "valueChange", "focusCalendar", "blur", "blurEvent", "keydown", "views", "min", "max", "size", "id", "activeRangeEnd", "selectionRange", "allowReverse", "disabled", "isActive", "showOtherMonthDays", "tabIndex", "activeView", "bottomView", "topView", "weekDaysFormat", "weekNumber", "animateNavigation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "weekNumberTemplate", "focusedDate", "selection", "value", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"]];
    },
    template: function CalendarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 1);
        ɵɵtemplate(1, CalendarComponent_ng_container_1_Template, 4, 24, "ng-container", 2)(2, CalendarComponent_ng_container_2_Template, 4, 36, "ng-container", 2);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "infinite");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "classic");
      }
    },
    dependencies: [CalendarLocalizedMessagesDirective, NgIf, NavigationComponent, ViewListComponent, ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-calendar",
      providers: [BusViewService, CALENDAR_VALUE_ACCESSOR, CALENDAR_RANGE_VALIDATORS, KENDO_INPUT_PROVIDER, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.calendar"
      }, NavigationService, ScrollSyncService, SelectionService],
      selector: "kendo-calendar",
      template: `
    <ng-container kendoCalendarLocalizedMessages
        i18n-today="kendo.calendar.today|The label for the today button in the calendar header"
        today="Today"

        i18n-prevButtonTitle="kendo.calendar.prevButtonTitle|The title of the previous button in the Classic calendar"
        prevButtonTitle="Navigate to previous view"

        i18n-nextButtonTitle="kendo.calendar.nextButtonTitle|The title of the next button in the Classic calendar"
        nextButtonTitle="Navigate to next view"

        i18n-parentViewButtonTitle="kendo.calendar.parentViewButtonTitle|The title of the parent view button in the calendar header"
        parentViewButtonTitle="Navigate to parent view"
    >
    </ng-container>
    <ng-container *ngIf="type === 'infinite'">
        <kendo-calendar-navigation
            *ngIf="navigation"
            [activeView]="activeViewEnum"
            [focusedDate]="focusedDate"
            [min]="min"
            [max]="max"
            [templateRef]="navigationItemTemplateRef?.templateRef"
            (valueChange)="handleNavigation($event)"
            (pageChange)="onPageChange()"
        >
        </kendo-calendar-navigation>
        <kendo-calendar-viewlist
            [activeView]="activeViewEnum"
            [allowReverse]="allowReverse"
            [showOtherMonthDays]="showOtherMonthDays"
            [activeRangeEnd]="activeRangeEnd"
            [selectionRange]="selectionRange"
            [size]="size"
            [isActive]="isActive"
            [id]="headerId"
            [weekDaysFormat]="weekDaysFormat"
            [cellTemplateRef]="activeCellTemplate()?.templateRef"
            [headerTitleTemplateRef]="headerTitleTemplateRef?.templateRef"
            [headerTemplateRef]="headerTemplateRef?.templateRef"
            [showFooter]="footer"
            [footerTemplateRef]="footerTemplateRef?.templateRef"
            [weekNumberTemplateRef]="weekNumberTemplateRef?.templateRef"
            [cellUID]="cellUID"
            [min]="min"
            [max]="max"
            [focusedDate]="focusedDate"
            [weekNumber]="weekNumber"
            [selectedDates]="selectedDates"
            [tabIndex]="tabIndex"
            [disabled]="disabled"
            (todayButtonClick)="handleDateChange({
                selectedDates: [$event],
                focusedDate: $event
            })"
            (cellClick)="handleCellClick($event)"
            (weekNumberCellClick)="handleWeekNumberClick($event)"
            (activeDateChange)="handleActiveDateChange($event)"
            (pageChange)="onPageChange()"
            (focusCalendar)="handleFocus()"
            (blurCalendar)="handleBlur($event)"
            (cellEnter)="onCellEnter($event)"
        >
        </kendo-calendar-viewlist>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
    </ng-container>
    <ng-container *ngIf="type === 'classic'">
        <kendo-multiviewcalendar
            #multiviewcalendar
            [views]="1"
            [min]="min"
            [max]="max"
            [size]="size"
            [id]="id"
            [activeRangeEnd]="activeRangeEnd"
            [selectionRange]="selectionRange"
            [allowReverse]="allowReverse"
            [disabled]="disabled"
            [isActive]="isActive"
            [showOtherMonthDays]="showOtherMonthDays"
            [tabIndex]="tabIndex"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [weekDaysFormat]="weekDaysFormat"
            [weekNumber]="weekNumber"
            [animateNavigation]="animateNavigation"
            [cellTemplate]="activeCellTemplate()"
            [monthCellTemplate]="monthCellTemplateRef"
            [yearCellTemplate]="yearCellTemplateRef"
            [decadeCellTemplate]="decadeCellTemplateRef"
            [centuryCellTemplate]="centuryCellTemplateRef"
            [headerTitleTemplate]="headerTitleTemplateRef"
            [headerTemplate]="headerTemplateRef"
            [footerTemplate]="footerTemplateRef"
            [footer]="footer"
            [weekNumberTemplate]="weekNumberTemplateRef"
            [focusedDate]="focusedDate"
            [selection]="selection"
            [value]="value"
            [disabledDates]="disabledDates"
            (onClosePopup)="closePopup.emit()"
            (activeViewChange)="handleActiveViewChange($event)"
            (navigate)="handleNavigate($event)"
            (valueChange)="handleMultiViewCalendarValueChange($event, multiviewcalendar.focusedDate)"
            (focusCalendar)="handleFocus()"
            (blur)="handleBlur($event)"
            (blurEvent)="handleBlur($event)"
            (keydown)="handleMultiViewCalendarKeydown($event)"
        >
            <kendo-multiviewcalendar-messages
                [today]="localization.get('today')"
                [prevButtonTitle]="localization.get('prevButtonTitle')"
                [nextButtonTitle]="localization.get('nextButtonTitle')"
                [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
            >
            </kendo-multiviewcalendar-messages>
        </kendo-multiviewcalendar>
    </ng-container>
  `,
      standalone: true,
      imports: [CalendarLocalizedMessagesDirective, NgIf, NavigationComponent, ViewListComponent, ResizeSensorComponent, MultiViewCalendarComponent, MultiViewCalendarCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: CalendarDOMService
    }, {
      type: ElementRef
    }, {
      type: NavigationService
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: ScrollSyncService
    }, {
      type: DisabledDatesService
    }, {
      type: LocalizationService
    }, {
      type: SelectionService
    }, {
      type: PickerService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showOtherMonthDays: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    navigation: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-week-number"]
    }],
    closePopup: [{
      type: Output
    }],
    activeViewChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    activeViewDateChange: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    valueChange: [{
      type: Output
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    navigationItemTemplate: [{
      type: ContentChild,
      args: [NavigationItemTemplateDirective, {
        static: false
      }]
    }],
    navigationItemTemplateRef: [{
      type: Input,
      args: ["navigationItemTemplate"]
    }],
    size: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    navigationView: [{
      type: ViewChild,
      args: [NavigationComponent, {
        static: false
      }]
    }],
    monthView: [{
      type: ViewChild,
      args: [ViewListComponent, {
        static: false
      }]
    }],
    multiViewCalendar: [{
      type: ViewChild,
      args: [MultiViewCalendarComponent, {
        static: false
      }]
    }],
    widgetId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var incompleteDateValidator = () => {
  return (control, incomplete) => {
    if (!isPresent3(control.value) && incomplete) {
      return {
        incompleteDate: true
      };
    } else {
      return null;
    }
  };
};
var Arrow;
(function(Arrow2) {
  Arrow2[Arrow2["Up"] = 0] = "Up";
  Arrow2[Arrow2["Down"] = 1] = "Down";
  Arrow2[Arrow2["None"] = 2] = "None";
})(Arrow || (Arrow = {}));
var DateInputMessages = class _DateInputMessages extends ComponentMessages {
  /**
   * The title of the **Decrement** button of the DateInput.
   */
  decrement;
  /**
   * The title of the **Increment** button of the DateInput.
   */
  increment;
  /**
   * The title of the **Clear** button of the DateInput.
   */
  clearTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateInputMessages_BaseFactory;
    return function DateInputMessages_Factory(t) {
      return (ɵDateInputMessages_BaseFactory || (ɵDateInputMessages_BaseFactory = ɵɵgetInheritedFactory(_DateInputMessages)))(t || _DateInputMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateInputMessages,
    selectors: [["kendo-dateinput-messages-base"]],
    inputs: {
      decrement: "decrement",
      increment: "increment",
      clearTitle: "clearTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-dateinput-messages-base"
    }]
  }], null, {
    decrement: [{
      type: Input
    }],
    increment: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }]
  });
})();
var DateInputLocalizedMessagesDirective = class _DateInputLocalizedMessagesDirective extends DateInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DateInputLocalizedMessagesDirective_Factory(t) {
    return new (t || _DateInputLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateInputLocalizedMessagesDirective,
    selectors: [["", "kendoDateInputLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DateInputMessages,
      useExisting: forwardRef(() => _DateInputLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateInputMessages,
        useExisting: forwardRef(() => DateInputLocalizedMessagesDirective)
      }],
      selector: "[kendoDateInputLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var nextId = 0;
var MIN_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min";
var MAX_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max";
var VALUE_DOC_LINK$3 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json";
var TWO_DIGIT_YEAR_MAX$2 = 68;
var DEFAULT_FORMAT$1 = "d";
var DEFAULT_FORMAT_PLACEHOLDER = "wide";
var DATE_PART_REGEXP = /year|month|<day>/;
var TIME_PART_REGEXP = /hour|minute|second|millisecond/;
var DateInputIntl = class {
  service;
  format;
  toString;
  formatDate;
  parseDate;
  parseNumber;
  formatNumber;
  splitDateFormat;
  numberSymbols;
  firstDay;
  weekendRange;
  dateFieldName;
  dateFormatNames;
  cldr = {};
  localeId;
  constructor(service) {
    this.service = service;
    this.localeId = service["localeId"];
    this.format = service.format;
    this.toString = service.toString;
    this.formatDate = service.formatDate;
    this.parseDate = service.parseDate;
    this.parseNumber = service.parseNumber;
    this.formatNumber = service.formatNumber;
    this.splitDateFormat = service.splitDateFormat;
    this.numberSymbols = service.numberSymbols;
    this.firstDay = service.firstDay;
    this.weekendRange = service.weekendRange;
    this.dateFieldName = service.dateFieldName;
    this.dateFormatNames = (localeId, options) => this.service.dateFormatNames(options, localeId || this.localeId);
    const _localeData = localeData(this.localeId);
    this.cldr[_localeData.name] = _localeData;
  }
};
var DateInputComponent = class _DateInputComponent {
  cdr;
  intl;
  renderer;
  wrapper;
  ngZone;
  injector;
  localization;
  pickerService;
  /**
   * @hidden
   */
  caretAltUpIcon = caretAltUpIcon;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  set focusableId(_focusableId) {
    if (_focusableId) {
      this._focusableId = _focusableId;
    }
  }
  get focusableId() {
    return this._focusableId;
  }
  /**
   * @hidden
   */
  set pickerType(_pickerType) {
    if (_pickerType) {
      this.focusableId = `${_pickerType}-${nextId}`;
    }
  }
  /**
   * If set to `true`, renders a clear button after the input text or DateInput value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Sets or gets the `disabled` property of the DateInput and
   * determines whether the component is active
   * ([see example]({% slug disabled_dateinput %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_dateinput#toc-managing-the-dateinput-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets or gets the read-only state of the DateInput
   * ([see example]({% slug readonly_dateinput %})).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the title of the input element of the DateInput.
   */
  title = "";
  /**
   * Sets or gets the `tabIndex` property of the DateInput.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  role = "textbox";
  /**
   * @hidden
   */
  ariaReadOnly = false;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * @hidden
   */
  isRequired = false;
  /**
   * Specifies the date format that is used to display the input value
   * ([see example]({% slug formats_dateinput %})).
   *
   * Format value options:
   * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
   * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
   */
  format = DEFAULT_FORMAT$1;
  /**
   * Defines the descriptions of the format sections in the input field.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_dateinput %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   * <div class="row example-wrapper" [style.min-height.px]="450">
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Full-length format description:</p>
   *    <kendo-dateinput formatPlaceholder="wide"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Narrow-length format description:</p>
   *    <kendo-dateinput formatPlaceholder="narrow"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Short-length format description:</p>
   *    <kendo-dateinput formatPlaceholder="short"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Display defined format:</p>
   *    <kendo-dateinput format="MM/dd/yyyy" formatPlaceholder="formatPattern"></kendo-dateinput>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Custom defined format descriptions</p>
   *    <kendo-dateinput format="G"
   *      [formatPlaceholder]="{
   *        year: 'y', month: 'M', day: 'd',
   *        hour: 'h', minute: 'm', second: 's'
   *      }"
   *    ></kendo-dateinput>
   *  </div>
   * </div>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  set formatPlaceholder(format) {
    this._formatPlaceholder = format ? format : DEFAULT_FORMAT_PLACEHOLDER;
  }
  get formatPlaceholder() {
    return this._formatPlaceholder;
  }
  /**
   * Specifies the hint the DateInput displays when its value is `null`.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_dateinput %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-dateinput placeholder="Enter birth date..."></kendo-dateinput>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  placeholder = null;
  /**
   * Configures the incremental steps of the DateInput.
   * For more information, refer to the article on
   * [incremental steps]({% slug incrementalsteps_dateinput %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-dateinput [steps]="steps"></kendo-dateinput>
   * `
   * })
   * export class AppComponent {
   *   public steps = { year: 10, month: 1, day: 5 };
   * }
   * ```
   */
  steps = {};
  /**
   * Specifies the biggest date that is valid
   * ([see example]({% slug dateranges_dateinput %})).
   * By default, the `max` value is `2099-12-31`.
   */
  max = cloneDate(MAX_DATE);
  /**
   * Specifies the smallest date that is valid
   * ([see example]({% slug dateranges_dateinput %})).
   * By default, the `min` value is `1900-1-1`.
   */
  min = cloneDate(MIN_DATE);
  /**
   * Determines whether the built-in min or max validators are to be enforced when a form is being validated.
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Determines whether to autocorrect invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * When enabled, the DateInput will autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_dateinput %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX$2;
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Specifies the value of the DateInput component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value) {
    this.verifyValue(value);
    this.showClearButton = value || !value && this.isDateIncomplete ? true : false;
    this._value = cloneDate(value);
    this.valueUpdate.emit(cloneDate(value));
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies whether the **Up** and **Down** spin buttons will be rendered.
   * For more information, refer to the article on
   * [spinner buttons]({% slug spinbuttons_dateinput %}).
   */
  spinners = false;
  /**
   * @hidden
   */
  isPopupOpen;
  /**
   * @hidden
   */
  hasPopup;
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    const newSize = size ? size : DEFAULT_SIZE2;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      if (this.spinners && this.spinup && this.spindown) {
        this.setSpinnerFill(this.spinup.nativeElement, newFillMode, this.fillMode);
        this.setSpinnerFill(this.spindown.nativeElement, newFillMode, this.fillMode);
      }
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.dateInput.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_dateinput)).
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   * Fires each time the user selects a new value
   * ([see example](slug:events_dateinput)).
   */
  valueUpdate = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_dateinput)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_dateinput)).
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  dateInput;
  get wrapperClass() {
    return true;
  }
  get disabledClass() {
    return this.disabled;
  }
  get inputElement() {
    return this.dateInput ? this.dateInput.nativeElement : null;
  }
  get inputValue() {
    return (this.inputElement || {}).value || "";
  }
  get isActive() {
    return this._active;
  }
  set isActive(value) {
    this._active = value;
    if (!this.wrapper) {
      return;
    }
    if (!isPresent3(this.pickerService)) {
      const element = this.wrapper.nativeElement;
      if (value) {
        this.renderer.addClass(element, "k-focus");
      } else {
        this.renderer.removeClass(element, "k-focus");
      }
    }
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  get options() {
    return {
      format: this.format,
      steps: this.steps,
      readonly: this.readonly,
      formatPlaceholder: this.formatPlaceholder,
      placeholder: this.placeholder,
      autoCorrectParts: this.autoCorrectParts,
      autoSwitchParts: this.autoSwitchParts,
      selectPreviousSegmentOnBackspace: true,
      autoSwitchKeys: this.autoSwitchKeys,
      twoDigitYearMax: this.twoDigitYearMax,
      enableMouseWheel: this.enableMouseWheel,
      selectNearestSegmentOnFocus: true,
      allowCaretMode: this.allowCaretMode,
      autoFill: this.autoFill,
      value: this.value,
      intlService: new DateInputIntl(this.intl)
    };
  }
  arrow = Arrow;
  arrowDirection = Arrow.None;
  formatSections = {
    date: false,
    time: false
  };
  hasMousedown = false;
  focusedPriorToMousedown = false;
  showClearButton = false;
  /**
   * @hidden
   */
  isDateIncomplete = false;
  currentFormat = "";
  spinup;
  spindown;
  minValidator = noop$2;
  maxValidator = noop$2;
  incompleteValidator = noop$2;
  _value = null;
  _active = false;
  _focusableId = `dateinput-${nextId++}`;
  _formatPlaceholder = DEFAULT_FORMAT_PLACEHOLDER;
  kendoDate = null;
  kendoDateObject = null;
  domEvents = [];
  ngControl;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  _size = DEFAULT_SIZE2;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  control;
  subs = new Subscription();
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      "aria-readonly": this.ariaReadOnly,
      id: this.focusableId,
      title: this.title,
      tabindex: this.tabindex,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      placeholder: this.placeholder,
      "aria-expanded": this.isPopupOpen,
      "aria-haspopup": this.hasPopup,
      required: this.isControlRequired ? "" : null
    };
  }
  get mutableAttributes() {
    return {
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      spellcheck: "false",
      role: this.role
    };
  }
  constructor(cdr, intl, renderer, wrapper, ngZone, injector, localization, pickerService) {
    this.cdr = cdr;
    this.intl = intl;
    this.renderer = renderer;
    this.wrapper = wrapper;
    this.ngZone = ngZone;
    this.injector = injector;
    this.localization = localization;
    this.pickerService = pickerService;
    validatePackage(packageMetadata2);
    if (this.pickerService) {
      this.pickerService.input = this;
    } else {
      this.ariaReadOnly = null;
    }
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty
   */
  isEmpty() {
    const currentValue = this.dateInput.nativeElement.value;
    return !currentValue || !String(currentValue).trim();
  }
  /**
   * @hidden
   */
  handleDragAndDrop(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.wrapper.nativeElement));
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.kendoDate) {
      this.kendoDate.destroy();
    }
    this.kendoDate = this.initKendoDate();
    this.kendoDateObject = this.kendoDate.dateObject;
    this.updateFormatSections();
    this.subs.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    this.ngControl = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    }
    this.minValidator = this.rangeValidation ? minValidator(this.min) : noop$2;
    this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop$2;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    this.verifyRange();
    if (anyChanged(["min", "max", "rangeValidation", "incompleteDateValidation"], changes, false)) {
      this.minValidator = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (changes["clearButton"]) {
      this.showClearButton = this.clearButton && (isPresent3(this.value) || this.isDateIncomplete);
    }
    const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.value);
    if (!isEqualToKendoDate) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate.writeValue(this.value);
    }
    if (changes["format"] || changes["placeholder"]) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate?.setOptions(this.options, true);
      this.updateFormatSections();
    }
    if (anyChanged(["enableMouseWheel", "autoFill", "autoSwitchParts", "autoSwitchKeys", "twoDigitYearMax", "allowCaretMode", "autoCorrectParts", "readonly", "steps", "formatPlaceholder"], changes)) {
      if (!this.kendoDate) {
        return;
      }
      this.kendoDate?.setOptions(this.options, true);
    }
  }
  updateFormatSections() {
    this.formatSections = this.intl.splitDateFormat(this.kendoDate.inputFormat).reduce(({
      date: date2,
      time
    }, p) => {
      return {
        date: date2 || DATE_PART_REGEXP.test(p.type),
        time: time || TIME_PART_REGEXP.test(p.type)
      };
    }, {
      date: false,
      time: false
    });
  }
  updateIncompleteValidationStatus() {
    const previousValue = this.isDateIncomplete;
    this.isDateIncomplete = this.kendoDateObject.hasValue() && this.value === null;
    if (previousValue === this.isDateIncomplete || !this.incompleteDateValidation) {
      return;
    }
    if (isPresent3(this.ngControl) && !isPresent3(this.pickerService)) {
      this.cdr.markForCheck();
      this.ngZone.run(() => this.onValidatorChange());
    } else if (isPresent3(this.pickerService)) {
      this.pickerService.dateCompletenessChange.emit();
    }
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    const formControl = this.injector.get(NgControl, null)?.control;
    this.control = formControl;
    this.subs.add(this.formControl?.statusChanges.subscribe(() => this.setAriaInvalid()));
    this.setAriaInvalid();
    this.subs.add(this.dateInput?.nativeElement.addEventListener("keydown", this.handleKeyDown, true));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    if (this.pickerService) {
      this.pickerService.input = null;
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  /**
   * @hidden
   */
  setAriaInvalid() {
    if (!this.control) {
      return;
    }
    if (this.control.invalid) {
      this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, "true");
    } else {
      this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, "false");
    }
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl) || this.isRequired;
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidator(control) || this.maxValidator(control) || this.incompleteValidator(control, this.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  //ngModel binding
  /**
   * @hidden
   */
  writeValue(value) {
    this.verifyValue(value);
    this.value = cloneDate(value);
    this.kendoDate?.setOptions(this.options, true);
    this.kendoDateObject?.setValue(this.value);
    this.kendoDate?.refreshElementValue();
  }
  resetInput() {
    this.isDateIncomplete = false;
    this.writeValue(null);
    this.notify();
    this.showClearButton = false;
  }
  /**
   * @hidden
   */
  triggerChange() {
    const value = this.kendoDate.value;
    const oneValuePresent = isPresent3(value) !== isPresent3(this.value);
    if (+value !== +this.value || oneValuePresent) {
      this.value = cloneDate(value);
      this.notify();
    }
  }
  /**
   * @hidden
   */
  notify() {
    this.ngZone.run(() => {
      this.showClearButton = this.value ? true : false;
      this.onControlChange(cloneDate(this.value));
      this.valueChange.emit(cloneDate(this.value));
    });
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * Focuses the DateInput component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="dateinput.focus()">Focus date input</button>
   *  <kendo-dateinput #dateinput></kendo-dateinput>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.kendoDate && this.kendoDate.focus();
  }
  /**
   * Blurs the DateInput component.
   */
  blur() {
    const input = this.inputElement;
    if (input) {
      input.blur();
    }
  }
  /**
   * @hidden
   */
  handleButtonClick(offset3) {
    this.showClearButton = true;
    this.arrowDirection = Arrow.None;
    if (!this.isActive) {
      this.kendoDate.focus();
    }
    this.kendoDate.modifyDateSegmentValue(offset3);
  }
  initKendoDate() {
    const kendoDate = new DateInput(this.dateInput.nativeElement, __spreadProps(__spreadValues({}, this.options), {
      events: {
        valueChange: this.onWidgetValueChange.bind(this),
        inputEnd: this.onWidgetInputEnd.bind(this),
        focusEnd: this.onWidgetFocus.bind(this),
        blurEnd: this.onWidgetBlur.bind(this),
        keydown: this.onWidgetKeyDown.bind(this)
      }
    }));
    return kendoDate;
  }
  onWidgetValueChange() {
    this.triggerChange();
  }
  onWidgetKeyDown() {
    this.kendoDateObject = this.kendoDate.dateObject;
  }
  onWidgetInputEnd() {
    this.updateIncompleteValidationStatus();
    if (this.clearButton) {
      this.showClearButton = this.value || this.isDateIncomplete ? true : false;
      this.cdr.markForCheck();
    }
  }
  onWidgetFocus(args) {
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => {
        this.emitFocus(args.event);
      });
    } else {
      this.emitFocus(args.event);
    }
  }
  onWidgetBlur(args) {
    this.isActive = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.ngControl)) {
      this.ngZone.run(() => {
        this.onControlTouched();
        this.emitBlur(args.event);
        this.cdr.markForCheck();
      });
    } else {
      this.emitBlur(args.event);
    }
  }
  handleKeyDown(event2) {
    if (!isPresent3(event2.keyCode)) {
      event2.stopImmediatePropagation();
    }
  }
  verifyRange() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK$1} and ${MAX_DOC_LINK$1}.`);
    }
  }
  verifyValue(value) {
    if (!isDevMode()) {
      return;
    }
    if (value && !(value instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$3} for possible resolution.`);
    }
  }
  intlChange() {
    this.kendoDate.setOptions(this.options, true);
    this.updateFormatSections();
  }
  emitFocus(args) {
    this.onFocus.emit();
    if (this.pickerService) {
      this.pickerService.onFocus.emit(args);
    }
  }
  emitBlur(args) {
    this.onBlur.emit();
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
  }
  setSpinnerFill(spinner, fill, oldFill) {
    if (oldFill !== "none") {
      this.renderer.removeClass(spinner, `k-button-${oldFill}`);
      this.renderer.removeClass(spinner, `k-button-${oldFill}-base`);
    }
    this.renderer.addClass(spinner, `k-button-${fill}`);
    this.renderer.addClass(spinner, `k-button-${fill}-base`);
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
    if (this.spinners && this.fillMode !== "none") {
      this.setSpinnerFill(this.spinup.nativeElement, this.fillMode);
      this.setSpinnerFill(this.spindown.nativeElement, this.fillMode);
    }
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.dateInput.nativeElement, this.ngZone);
  }
  static ɵfac = function DateInputComponent_Factory(t) {
    return new (t || _DateInputComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateInputComponent,
    selectors: [["kendo-dateinput"]],
    viewQuery: function DateInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c10, 7);
        ɵɵviewQuery(_c11, 5);
        ɵɵviewQuery(_c122, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.spinup = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.spindown = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DateInputComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-input", ctx.wrapperClass)("k-dateinput", ctx.wrapperClass)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      pickerType: "pickerType",
      clearButton: "clearButton",
      disabled: "disabled",
      readonly: "readonly",
      title: "title",
      tabindex: "tabindex",
      role: "role",
      ariaReadOnly: "ariaReadOnly",
      tabIndex: "tabIndex",
      isRequired: "isRequired",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      steps: "steps",
      max: "max",
      min: "min",
      rangeValidation: "rangeValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      allowCaretMode: "allowCaretMode",
      autoFill: "autoFill",
      incompleteDateValidation: "incompleteDateValidation",
      twoDigitYearMax: "twoDigitYearMax",
      enableMouseWheel: "enableMouseWheel",
      value: "value",
      spinners: "spinners",
      isPopupOpen: "isPopupOpen",
      hasPopup: "hasPopup",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      valueUpdate: "valueUpdate",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendo-dateinput"],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DateInputComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DateInputComponent),
      multi: true
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.dateinput"
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DateInputComponent)
    }, LocalizationService]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 5,
    vars: 18,
    consts: () => {
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_8 = goog.getMsg("Increase value");
        i18n_8 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.dateinput.increment|The label for the **Increment** button in the DateInput:Increase value`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_9 = goog.getMsg("Decrease value");
        i18n_9 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput:Decrease value`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_10 = goog.getMsg("clear");
        i18n_10 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.dateinput.clearTitle|The title of the clear button:clear`;
      }
      return [["dateInput", ""], ["spinup", ""], ["spindown", ""], ["kendoDateInputLocalizedMessages", "", "increment", i18n_8, "decrement", i18n_9, "clearTitle", i18n_10], ["autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-input-inner", 3, "id", "title", "tabindex", "disabled", "readonly", "placeholder", "kendoEventsOutsideAngular", "scope"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "click", "mousedown", 4, "ngIf"], ["class", "k-input-spinner k-spin-button", 3, "mousedown", 4, "ngIf"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "click", "mousedown"], ["name", "x", 3, "svgIcon"], [1, "k-input-spinner", "k-spin-button", 3, "mousedown"], ["tabindex", "-1", 1, "k-spinner-increase", "k-button", "k-icon-button", 3, "mousedown", "mouseleave", "click", "title"], ["name", "caret-alt-up", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["tabindex", "-1", 1, "k-spinner-decrease", "k-button", "k-icon-button", 3, "click", "mousedown", "mouseleave", "title"], ["name", "caret-alt-down", "innerCssClass", "k-button-icon", 3, "svgIcon"]];
    },
    template: function DateInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 3);
        ɵɵelement(1, "input", 4, 0);
        ɵɵtemplate(3, DateInputComponent_span_3_Template, 2, 2, "span", 5)(4, DateInputComponent_span_4_Template, 7, 10, "span", 6);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("title", ctx.title)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("readonly", ctx.readonly)("placeholder", ctx.placeholder)("kendoEventsOutsideAngular", ɵɵpureFunction2(15, _c13, ctx.handleDragAndDrop, ctx.handleDragAndDrop))("scope", ctx);
        ɵɵattribute("required", ctx.isControlRequired ? "" : null)("role", ctx.role)("aria-readonly", ctx.ariaReadOnly)("aria-expanded", ctx.isPopupOpen)("aria-haspopup", ctx.hasPopup);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.clearButton && ctx.showClearButton);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.spinners);
      }
    },
    dependencies: [DateInputLocalizedMessagesDirective, EventsOutsideAngularDirective, NgIf, IconWrapperComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-dateinput",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateInputComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DateInputComponent),
        multi: true
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.dateinput"
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DateInputComponent)
      }, LocalizationService],
      selector: "kendo-dateinput",
      template: `
    <ng-container kendoDateInputLocalizedMessages
        i18n-increment="kendo.dateinput.increment|The label for the **Increment** button in the DateInput"
        increment="Increase value"

        i18n-decrement="kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput"
        decrement="Decrease value"

        i18n-clearTitle="kendo.dateinput.clearTitle|The title of the clear button"
        clearTitle="clear"
    >
    </ng-container>
    <input #dateInput
        class="k-input-inner"
        [attr.required]="isControlRequired ? '' : null"
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        [attr.role]="role"
        [attr.aria-readonly]="ariaReadOnly"
        [id]="focusableId"
        [title]="title"
        [tabindex]="tabindex"
        [disabled]="disabled"
        [readonly]="readonly"
        [placeholder]="placeholder"
        [attr.aria-expanded]="isPopupOpen"
        [attr.aria-haspopup]="hasPopup"
        [kendoEventsOutsideAngular]="{
            dragstart: handleDragAndDrop,
            drop: handleDragAndDrop
        }"
        [scope]="this"
        />
    <span
        *ngIf="clearButton && showClearButton"
        class="k-clear-value"
        [attr.title]="localization.get('clearTitle')"
        role="button"
        tabindex="-1"
        (click)="resetInput()"
        (mousedown)="$event.preventDefault()"
    >
        <kendo-icon-wrapper
            name="x"
            [svgIcon]="xIcon"
        >
        </kendo-icon-wrapper>
    </span>
    <span *ngIf="spinners" class="k-input-spinner k-spin-button" (mousedown)="$event.preventDefault()">
        <button
            #spinup
            tabindex="-1"
            class="k-spinner-increase k-button k-icon-button"
            [class.k-active]="arrowDirection === arrow.Up"
            (mousedown)="arrowDirection = arrow.Up"
            (mouseleave)="arrowDirection = arrow.None"
            (click)="handleButtonClick(1)"
            [title]="localization.get('increment')"
            [attr.aria-label]="localization.get('increment')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-up"
                    [svgIcon]="caretAltUpIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
        <button
            #spindown
            tabindex="-1"
            class="k-spinner-decrease k-button k-icon-button"
            (click)="handleButtonClick(-1)"
            [class.k-active]="arrowDirection === arrow.Down"
            (mousedown)="arrowDirection = arrow.Down"
            (mouseleave)="arrowDirection = arrow.None"
            [title]="localization.get('decrement')"
            [attr.aria-label]="localization.get('decrement')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-down"
                    [svgIcon]="caretAltDownIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
    </span>
  `,
      standalone: true,
      imports: [DateInputLocalizedMessagesDirective, EventsOutsideAngularDirective, NgIf, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: IntlService
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: LocalizationService
    }, {
      type: PickerService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    pickerType: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    title: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    ariaReadOnly: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    isRequired: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    isPopupOpen: [{
      type: Input
    }],
    hasPopup: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    valueUpdate: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    dateInput: [{
      type: ViewChild,
      args: ["dateInput", {
        static: true
      }]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-dateinput"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    spinup: [{
      type: ViewChild,
      args: ["spinup", {
        static: false
      }]
    }],
    spindown: [{
      type: ViewChild,
      args: ["spindown", {
        static: false
      }]
    }]
  });
})();
var PreventableEvent3 = class {
  prevented = false;
  /** @hidden */
  constructor() {
  }
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var disabledDatesValidator = (isDateDisabled) => {
  return (control) => {
    if (!isDateDisabled || !control.value) {
      return null;
    }
    const error2 = {
      disabledDate: true
    };
    return isDateDisabled(control.value) ? error2 : null;
  };
};
var CalendarCustomMessagesComponent = class _CalendarCustomMessagesComponent extends CalendarMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CalendarCustomMessagesComponent_Factory(t) {
    return new (t || _CalendarCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CalendarCustomMessagesComponent,
    selectors: [["kendo-calendar-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: CalendarMessages,
      useExisting: forwardRef(() => _CalendarCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function CalendarCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: CalendarMessages,
        useExisting: forwardRef(() => CalendarCustomMessagesComponent)
      }],
      selector: "kendo-calendar-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateInputCustomMessagesComponent = class _DateInputCustomMessagesComponent extends DateInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateInputCustomMessagesComponent_Factory(t) {
    return new (t || _DateInputCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateInputCustomMessagesComponent,
    selectors: [["kendo-dateinput-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DateInputMessages,
      useExisting: forwardRef(() => _DateInputCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function DateInputCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateInputMessages,
        useExisting: forwardRef(() => DateInputCustomMessagesComponent)
      }],
      selector: "kendo-dateinput-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DatePickerMessages = class _DatePickerMessages extends ComponentMessages {
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The title of the **Toggle** button of the DatePicker.
   */
  toggle;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  /**
   * The title of the **Clear** button of the DatePicker.
   */
  clearTitle;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDatePickerMessages_BaseFactory;
    return function DatePickerMessages_Factory(t) {
      return (ɵDatePickerMessages_BaseFactory || (ɵDatePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_DatePickerMessages)))(t || _DatePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DatePickerMessages,
    selectors: [["kendo-datepicker-messages-base"]],
    inputs: {
      today: "today",
      toggle: "toggle",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle",
      clearTitle: "clearTitle",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-datepicker-messages-base"
    }]
  }], null, {
    today: [{
      type: Input
    }],
    toggle: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var DatePickerLocalizedMessagesDirective = class _DatePickerLocalizedMessagesDirective extends DatePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DatePickerLocalizedMessagesDirective_Factory(t) {
    return new (t || _DatePickerLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DatePickerLocalizedMessagesDirective,
    selectors: [["", "kendoDatePickerLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DatePickerMessages,
      useExisting: forwardRef(() => _DatePickerLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DatePickerMessages,
        useExisting: forwardRef(() => DatePickerLocalizedMessagesDirective)
      }],
      selector: "[kendoDatePickerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var MIN_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-min";
var MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DatePickerComponent/#toc-max";
var VALUE_DOC_LINK$2 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datepicker/#toc-using-with-json";
var DEFAULT_FORMAT = "d";
var TWO_DIGIT_YEAR_MAX$1 = 68;
var DatePickerComponent = class _DatePickerComponent extends MultiTabStop {
  zone;
  localization;
  cdr;
  popupService;
  wrapper;
  renderer;
  injector;
  pickerService;
  disabledDatesService;
  adaptiveService;
  /**
   * @hidden
   */
  calendarIcon = calendarIcon;
  container;
  popupTemplate;
  toggleButton;
  actionSheet;
  /**
   * @hidden
   */
  focusableId;
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  set cellTemplateRef(template) {
    this.cellTemplate = template;
  }
  /**
   * If set to `true`, renders a clear button after the input text or DatePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * @hidden
   */
  monthCellTemplate;
  /**
   * @hidden
   */
  set monthCellTemplateRef(template) {
    this.monthCellTemplate = template;
  }
  /**
   * @hidden
   */
  yearCellTemplate;
  /**
   * @hidden
   */
  set yearCellTemplateRef(template) {
    this.yearCellTemplate = template;
  }
  /**
   * @hidden
   */
  decadeCellTemplate;
  /**
   * @hidden
   */
  set decadeCellTemplateRef(template) {
    this.decadeCellTemplate = template;
  }
  /**
   * @hidden
   */
  centuryCellTemplate;
  /**
   * @hidden
   */
  set centuryCellTemplateRef(template) {
    this.centuryCellTemplate = template;
  }
  /**
   * @hidden
   */
  weekNumberTemplate;
  /**
   * @hidden
   */
  set weekNumberTemplateRef(template) {
    this.weekNumberTemplate = template;
  }
  /**
   * @hidden
   */
  headerTitleTemplate;
  /**
   * @hidden
   */
  set headerTitleTemplateRef(template) {
    this.headerTitleTemplate = template;
  }
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  set headerTemplateRef(template) {
    this.headerTemplate = template;
  }
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  set footerTemplateRef(template) {
    this.footerTemplate = template;
  }
  /**
   * Toggles the visibility of the Calendar footer.
   * @default false
   */
  footer = false;
  /**
   * @hidden
   */
  navigationItemTemplate;
  /**
   * @hidden
   */
  set navigationItemTemplateRef(template) {
    this.navigationItemTemplate = template;
  }
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Displays the days that fall out of the current month in the Calendar ([see example]({% slug viewoptions_calendar %}#toc-displaying-other-month-days)).
   * The default values per Calendar type are:
   * - `infinite` - false
   * - `classic` - true
   */
  showOtherMonthDays;
  /**
   * Defines the active view that the Calendar initially renders
   * ([see example]({% slug viewoptions_calendar %}#toc-active-view)).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost Calendar view to which the user can navigate
   * ([see example](slug:datepicker_calendar_options#toc-view-selection-depth)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost Calendar view to which the user can navigate
   * ([see example](slug:datepicker_calendar_options#toc-view-selection-depth)).
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Specifies the Calendar type.
   *
   * The possible values are:
   * - `infinite` (default)
   * - `classic`
   *
   */
  calendarType = "infinite";
  /**
   * Determines whether to enable animation when navigating to previous/next Calendar view.
   * Applies to the [`classic`]({% slug api_dateinputs_datepickercomponent %}#toc-calendartype) Calendar only.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateCalendarNavigation = false;
  /**
   * Sets or gets the `disabled` property of the DatePicker and determines whether the component is active
   * ([see example]({% slug disabled_datepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_datepicker#toc-managing-the-datepicker-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the DatePicker
   * ([see example]({% slug readonly_datepicker %}#toc-read-only-datepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the DatePicker input field
   * ([see example]({% slug readonly_datepicker %}#toc-read-only-input)).
   *
   * > Note that if you set the [`readonly`]({% slug api_dateinputs_datepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   */
  readOnlyInput = false;
  /**
   * Configures the popup options of the DatePicker.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets or gets the `navigation` property of the Calendar
   * and determines whether the navigation side-bar is displayed.
   * ([see example]({% slug sidebar_datepicker %})).
   */
  set navigation(state2) {
    this._navigation = state2;
  }
  get navigation() {
    if (this.isAdaptive) {
      return;
    }
    return this._navigation;
  }
  _navigation = true;
  /**
   * Specifies the smallest valid date
   * ([see example]({% slug dateranges_datepicker %})).
   * By default, the `min` value is `1900-1-1`.
   */
  min = cloneDate(MIN_DATE);
  /**
   * Specifies the biggest valid date
   * ([see example]({% slug dateranges_datepicker %})).
   * By default, the `max` value is `2099-12-31`.
   */
  max = cloneDate(MAX_DATE);
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to autocorrect invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * When enabled, the DatePicker will autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Specifies the focused date of the Calendar component
   * ([see example](slug:datepicker_calendar_options#toc-focused-dates)).
   */
  focusedDate = null;
  /**
   * Specifies the value of the DatePicker component.
   *
   * > The `value` has to be a valid
   * [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value) {
    this.verifyValue(value);
    this._value = cloneDate(value);
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the date format that is used to display the input value
   * ([see example]({% slug formats_datepicker %})).
   *
   * Format value options:
   * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
   * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
   */
  format = DEFAULT_FORMAT;
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_datepicker %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX$1;
  /**
   * Defines the descriptions of the format sections in the input field.
   * ([more information and examples]({% slug placeholders_datepicker %})).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   * <div class="row example-wrapper" [style.min-height.px]="450">
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Full-length format description:</p>
   *    <kendo-datepicker formatPlaceholder="wide"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Narrow-length format description:</p>
   *    <kendo-datepicker formatPlaceholder="narrow"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Short-length format description:</p>
   *    <kendo-datepicker formatPlaceholder="short"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Display defined format:</p>
   *    <kendo-datepicker format="MM/dd/yyyy" formatPlaceholder="formatPattern"></kendo-datepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Custom defined format descriptions</p>
   *    <kendo-datepicker format="MM/dd/yyyy"
   *      [formatPlaceholder]="{ year: 'y', month: 'M', day: 'd' }"
   *    ></kendo-datepicker>
   *  </div>
   * </div>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  formatPlaceholder;
  /**
   * Specifies the hint the DatePicker displays when its value is `null`.
   * ([more information and exaples]({% slug placeholders_datepicker %})).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-datepicker placeholder="Enter birth date..."></kendo-datepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  placeholder = null;
  /**
   * Sets or gets the `tabindex` property of the DatePicker.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the dates of the DatePicker that will be disabled
   * ([see example]({% slug disabled_dates_datepicker %})).
   */
  set disabledDates(value) {
    this._disabledDates = value;
    this.disabledDatesService.initialize(value);
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Sets the title of the input element of the DatePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveSubtitle = "";
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form.
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example]( slug:disabled_dates_datepicker#toc-using-a-function)).
   */
  disabledDatesValidation = true;
  /**
   * Determines whether to display a week number column in the `month` view of the Calendar
   * ([see example](slug:datepicker_calendar_options#toc-week-number-column)).
   */
  weekNumber = false;
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size ? size : DEFAULT_SIZE2;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_datepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_datepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_datepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_datepicker)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_datepicker)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * @hidden
   */
  wrapperClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  get popupUID() {
    return this.calendar?.popupId;
  }
  popupRef;
  get isActive() {
    return this._active;
  }
  set isActive(value) {
    this._active = value;
    if (!this.wrapper) {
      return;
    }
    const element = this.wrapper.nativeElement;
    if (value) {
      this.renderer.addClass(element, "k-focus");
    } else {
      this.renderer.removeClass(element, "k-focus");
    }
  }
  get show() {
    return this._show;
  }
  set show(show) {
    if (show && (this.disabled || this.readonly)) {
      return;
    }
    const skipZone = !show && (!this._show || !hasObservers(this.close) && !hasObservers(this.open));
    if (!skipZone) {
      this.zone.run(() => {
        const event2 = new PreventableEvent3();
        if (!this._show && show) {
          this.open.emit(event2);
        } else if (this._show && !show) {
          this.close.emit(event2);
        }
        if (event2.isDefaultPrevented()) {
          return;
        }
        this.toggleCalendar(show);
      });
    } else {
      this.toggleCalendar(show);
    }
  }
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  /**
   * @hidden
   */
  windowSize;
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control);
  }
  _popupSettings = {
    animate: true
  };
  _show = false;
  _value = null;
  _active = false;
  _disabledDates;
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesValidateFn = noop$2;
  incompleteValidator = noop$2;
  resolvedPromise = Promise.resolve(null);
  subscription;
  pickerSubscriptions;
  localizationChangeSubscription;
  windowBlurSubscription;
  ariaActiveDescendantSubscription;
  control;
  domEvents = [];
  _size = DEFAULT_SIZE2;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  constructor(zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, disabledDatesService, adaptiveService) {
    super();
    this.zone = zone;
    this.localization = localization;
    this.cdr = cdr;
    this.popupService = popupService;
    this.wrapper = wrapper;
    this.renderer = renderer;
    this.injector = injector;
    this.pickerService = pickerService;
    this.disabledDatesService = disabledDatesService;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata2);
    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleSameSelection.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty.
   */
  isEmpty() {
    return !this.value && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.control = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
    this.focusableId = this.dateInput?.focusableId;
    this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
    this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    this.windowSize = this.adaptiveService.size;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    this.verifySettings();
    if (changes.min || changes.max || changes.rangeValidation || changes.disabledDatesValidation || changes.disabledDates || changes.incompleteDateValidation) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (!this.focusableId || changes.focusableId) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.isAdaptive && this.isOpen) {
      this.toggleActionSheet(false);
    }
    this.isActive = false;
    this.show = false;
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    this.pickerSubscriptions.unsubscribe();
  }
  /**
   * Indicates whether the component is currently open. That is when the popup or actionSheet is open.
   */
  get isOpen() {
    return this.show;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.verifyValue(value);
    this.value = cloneDate(value);
    this.cdr.markForCheck();
    if (!value && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleActionSheetClick(e) {
    e.preventDefault();
  }
  /**
   * Focuses the DatePicker component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="datepicker.focus()">Focus date picker</button>
   *  <kendo-datepicker #datepicker></kendo-datepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.dateInput.focus();
  }
  /**
   * Blurs the DatePicker component.
   */
  blur() {
    (this.calendar || this.dateInput)["blur"]();
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show - The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.resolvedPromise.then(() => {
      this.toggleCalendar(show === void 0 ? !this.show : show);
    });
  }
  /**
   * @hidden
   */
  handleIconClick(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    event2.preventDefault();
    this.focusInput();
    this.handleFocus();
    this.show = !this.show;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.show = true;
    }
  }
  /**
   * @hidden
   */
  handleMousedown(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  handleChange(value, isInputValueChange) {
    this.value = value;
    if (this.show) {
      if (!isInputValueChange) {
        this.focusInput();
      }
      this.show = false;
    }
    this.onControlChange(cloneDate(value));
    this.valueChange.emit(cloneDate(value));
  }
  /**
   * @hidden
   */
  handleInputChange(value) {
    this.handleChange(this.dateInput.formatSections["time"] ? value : this.mergeTime(value), true);
  }
  /**
   * @hidden
   */
  get popupClasses() {
    return ["k-datepicker-popup", "k-calendar-container"].concat(this.popupSettings.popupClass || []);
  }
  /**
   * @hidden
   */
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  get dateInput() {
    return this.pickerService.input;
  }
  get calendar() {
    return this.pickerService.calendar;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.isOpen || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   */
  mergeTime(value) {
    return this.value && value ? setTime(value, this.value) : value;
  }
  /**
   * @hidden
   */
  handleKeydown(e) {
    const {
      altKey,
      shiftKey,
      keyCode,
      target
    } = e;
    if (keyCode === Keys.Escape) {
      this.dateInput.focus();
      this.show = false;
      hasObservers(this.escape) && this.escape.emit();
    }
    if (altKey) {
      if (keyCode === Keys.ArrowDown && !this.show) {
        this.show = true;
      }
      if (keyCode === Keys.ArrowUp) {
        this.dateInput.focus();
        this.show = false;
      }
    }
    if (keyCode === Keys.Tab && this.show && this.calendar.isActive && isTabExitingCalendar(this.calendarType, target, shiftKey)) {
      this.dateInput.focus();
      this.show = false;
    }
  }
  toggleCalendar(show) {
    const previousWindowSize = this.windowSize;
    this.windowSize = this.adaptiveService.size;
    if (previousWindowSize !== this.windowSize && !show) {
      if (previousWindowSize !== "large") {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    } else {
      if (this.isAdaptive) {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    }
    this.toggleFocus();
  }
  togglePopup(show) {
    if (show === this._show) {
      return;
    }
    this._show = show;
    if (show) {
      const direction = this.localization.rtl ? "right" : "left";
      const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
      this.popupRef = this.popupService.open({
        anchor: this.wrapper,
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.popupSettings.animate,
        appendTo: this.appendTo,
        content: this.popupTemplate,
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        popupClass: this.popupClasses,
        positionMode: appendToComponent ? "fixed" : "absolute"
      });
      this.setAriaActiveDescendant();
      this.popupRef.popupElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.subscription = this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
    } else {
      this.popupRef.close();
      this.popupRef = null;
      this.subscription.unsubscribe();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
      }
      this.cdr.detectChanges();
    }
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.isOpen) {
      this.actionSheet.toggle();
      this.setAriaActiveDescendant();
      this.actionSheet.element.nativeElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    } else if (!show && this.isOpen) {
      this.actionSheet.toggle();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
        this.dateInput.focus();
      }
    }
    this._show = show;
  }
  setAriaActiveDescendant() {
    const focusedCellChangeEvent = this.calendar.type === "infinite" ? this.calendar.monthView.focusedCellChange : this.calendar.multiViewCalendar.viewList.focusedCellChange;
    this.ariaActiveDescendantSubscription = focusedCellChangeEvent.subscribe((id2) => this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant, id2));
  }
  focusInput() {
    if (touchEnabled) {
      return;
    }
    this.dateInput.focus();
  }
  toggleFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.show) {
      if (!this.calendar) {
        this.cdr.detectChanges();
      }
      if (this.calendar) {
        this.calendar.focus();
      }
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
    }
  }
  verifyValue(value) {
    if (!isDevMode()) {
      return;
    }
    if (value && !(value instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$2} for possible resolution.`);
    }
  }
  bindEvents() {
    const element = this.wrapper.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)));
    if (isWindowAvailable()) {
      this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this));
    }
  }
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleWindowBlur() {
    if (!this.isOpen || this.actionSheet.expanded) {
      return;
    }
    this.show = false;
  }
  handleBlur(args) {
    const currentTarget = args && currentFocusTarget(args);
    const target = args && args.target;
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(target) || this.actionSheet.element.nativeElement.contains(currentTarget));
    if (currentTarget && (this.dateInput.containsElement(currentTarget) || this.calendar && this.calendar.containsElement(currentTarget) || isInsideActionSheet)) {
      return;
    }
    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.blurComponent();
        this.cdr.markForCheck();
      });
    } else {
      this.blurComponent();
    }
  }
  blurComponent() {
    this.isActive = false;
    this.show = false;
    this.cdr.detectChanges();
    this.onControlTouched();
    this.onBlur.emit();
  }
  handleSameSelection() {
    if (this.show) {
      this.focusInput();
      this.show = false;
    }
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.zone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function DatePickerComponent_Factory(t) {
    return new (t || _DatePickerComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DatePickerComponent,
    selectors: [["kendo-datepicker"]],
    contentQueries: function DatePickerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NavigationItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navigationItemTemplate = _t.first);
      }
    },
    viewQuery: function DatePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 7, ViewContainerRef);
        ɵɵviewQuery(_c15, 7);
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DatePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-datepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      cellTemplateRef: [InputFlags.None, "cellTemplate", "cellTemplateRef"],
      clearButton: "clearButton",
      inputAttributes: "inputAttributes",
      monthCellTemplateRef: [InputFlags.None, "monthCellTemplate", "monthCellTemplateRef"],
      yearCellTemplateRef: [InputFlags.None, "yearCellTemplate", "yearCellTemplateRef"],
      decadeCellTemplateRef: [InputFlags.None, "decadeCellTemplate", "decadeCellTemplateRef"],
      centuryCellTemplateRef: [InputFlags.None, "centuryCellTemplate", "centuryCellTemplateRef"],
      weekNumberTemplateRef: [InputFlags.None, "weekNumberTemplate", "weekNumberTemplateRef"],
      headerTitleTemplateRef: [InputFlags.None, "headerTitleTemplate", "headerTitleTemplateRef"],
      headerTemplateRef: [InputFlags.None, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [InputFlags.None, "footerTemplate", "footerTemplateRef"],
      footer: "footer",
      navigationItemTemplateRef: [InputFlags.None, "navigationItemTemplate", "navigationItemTemplateRef"],
      weekDaysFormat: "weekDaysFormat",
      showOtherMonthDays: "showOtherMonthDays",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      calendarType: "calendarType",
      animateCalendarNavigation: "animateCalendarNavigation",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      popupSettings: "popupSettings",
      navigation: "navigation",
      min: "min",
      max: "max",
      incompleteDateValidation: "incompleteDateValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      autoFill: "autoFill",
      focusedDate: "focusedDate",
      value: "value",
      format: "format",
      twoDigitYearMax: "twoDigitYearMax",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      disabledDates: "disabledDates",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      rangeValidation: "rangeValidation",
      disabledDatesValidation: "disabledDatesValidation",
      weekNumber: "weekNumber",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      adaptiveMode: "adaptiveMode"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      close: "close",
      escape: "escape"
    },
    exportAs: ["kendo-datepicker"],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DatePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DatePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DatePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _DatePickerComponent)
    }, LocalizationService, PickerService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.datepicker"
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 17,
    vars: 49,
    consts: () => {
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_11 = goog.getMsg("Today");
        i18n_11 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.datepicker.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_12 = goog.getMsg("Toggle calendar");
        i18n_12 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.datepicker.toggle|The title of the toggle button in the datepicker component:Toggle calendar`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_13 = goog.getMsg("Navigate to previous view");
        i18n_13 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_14 = goog.getMsg("Navigate to next view");
        i18n_14 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_15 = goog.getMsg("Navigate to parent view");
        i18n_15 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.datepicker.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_16 = goog.getMsg("clear");
        i18n_16 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.datepicker.clearTitle|The title of the clear button:clear`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_17 = goog.getMsg("Close");
        i18n_17 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.datepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["input", ""], ["toggleButton", ""], ["container", ""], ["popupTemplate", ""], ["actionSheet", ""], ["calendarTemplate", ""], ["calendar", ""], ["kendoDatePickerLocalizedMessages", "", "today", i18n_11, "toggle", i18n_12, "prevButtonTitle", i18n_13, "nextButtonTitle", i18n_14, "parentViewButtonTitle", i18n_15, "clearTitle", i18n_16, "adaptiveCloseButtonTitle", i18n_17], ["pickerType", "datepicker", "hasPopup", "grid", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "role", "isPopupOpen", "clearButton", "disabled", "readonly", "ariaReadOnly", "tabindex", "isRequired", "title", "focusableId", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "inputAttributes", "value"], [3, "clearTitle"], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon"], [3, "resize", 4, "ngIf"], [3, "overlayClick", "collapse", "kendoEventsOutsideAngular", "scope", "titleId", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], ["class", "k-text-center", 4, "ngIf"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "themeColor", "primary", "fillMode", "flat", "aria-hidden", "true", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [3, "closePopup", "valueChange", "type", "size", "min", "max", "weekDaysFormat", "navigation", "animateNavigation", "activeView", "bottomView", "showOtherMonthDays", "topView", "weekNumber", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "focusedDate", "value", "kendoEventsOutsideAngular", "scope", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"]];
    },
    template: function DatePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8, 0);
        ɵɵlistener("valueChange", function DatePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputChange($event));
        })("click", function DatePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(3, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 10, 1);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵelementContainer(7, null, 2);
        ɵɵtemplate(9, DatePickerComponent_ng_template_9_Template, 1, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor)(11, DatePickerComponent_kendo_resize_sensor_11_Template, 1, 0, "kendo-resize-sensor", 12);
        ɵɵelementStart(12, "kendo-actionsheet", 13, 4);
        ɵɵlistener("overlayClick", function DatePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function DatePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, DatePickerComponent_ng_template_14_Template, 9, 6, "ng-template", 14);
        ɵɵelementEnd();
        ɵɵtemplate(15, DatePickerComponent_ng_template_15_Template, 3, 34, "ng-template", null, 5, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("role", "combobox")("isPopupOpen", ctx.show)("clearButton", ctx.clearButton)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.readOnlyInput)("ariaReadOnly", ctx.readonly)("tabindex", ctx.tabindex)("isRequired", ctx.isControlRequired)("title", ctx.adaptiveTitle)("focusableId", ctx.focusableId)("format", ctx.format)("twoDigitYearMax", ctx.twoDigitYearMax)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("autoCorrectParts", ctx.autoCorrectParts)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("autoFill", ctx.autoFill)("inputAttributes", ctx.inputAttributes)("value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵɵpureFunction2(39, _c18, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.calendarIcon);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(42, _c52, ctx.handleActionSheetClick))("scope", ctx)("titleId", ctx.calendar == null ? null : ctx.calendar.headerId)("cssClass", ɵɵpureFunction2(44, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(47, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [DatePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, CalendarComponent, CalendarCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-datepicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DatePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DatePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => DatePickerComponent)
      }, LocalizationService, PickerService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.datepicker"
      }],
      selector: "kendo-datepicker",
      template: `
        <ng-container kendoDatePickerLocalizedMessages
            i18n-today="kendo.datepicker.today|The label for the today button in the calendar header"
            today="Today"

            i18n-toggle="kendo.datepicker.toggle|The title of the toggle button in the datepicker component"
            toggle="Toggle calendar"

            i18n-prevButtonTitle="kendo.datepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
            prevButtonTitle="Navigate to previous view"

            i18n-nextButtonTitle="kendo.datepicker.nextButtonTitle|The title of the next button in the Classic calendar"
            nextButtonTitle="Navigate to next view"

            i18n-parentViewButtonTitle="kendo.datepicker.parentViewButtonTitle|The title of the parent view button in the calendar header"
            parentViewButtonTitle="Navigate to parent view"

            i18n-clearTitle="kendo.datepicker.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-adaptiveCloseButtonTitle="kendo.datepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"
        >
        </ng-container>
        <kendo-dateinput
            #input
            [role]="'combobox'"
            pickerType="datepicker"
            hasPopup="grid"
            [isPopupOpen]="show"
            [clearButton]="clearButton"
            [disabled]="disabled"
            [readonly]="readonly || readOnlyInput"
            [ariaReadOnly]="readonly"
            [tabindex]="tabindex"
            [isRequired]="isControlRequired"
            [title]="adaptiveTitle"
            [focusableId]="focusableId"
            [format]="format"
            [twoDigitYearMax]="twoDigitYearMax"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [incompleteDateValidation]="incompleteDateValidation"
            [autoCorrectParts]="autoCorrectParts"
            [autoSwitchParts]="autoSwitchParts"
            [autoSwitchKeys]="autoSwitchKeys"
            [enableMouseWheel]="enableMouseWheel"
            [allowCaretMode]="allowCaretMode"
            [autoFill]="autoFill"
            fillMode="none"
            rounded="none"
            size="none"
            [inputAttributes]="inputAttributes"
            [value]="value"
            (valueChange)="handleInputChange($event)"
            (click)="handleDateInputClick()"
        >
            <kendo-dateinput-messages
                [clearTitle]="localization.get('clearTitle')"
            >
            </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
            #toggleButton
            type="button"
            class="k-input-button k-button k-icon-button"
            [tabindex]="-1"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
            [scope]="this"
        >
            <kendo-icon-wrapper
                name="calendar"
                [svgIcon]="calendarIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
        </button>

        <ng-container #container></ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="calendarTemplate"></ng-container>
        </ng-template>

        <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <kendo-actionsheet
            #actionSheet
            (overlayClick)="show=false"
            [kendoEventsOutsideAngular]="{
                click: handleActionSheetClick
            }"
            [scope]="this"
            (collapse)="handleActionSheetCollapse()"
            [titleId]="calendar?.headerId"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center" *ngIf="adaptiveTitle">{{ adaptiveTitle }}</div>
                            <div class="k-actionsheet-subtitle k-text-center" *ngIf="adaptiveSubtitle">{{ adaptiveSubtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="check"
                                themeColor="primary"
                                [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                                [svgIcon]="checkIcon"
                                fillMode="flat"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="show = false">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content">
                    <ng-container *ngTemplateOutlet="calendarTemplate"></ng-container>
                </div>
            </ng-template>
        </kendo-actionsheet>

        <ng-template #calendarTemplate>
            <kendo-calendar
                #calendar
                [type]="calendarType"
                [size]="isAdaptive ? 'large' : size"
                [min]="min"
                [max]="max"
                [weekDaysFormat]="weekDaysFormat"
                [navigation]="navigation"
                [animateNavigation]="animateCalendarNavigation"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [showOtherMonthDays]="showOtherMonthDays"
                [topView]="topView"
                [weekNumber]="weekNumber"
                [cellTemplate]="cellTemplate"
                [monthCellTemplate]="monthCellTemplate"
                [yearCellTemplate]="yearCellTemplate"
                [decadeCellTemplate]="decadeCellTemplate"
                [centuryCellTemplate]="centuryCellTemplate"
                [weekNumberTemplate]="weekNumberTemplate"
                [headerTitleTemplate]="headerTitleTemplate"
                [headerTemplate]="headerTemplate"
                [footerTemplate]="footerTemplate"
                [footer]="footer"
                [navigationItemTemplate]="navigationItemTemplate"
                [focusedDate]="focusedDate"
                [value]="value"
                (closePopup)="show = false;"
                (valueChange)="handleChange(mergeTime($event))"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown
                }"
                [scope]="this"
                [disabledDates]="disabledDates"
            >
                <kendo-calendar-messages
                    [today]="localization.get('today')"
                    [prevButtonTitle]="localization.get('prevButtonTitle')"
                    [nextButtonTitle]="localization.get('nextButtonTitle')"
                    [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
                >
                </kendo-calendar-messages>
            </kendo-calendar>
        </ng-template>
    `,
      standalone: true,
      imports: [DatePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, CalendarComponent, CalendarCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PopupService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: PickerService
    }, {
      type: DisabledDatesService
    }, {
      type: AdaptiveService
    }];
  }, {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    focusableId: [{
      type: Input
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    cellTemplateRef: [{
      type: Input,
      args: ["cellTemplate"]
    }],
    clearButton: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplateRef: [{
      type: Input,
      args: ["monthCellTemplate"]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplateRef: [{
      type: Input,
      args: ["yearCellTemplate"]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplateRef: [{
      type: Input,
      args: ["decadeCellTemplate"]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplateRef: [{
      type: Input,
      args: ["centuryCellTemplate"]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplateRef: [{
      type: Input,
      args: ["weekNumberTemplate"]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTitleTemplateRef: [{
      type: Input,
      args: ["headerTitleTemplate"]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    footer: [{
      type: Input
    }],
    navigationItemTemplate: [{
      type: ContentChild,
      args: [NavigationItemTemplateDirective, {
        static: false
      }]
    }],
    navigationItemTemplateRef: [{
      type: Input,
      args: ["navigationItemTemplate"]
    }],
    weekDaysFormat: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    animateCalendarNavigation: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    navigation: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesValidation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-datepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var TIME_PART = {
  dayperiod: "dayperiod",
  hour: "hour",
  millisecond: "millisecond",
  minute: "minute",
  second: "second"
};
var div = domContainerFactory("div");
var ul = domContainerFactory("ul");
var li = domContainerFactory("li");
var span = domContainerFactory("span");
var listTitle = () => span("hour", "k-title k-timeselector-title");
var listItem = () => li("<span>02</span>", "k-item");
var list = () => ul([listItem()], "k-reset");
var scrollable = () => div([list()], "k-time-container k-flex k-content k-scrollable");
var actionSheetContent = (isDateTimePicker) => [isDateTimePicker ? div([div("button", "k-button k-button-lg")], "k-datetime-buttongroup") : null, div([div([span("title", "k-title")], "k-time-header"), div([listTitle(), div([scrollable()], "k-time-list")], "k-time-list-wrapper")], "k-timeselector k-timeselector-lg")];
var timeListWrapper = (isAdaptiveEnabled = false, windowSize, isDateTimePicker) => {
  if (!isDocumentAvailable()) {
    return null;
  }
  if (!isAdaptiveEnabled) {
    return div([listTitle(), div([scrollable()], "k-time-list")], "k-time-list-wrapper", {
      left: "-10000px",
      position: "absolute"
    });
  }
  return div([div([div([div([div([], "k-i-x k-button-icon k-icon")], "k-icon-wrapper-host")], "k-button k-icon-button k-button-lg")], "k-actionsheet-titlebar"), div([isDateTimePicker ? div([...actionSheetContent(isDateTimePicker)], "k-datetime-wrap k-time-tab") : actionSheetContent(isDateTimePicker)[1]], "k-actionsheet-content"), div([div("button", "k-button k-button-lg")], "k-adaptive-actionsheet k-actionsheet-footer")], `k-actionsheet k-adaptive-actionsheet ${windowSize === "small" ? "k-actionsheet-fullscreen" : ""}`, {
    height: windowSize === "small" ? "100%" : "60vh",
    left: "-10000px",
    position: "absolute",
    top: 0
  });
};
var TimePickerDOMService = class _TimePickerDOMService {
  adaptiveService;
  constructor(adaptiveService) {
    this.adaptiveService = adaptiveService;
  }
  itemHeight;
  timeListHeight;
  isAdaptiveEnabled;
  isDateTimePicker;
  get windowSize() {
    return this.adaptiveService.size;
  }
  ensureHeights() {
    if (this.timeListHeight !== void 0) {
      return;
    }
    this.calculateHeights();
  }
  calculateHeights(container) {
    if (!isDocumentAvailable()) {
      return;
    }
    let wrapper;
    let hostContainer;
    if (!this.isAdaptiveEnabled || this.windowSize === "large") {
      const listContainer = container && container.querySelector(".k-time-list-container");
      hostContainer = listContainer || document.body;
      wrapper = hostContainer.appendChild(timeListWrapper());
    } else {
      hostContainer = document.body;
      wrapper = hostContainer.appendChild(timeListWrapper(true, this.windowSize, this.isDateTimePicker));
    }
    this.timeListHeight = wrapper.querySelector(".k-scrollable").offsetHeight;
    this.itemHeight = wrapper.querySelector("li").offsetHeight;
    hostContainer.removeChild(wrapper);
  }
  isActive(element) {
    if (!isDocumentAvailable() || !element) {
      return false;
    }
    return (element.nativeElement || element) === document.activeElement;
  }
  static ɵfac = function TimePickerDOMService_Factory(t) {
    return new (t || _TimePickerDOMService)(ɵɵinject(AdaptiveService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TimePickerDOMService,
    factory: _TimePickerDOMService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerDOMService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: AdaptiveService
    }];
  }, null);
})();
var HOURS_IN_DAY = 24;
var clampToRange$3 = (rangeValue) => (value) => value % rangeValue;
var clamp$3 = clampToRange$3(HOURS_IN_DAY);
var stepper$3 = (start, step) => (idx2) => clamp$3(start + idx2 * step);
var distanceFromMin$3 = (value, min) => clamp$3(HOURS_IN_DAY + value - min);
var limit$3 = (borderValue) => (barrier, value) => {
  const useBarrier = !value || getDate(barrier).getTime() === getDate(value).getTime();
  return useBarrier ? barrier : setHours$1(barrier, borderValue);
};
var limitDown$3 = limit$3(0);
var limitUp$3 = limit$3(HOURS_IN_DAY - 1);
var HoursService = class _HoursService {
  intl;
  boundRange = false;
  insertUndividedMax = false;
  min;
  max;
  step;
  toListItem;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value, candidate) {
    return setHours$1(value, candidate.getHours());
  }
  configure(settings) {
    const {
      boundRange = this.boundRange,
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.boundRange = boundRange;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (hour) => {
      const date2 = setHours$1(MIDNIGHT_DATE, hour);
      return {
        text: this.intl.formatDate(date2, part.pattern),
        value: date2
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getHour = stepper$3(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getHour(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value) {
    return this.boundRange ? [limitDown$3(min, value), limitUp$3(max, value)] : [min, max];
  }
  total(value) {
    const last2 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
    const missing = this.isMissing(value) ? 1 : 0;
    return this.countFromMin(value) + missing + last2;
  }
  selectedIndex(value) {
    return Math.ceil(this.divideByStep(value));
  }
  valueInList(value) {
    if (!value) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastHour(value) === value.getHours();
    return matchMax || !this.isMissing(value);
  }
  addLast(data, value) {
    if (this.insertUndividedMax && this.isLastMissing(value)) {
      data.push(this.toListItem(this.lastHour(value)));
    }
    return data;
  }
  addMissing(data, value) {
    if (this.valueInList(value)) {
      return data;
    }
    const missingItem = this.toListItem(value.getHours());
    data.splice(this.selectedIndex(value), 0, missingItem);
    return data;
  }
  countFromMin(value) {
    const [min, max] = this.range(value);
    return Math.floor(distanceFromMin$3(max, min) / this.step) + 1;
  }
  isMissing(value) {
    if (!value) {
      return false;
    }
    return this.selectedIndex(value) !== this.divideByStep(value);
  }
  isLastMissing(value) {
    return this.isMissing(setHours$1(this.max, this.lastHour(value)));
  }
  divideByStep(value) {
    return distanceFromMin$3(value.getHours(), this.min.getHours()) / this.step;
  }
  lastHour(value) {
    return this.range(value)[1];
  }
  range(value) {
    const [min, max] = this.limitRange(this.min, this.max, value);
    return [min.getHours(), max.getHours()];
  }
  static ɵfac = function HoursService_Factory(t) {
    return new (t || _HoursService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _HoursService,
    factory: _HoursService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HoursService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var MINUTES_IN_HOUR = 60;
var clampToRange$2 = (rangeValue) => (value) => value % rangeValue;
var clamp$2 = clampToRange$2(MINUTES_IN_HOUR);
var stepper$2 = (start, step) => (idx2) => clamp$2(start + idx2 * step);
var distanceFromMin$2 = (value, min) => clamp$2(MINUTES_IN_HOUR + value - min);
var limit$2 = (borderValue) => (barrier, value) => {
  const useBarrier = !value || barrier.getHours() === value.getHours();
  return useBarrier ? barrier : setMinutes(barrier, borderValue);
};
var limitDown$2 = limit$2(0);
var limitUp$2 = limit$2(MINUTES_IN_HOUR - 1);
var MinutesService = class _MinutesService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value, candidate) {
    return setMinutes(value, candidate.getMinutes());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (minute) => {
      const date2 = setMinutes(MIDNIGHT_DATE, minute);
      return {
        text: this.intl.formatDate(date2, part.pattern),
        value: date2
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getMinute = stepper$2(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getMinute(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value) {
    return [limitDown$2(min, value), limitUp$2(max, value)];
  }
  total(value) {
    const last2 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
    const missing = this.isMissing(value) ? 1 : 0;
    return this.countFromMin(value) + missing + last2;
  }
  selectedIndex(value) {
    return Math.ceil(this.divideByStep(value));
  }
  valueInList(value) {
    if (!value) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastMinute(value) === value.getMinutes();
    return matchMax || !this.isMissing(value);
  }
  addLast(data, value) {
    if (this.insertUndividedMax && this.isLastMissing(value)) {
      data.push(this.toListItem(this.lastMinute(value)));
    }
    return data;
  }
  addMissing(data, value) {
    if (this.valueInList(value)) {
      return data;
    }
    const missingItem = this.toListItem(value.getMinutes());
    data.splice(this.selectedIndex(value), 0, missingItem);
    return data;
  }
  countFromMin(value) {
    const [min, max] = this.range(value);
    return Math.floor(distanceFromMin$2(max, min) / this.step) + 1;
  }
  isMissing(value) {
    if (!value) {
      return false;
    }
    return this.selectedIndex(value) !== this.divideByStep(value);
  }
  isLastMissing(value) {
    return this.isMissing(setMinutes(this.max, this.lastMinute(value)));
  }
  divideByStep(value) {
    return distanceFromMin$2(value.getMinutes(), this.min.getMinutes()) / this.step;
  }
  lastMinute(value) {
    return this.range(value)[1];
  }
  range(value) {
    const [min, max] = this.limitRange(this.min, this.max, value);
    return [min.getMinutes(), max.getMinutes()];
  }
  static ɵfac = function MinutesService_Factory(t) {
    return new (t || _MinutesService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MinutesService,
    factory: _MinutesService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinutesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var SECONDS_IN_HOUR = 60;
var clampToRange$1 = (rangeValue) => (value) => value % rangeValue;
var clamp$1 = clampToRange$1(SECONDS_IN_HOUR);
var stepper$1 = (start, step) => (idx2) => clamp$1(start + idx2 * step);
var distanceFromMin$1 = (value, min) => clamp$1(SECONDS_IN_HOUR + value - min);
var limit$1 = (borderValue) => (barrier, value) => {
  const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes();
  return useBarrier ? barrier : setSeconds(barrier, borderValue);
};
var limitDown$1 = limit$1(0);
var limitUp$1 = limit$1(SECONDS_IN_HOUR - 1);
var SecondsService = class _SecondsService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value, candidate) {
    return setSeconds(value, candidate.getSeconds());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      part,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (second) => {
      const date2 = setSeconds(MIDNIGHT_DATE, second);
      return {
        text: this.intl.formatDate(date2, part.pattern),
        value: date2
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getSecond = stepper$1(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getSecond(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value) {
    return [limitDown$1(min, value), limitUp$1(max, value)];
  }
  total(value) {
    const last2 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
    const missing = this.isMissing(value) ? 1 : 0;
    return this.countFromMin(value) + missing + last2;
  }
  selectedIndex(value) {
    return Math.ceil(this.divideByStep(value));
  }
  valueInList(value) {
    if (!value) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastSecond(value) === value.getSeconds();
    return matchMax || !this.isMissing(value);
  }
  divideByStep(value) {
    return distanceFromMin$1(value.getSeconds(), this.min.getSeconds()) / this.step;
  }
  addLast(data, value) {
    if (this.insertUndividedMax && this.isLastMissing(value)) {
      data.push(this.toListItem(this.lastSecond(value)));
    }
    return data;
  }
  addMissing(data, value) {
    if (this.valueInList(value)) {
      return data;
    }
    const missingItem = this.toListItem(value.getSeconds());
    data.splice(this.selectedIndex(value), 0, missingItem);
    return data;
  }
  countFromMin(value) {
    const [min, max] = this.range(value);
    return Math.floor(distanceFromMin$1(max, min) / this.step) + 1;
  }
  isMissing(value) {
    if (!value) {
      return false;
    }
    return this.selectedIndex(value) !== this.divideByStep(value);
  }
  isLastMissing(value) {
    return this.isMissing(setSeconds(this.max, this.lastSecond(value)));
  }
  lastSecond(value) {
    return this.range(value)[1];
  }
  range(value) {
    const [min, max] = this.limitRange(this.min, this.max, value);
    return [min.getSeconds(), max.getSeconds()];
  }
  static ɵfac = function SecondsService_Factory(t) {
    return new (t || _SecondsService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SecondsService,
    factory: _SecondsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SecondsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var MILLISECONDS_IN_SECOND = 1e3;
var clampToRange = (rangeValue) => (value) => value % rangeValue;
var clamp2 = clampToRange(MILLISECONDS_IN_SECOND);
var stepper = (start, step) => (idx2) => clamp2(start + idx2 * step);
var distanceFromMin = (value, min) => clamp2(MILLISECONDS_IN_SECOND + value - min);
var limit = (borderValue) => (barrier, value) => {
  const useBarrier = !value || barrier.getHours() === value.getHours() && barrier.getMinutes() === value.getMinutes() && barrier.getSeconds() === value.getSeconds();
  return useBarrier ? barrier : setMilliseconds(barrier, borderValue);
};
var limitDown = limit(0);
var limitUp = limit(MILLISECONDS_IN_SECOND - 1);
var MillisecondsService = class _MillisecondsService {
  intl;
  toListItem;
  min;
  max;
  step;
  insertUndividedMax = false;
  constructor(intl) {
    this.intl = intl;
  }
  apply(value, candidate) {
    return setMilliseconds(value, candidate.getMilliseconds());
  }
  configure(settings) {
    const {
      insertUndividedMax = this.insertUndividedMax,
      min = this.min,
      max = this.max,
      step = this.step
    } = settings;
    this.insertUndividedMax = insertUndividedMax;
    this.toListItem = (millisecond) => {
      const date2 = setMilliseconds(MIDNIGHT_DATE, millisecond);
      return {
        text: this.intl.formatDate(date2, "SSS"),
        value: date2
      };
    };
    this.min = min;
    this.max = max;
    this.step = step;
  }
  data(selectedValue) {
    const [min] = this.range(selectedValue);
    const getMillisecond = stepper(min, this.step);
    const convertToItem = (idx2) => this.toListItem(getMillisecond(idx2));
    const data = range(0, this.countFromMin(selectedValue)).map(convertToItem);
    this.addLast(data);
    this.addMissing(data, selectedValue);
    return data;
  }
  isRangeChanged(min, max) {
    return !isEqual(this.min, min) || !isEqual(this.max, max);
  }
  limitRange(min, max, value) {
    return [limitDown(min, value), limitUp(max, value)];
  }
  total(value) {
    const last2 = this.insertUndividedMax && this.isLastMissing(value) ? 1 : 0;
    const missing = this.isMissing(value) ? 1 : 0;
    return this.countFromMin(value) + missing + last2;
  }
  selectedIndex(value) {
    return Math.ceil(this.divideByStep(value));
  }
  valueInList(value) {
    if (!value) {
      return true;
    }
    const matchMax = this.insertUndividedMax && this.lastMillisecond(value) === value.getMilliseconds();
    return matchMax || !this.isMissing(value);
  }
  divideByStep(value) {
    return distanceFromMin(value.getMilliseconds(), this.min.getMilliseconds()) / this.step;
  }
  addLast(data, value) {
    if (this.insertUndividedMax && this.isLastMissing(value)) {
      data.push(this.toListItem(this.lastMillisecond(value)));
    }
    return data;
  }
  addMissing(data, value) {
    if (this.valueInList(value)) {
      return data;
    }
    const missingItem = this.toListItem(value.getMilliseconds());
    data.splice(this.selectedIndex(value), 0, missingItem);
    return data;
  }
  countFromMin(value) {
    const [min, max] = this.range(value);
    return Math.floor(distanceFromMin(max, min) / this.step) + 1;
  }
  isMissing(value) {
    if (!value) {
      return false;
    }
    return this.selectedIndex(value) !== this.divideByStep(value);
  }
  isLastMissing(value) {
    return this.isMissing(setMilliseconds(this.max, this.lastMillisecond(value)));
  }
  lastMillisecond(value) {
    return this.range(value)[1];
  }
  range(value) {
    const [min, max] = this.limitRange(this.min, this.max, value);
    return [min.getMilliseconds(), max.getMilliseconds()];
  }
  static ɵfac = function MillisecondsService_Factory(t) {
    return new (t || _MillisecondsService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MillisecondsService,
    factory: _MillisecondsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MillisecondsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var setHours = (date2, hours) => {
  const clone = cloneDate(date2);
  clone.setHours(hours);
  return clone;
};
var isAM = (value) => value !== null && value < 12;
var isPM = (value) => value !== null && (!value || value > 11);
var inRange = (value, min, max) => !min && !max || value >= min && value <= max;
var inReverseRange = (value, min, max) => !min && !max || value >= min || value <= max;
var DayPeriodService = class _DayPeriodService {
  intl;
  min;
  max;
  part;
  constructor(intl) {
    this.intl = intl;
  }
  /**
   * @hidden
   */
  apply(value, candidate) {
    const hour = value.getHours();
    const hourAM = isAM(hour);
    const candidateAM = isAM(candidate.getHours());
    if (hourAM && candidateAM || !hourAM && !candidateAM) {
      return value;
    }
    const [min, max = 24] = this.normalizedRange();
    const result = hour + (candidateAM ? -12 : 12);
    return setHours(value, Math.min(Math.max(min, result), max || 24));
  }
  /**
   * @hidden
   */
  configure(settings) {
    const {
      min = this.min,
      max = this.max,
      part = this.part
    } = settings;
    this.min = min;
    this.max = max;
    this.part = part;
  }
  /**
   * @hidden
   */
  data(_) {
    const names = this.part.names;
    if (!names) {
      return [];
    }
    const data = [];
    const [min, max] = this.normalizedRange();
    const dayPeriod = this.intl.dateFormatNames(names);
    if (isAM(min)) {
      data.push({
        text: dayPeriod.am,
        value: setHours(this.min, min)
      });
    }
    if (isPM(max)) {
      data.push({
        text: dayPeriod.pm,
        value: setHours(this.min, Math.max(12, max))
      });
    }
    return this.min.getHours() !== min ? data.reverse() : data;
  }
  /**
   * @hidden
   */
  isRangeChanged(_, __) {
    return false;
  }
  /**
   * @hidden
   */
  limitRange(min, max, _) {
    return [min, max];
  }
  /**
   * @hidden
   */
  total() {
    const [min, max] = this.normalizedRange();
    if (!min && !max) {
      return 2;
    }
    if (min > 11 || max < 12) {
      return 1;
    }
    return 2;
  }
  /**
   * @hidden
   */
  selectedIndex(value) {
    if (!this.valueInList(value)) {
      return -1;
    }
    const index = Math.floor(value.getHours() / 12);
    return this.min.getHours() === this.normalizedRange()[0] ? index : index === 0 ? 1 : 0;
  }
  /**
   * @hidden
   */
  valueInList(value) {
    const reverse = this.min.getHours() !== this.normalizedRange()[0];
    const isInRange2 = reverse ? inReverseRange : inRange;
    return isInRange2(value.getHours(), this.min.getHours(), this.max.getHours());
  }
  normalizedRange() {
    const minHour = this.min.getHours();
    const maxHour = this.max.getHours();
    return [Math.min(minHour, maxHour), Math.max(minHour, maxHour)];
  }
  static ɵfac = function DayPeriodService_Factory(t) {
    return new (t || _DayPeriodService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DayPeriodService,
    factory: _DayPeriodService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DayPeriodService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var SNAP_THRESHOLD = 0.05;
var SCROLL_THRESHOLD = 2;
var nil = () => null;
var getters = {
  35: (data, _) => data[data.length - 1],
  36: (data, _) => data[0],
  38: (data, index) => data[index - 1],
  40: (data, index) => data[index + 1]
};
var services = {
  [TIME_PART.dayperiod]: DayPeriodService,
  [TIME_PART.hour]: HoursService,
  [TIME_PART.minute]: MinutesService,
  [TIME_PART.second]: SecondsService,
  [TIME_PART.millisecond]: MillisecondsService
};
var TimeListComponent = class _TimeListComponent {
  element;
  injector;
  dom;
  renderer;
  zone;
  localization;
  min = cloneDate(MIDNIGHT_DATE);
  max = cloneDate(MAX_TIME);
  part;
  step = 1;
  disabled = false;
  value;
  isLast = false;
  isFirst = false;
  valueChange = new EventEmitter();
  tabOutLastPart = new EventEmitter();
  tabOutFirstPart = new EventEmitter();
  virtualization;
  get tabIndex() {
    return this.disabled ? void 0 : 0;
  }
  componentClass = true;
  get isDayPeriod() {
    return this.part?.type === "dayperiod";
  }
  get currentSelectedIndex() {
    return this.selectedIndex(this.value);
  }
  get roleAttribute() {
    return "listbox";
  }
  get ariaLabel() {
    return this.localization.get(this.part?.type);
  }
  animateToIndex = true;
  isActive = false;
  skip = 0;
  total = 60;
  service;
  itemHeight;
  listHeight;
  topOffset;
  bottomOffset;
  bottomThreshold;
  topThreshold;
  style;
  data = [];
  indexToScroll = -1;
  scrollSubscription;
  domEvents = [];
  constructor(element, injector, dom, renderer, zone, localization) {
    this.element = element;
    this.injector = injector;
    this.dom = dom;
    this.renderer = renderer;
    this.zone = zone;
    this.localization = localization;
  }
  ngOnChanges(changes) {
    if (changes.part) {
      this.service = this.injector.get(services[this.part.type]);
      this.service.configure(this.serviceSettings());
    }
    const value = this.value;
    const valueChanges = changes.value || {};
    const [min, max] = this.service.limitRange(this.min, this.max, value);
    if (this.service.isRangeChanged(min, max) || changes.min || changes.max || changes.step) {
      this.data = [];
      this.service.configure(this.serviceSettings({
        min,
        max
      }));
    }
    if (!this.data.length || this.hasMissingValue(valueChanges)) {
      this.animateToIndex = false;
      this.data = this.service.data(value);
    }
    this.animateToIndex = this.animateToIndex && this.textHasChanged(valueChanges);
    this.total = this.service.total(value);
    this.indexToScroll = this.selectedIndex(value);
  }
  ngOnInit() {
    this.animateToIndex = true;
    this.dom.ensureHeights();
    this.itemHeight = this.dom.itemHeight;
    this.listHeight = this.dom.timeListHeight;
    this.topOffset = (this.listHeight - this.itemHeight) / 2;
    this.bottomOffset = this.listHeight - this.itemHeight;
    this.topThreshold = this.itemHeight * SNAP_THRESHOLD;
    this.bottomThreshold = this.itemHeight * (1 - SNAP_THRESHOLD);
    const translate = `translateY(${this.topOffset}px)`;
    this.style = {
      transform: translate,
      "-ms-transform": translate
    };
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
  }
  ngOnDestroy() {
    this.scrollSubscription.unsubscribe();
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  ngAfterViewInit() {
    this.scrollOnce((index) => this.virtualization.scrollToIndex(index));
  }
  ngAfterViewChecked() {
    this.scrollOnce((index) => {
      const action = this.animateToIndex ? "animateToIndex" : "scrollToIndex";
      this.virtualization[action](index);
      this.animateToIndex = true;
    });
  }
  getCurrentItem() {
    return this.indexToScroll >= 0 ? this.data[this.indexToScroll] : null;
  }
  handleChange(dataItem) {
    const candidate = this.service.apply(this.value, dataItem.value);
    if (this.value.getTime() === candidate.getTime()) {
      return;
    }
    this.indexToScroll = this.data.indexOf(dataItem);
    this.value = candidate;
    this.valueChange.emit(candidate);
  }
  handleItemClick(args) {
    const item = closestInScope(args.target, (node) => node.hasAttribute("data-timelist-item-index"), this.element.nativeElement);
    if (item) {
      const index = item.getAttribute("data-timelist-item-index");
      this.handleChange(this.data[index]);
    }
  }
  /**
   * Focuses the host element of the TimeList.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="timelist.focus()">Focus TimeList</button>
   *  <kendo-timelist #timelist></kendo-timelist>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.focus();
  }
  /**
   * Blurs the TimeList component.
   */
  blur() {
    if (!this.element) {
      return;
    }
    this.element.nativeElement.blur();
  }
  itemOffset(scrollTop) {
    const valueIndex = this.selectedIndex(this.value);
    const activeIndex = this.virtualization.activeIndex();
    const offset3 = this.virtualization.itemOffset(activeIndex);
    const distance = Math.abs(Math.ceil(scrollTop) - offset3);
    if (valueIndex === activeIndex && distance < SCROLL_THRESHOLD) {
      return offset3;
    }
    const scrollUp = valueIndex > activeIndex;
    const moveToNext = scrollUp && distance >= this.bottomThreshold || !scrollUp && distance > this.topThreshold;
    return moveToNext ? this.virtualization.itemOffset(activeIndex + 1) : offset3;
  }
  hasMissingValue({
    previousValue,
    currentValue
  }) {
    const isPreviousMissing = previousValue && !this.service.valueInList(previousValue);
    const isCurrentMissing = currentValue && !this.service.valueInList(currentValue);
    return isPreviousMissing || isCurrentMissing;
  }
  scrollOnce(action) {
    if (this.indexToScroll !== -1) {
      action(this.indexToScroll);
      this.indexToScroll = -1;
    }
  }
  serviceSettings(settings) {
    const defaults2 = {
      boundRange: false,
      insertUndividedMax: false,
      max: this.max,
      min: this.min,
      part: this.part,
      step: this.step
    };
    const result = Object.assign({}, defaults2, settings);
    result.boundRange = result.part.type !== "hour";
    return result;
  }
  selectedIndex(value) {
    if (!value) {
      return -1;
    }
    return this.service.selectedIndex(value);
  }
  textHasChanged({
    previousValue,
    currentValue
  }) {
    if (!previousValue || !currentValue) {
      return false;
    }
    const oldData = this.data[this.selectedIndex(previousValue)];
    const newData = this.data[this.selectedIndex(currentValue)];
    return oldData && newData && oldData.text !== newData.text;
  }
  handleKeyDown(e) {
    if (e.keyCode === Keys.Tab && !e.shiftKey && this.isLast) {
      e.preventDefault();
      this.tabOutLastPart.emit();
    }
    if (e.keyCode === Keys.Tab && e.shiftKey && this.isFirst) {
      e.preventDefault();
      this.tabOutFirstPart.emit();
    }
    const getter3 = getters[e.keyCode] || nil;
    const dataItem = getter3(this.data, this.service.selectedIndex(this.value));
    if (dataItem) {
      this.handleChange(dataItem);
      e.preventDefault();
    }
  }
  bindEvents() {
    this.scrollSubscription = this.virtualization.scroll$().pipe(debounceTime(100), map((e) => e.target.scrollTop), map((top) => this.itemOffset(top)), map((itemOffset) => this.virtualization.itemIndex(itemOffset))).subscribe((index) => {
      this.virtualization.scrollToIndex(index);
      this.handleChange(this.data[index]);
    });
    const element = this.element.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "mouseover", () => !this.isActive && this.focus()), this.renderer.listen(element, "click", () => this.focus()), this.renderer.listen(element, "blur", () => this.isActive = false), this.renderer.listen(element, "focus", () => this.isActive = true), this.renderer.listen(element, "keydown", this.handleKeyDown.bind(this)));
  }
  static ɵfac = function TimeListComponent_Factory(t) {
    return new (t || _TimeListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(TimePickerDOMService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeListComponent,
    selectors: [["kendo-timelist"]],
    viewQuery: function TimeListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(VirtualizationComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualization = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function TimeListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("tabindex", ctx.tabIndex);
        ɵɵclassProp("k-time-list", ctx.componentClass);
      }
    },
    inputs: {
      min: "min",
      max: "max",
      part: "part",
      step: "step",
      disabled: "disabled",
      value: "value",
      isLast: "isLast",
      isFirst: "isFirst"
    },
    outputs: {
      valueChange: "valueChange",
      tabOutLastPart: "tabOutLastPart",
      tabOutFirstPart: "tabOutFirstPart"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 16,
    consts: [["tabindex", "-1", 1, "k-time-container", 3, "skip", "take", "total", "itemHeight", "maxScrollDifference", "topOffset", "bottomOffset"], [1, "k-reset", 3, "ngStyle", "kendoEventsOutsideAngular", "scope"], ["class", "k-item", 4, "ngFor", "ngForOf"], [1, "k-item"]],
    template: function TimeListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-virtualization", 0)(1, "ul", 1);
        ɵɵtemplate(2, TimeListComponent_li_2_Template, 3, 4, "li", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("skip", ctx.skip)("take", ctx.total)("total", ctx.total)("itemHeight", ctx.itemHeight)("maxScrollDifference", ctx.listHeight)("topOffset", ctx.topOffset)("bottomOffset", ctx.bottomOffset);
        ɵɵattribute("role", ctx.roleAttribute)("aria-label", ctx.ariaLabel);
        ɵɵadvance();
        ɵɵproperty("ngStyle", ctx.style)("kendoEventsOutsideAngular", ɵɵpureFunction1(14, _c52, ctx.handleItemClick))("scope", ctx);
        ɵɵattribute("role", "presentation");
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.data);
      }
    },
    dependencies: [VirtualizationComponent, NgStyle, EventsOutsideAngularDirective, NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-timelist",
      template: `
    <kendo-virtualization
        [attr.role]="roleAttribute"
        [attr.aria-label]="ariaLabel"
        [skip]="skip"
        [take]="total"
        [total]="total"
        [itemHeight]="itemHeight"
        [maxScrollDifference]="listHeight"
        [topOffset]="topOffset"
        [bottomOffset]="bottomOffset"
        class="k-time-container"
        tabindex="-1"
    >
        <ul [ngStyle]="style" class="k-reset"
            [kendoEventsOutsideAngular]="{
                click: handleItemClick
            }"
            [scope]="this"
            [attr.role]="'presentation'"
        >
            <li *ngFor="let item of data; let index = index;" class="k-item"
                [attr.data-timelist-item-index]="index"
                [attr.role]="'option'"
                [attr.aria-selected]="index === currentSelectedIndex"
                >
                <span>{{item.text}}</span>
            </li>
        </ul>
    </kendo-virtualization>
  `,
      standalone: true,
      imports: [VirtualizationComponent, NgStyle, EventsOutsideAngularDirective, NgForOf]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Injector
    }, {
      type: TimePickerDOMService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: LocalizationService
    }];
  }, {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    part: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isFirst: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    tabOutLastPart: [{
      type: Output
    }],
    tabOutFirstPart: [{
      type: Output
    }],
    virtualization: [{
      type: ViewChild,
      args: [VirtualizationComponent, {
        static: true
      }]
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    componentClass: [{
      type: HostBinding,
      args: ["class.k-time-list"]
    }]
  });
})();
var isEqualTillMinute = (value, min) => value.getHours() === min.getHours() && value.getMinutes() === min.getMinutes();
var isEqualTillSecond = (value, min) => isEqualTillMinute(value, min) && value.getSeconds() === min.getSeconds();
var isEqualTillMillisecond = (value, min) => isEqualTillSecond(value, min) && value.getMilliseconds() === min.getMilliseconds();
var defaultGetters = [{
  type: TIME_PART.hour,
  getter: (value) => value.getHours(),
  minGetter: (_, min) => min.getHours()
}, {
  type: TIME_PART.minute,
  getter: (value) => value.getMinutes(),
  minGetter: (value, min) => isEqualTillMinute(value, min) ? min.getMinutes() : 0
}, {
  type: TIME_PART.second,
  getter: (value) => value.getSeconds(),
  minGetter: (value, min) => isEqualTillSecond(value, min) ? min.getSeconds() : 0
}, {
  type: TIME_PART.millisecond,
  getter: (value) => value.getMilliseconds(),
  minGetter: (value, min) => isEqualTillMillisecond(value, min) ? min.getMilliseconds() : 0
}];
var left = (getter3) => (origin, _) => getter3(origin);
var right = (getter3) => (_, candidate) => getter3(candidate);
var convertToObject = (parts) => parts.reduce((obj, p) => {
  obj[p.type] = p.type;
  return obj;
}, {});
var getterByPart = (parts) => (g) => parts[g.type] ? right(g.getter) : left(g.getter);
var gettersFactory = (getters2) => (parts) => getters2.map(getterByPart(convertToObject(parts)));
var snapValue = (getter3, minGetter, step) => (date2, min) => {
  const value = getter3(date2);
  const minValue = minGetter(date2, min);
  const rest = value - minValue;
  if (rest < 0) {
    return minValue;
  }
  const mod = rest % step;
  return value - mod + (mod > step / 2 ? step : 0);
};
var snappersFactory = (getters2) => (steps) => getters2.map((g) => {
  const step = steps[g.type];
  return step ? snapValue(g.getter, g.minGetter, step) : g.getter;
});
var generateGetters = gettersFactory(defaultGetters);
var generateSnappers = snappersFactory(defaultGetters);
var valueMerger = (getters2) => (origin, candidate) => {
  origin.setHours(...getters2.map((g) => g(origin, candidate)));
  return origin;
};
var snapTime = (snappers) => (candidate, min) => {
  const date2 = cloneDate(candidate);
  date2.setHours(...snappers.map((s) => s(date2, min)));
  return date2;
};
var TimePickerMessages = class _TimePickerMessages extends ComponentMessages {
  /**
   * The text of the **Accept** button in the popup footer of the TimeList.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the TimeList.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the TimeList.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the TimeList.
   */
  cancelLabel;
  /**
   * The text of the **Now** button in the popup header of the TimeList.
   */
  now;
  /**
   * The label of the **Now** button in the popup header of the TimeList.
   */
  nowLabel;
  /**
   * The title of the **Toggle** button of the TimePicker.
   */
  toggle;
  /**
   * The label of the **Hour** part in the TimePicker.
   */
  hour;
  /**
   * The label of the **Minute** part in the TimePicker.
   */
  minute;
  /**
   * The label of the **Second** part in the TimePicker.
   */
  second;
  /**
   * The label of the **Millisecond** part in the TimePicker.
   */
  millisecond;
  /**
   * The label of the **Dayperiod** part in the TimePicker.
   */
  dayperiod;
  /**
   * The title of the **Clear** button of the TimePicker.
   */
  clearTitle;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTimePickerMessages_BaseFactory;
    return function TimePickerMessages_Factory(t) {
      return (ɵTimePickerMessages_BaseFactory || (ɵTimePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_TimePickerMessages)))(t || _TimePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TimePickerMessages,
    selectors: [["kendo-timepicker-messages-base"]],
    inputs: {
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      now: "now",
      nowLabel: "nowLabel",
      toggle: "toggle",
      hour: "hour",
      minute: "minute",
      second: "second",
      millisecond: "millisecond",
      dayperiod: "dayperiod",
      clearTitle: "clearTitle",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-timepicker-messages-base"
    }]
  }], null, {
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    now: [{
      type: Input
    }],
    nowLabel: [{
      type: Input
    }],
    toggle: [{
      type: Input
    }],
    hour: [{
      type: Input
    }],
    minute: [{
      type: Input
    }],
    second: [{
      type: Input
    }],
    millisecond: [{
      type: Input
    }],
    dayperiod: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var TimeSelectorLocalizedMessagesDirective = class _TimeSelectorLocalizedMessagesDirective extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function TimeSelectorLocalizedMessagesDirective_Factory(t) {
    return new (t || _TimeSelectorLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimeSelectorLocalizedMessagesDirective,
    selectors: [["", "kendoTimeSelectorLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimeSelectorLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimeSelectorLocalizedMessagesDirective)
      }],
      selector: "[kendoTimeSelectorLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var listReducer = (state2, list2, idx2, all) => {
  if (state2.length || !list2.isActive) {
    return state2;
  }
  return [{
    next: all[idx2 + 1] || list2,
    prev: all[idx2 - 1] || list2
  }];
};
var Direction2;
(function(Direction3) {
  Direction3[Direction3["Left"] = 0] = "Left";
  Direction3[Direction3["Right"] = 1] = "Right";
})(Direction2 || (Direction2 = {}));
var TimeSelectorComponent = class _TimeSelectorComponent {
  localization;
  cdr;
  element;
  intl;
  dom;
  zone;
  renderer;
  pickerService;
  accept;
  cancel;
  now;
  timeLists;
  timeListWrappers;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * Specifies the time format used to display the time list columns.
   */
  format = "t";
  /**
   * Specifies the smallest valid time value.
   */
  min = cloneDate(MIN_TIME);
  /**
   * Specifies the biggest valid time value.
   */
  max = cloneDate(MAX_TIME);
  /**
   * Determines whether to display the **Cancel** button in the popup.
   */
  cancelButton = true;
  /**
   * Determines whether to display the **Set** button in the popup.
   */
  setButton = true;
  /**
   * Determines whether to display the **Now** button in the popup.
   *
   * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
   */
  nowButton = true;
  /**
   * Sets or gets the `disabled` property of the TimeSelector and determines whether the component is active.
   */
  disabled = false;
  /**
   * Needed in order to set it in the dom service so that timeselector height can be properly calculated
   */
  isAdaptiveEnabled;
  isDateTimePicker;
  /**
   * Configures the incremental steps of the TimeSelector.
   *
   * The available options are:
   * - `hour: Number`&mdash;Controls the incremental step of the hour value.
   * - `minute: Number`&mdash;Controls the incremental step of the minute value.
   * - `second: Number`&mdash;Controls the incremental step of the second value.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-timeselector format="HH:mm:ss" [steps]="steps"></kendo-timeselector>
   * `
   * })
   * export class AppComponent {
   *   public steps = { hour: 2, minute: 15, second: 15 };
   * }
   * ```
   *
   * > If the incremental step is greater than `1`, the **Now** button will be hidden.
   */
  set steps(steps) {
    this._steps = steps || {};
  }
  get steps() {
    return this._steps;
  }
  /**
   * Specifies the value of the TimeSelector component.
   */
  value = null;
  /**
   * Fires each time the user selects a new value.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user cancels the selected value.
   */
  valueReject = new EventEmitter();
  tabOutLastPart = new EventEmitter();
  tabOutFirstPart = new EventEmitter();
  tabOutNow = new EventEmitter();
  dateFormatParts;
  isActive = false;
  showNowButton = true;
  set current(value) {
    this._current = timeInRange(this.snapTime(cloneDate(value || MIDNIGHT_DATE), this.min), this.min, this.max);
    if (!NgZone.isInAngularZone()) {
      this.cdr.detectChanges();
    }
  }
  get current() {
    return this._current;
  }
  get activeListIndex() {
    return this._activeListIndex;
  }
  set activeListIndex(value) {
    this._activeListIndex = value;
    if (!this.timeListWrappers || !this.timeListWrappers.length) {
      return;
    }
    this.timeListWrappers.forEach((listWrapper) => {
      this.renderer.removeClass(listWrapper.nativeElement, "k-focus");
    });
    if (value >= 0) {
      const listIndex = this.listIndex(value);
      const focusedWrapper = this.timeListWrappers.toArray()[listIndex];
      if (focusedWrapper) {
        this.renderer.addClass(focusedWrapper.nativeElement, "k-focus");
      }
    }
  }
  mergeValue;
  snapTime;
  _activeListIndex = -1;
  _current;
  _steps = {};
  subscriptions;
  domEvents = [];
  constructor(localization, cdr, element, intl, dom, zone, renderer, pickerService) {
    this.localization = localization;
    this.cdr = cdr;
    this.element = element;
    this.intl = intl;
    this.dom = dom;
    this.zone = zone;
    this.renderer = renderer;
    this.pickerService = pickerService;
    if (this.pickerService) {
      this.pickerService.timeSelector = this;
    }
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
    if (this.localization) {
      this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    }
    this.renderer.addClass(this.element.nativeElement, "k-timeselector");
    this.dom.isAdaptiveEnabled = this.isAdaptiveEnabled;
    this.dom.isDateTimePicker = this.isDateTimePicker;
    this.dom.calculateHeights(this.element.nativeElement);
    this.init();
    this.bindEvents();
  }
  /**
   * @hidden
   */
  ngOnChanges() {
    this.init();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.pickerService) {
      this.pickerService.timeSelector = null;
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
  }
  /**
   * Focuses the TimeSelector component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="timeselector.focus()">Focus time picker</button>
   *  <kendo-timeselector #timeselector></kendo-timeselector>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    const list2 = this.timeLists.first;
    if (!list2) {
      return;
    }
    list2.focus();
  }
  /**
   * Blurs the TimeSelector component.
   */
  blur() {
    const list2 = this.timeLists.first;
    if (!list2) {
      return;
    }
    list2.blur();
  }
  /**
   * @hidden
   */
  handleAccept() {
    this.handleChange(this.mergeValue(cloneDate(this.value || getDate(getNow())), this.current));
  }
  /**
   * @hidden
   */
  handleNow() {
    this.current = getNow();
    this.handleChange(this.current);
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleReject() {
    this.current = this.value;
    this.valueReject.emit();
  }
  /**
   * @hidden
   */
  handleFocus(args) {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    this.emitFocus(args);
  }
  /**
   * @hidden
   */
  handleListFocus(args) {
    const index = parseInt(args.target.getAttribute("data-timelist-index"), 10);
    this.activeListIndex = index;
    this.handleFocus(args);
  }
  /**
   * @hidden
   */
  handleBlur(args) {
    const currentTarget = currentFocusTarget(args);
    if (currentTarget && this.containsElement(currentTarget)) {
      return;
    }
    this.activeListIndex = -1;
    this.isActive = false;
    this.emitBlur(args);
  }
  /**
   * @hidden
   */
  containsElement(element) {
    return Boolean(closest2(element, (node) => node === this.element.nativeElement));
  }
  /**
   * @hidden
   */
  handleTabOut(event2) {
    const {
      keyCode,
      shiftKey
    } = event2;
    if (event2.target === this.now?.nativeElement && keyCode === Keys.Tab && shiftKey) {
      event2.preventDefault();
      if (this.isDateTimePicker) {
        this.tabOutNow.emit();
      } else {
        this.cancel ? this.cancel.nativeElement.focus() : this.accept?.nativeElement.focus();
      }
      return;
    }
    if (keyCode === Keys.Tab && !shiftKey && event2.target !== this.now?.nativeElement) {
      event2.preventDefault();
      if (document.activeElement === this.accept.nativeElement) {
        if (this.cancel) {
          this.cancel.nativeElement.focus();
        } else {
          this.now ? this.now.nativeElement.focus() : this.timeLists.first.focus();
        }
      } else {
        this.now ? this.now.nativeElement.focus() : this.timeLists.first.focus();
      }
    }
  }
  partStep(part) {
    return this.steps[part.type] || 1;
  }
  init(changes) {
    if (!changes || hasChange(changes, "format")) {
      this.dateFormatParts = this.intl.splitDateFormat(this.format);
      this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
    }
    if (!changes || hasChange(changes, "steps")) {
      this.snapTime = snapTime(generateSnappers(this.steps));
    }
    if (!changes || hasChange(changes, "value")) {
      this.current = this.value;
    }
    this.showNowButton = !this.hasSteps() && this.nowButton && isInTimeRange(getNow(), this.min, this.max);
  }
  focusList(dir2) {
    if (!this.timeLists.length) {
      return;
    }
    this.timeLists.reduce(listReducer, []).map((state2) => dir2 === Direction2.Right ? state2.next : state2.prev).map((list2) => list2 && list2.focus());
  }
  handleChange(value) {
    this.value = value;
    this.valueChange.emit(cloneDate(value));
  }
  hasActiveButton() {
    if (!this.accept) {
      return false;
    }
    return [this.accept, this.cancel, this.now].reduce((isActive2, el) => isActive2 || this.dom.isActive(el), false);
  }
  hasSteps() {
    const keys = Object.keys(this.steps);
    return keys.length !== keys.reduce((acc, k) => acc + this.steps[k], 0);
  }
  intlChange() {
    this.dateFormatParts = this.intl.splitDateFormat(this.format);
    this.mergeValue = valueMerger(generateGetters(this.dateFormatParts));
    this.cdr.markForCheck();
  }
  bindEvents() {
    if (this.element) {
      this.zone.runOutsideAngular(() => {
        this.domEvents.push(this.renderer.listen(this.element.nativeElement, "keydown", this.handleKeydown.bind(this)));
      });
    }
  }
  handleKeydown(args) {
    const {
      keyCode,
      altKey
    } = args;
    const arrowKeyPressed = [Keys.ArrowLeft, Keys.ArrowRight].indexOf(keyCode) !== -1;
    if (isPresent3(this.pickerService) && arrowKeyPressed && altKey) {
      return;
    }
    if (keyCode === Keys.Enter && !this.hasActiveButton()) {
      this.handleAccept();
    } else if (keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight) {
      this.focusList(keyCode === Keys.ArrowLeft ? Direction2.Left : Direction2.Right);
    }
  }
  emitBlur(args) {
    if (this.pickerService) {
      this.pickerService.onBlur.emit(args);
    }
  }
  emitFocus(args) {
    if (this.pickerService) {
      this.pickerService.onFocus.emit(args);
    }
  }
  listIndex(partIndex) {
    let listIdx = 0;
    let partIdx = 0;
    while (partIdx < partIndex) {
      if (this.dateFormatParts[partIdx].type !== "literal") {
        listIdx++;
      }
      partIdx++;
    }
    return listIdx;
  }
  static ɵfac = function TimeSelectorComponent_Factory(t) {
    return new (t || _TimeSelectorComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(TimePickerDOMService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PickerService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeSelectorComponent,
    selectors: [["kendo-timeselector"]],
    viewQuery: function TimeSelectorComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c222, 5);
        ɵɵviewQuery(_c23, 5);
        ɵɵviewQuery(_c24, 5);
        ɵɵviewQuery(TimeListComponent, 5);
        ɵɵviewQuery(_c25, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accept = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cancel = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.now = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeLists = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timeListWrappers = _t);
      }
    },
    hostVars: 2,
    hostBindings: function TimeSelectorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      format: "format",
      min: "min",
      max: "max",
      cancelButton: "cancelButton",
      setButton: "setButton",
      nowButton: "nowButton",
      disabled: "disabled",
      isAdaptiveEnabled: "isAdaptiveEnabled",
      isDateTimePicker: "isDateTimePicker",
      steps: "steps",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange",
      valueReject: "valueReject",
      tabOutLastPart: "tabOutLastPart",
      tabOutFirstPart: "tabOutFirstPart",
      tabOutNow: "tabOutNow"
    },
    exportAs: ["kendo-timeselector"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.timeselector"
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 9,
    vars: 4,
    consts: () => {
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_18 = goog.getMsg("Set");
        i18n_18 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.timeselector.accept|The Accept button text in the timeselector component:Set`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_19 = goog.getMsg("Set time");
        i18n_19 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component:Set time`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_20 = goog.getMsg("Cancel");
        i18n_20 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.timeselector.cancel|The Cancel button text in the timeselector component:Cancel`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_21 = goog.getMsg("Cancel changes");
        i18n_21 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component:Cancel changes`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_22 = goog.getMsg("Now");
        i18n_22 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.timeselector.now|The Now button text in the timeselector component:Now`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_23 = goog.getMsg("Select now");
        i18n_23 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.timeselector.nowLabel|The label for the Now button in the timeselector component:Select now`;
      }
      return [["now", ""], ["listWrapper", ""], ["accept", ""], ["cancel", ""], ["kendoTimeSelectorLocalizedMessages", "", "accept", i18n_18, "acceptLabel", i18n_19, "cancel", i18n_20, "cancelLabel", i18n_21, "now", i18n_22, "nowLabel", i18n_23], [1, "k-time-header"], [1, "k-title", "k-timeselector-title"], ["type", "button", "class", "k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary k-time-now", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], [1, "k-time-list-container"], [1, "k-time-highlight"], ["ngFor", "", 3, "ngForOf"], ["class", "k-time-footer k-actions k-actions-stretched k-actions-horizontal", 4, "ngIf"], ["type", "button", 1, "k-button", "k-button-md", "k-rounded-md", "k-button-flat", "k-button-flat-primary", "k-time-now", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["class", "k-time-list-wrapper", "role", "presentation", "tabindex", "-1", 4, "ngIf"], ["class", "k-time-separator", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-time-list-wrapper"], [3, "valueChange", "tabOutLastPart", "tabOutFirstPart", "isLast", "isFirst", "min", "max", "part", "step", "disabled", "value", "kendoEventsOutsideAngular", "scope"], [1, "k-time-separator"], [1, "k-time-footer", "k-actions", "k-actions-stretched", "k-actions-horizontal"], ["type", "button", "class", "k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], ["class", "k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base", "type", "button", 3, "kendoEventsOutsideAngular", "scope", "disabled", 4, "ngIf"], ["type", "button", 1, "k-button", "k-time-accept", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-primary", 3, "kendoEventsOutsideAngular", "scope", "disabled"], ["type", "button", 1, "k-button", "k-time-cancel", "k-button-md", "k-rounded-md", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "scope", "disabled"]];
    },
    template: function TimeSelectorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 4);
        ɵɵelementStart(1, "div", 5)(2, "span", 6);
        ɵɵtext(3);
        ɵɵelementEnd();
        ɵɵtemplate(4, TimeSelectorComponent_button_4_Template, 3, 11, "button", 7);
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 8);
        ɵɵelement(6, "span", 9);
        ɵɵtemplate(7, TimeSelectorComponent_ng_template_7_Template, 2, 2, "ng-template", 10);
        ɵɵelementEnd();
        ɵɵtemplate(8, TimeSelectorComponent_div_8_Template, 3, 2, "div", 11);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵtextInterpolate1(" ", ctx.intl.formatDate(ctx.current, ctx.format), " ");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showNowButton);
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.dateFormatParts);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.setButton || ctx.cancelButton);
      }
    },
    dependencies: [TimeSelectorLocalizedMessagesDirective, NgIf, EventsOutsideAngularDirective, NgForOf, TimeListComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-timeselector",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.timeselector"
      }],
      selector: "kendo-timeselector",
      template: `
        <ng-container kendoTimeSelectorLocalizedMessages
            i18n-accept="kendo.timeselector.accept|The Accept button text in the timeselector component"
            accept="Set"

            i18n-acceptLabel="kendo.timeselector.acceptLabel|The label for the Accept button in the timeselector component"
            acceptLabel="Set time"

            i18n-cancel="kendo.timeselector.cancel|The Cancel button text in the timeselector component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.timeselector.cancelLabel|The label for the Cancel button in the timeselector component"
            cancelLabel="Cancel changes"

            i18n-now="kendo.timeselector.now|The Now button text in the timeselector component"
            now="Now"

            i18n-nowLabel="kendo.timeselector.nowLabel|The label for the Now button in the timeselector component"
            nowLabel="Select now"
        >
        </ng-container>
        <div class="k-time-header">
            <span class="k-title k-timeselector-title">
                {{ intl.formatDate(current, format) }}
            </span>
            <button
                #now
                *ngIf="showNowButton"
                type="button"
                class="k-button k-button-md k-rounded-md k-button-flat k-button-flat-primary k-time-now"
                [attr.title]="localization.get('nowLabel')"
                [attr.aria-label]="localization.get('nowLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleNow,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('now')}}</button>
        </div>
        <div class="k-time-list-container">
            <span class="k-time-highlight"></span>
            <ng-template ngFor [ngForOf]="dateFormatParts" let-part let-idx="index">
                <div
                    #listWrapper
                    class="k-time-list-wrapper"
                    role="presentation" tabindex="-1"
                    *ngIf="part.type !== 'literal'"
                >
                    <span class="k-title k-timeselector-title">{{intl.dateFieldName(part)}}</span>
                    <kendo-timelist
                        [isLast]="idx === dateFormatParts.length - 1"
                        [isFirst]="idx === 0"
                        [min]="min"
                        [max]="max"
                        [part]="part"
                        [step]="partStep(part)"
                        [disabled]="disabled"
                        [(value)]="current"
                        (tabOutLastPart)="tabOutLastPart.emit()"
                        (tabOutFirstPart)="tabOutFirstPart.emit()"
                        [kendoEventsOutsideAngular]="{
                            focus: handleListFocus,
                            blur: handleBlur
                        }"
                        [scope]="this"
                        [attr.data-timelist-index]="idx"
                    ></kendo-timelist>
                </div>
                <div class="k-time-separator" *ngIf="part.type === 'literal'">
                    {{part.pattern}}
                </div>
            </ng-template>
        </div>
        <div class="k-time-footer k-actions k-actions-stretched k-actions-horizontal" *ngIf="setButton || cancelButton">
            <button
                #accept
                *ngIf="setButton"
                type="button"
                class="k-button k-time-accept k-button-md k-rounded-md k-button-solid k-button-solid-primary"
                [attr.title]="localization.get('acceptLabel')"
                [attr.aria-label]="localization.get('acceptLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleAccept,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('accept')}}</button>
            <button
                #cancel
                *ngIf="cancelButton"
                class="k-button k-time-cancel k-button-md k-rounded-md k-button-solid k-button-solid-base"
                type="button"
                [attr.title]="localization.get('cancelLabel')"
                [attr.aria-label]="localization.get('cancelLabel')"
                [kendoEventsOutsideAngular]="{
                    click: handleReject,
                    focus: handleFocus,
                    blur: handleBlur,
                    keydown: handleTabOut
                }"
                [scope]="this"
                [disabled]="disabled"
            >{{localization.get('cancel')}}</button>
        </div>
    `,
      standalone: true,
      imports: [TimeSelectorLocalizedMessagesDirective, NgIf, EventsOutsideAngularDirective, NgForOf, TimeListComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: IntlService
    }, {
      type: TimePickerDOMService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: PickerService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    accept: [{
      type: ViewChild,
      args: ["accept", {
        static: false
      }]
    }],
    cancel: [{
      type: ViewChild,
      args: ["cancel", {
        static: false
      }]
    }],
    now: [{
      type: ViewChild,
      args: ["now", {
        static: false
      }]
    }],
    timeLists: [{
      type: ViewChildren,
      args: [TimeListComponent]
    }],
    timeListWrappers: [{
      type: ViewChildren,
      args: ["listWrapper"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    format: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    setButton: [{
      type: Input
    }],
    nowButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    isAdaptiveEnabled: [{
      type: Input
    }],
    isDateTimePicker: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    valueReject: [{
      type: Output
    }],
    tabOutLastPart: [{
      type: Output
    }],
    tabOutFirstPart: [{
      type: Output
    }],
    tabOutNow: [{
      type: Output
    }]
  });
})();
var timeRangeValidator = (min, max) => {
  return (control) => {
    if (!min || !max || !control.value) {
      return null;
    }
    const err = {
      timeRangeError: {
        maxValue: max,
        minValue: min,
        value: control.value
      }
    };
    return isInTimeRange(control.value, min, max) ? null : err;
  };
};
var TimeSelectorCustomMessagesComponent = class _TimeSelectorCustomMessagesComponent extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TimeSelectorCustomMessagesComponent_Factory(t) {
    return new (t || _TimeSelectorCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimeSelectorCustomMessagesComponent,
    selectors: [["kendo-timeselector-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimeSelectorCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function TimeSelectorCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeSelectorCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimeSelectorCustomMessagesComponent)
      }],
      selector: "kendo-timeselector-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var TimePickerLocalizedMessagesDirective = class _TimePickerLocalizedMessagesDirective extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function TimePickerLocalizedMessagesDirective_Factory(t) {
    return new (t || _TimePickerLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TimePickerLocalizedMessagesDirective,
    selectors: [["", "kendoTimePickerLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimePickerLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimePickerLocalizedMessagesDirective)
      }],
      selector: "[kendoTimePickerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var VALUE_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/timepicker/#toc-integration-with-json";
var INTL_DATE_FORMAT = "https://github.com/telerik/kendo-intl/blob/master/docs/date-formatting/index.md";
var formatRegExp2 = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.millisecond}|${TIME_PART.dayperiod}|literal`);
var ACCEPT_BUTTON_SELECTOR$1 = ".k-button.k-time-accept";
var CANCEL_BUTTON_SELECTOR = ".k-button.k-time-cancel";
var TimePickerComponent = class _TimePickerComponent extends MultiTabStop {
  bus;
  zone;
  localization;
  cdr;
  popupService;
  wrapper;
  renderer;
  injector;
  pickerService;
  intl;
  adaptiveService;
  /**
   * @hidden
   */
  clockIcon = clockIcon;
  container;
  popupTemplate;
  toggleButton;
  actionSheet;
  /**
   * @hidden
   */
  focusableId;
  /**
   * Sets or gets the `disabled` property of the TimePicker and
   * determines whether the component is active
   * ([see example]({% slug disabled_timepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_timepicker#toc-managing-the-timepicker-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the TimePicker
   * ([see example]({% slug readonly_timepicker %}#toc-read-only-timepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the TimePicker input field
   * ([see example]({% slug readonly_timepicker %}#toc-read-only-input)).
   *
   * > Note that if you set the [`readonly`]({% slug api_dateinputs_timepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   */
  readOnlyInput = false;
  /**
   * If set to `true`, renders a clear button after the input text or TimePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * Specifies the time format that is used to display the input value
   * ([see example]({% slug formats_timepicker %})).
   */
  format = "t";
  /**
   * Defines the descriptions of the format sections in the input field.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_timepicker %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   * <div class="row example-wrapper" [style.min-height.px]="450">
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Full-length format description:</p>
   *    <kendo-timepicker formatPlaceholder="wide"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Narrow-length format description:</p>
   *    <kendo-timepicker formatPlaceholder="narrow"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Short-length format description:</p>
   *    <kendo-timepicker formatPlaceholder="short"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Display defined format:</p>
   *    <kendo-timepicker format="HH:mm:ss" formatPlaceholder="formatPattern"></kendo-timepicker>
   *  </div>
   *
   *  <div class="col-xs-12 col-md-6 example-col">
   *    <p>Custom defined format descriptions</p>
   *    <kendo-timepicker format="HH:mm:ss"
   *      [formatPlaceholder]="{ hour: 'H', minute: 'm', second: 's' }"
   *    ></kendo-timepicker>
   *  </div>
   * </div>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  formatPlaceholder;
  /**
   * Specifies the hint the TimePicker displays when its value is `null`.
   * For more information, refer to the article on
   * [placeholders]({% slug placeholders_timepicker %}).
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-timepicker placeholder="Enter start..."></kendo-timepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  placeholder = null;
  /**
   * Specifies the smallest valid time value
   * ([see example]({% slug timeranges_timepicker %})).
   */
  set min(min) {
    this._min = cloneDate(min || MIN_TIME);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the biggest valid time value
   * ([see example]({% slug timeranges_timepicker %})).
   */
  set max(max) {
    this._max = cloneDate(max || MAX_TIME);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * Determines whether to display the **Cancel** button in the popup.
   */
  cancelButton = true;
  /**
   * Determines whether to display the **Now** button in the popup.
   *
   * > If the current time is out of range or the incremental step is greater than `1`, the **Now** button will be hidden.
   */
  nowButton = true;
  /**
   * Configures the incremental steps of the TimePicker.
   * For more information, refer to the article on
   * [incremental steps]({% slug incrementalsteps_timepicker %}).
   *
   * > If the incremental step is greater than `1`, the **Now** button will be hidden.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <kendo-timepicker format="HH:mm:ss" [steps]="steps"></kendo-timepicker>
   * `
   * })
   * class AppComponent {
   *   public steps = { hour: 2, minute: 15, second: 15, millisecond: 10 };
   * }
   * ```
   *
   */
  set steps(steps) {
    this._steps = steps || {};
  }
  get steps() {
    return this._steps;
  }
  /**
   * Configures the popup of the TimePicker.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets or gets the `tabindex` property of the TimePicker.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the title of the input element of the TimePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   * By default, subtitle is not rendered.
   */
  adaptiveSubtitle;
  /**
   * Determines whether the built-in min or max validators are enforced when a form is being validated.
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Specifies the value of the TimePicker component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value) {
    this.verifyValue(value);
    this._value = cloneDate(value);
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size ? size : DEFAULT_SIZE2;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_timepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user focuses the input element
   * ([see example](slug:events_timepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the input element gets blurred
   * ([see example](slug:events_timepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_timepicker)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_timepicker)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * @hidden
   */
  wrapperClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  get popupUID() {
    return `k-timepicker-popup-${this.bus.calendarId}-`;
  }
  popupRef;
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  get isActive() {
    return this._active;
  }
  set isActive(value) {
    this._active = value;
    if (!this.wrapper) {
      return;
    }
    const element = this.wrapper.nativeElement;
    if (value) {
      this.renderer.addClass(element, "k-focus");
    } else {
      this.renderer.removeClass(element, "k-focus");
    }
  }
  get show() {
    return this._show;
  }
  set show(show) {
    if (show && (this.disabled || this.readonly)) {
      return;
    }
    const skipZone = !show && (!this._show || !hasObservers(this.close) && !hasObservers(this.open));
    if (!skipZone) {
      this.zone.run(() => {
        const event2 = new PreventableEvent3();
        if (!this._show && show) {
          this.open.emit(event2);
        } else if (this._show && !show) {
          this.close.emit(event2);
        }
        if (event2.isDefaultPrevented()) {
          return;
        }
        this.toggleTimeSelector(show);
      });
    } else {
      this.toggleTimeSelector(show);
    }
  }
  get dateInput() {
    return this.pickerService.input;
  }
  get timeSelector() {
    return this.pickerService.timeSelector;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control);
  }
  /**
   * @hidden
   */
  windowSize;
  get adaptiveAcceptButton() {
    return this.actionSheet.element.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR$1);
  }
  get adaptiveCancelButton() {
    return this.actionSheet.element.nativeElement.querySelector(CANCEL_BUTTON_SELECTOR);
  }
  get inputElement() {
    return this.wrapper.nativeElement.querySelector("input");
  }
  onControlChange = noop$2;
  onControlTouched = noop$2;
  onValidatorChange = noop$2;
  resolvedPromise = Promise.resolve(null);
  timeRangeValidateFn = noop$2;
  incompleteValidator = noop$2;
  _min = cloneDate(MIN_TIME);
  _max = cloneDate(MAX_TIME);
  _popupSettings = {
    animate: true
  };
  _show = false;
  _steps = {};
  _value = null;
  _active = false;
  localizationChangeSubscription;
  pickerSubscriptions;
  windowBlurSubscription;
  control;
  domEvents = [];
  _size = DEFAULT_SIZE2;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  constructor(bus, zone, localization, cdr, popupService, wrapper, renderer, injector, pickerService, intl, adaptiveService) {
    super();
    this.bus = bus;
    this.zone = zone;
    this.localization = localization;
    this.cdr = cdr;
    this.popupService = popupService;
    this.wrapper = wrapper;
    this.renderer = renderer;
    this.injector = injector;
    this.pickerService = pickerService;
    this.intl = intl;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata2);
    this.pickerSubscriptions = this.pickerService.onFocus.subscribe(this.handleFocus.bind(this));
    this.pickerSubscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.pickerSubscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty
   */
  isEmpty() {
    return !this.value && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.localizationChangeSubscription = this.localization.changes.subscribe(() => this.cdr.markForCheck());
    this.control = this.injector.get(NgControl, null);
    if (this.wrapper) {
      this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
      this.zone.runOutsideAngular(() => {
        this.bindEvents();
      });
    }
    this.focusableId = this.dateInput?.focusableId;
  }
  /**
   * @hidden
   */
  ngAfterViewInit() {
    this.setComponentClasses();
    this.windowSize = this.adaptiveService.size;
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (changes.min || changes.max || changes.rangeValidation || changes.incompleteDateValidation) {
      this.timeRangeValidateFn = this.rangeValidation ? timeRangeValidator(this.min, this.max) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (changes.format) {
      this.verifyFormat();
    }
    if (!this.focusableId || changes.focusableId) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.isActive = false;
    this.show = false;
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
    this.domEvents.forEach((unbindCallback) => unbindCallback());
    this.pickerSubscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleKeydown(event2) {
    const {
      altKey,
      keyCode
    } = event2;
    if (keyCode === Keys.Escape) {
      this.focusInput();
      this.show = false;
      hasObservers(this.escape) && this.escape.emit();
      this.cdr.detectChanges();
      return;
    }
    if (altKey) {
      if (keyCode === Keys.ArrowUp) {
        event2.preventDefault();
        this.focusInput();
        this.show = false;
        this.cdr.detectChanges();
      }
      if (keyCode === Keys.ArrowDown && !this.show) {
        event2.preventDefault();
        this.show = true;
      }
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.verifyValue(value);
    this.value = cloneDate(value);
    this.cdr.markForCheck();
    if (!value && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.timeRangeValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * Focuses the TimePicker component.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="timepicker.focus()">Focus time picker</button>
   *  <kendo-timepicker #timepicker></kendo-timepicker>
   * `
   * })
   * export class AppComponent { }
   * ```
   */
  focus() {
    this.dateInput.focus();
  }
  /**
   * Blurs the TimePicker component.
   */
  blur() {
    (this.timeSelector || this.dateInput)["blur"]();
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show - The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.resolvedPromise.then(() => {
      this.toggleTimeSelector(show === void 0 ? !this.show : show);
    });
  }
  /**
   * Indicates whether the component is currently open. That is when the popup or actionSheet is open.
   */
  get isOpen() {
    return this.show;
  }
  /**
   * @hidden
   */
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  handleChange(value) {
    if (isEqual(this.value, value)) {
      if (this.show) {
        this.focusInput();
        this.show = false;
      }
      if (this.incompleteDateValidation) {
        this.onControlChange(cloneDate(value));
      }
      return;
    }
    this.value = cloneDate(value);
    this.zone.run(() => {
      if (this.show) {
        this.focusInput();
        this.show = false;
      }
      this.dateInput.showClearButton = true;
      this.onControlChange(cloneDate(value));
      this.valueChange.emit(cloneDate(value));
    });
  }
  /**
   * @hidden
   */
  handleActionSheetAccept() {
    this.timeSelector.handleAccept();
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleReject() {
    this.focusInput();
    this.show = false;
  }
  /**
   * @hidden
   */
  handleInputChange(value) {
    const val = this.dateInput.formatSections["date"] ? value : this.mergeTime(value);
    this.handleChange(val);
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.show = true;
    }
  }
  /**
   * @hidden
   */
  onTabOutNow() {
    if (!this.timeSelector.showNowButton) {
      this.cancelButton ? this.timeSelector.cancel.nativeElement.focus() : this.timeSelector.accept.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  handleMousedown(args) {
    args.preventDefault();
  }
  /**
   * @hidden
   */
  handleIconClick(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    event2.preventDefault();
    this.focusInput();
    this.handleFocus();
    this.show = !this.show;
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  get popupClasses() {
    return ["k-timepicker-popup"].concat(this.popupSettings.popupClass || []);
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  normalizeTime(date2) {
    return setTime(MIDNIGHT_DATE, date2);
  }
  /**
   * @hidden
   */
  mergeTime(value) {
    return this.value && value ? setTime(this.value, value) : value;
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.isOpen || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   */
  onTabOutLastPart() {
    this.renderer.removeClass(this.timeSelector.timeListWrappers.last.nativeElement, "k-focus");
    if (this.isAdaptive) {
      this.cancelButton ? this.adaptiveCancelButton.focus() : this.adaptiveAcceptButton.focus();
    } else {
      this.timeSelector.accept.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutFirstPart() {
    this.renderer.removeClass(this.timeSelector.timeListWrappers.first.nativeElement, "k-focus");
    if (this.timeSelector.showNowButton) {
      this.timeSelector.now.nativeElement.focus();
    } else {
      this.cancelButton ? this.timeSelector.cancel.nativeElement.focus() : this.timeSelector.accept.nativeElement.focus();
    }
  }
  toggleTimeSelector(show) {
    const previousWindowSize = this.windowSize;
    this.windowSize = this.adaptiveService.size;
    if (previousWindowSize !== this.windowSize && !show) {
      if (previousWindowSize !== "large") {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    } else {
      if (this.isAdaptive) {
        this.toggleActionSheet(show);
      } else {
        this.togglePopup(show);
      }
    }
    this.toggleFocus();
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.isOpen) {
      this.actionSheet.toggle();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    } else if (!show && this.isOpen) {
      this.renderer.setStyle(this.timeSelector.element.nativeElement, "pointer-events", "none");
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
      }
      this.actionSheet.toggle();
      this.dateInput.focus();
    }
    this._show = show;
  }
  togglePopup(show) {
    if (show === this.isOpen) {
      return;
    }
    this._show = show;
    this.cdr.markForCheck();
    if (show) {
      const direction = this.localization.rtl ? "right" : "left";
      const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
      this.popupRef = this.popupService.open({
        anchor: this.wrapper,
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.popupSettings.animate,
        appendTo: this.appendTo,
        content: this.popupTemplate,
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        popupClass: this.popupClasses,
        positionMode: appendToComponent ? "fixed" : "absolute"
      });
      this.popupRef.popupElement.setAttribute("id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.popupRef.popupAnchorViewportLeave.subscribe(() => this.show = false);
    } else {
      this.popupRef.close();
      this.popupRef = null;
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaControls);
      }
    }
  }
  focusInput() {
    if (touchEnabled) {
      return;
    }
    this.dateInput.focus();
  }
  toggleFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.show) {
      if (!this.timeSelector) {
        this.cdr.detectChanges();
      }
      if (this.isActive) {
        this.timeSelector.focus();
      }
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  verifyValue(value) {
    if (!isDevMode()) {
      return;
    }
    if (value && !(value instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK$1} for possible resolution.`);
    }
  }
  verifyFormat() {
    if (!isDevMode()) {
      return;
    }
    const formatContainsDateParts = this.intl.splitDateFormat(this.format).some((part) => !formatRegExp2.test(part.type));
    if (formatContainsDateParts) {
      throw new Error(`Provided format is not supported. Supported specifiers are T|t|H|h|m|s|S|a. See ${INTL_DATE_FORMAT}`);
    }
  }
  bindEvents() {
    const element = this.wrapper.nativeElement;
    this.domEvents.push(this.renderer.listen(element, "keydown", this.handleKeydown.bind(this)));
    if (isWindowAvailable()) {
      this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this));
    }
  }
  handleWindowBlur() {
    if (!this.isOpen || this.actionSheet.expanded) {
      return;
    }
    this.show = false;
  }
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleBlur(args) {
    const currentTarget = args && currentFocusTarget(args);
    const target = args && args.target;
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(target) || this.actionSheet.element.nativeElement.contains(currentTarget));
    if (currentTarget && (this.dateInput.containsElement(currentTarget) || this.timeSelector && this.timeSelector.containsElement(currentTarget) || isInsideActionSheet)) {
      return;
    }
    if (hasObservers(this.onBlur) || this.show && hasObservers(this.close) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.blurComponent();
        this.cdr.markForCheck();
      });
    } else {
      this.blurComponent();
    }
    this.cdr.detectChanges();
  }
  blurComponent() {
    this.isActive = false;
    this.show = false;
    this.onControlTouched();
    this.onBlur.emit();
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.zone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function TimePickerComponent_Factory(t) {
    return new (t || _TimePickerComponent)(ɵɵdirectiveInject(BusViewService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimePickerComponent,
    selectors: [["kendo-timepicker"]],
    viewQuery: function TimePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 5, ViewContainerRef);
        ɵɵviewQuery(_c15, 5);
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function TimePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-readonly", ctx.readonly)("k-timepicker", ctx.wrapperClasses)("k-input", ctx.wrapperClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      clearButton: "clearButton",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      min: "min",
      max: "max",
      incompleteDateValidation: "incompleteDateValidation",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      cancelButton: "cancelButton",
      nowButton: "nowButton",
      steps: "steps",
      popupSettings: "popupSettings",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      rangeValidation: "rangeValidation",
      adaptiveMode: "adaptiveMode",
      value: "value",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      close: "close",
      escape: "escape"
    },
    exportAs: ["kendo-timepicker"],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TimePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _TimePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TimePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _TimePickerComponent)
    }, LocalizationService, BusViewService, {
      provide: L10N_PREFIX,
      useValue: "kendo.timepicker"
    }, PickerService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 17,
    vars: 42,
    consts: () => {
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_24 = goog.getMsg("Set");
        i18n_24 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.timepicker.accept|The Accept button text in the timepicker component:Set`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_25 = goog.getMsg("Set time");
        i18n_25 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component:Set time`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_26 = goog.getMsg("Cancel");
        i18n_26 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.timepicker.cancel|The Cancel button text in the timepicker component:Cancel`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_27 = goog.getMsg("Cancel changes");
        i18n_27 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component:Cancel changes`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_28 = goog.getMsg("Now");
        i18n_28 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.timepicker.now|The Now button text in the timepicker component:Now`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_29 = goog.getMsg("Select now");
        i18n_29 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.timepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_30 = goog.getMsg("Toggle time list");
        i18n_30 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.timepicker.toggle|The label for the toggle button in the timepicker component:Toggle time list`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_31 = goog.getMsg("Hour");
        i18n_31 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.timepicker.hour|The label for the hour part in the timepicker component:Hour`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_32 = goog.getMsg("Minute");
        i18n_32 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.timepicker.minute|The label for the minute part in the timepicker component:Minute`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_33 = goog.getMsg("Second");
        i18n_33 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.timepicker.second|The label for the second part in the timepicker component:Second`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_34 = goog.getMsg("Millisecond");
        i18n_34 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.timepicker.millisecond|The label for the millisecond part in the timepicker component:Millisecond`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_35 = goog.getMsg("Dayperiod");
        i18n_35 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.timepicker.dayperiod|The label for the dayperiod part in the timepicker component:Dayperiod`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_36 = goog.getMsg("clear");
        i18n_36 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.timepicker.clearTitle|The title of the clear button:clear`;
      }
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_37 = goog.getMsg("Close");
        i18n_37 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.timepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["input", ""], ["toggleButton", ""], ["popupTemplate", ""], ["container", ""], ["actionSheet", ""], ["timeSelectorTemplate", ""], ["timeSelector", ""], ["kendoTimePickerLocalizedMessages", "", "accept", i18n_24, "acceptLabel", i18n_25, "cancel", i18n_26, "cancelLabel", i18n_27, "now", i18n_28, "nowLabel", i18n_29, "toggle", i18n_30, "hour", i18n_31, "minute", i18n_32, "second", i18n_33, "millisecond", i18n_34, "dayperiod", i18n_35, "clearTitle", i18n_36, "adaptiveCloseButtonTitle", i18n_37], ["pickerType", "timepicker", "hasPopup", "dialog", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "isPopupOpen", "disabled", "clearButton", "readonly", "role", "ariaReadOnly", "format", "formatPlaceholder", "placeholder", "focusableId", "min", "max", "incompleteDateValidation", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "steps", "tabindex", "isRequired", "title", "inputAttributes", "value"], [3, "clearTitle"], ["type", "button", "tabindex", "-1", 1, "k-input-button", "k-button", "k-icon-button", 3, "kendoEventsOutsideAngular", "scope"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon"], [3, "resize", 4, "ngIf"], [3, "overlayClick", "collapse", "titleId", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], ["class", "k-text-center", 4, "ngIf"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "fillMode", "flat", "size", "large", "aria-hidden", "true", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [3, "valueChange", "valueReject", "tabOutLastPart", "tabOutFirstPart", "tabOutNow", "cancelButton", "setButton", "nowButton", "format", "min", "max", "steps", "value", "isAdaptiveEnabled", "kendoEventsOutsideAngular", "scope"], [3, "acceptLabel", "accept", "cancelLabel", "cancel", "nowLabel", "now", "hour", "minute", "second", "millisecond", "dayperiod"]];
    },
    template: function TimePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8, 0);
        ɵɵlistener("valueChange", function TimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputChange($event));
        })("click", function TimePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(3, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 10, 1);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵtemplate(7, TimePickerComponent_ng_template_7_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(9, null, 3);
        ɵɵtemplate(11, TimePickerComponent_kendo_resize_sensor_11_Template, 1, 0, "kendo-resize-sensor", 12);
        ɵɵelementStart(12, "kendo-actionsheet", 13, 4);
        ɵɵlistener("overlayClick", function TimePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function TimePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, TimePickerComponent_ng_template_14_Template, 14, 12, "ng-template", 14);
        ɵɵelementEnd();
        ɵɵtemplate(15, TimePickerComponent_ng_template_15_Template, 3, 27, "ng-template", null, 5, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("isPopupOpen", ctx.show)("disabled", ctx.disabled)("clearButton", ctx.clearButton)("readonly", ctx.readonly || ctx.readOnlyInput)("role", "combobox")("ariaReadOnly", ctx.readonly)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("focusableId", ctx.focusableId)("min", ctx.normalizeTime(ctx.min))("max", ctx.normalizeTime(ctx.max))("incompleteDateValidation", ctx.incompleteDateValidation)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("steps", ctx.steps)("tabindex", !ctx.show ? ctx.tabindex : -1)("isRequired", ctx.isControlRequired)("title", ctx.adaptiveTitle)("inputAttributes", ctx.inputAttributes)("value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(34, _c18, ctx.handleIconClick, ctx.handleMousedown))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.clockIcon);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("titleId", ctx.focusableId)("cssClass", ɵɵpureFunction2(37, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(40, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [TimePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendo-timepicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TimePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => TimePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TimePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => TimePickerComponent)
      }, LocalizationService, BusViewService, {
        provide: L10N_PREFIX,
        useValue: "kendo.timepicker"
      }, PickerService],
      selector: "kendo-timepicker",
      template: `
        <ng-container kendoTimePickerLocalizedMessages
            i18n-accept="kendo.timepicker.accept|The Accept button text in the timepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.timepicker.acceptLabel|The label for the Accept button in the timepicker component"
            acceptLabel="Set time"

            i18n-cancel="kendo.timepicker.cancel|The Cancel button text in the timepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.timepicker.cancelLabel|The label for the Cancel button in the timepicker component"
            cancelLabel="Cancel changes"

            i18n-now="kendo.timepicker.now|The Now button text in the timepicker component"
            now="Now"

            i18n-nowLabel="kendo.timepicker.nowLabel|The label for the Now button in the timepicker component"
            nowLabel="Select now"

            i18n-toggle="kendo.timepicker.toggle|The label for the toggle button in the timepicker component"
            toggle="Toggle time list"

            i18n-hour="kendo.timepicker.hour|The label for the hour part in the timepicker component"
            hour="Hour"

            i18n-minute="kendo.timepicker.minute|The label for the minute part in the timepicker component"
            minute="Minute"

            i18n-second="kendo.timepicker.second|The label for the second part in the timepicker component"
            second="Second"

            i18n-millisecond="kendo.timepicker.millisecond|The label for the millisecond part in the timepicker component"
            millisecond="Millisecond"

            i18n-dayperiod="kendo.timepicker.dayperiod|The label for the dayperiod part in the timepicker component"
            dayperiod="Dayperiod"

            i18n-clearTitle="kendo.timepicker.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-adaptiveCloseButtonTitle="kendo.timepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"
        >
        </ng-container>
        <kendo-dateinput
            #input
            pickerType="timepicker"
            hasPopup="dialog"
            [isPopupOpen]="show"
            [disabled]="disabled"
            [clearButton]="clearButton"
            [readonly]="readonly || readOnlyInput"
            [role]="'combobox'"
            [ariaReadOnly]="readonly"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [focusableId]="focusableId"
            [min]="normalizeTime(min)"
            [max]="normalizeTime(max)"
            [incompleteDateValidation]="incompleteDateValidation"
            [autoSwitchParts]="autoSwitchParts"
            [autoSwitchKeys]="autoSwitchKeys"
            [enableMouseWheel]="enableMouseWheel"
            [allowCaretMode]="allowCaretMode"
            fillMode="none"
            rounded="none"
            size="none"
            [steps]="steps"
            [tabindex]="!show ? tabindex : -1"
            [isRequired]="isControlRequired"
            [title]="adaptiveTitle"
            [inputAttributes]="inputAttributes"
            [value]="value"
            (valueChange)="handleInputChange($event)"
            (click)="handleDateInputClick()"
        >
            <kendo-dateinput-messages
                [clearTitle]="localization.get('clearTitle')"
            >
            </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
            #toggleButton
            type="button"
            tabindex="-1"
            class="k-input-button k-button k-icon-button"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                click: handleIconClick,
                mousedown: handleMousedown
            }"
            [scope]="this"
        >
            <kendo-icon-wrapper
                name="clock"
                [svgIcon]="clockIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
        </button>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="timeSelectorTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>

        <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <kendo-actionsheet 
            #actionSheet
            (overlayClick)="show=false"
            (collapse)="handleActionSheetCollapse()"
            [titleId]="focusableId"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center" *ngIf="adaptiveTitle">{{ adaptiveTitle }}</div>
                            <div class="k-actionsheet-subtitle k-text-center" *ngIf="adaptiveSubtitle">{{ adaptiveSubtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="check"
                                [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                                [svgIcon]="checkIcon"
                                fillMode="flat"
                                size="large"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                (click)="show = false">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content">
                    <ng-container *ngTemplateOutlet="timeSelectorTemplate"></ng-container>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton 
                        type="button"
                        (click)="handleReject()"
                        size="large"
                        class="k-time-cancel"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        type="button"
                        (click)="handleActionSheetAccept()"
                        size="large"
                        class="k-time-accept"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>

        <ng-template #timeSelectorTemplate>
            <kendo-timeselector
                #timeSelector
                [class.k-timeselector-lg]="isAdaptive"
                [cancelButton]="cancelButton && !this.isAdaptive"
                [setButton]="!isAdaptive"
                [nowButton]="nowButton"
                [format]="format"
                [min]="min"
                [max]="max"
                [steps]="steps"
                [value]="value"
                [isAdaptiveEnabled]="isAdaptiveModeEnabled"
                [kendoEventsOutsideAngular]="{
                    keydown: handleKeydown,
                    mousedown: handleMousedown
                }"
                [scope]="this"
                (valueChange)="handleChange($event)"
                (valueReject)="handleReject()"
                (tabOutLastPart)="onTabOutLastPart()"
                (tabOutFirstPart)="onTabOutFirstPart()"
                (tabOutNow)="onTabOutNow()"
            >
                <kendo-timeselector-messages
                    [acceptLabel]="localization.get('acceptLabel')"
                    [accept]="localization.get('accept')"
                    [cancelLabel]="localization.get('cancelLabel')"
                    [cancel]="localization.get('cancel')"
                    [nowLabel]="localization.get('nowLabel')"
                    [now]="localization.get('now')"
                    [hour]="localization.get('hour')"
                    [minute]="localization.get('minute')"
                    [second]="localization.get('second')"
                    [millisecond]="localization.get('millisecond')"
                    [dayperiod]="localization.get('dayperiod')"
                >
                </kendo-timeselector-messages>
            </kendo-timeselector>
        </ng-template>
    `,
      standalone: true,
      imports: [TimePickerLocalizedMessagesDirective, DateInputComponent, DateInputCustomMessagesComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, NgIf, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: BusViewService
    }, {
      type: NgZone
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PopupService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: PickerService
    }, {
      type: IntlService
    }, {
      type: AdaptiveService
    }];
  }, {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: false
      }]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    focusableId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    nowButton: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-timepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }]
  });
})();
var DateTimePickerMessages = class _DateTimePickerMessages extends ComponentMessages {
  /**
   * The title of the **Toggle** button of the DateTimePicker.
   */
  toggle;
  /**
   * The text of the **Date** tab in the popup header of the DateTimePicker.
   */
  dateTab;
  /**
   * The label of the **Date** tab in the popup header of the DateTimePicker.
   */
  dateTabLabel;
  /**
   * The text of the **Time** tab in the popup header of the DateTimePicker.
   */
  timeTab;
  /**
   * The label of the **Time** tab in the popup header of the DateTimePicker.
   */
  timeTabLabel;
  /**
   * The text of the **Accept** button in the popup footer of the DateTimePicker.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the DateTimePicker.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the DateTimePicker.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the DateTimePicker.
   */
  cancelLabel;
  /**
   * The **Today** button text in the header of the Calendar.
   */
  today;
  /**
   * The text of the **Now** button in the popup header of the TimePicker.
   */
  now;
  /**
   * The label of the **Now** button in the popup header of the TimePicker.
   */
  nowLabel;
  /**
   * The title of the **Prev** button in the header of the Classic Calendar.
   */
  prevButtonTitle;
  /**
   * The title of the **Next** button in the header of the Classic Calendar.
   */
  nextButtonTitle;
  /**
   * The title of the **Parent View** button in the header of the Calendar.
   */
  parentViewButtonTitle;
  /**
   * The label of the **Hour** part in the TimePicker.
   */
  hour;
  /**
   * The label of the **Minute** part in the TimePicker.
   */
  minute;
  /**
   * The label of the **Second** part in the TimePicker.
   */
  second;
  /**
   * The label of the **Millisecond** part in the TimePicker.
   */
  millisecond;
  /**
   * The label of the **Dayperiod** part in the TimePicker.
   */
  dayperiod;
  /**
   * The title of the **Clear** button of the DateTimePicker.
   */
  clearTitle;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateTimePickerMessages_BaseFactory;
    return function DateTimePickerMessages_Factory(t) {
      return (ɵDateTimePickerMessages_BaseFactory || (ɵDateTimePickerMessages_BaseFactory = ɵɵgetInheritedFactory(_DateTimePickerMessages)))(t || _DateTimePickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateTimePickerMessages,
    selectors: [["kendo-datetimepicker-messages-base"]],
    inputs: {
      toggle: "toggle",
      dateTab: "dateTab",
      dateTabLabel: "dateTabLabel",
      timeTab: "timeTab",
      timeTabLabel: "timeTabLabel",
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      today: "today",
      now: "now",
      nowLabel: "nowLabel",
      prevButtonTitle: "prevButtonTitle",
      nextButtonTitle: "nextButtonTitle",
      parentViewButtonTitle: "parentViewButtonTitle",
      hour: "hour",
      minute: "minute",
      second: "second",
      millisecond: "millisecond",
      dayperiod: "dayperiod",
      clearTitle: "clearTitle",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-datetimepicker-messages-base"
    }]
  }], null, {
    toggle: [{
      type: Input
    }],
    dateTab: [{
      type: Input
    }],
    dateTabLabel: [{
      type: Input
    }],
    timeTab: [{
      type: Input
    }],
    timeTabLabel: [{
      type: Input
    }],
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    today: [{
      type: Input
    }],
    now: [{
      type: Input
    }],
    nowLabel: [{
      type: Input
    }],
    prevButtonTitle: [{
      type: Input
    }],
    nextButtonTitle: [{
      type: Input
    }],
    parentViewButtonTitle: [{
      type: Input
    }],
    hour: [{
      type: Input
    }],
    minute: [{
      type: Input
    }],
    second: [{
      type: Input
    }],
    millisecond: [{
      type: Input
    }],
    dayperiod: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective2 = class _LocalizedMessagesDirective extends DateTimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(t) {
    return new (t || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoDateTimePickerLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DateTimePickerMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective2, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateTimePickerMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective2)
      }],
      selector: "[kendoDateTimePickerLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var timeFormatRegExp = new RegExp(`${TIME_PART.hour}|${TIME_PART.minute}|${TIME_PART.second}|${TIME_PART.dayperiod}|literal`);
var VALUE_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/integration-with-json/";
var MIN_MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/dateinputs/datetimepicker/date-time-limits/";
var DEFAULT_ACTIVE_TAB = "date";
var DEFAULT_DATEINPUT_FORMAT = "g";
var DEFAULT_TIMESELECTOR_FORMAT = "t";
var TWO_DIGIT_YEAR_MAX = 68;
var ACCEPT_BUTTON_SELECTOR = ".k-button.k-time-accept";
var CANCEL_BUTTON_SELECOTR = ".k-button.k-time-cancel";
var DATE_TAB_BUTTON_SELECTOR = ".k-button.k-group-start";
var TIME_TAB_BUTTON_SELECTOR = ".k-button.k-group-end";
var TODAY_BUTTON_SELECTOR = ".k-button.k-calendar-nav-today";
var DateTimePickerComponent = class _DateTimePickerComponent extends MultiTabStop {
  popupService;
  intl;
  cdr;
  pickerService;
  ngZone;
  wrapper;
  localization;
  disabledDatesService;
  renderer;
  injector;
  adaptiveService;
  /**
   * @hidden
   */
  calendarIcon = calendarIcon;
  /**
   * @hidden
   */
  clockIcon = clockIcon;
  /**
   * @hidden
   */
  hostClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  toggleButton;
  /**
   * @hidden
   */
  get dateInput() {
    return this.pickerService.input;
  }
  /**
   * @hidden
   */
  get calendar() {
    return this.pickerService.calendar;
  }
  /**
   * @hidden
   */
  get timeSelector() {
    return this.pickerService.timeSelector;
  }
  /**
   * @hidden
   */
  focusableId;
  /**
   * Sets the format of the displayed Calendar week days' names.
   * @default 'short'
   */
  weekDaysFormat = "short";
  /**
   * Displays the days that fall out of the current month in the Calendar ([see example]({% slug datetimepicker_calendar_options %}#toc-displaying-other-month-days)).
   * The default values per Calendar type are:
   * - `infinite` - false
   * - `classic` - true
   */
  showOtherMonthDays;
  /**
   * Specifies the value of the DateTimePicker component.
   *
   * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance or `null`.
   */
  set value(value) {
    this.verifyValue(value);
    this._value = cloneDate(value);
    this.setCalendarValue(value);
    this.cdr.markForCheck();
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the date format for displaying the input value
   * ([see example]({% slug formats_datetimepicker %}))
   *
   * Format value options:
   * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
   * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
   *
   * > If a [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) object is provided, the `displayFormat` value will be used for the popup TimePicker.
   */
  set format(format) {
    this._format = format;
    const displayFormat = this.getDisplayFormat(format);
    this.timeSelectorFormat = this.getTimeSelectorFormat(displayFormat);
  }
  get format() {
    return this._format;
  }
  /**
   * The maximum year to assume to be from the current century when typing two-digit year value
   * ([see example]({% slug formats_datetimepicker %}#toc-two-digit-year-format)).
   *
   * The default value is 68, indicating that typing any value less than 69
   * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
   */
  twoDigitYearMax = TWO_DIGIT_YEAR_MAX;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the DateTimePicker.
   */
  set tabindex(value) {
    const tabindex = Number(value);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return this.disabled ? -1 : this._tabindex;
  }
  /**
   * Sets the dates of the DateTimePicker that will be disabled
   * ([see example]({% slug disabled_dates_datetimepicker %})).
   */
  set disabledDates(value) {
    this._disabledDates = value;
    this.disabledDatesService.initialize(value);
  }
  get disabledDates() {
    return this._disabledDates;
  }
  /**
   * Configures the popup settings of the DateTimePicker
   * ([see example]({% slug datetimepicker_popup_options %}#toc-customizing-the-popup)).
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `appendTo: 'root' | 'component' | ViewContainerRef`&mdash;Controls the popup container. By default, the popup will be appended to the root component.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, {
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the title of the input element of the DateTimePicker and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveSubtitle = "";
  /**
   * Sets or gets the `disabled` property of the DateTimePicker and determines whether the component is active
   * ([see example]({% slug disabled_datetimepicker %})).
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_datetimepicker#toc-managing-the-datetimepicker-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the DateTimePicker
   * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-datetimepicker)).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the read-only state of the DateTimePicker input field
   * ([see example]({% slug readonly_datetimepicker %}#toc-read-only-input)).
   *
   * > Note that if you set the [`readonly`]({% slug api_dateinputs_datetimepickercomponent %}#toc-readonly) property value to `true`,
   * the input will be rendered in a read-only state regardless of the `readOnlyInput` value.
   */
  readOnlyInput = false;
  /**
   * Determines whether to display the **Cancel** button in the popup
   * ([see example]({% slug datetimepicker_popup_options %}#toc-toggling-the-cancel-button)).
   */
  cancelButton = true;
  /**
   * Defines the descriptions of the format sections in the input field
   * ([see example]({% slug placeholders_datetimepicker %}#toc-format-sections-description)).
   */
  formatPlaceholder;
  /**
   * Specifies the hint which is displayed by the DateTimePicker when its value is `null`
   * ([see example]({% slug placeholders_datetimepicker %}#toc-text-hints)).
   */
  placeholder;
  /**
   * Configures the incremental steps of the DateInput and the popup component of the TimePicker
   * ([see example]({% slug incrementalsteps_datetimepicker %})).
   */
  steps = {};
  /**
   * Specifies the focused date of the popup Calendar
   * ([see example]({% slug datetimepicker_calendar_options %}#toc-focused-dates)).
   */
  focusedDate;
  /**
   * Specifies the Calendar type.
   *
   * The possible values are:
   * - `infinite` (default)
   * - `classic`
   *
   */
  calendarType = "infinite";
  /**
   * Determines whether to enable animation when navigating to previous/next Calendar view.
   * Applies to the [`classic`]({% slug api_dateinputs_datetimepickercomponent %}#toc-calendartype) Calendar only.
   *
   * > This feature uses the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API). In order to run the animation in browsers that do not support it, you need the `web-animations-js` polyfill.
   *
   * @default false
   */
  animateCalendarNavigation = false;
  /**
   * Determines whether to display a week number column in the `month` view of the popup Calendar
   * ([see example]({% slug datetimepicker_calendar_options %}#toc-week-number-column)).
   */
  weekNumber = false;
  /**
   * Specifies the smallest valid date.
   * The Calendar will not display dates before this value.
   * If the `min` value of the Calendar is selected, the TimePicker will not display
   * time entries before the specified time portion of this value
   * ([see example]({% slug dateranges_datetimepicker %})).
   */
  set min(value) {
    this._min = cloneDate(value);
    this.calendarMin = getDate(value || MIN_DATE);
  }
  get min() {
    return this._min;
  }
  /**
   * Specifies the biggest valid date.
   * The Calendar will not display dates after this value.
   * If the `max` value of the Calendar is selected, the TimePicker will not display
   * time entries after the specified time portion of this value
   * ([see example]({% slug dateranges_datetimepicker %})).
   */
  set max(value) {
    this._max = cloneDate(value);
    this.calendarMax = lastMillisecondOfDate(value || MAX_DATE);
  }
  get max() {
    return this._max;
  }
  /**
   * Determines whether the built-in min or max validators are enforced when validating a form
   * ([see example](slug:dateranges_datetimepicker)).
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Determines whether the built-in validator for disabled
   * date ranges is enforced when validating a form
   * ([see example](slug:disabled_dates_datetimepicker)).
   */
  disabledDatesValidation = true;
  /**
   * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
   */
  incompleteDateValidation = false;
  /**
   * Determines whether to autocorrect invalid segments automatically.
   *
   * @default true
   */
  autoCorrectParts = true;
  /**
   * Determines whether to automatically move to the next segment after the user completes the current one.
   *
   * @default true
   */
  autoSwitchParts = true;
  /**
   * A string array representing custom keys, which will move the focus to the next date format segment.
   */
  autoSwitchKeys = [];
  /**
   * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
   *
   * @default true
   */
  enableMouseWheel = true;
  /**
   * Determines if the users should see a blinking caret inside the Date Input when possible.
   *
   * @default false
   */
  allowCaretMode = false;
  /**
   * If set to `true`, renders a clear button after the input text or DateTimePicker value has been changed.
   * Clicking this button resets the value of the component to `null` and triggers the `valueChange` event.
   * @default false
   */
  clearButton = false;
  /**
   * When enabled, the DateTimePicker will autofill the rest of the date to the current date when the component loses focus.
   *
   * @default false
   */
  autoFill = false;
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the user selects a new value
   * ([see example](slug:events_datetimepicker)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:events_datetimepicker)).
   * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:events_datetimepicker)).
   * This event is preventable. If you cancel the event by setting `event.preventDefault()`, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires each time the user focuses the component
   * ([see example](slug:events_datetimepicker)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the user blurs the component
   * ([see example](slug:events_datetimepicker)).
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  /**
   * Indicates whether the component is currently open. That is when the popup or actionSheet is open.
   */
  get isOpen() {
    return this.actionSheet?.expanded || isPresent3(this.popupRef);
  }
  /**
   * Indicates whether the component or its popup content is focused.
   */
  get isActive() {
    return this._isActive;
  }
  set isActive(value) {
    if (value) {
      this.renderer.addClass(this.wrapper.nativeElement, "k-focus");
    } else {
      this.renderer.removeClass(this.wrapper.nativeElement, "k-focus");
    }
    this._isActive = value;
  }
  /**
   * Sets the active tab on opening the popup
   * ([see example]({% slug datetimepicker_popup_options %}#toc-setting-the-default-tab)).
   */
  set defaultTab(tab) {
    this._defaultTab = tab || DEFAULT_ACTIVE_TAB;
    this.activeTab = this.defaultTab;
  }
  get defaultTab() {
    return this._defaultTab;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
    this.renderer.removeClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    const newSize = size ? size : DEFAULT_SIZE2;
    if (newSize !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", newSize));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
    if (newRounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `solid` (Default)
   * * `flat`
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
    this.renderer.removeClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
    if (newFillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", newFillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${newFillMode}-base`);
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * @hidden
   */
  get tabSwitchTransition() {
    return this.isOpen ? null : "none";
  }
  /**
   * @hidden
   *
   * Indicates whether the Calendar will be disabled.
   * The inactive tab component gets disabled and becomes inaccessible on tab click.
   */
  get disableCalendar() {
    return this.activeTab !== "date" && !this.calendar.isActive;
  }
  /**
   * @hidden
   *
   * Indicates whether the TimeSelector will be disabled.
   * The inactive tab component gets disabled and becomes inaccessible on tab click.
   */
  get disableTimeSelector() {
    return this.activeTab !== "time" && !this.timeSelector.isActive;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.isOpen || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this._togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   *
   * Controls whether the Calendar or the TimeSelector will be displayed.
   */
  activeTab = DEFAULT_ACTIVE_TAB;
  /**
   * @hidden
   *
   * Specifies the stripped time-related format that is used in the TimeSelector.
   * Updates each time the `format` property value changes.
   */
  timeSelectorFormat = DEFAULT_TIMESELECTOR_FORMAT;
  /**
   * @hidden
   */
  timeSelectorMin = cloneDate(MIN_TIME);
  /**
   * @hidden
   */
  timeSelectorMax = cloneDate(MAX_TIME);
  /**
   * @hidden
   */
  calendarValue = null;
  /**
   * @hidden
   */
  calendarMin = cloneDate(MIN_DATE);
  /**
   * @hidden
   */
  calendarMax = lastMillisecondOfDate(MAX_DATE);
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  /**
   * @hidden
   */
  windowSize;
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  monthCellTemplate;
  /**
   * @hidden
   */
  yearCellTemplate;
  /**
   * @hidden
   */
  decadeCellTemplate;
  /**
   * @hidden
   */
  centuryCellTemplate;
  /**
   * @hidden
   */
  weekNumberTemplate;
  /**
   * @hidden
   */
  headerTitleTemplate;
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * @hidden
   */
  set headerTemplateRef(template) {
    this.headerTemplate = template;
  }
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  set footerTemplateRef(template) {
    this.footerTemplate = template;
  }
  /**
   * Toggles the visibility of the Calendar footer.
   * @default false
   */
  footer = false;
  get activeTabComponent() {
    if (!this.isOpen) {
      return;
    }
    if (!(isPresent3(this.calendar) || isPresent3(this.timeSelector))) {
      this.cdr.detectChanges();
    }
    return this.activeTab === "date" ? this.calendar : this.timeSelector;
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!isPresent3(appendTo) || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  container;
  popupTemplate;
  actionSheet;
  get popupUID() {
    return this.calendar?.popupId;
  }
  get acceptButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(ACCEPT_BUTTON_SELECTOR);
    }
  }
  get cancelButtonElement() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(CANCEL_BUTTON_SELECOTR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(CANCEL_BUTTON_SELECOTR);
    }
  }
  get dateTabButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(DATE_TAB_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(DATE_TAB_BUTTON_SELECTOR);
    }
  }
  get timeTabButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(TIME_TAB_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(TIME_TAB_BUTTON_SELECTOR);
    }
  }
  get todayButton() {
    if (this.isAdaptive) {
      return this.actionSheet.element.nativeElement.querySelector(TODAY_BUTTON_SELECTOR);
    } else {
      return this.popupRef?.popup.instance.container.nativeElement.querySelector(TODAY_BUTTON_SELECTOR);
    }
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  popupRef;
  _popupSettings = {
    animate: true
  };
  _value = null;
  _format = DEFAULT_DATEINPUT_FORMAT;
  _tabindex = 0;
  _defaultTab = DEFAULT_ACTIVE_TAB;
  _min = mergeDateAndTime(MIN_DATE, MIN_TIME);
  _max = mergeDateAndTime(MAX_DATE, MAX_TIME);
  _disabledDates;
  _isActive = false;
  onControlTouched = noop$2;
  onControlChange = noop$2;
  onValidatorChange = noop$2;
  minValidateFn = noop$2;
  maxValidateFn = noop$2;
  disabledDatesValidateFn = noop$2;
  incompleteValidator = noop$2;
  subscriptions = new Subscription();
  ariaActiveDescendantSubscription;
  _size = DEFAULT_SIZE2;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  constructor(popupService, intl, cdr, pickerService, ngZone, wrapper, localization, disabledDatesService, renderer, injector, adaptiveService) {
    super();
    this.popupService = popupService;
    this.intl = intl;
    this.cdr = cdr;
    this.pickerService = pickerService;
    this.ngZone = ngZone;
    this.wrapper = wrapper;
    this.localization = localization;
    this.disabledDatesService = disabledDatesService;
    this.renderer = renderer;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata2);
  }
  ngOnInit() {
    this.subscriptions.add(this.pickerService.onFocus.pipe(tap(this.detectPopupChanges.bind(this))).subscribe(this.handleFocus.bind(this)));
    this.subscriptions.add(this.pickerService.onBlur.subscribe(this.handleBlur.bind(this)));
    this.subscriptions.add(this.pickerService.sameDateSelected.subscribe(this.handleCalendarValueChange.bind(this)));
    this.subscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    this.subscriptions.add(this.pickerService.dateCompletenessChange.subscribe(this.handleDateCompletenessChange.bind(this)));
    if (isWindowAvailable()) {
      this.subscriptions.add(this.ngZone.runOutsideAngular(() => fromEvent(window, "blur").subscribe(() => {
        if (!this.isAdaptive) {
          this.handleCancel();
        }
      })));
    }
    this.focusableId = this.dateInput?.focusableId;
    this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
    this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    this.windowSize = this.adaptiveService.size;
  }
  ngOnChanges(changes) {
    if (isPresent3(changes["min"]) || isPresent3(changes["max"])) {
      this.verifyMinMaxRange();
    }
    if (changes["min"] || changes["max"] || changes["rangeValidation"] || changes["disabledDatesValidation"] || changes["disabledDates"] || changes["incompleteDateValidation"]) {
      this.minValidateFn = this.rangeValidation ? minValidator(this.min) : noop$2;
      this.maxValidateFn = this.rangeValidation ? maxValidator(this.max) : noop$2;
      this.disabledDatesValidateFn = this.disabledDatesValidation ? disabledDatesValidator(this.disabledDatesService.isDateDisabled) : noop$2;
      this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop$2;
      this.onValidatorChange();
    }
    if (!this.focusableId || changes["focusableId"]) {
      this.focusableId = this.dateInput?.focusableId;
    }
  }
  ngOnDestroy() {
    if (this.isOpen && !this.isAdaptive) {
      this.closePopup();
    }
    this.subscriptions.unsubscribe();
  }
  /**
   * * If the popup is closed, focuses the DateTimePicker input.
   * * If the popup is open, the focus is moved to its content.
   */
  focus() {
    if (this.disabled) {
      return;
    }
    if (this.isOpen) {
      this.activeTabComponent.focus();
    } else {
      this.dateInput.focus();
    }
  }
  /**
   * Blurs the DateTimePicker.
   */
  blur() {
    if (this.isOpen && this.activeTabComponent.isActive) {
      this.activeTabComponent.blur();
    } else {
      this.dateInput.blur();
    }
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show - The state of the popup.
   */
  toggle(show) {
    if (this.disabled || this.readonly || show === this.isOpen) {
      return;
    }
    const previousWindowSize = this.windowSize;
    this.windowSize = this.adaptiveService.size;
    if (previousWindowSize !== this.windowSize && !show) {
      if (previousWindowSize !== "large") {
        this.toggleActionSheet(show);
      } else {
        this._togglePopup(show);
      }
    } else {
      if (this.isAdaptive) {
        this.toggleActionSheet(show);
      } else {
        this._togglePopup(show);
      }
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.verifyValue(value);
    this.value = cloneDate(value);
    this.cdr.markForCheck();
    if (!value && this.dateInput) {
      this.dateInput.placeholder = this.placeholder;
      this.dateInput.writeValue(value);
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onControlChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onControlTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(disabled) {
    this.disabled = disabled;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control) || this.disabledDatesValidateFn(control) || this.incompleteValidator(control, this.dateInput && this.dateInput.isDateIncomplete);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  /**
   * @hidden
   *
   * Used by the TextBoxContainer to determine if the floating label will render in the input.
   */
  isEmpty() {
    return !isPresent3(this.value) && this.dateInput.isEmpty();
  }
  /**
   * @hidden
   */
  handleIconClick(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    event2.preventDefault();
    const runInZone = !this.isOpen || hasObservers(this.close);
    this.run(runInZone, () => {
      const shouldOpen = !this.isOpen;
      this.handleFocus();
      if (!shouldOpen) {
        this.dateInput.focus();
      }
      this.toggleDateTime(shouldOpen);
      this.switchFocus();
    });
  }
  /**
   * @hidden
   */
  handleFocus() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => this.onFocus.emit());
    }
  }
  /**
   * @hidden
   */
  handleBlur(event2) {
    if (!this.isActive || this.focusTargetInComponent(event2)) {
      return;
    }
    this.isActive = false;
    const isNgControlUntouched = this.wrapper.nativeElement.classList.contains("ng-untouched");
    const runInZone = isNgControlUntouched || hasObservers(this.onBlur) || this.isOpen && hasObservers(this.close);
    this.run(runInZone, () => {
      this.onBlur.emit();
      this.onControlTouched();
      this.toggleDateTime(false);
      this.cdr.markForCheck();
    });
  }
  /**
   * @hidden
   */
  changeActiveTab(tab) {
    if (!this.isOpen || this.activeTab === tab) {
      return;
    }
    if (!isEqual(this.timeSelector.value, this.timeSelector.current)) {
      this.timeSelector.handleAccept();
    }
    this.activeTab = tab;
    this.cdr.detectChanges();
    this.detectPopupChanges();
  }
  /**
   * @hidden
   */
  handleTabChangeTransitionEnd(dateTimeSelector, event2) {
    if (event2.target !== dateTimeSelector) {
      return;
    }
    if (this.activeTab === "time") {
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant);
    }
    this.activeTabComponent.focus();
  }
  /**
   * @hidden
   */
  onTabOutLastPart() {
    if (this.calendarValue) {
      this.acceptButton.focus();
    } else if (!this.calendarValue && this.cancelButton) {
      this.cancelButtonElement.focus();
    } else {
      this.dateTabButton.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutFirstPart() {
    if (this.activeTab === "time") {
      this.renderer.removeClass(this.timeSelector.timeListWrappers.first.nativeElement, "k-focus");
      this.timeSelector.showNowButton ? this.timeSelector.now.nativeElement.focus() : this.timeTabButton.focus();
    }
  }
  /**
   * @hidden
   */
  onTabOutNow() {
    this.timeTabButton.focus();
  }
  /**
   * @hidden
   */
  handleAccept() {
    if (!this.isOpen) {
      return;
    }
    const candidate = mergeDateAndTime(this.calendar.value, this.timeSelector.current);
    const valueChangePresent = !isEqual(this.value, candidate);
    const runInZone = valueChangePresent || hasObservers(this.close);
    this.run(runInZone, () => {
      this.handleValueChange(candidate);
      this.dateInput.focus();
      this.toggleDateTime(false);
    });
  }
  /**
   * @hidden
   */
  handleCancel() {
    if (!this.isOpen) {
      return;
    }
    const runInZone = hasObservers(this.close);
    this.dateInput.focus();
    this.run(runInZone, () => this.toggleDateTime(false));
    hasObservers(this.escape) && this.escape.emit();
  }
  /**
   * @hidden
   */
  handleInputValueChange(value) {
    this.handleValueChange(value);
    if (this.isOpen) {
      this.toggleDateTime(false);
    }
  }
  /**
   * @hidden
   */
  handleDateInputClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.toggleDateTime(true);
    }
  }
  /**
   * @hidden
   */
  handleCalendarValueChange() {
    this.setTimeSelectorMinMax(this.calendar.value);
    this.changeActiveTab("time");
  }
  /**
   * @hidden
   */
  handleKeyDown(event2) {
    if (this.disabled || this.readonly) {
      return;
    }
    const {
      keyCode,
      altKey
    } = event2;
    switch (keyCode) {
      case (altKey && Keys.ArrowUp):
      case Keys.Escape:
        this.handleCancel();
        break;
      case (!this.isOpen && altKey && Keys.ArrowDown):
        this.ngZone.run(() => this.toggleDateTime(true));
        break;
      case (altKey && Keys.ArrowRight):
        this.changeActiveTab("time");
        break;
      case (altKey && Keys.ArrowLeft):
        this.changeActiveTab("date");
        break;
      case (this.isOpen && this.timeSelector.isActive && isPresent3(this.calendarValue) && Keys.Enter):
        this.handleAccept();
        break;
      default:
        return;
    }
  }
  /**
   * @hidden
   */
  handleTab(event2) {
    event2.preventDefault();
    const {
      shiftKey
    } = event2;
    switch (event2.target) {
      case this.acceptButton:
        if (!shiftKey) {
          this.cancelButton ? this.cancelButtonElement.focus() : this.dateTabButton.focus();
        } else {
          if (this.activeTab === "date") {
            this.calendar.monthView.list.nativeElement.focus();
          } else {
            this.timeSelector.timeLists.last.focus();
          }
        }
        break;
      case this.cancelButtonElement:
        if (this.calendarValue) {
          shiftKey ? this.acceptButton.focus() : this.dateTabButton.focus();
        } else {
          if (shiftKey) {
            if (this.activeTab === "date") {
              this.calendar.monthView.list.nativeElement.focus();
            } else {
              this.timeSelector.timeLists.last.focus();
            }
          } else {
            this.dateTabButton.focus();
          }
        }
        break;
      case this.dateTabButton:
        if (this.cancelButton) {
          this.cancelButtonElement.focus();
        }
        if (!this.cancelButton && this.calendarValue) {
          this.acceptButton.focus();
        }
        if (!this.cancelButton && !this.calendarValue) {
          if (this.activeTab === "date") {
            this.calendar.monthView.list.nativeElement.focus();
          } else {
            this.timeSelector.timeLists.last.focus();
          }
        }
        break;
      case this.timeTabButton:
        if (this.activeTab === "time") {
          this.timeSelector.showNowButton ? this.timeSelector.now.nativeElement.focus() : this.timeSelector.timeLists.first.focus();
        } else {
          this.todayButton.focus();
        }
        break;
      default:
        break;
    }
  }
  /**
   * @hidden
   */
  handleActionSheetCollapse() {
    this.cdr.markForCheck();
    this.resetActiveTab();
  }
  /**
   * @hidden
   *
   * Prevents the diversion of the focus from the currently active element in the component.
   */
  preventMouseDown(event2) {
    event2.preventDefault();
  }
  /**
   * @hidden
   */
  toggleActionSheet(show) {
    if (isPresent3(show) && show && !this.isOpen) {
      this.actionSheet.toggle();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
      this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
      this.setAriaActiveDescendant();
    } else if (isPresent3(show) && !show && this.isOpen) {
      this.handleBlur();
      this.actionSheet.toggle();
      this.ariaActiveDescendantSubscription.unsubscribe();
      if (this.dateInput) {
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaActiveDescendant);
        this.renderer.removeAttribute(this.dateInput.inputElement, attributeNames.ariaControls);
        this.dateInput.focus();
      }
    }
  }
  _togglePopup(show) {
    const shouldOpen = isPresent3(show) ? show : !this.isOpen;
    if (shouldOpen) {
      this.openPopup();
      return;
    }
    this.closePopup();
    this.resetActiveTab();
  }
  /**
   * Changes the tab and the calendar or clock icon to the designated default.
   */
  resetActiveTab() {
    if (this.activeTab !== this.defaultTab) {
      this.activeTab = this.defaultTab;
      this.cdr.detectChanges();
    }
  }
  verifyValue(value) {
    if (!isDevMode()) {
      return;
    }
    if (isPresent3(value) && !(value instanceof Date)) {
      throw new Error(`The 'value' should be a valid JavaScript Date instance or null. Check ${VALUE_DOC_LINK} for possible resolution.`);
    }
  }
  verifyMinMaxRange() {
    if (!isDevMode()) {
      return;
    }
    if (!isValidRange(this.min, this.max)) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_MAX_DOC_LINK}.`);
    }
  }
  /**
   * Extracts the time slots and the literals that are not preceded by date parts
   * and concatenates the resulting parts into a string.
   * If the provided format value does not contain any time parts,
   * returns the designated format of the default popup component of the TimePicker.
   */
  getTimeSelectorFormat(format) {
    const timeSelectorFormat = this.intl.splitDateFormat(format).filter(this.timeFormatPartFilter).reduce((format2, part) => format2 += part.pattern, "");
    return timeSelectorFormat || DEFAULT_TIMESELECTOR_FORMAT;
  }
  /**
   * Extracts the `displayFormat` from the provided `string | FormatSettings` value.
   * Fallbacks to the default input value, if a falsy value param is passed.
   */
  getDisplayFormat(format) {
    if (!format) {
      return DEFAULT_DATEINPUT_FORMAT;
    }
    if (typeof format === "string") {
      return format;
    } else {
      return format.displayFormat;
    }
  }
  /**
   * The filter expression that filters out all format parts
   * except for `hour`, `minute`, `second`, `dayperiod`, and specific literals.
   * Literals will be left only if they are not preceded by date parts.
   */
  timeFormatPartFilter(part, index, parts) {
    const previousPart = index >= 1 && parts[index - 1];
    if (previousPart && part.type === "literal") {
      return timeFormatRegExp.test(previousPart.type);
    }
    return timeFormatRegExp.test(part.type);
  }
  /**
   * @hidden
   */
  toggleDateTime(open) {
    if (open === this.isOpen) {
      return;
    }
    const event2 = new PreventableEvent3();
    if (open) {
      this.open.emit(event2);
    } else {
      this.close.emit(event2);
    }
    if (event2.isDefaultPrevented()) {
      return;
    }
    this.toggle(open);
    this.switchFocus();
  }
  switchFocus() {
    if (!this.isActive) {
      return;
    }
    if (this.isOpen) {
      this.activeTabComponent.focus();
    } else if (!touchEnabled) {
      this.dateInput.focus();
    } else if (!this.dateInput.isActive) {
      this.handleBlur();
    }
  }
  openPopup() {
    this.setCalendarValue(this.value);
    this.setTimeSelectorMinMax(this.value);
    const direction = this.localization.rtl ? "right" : "left";
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      content: this.popupTemplate,
      positionMode: appendToComponent ? "fixed" : "absolute",
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      popupClass: `k-datetime-container k-datetimepicker-popup ${this.popupSettings.popupClass || ""}`,
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      }
    });
    this.popupRef.popupElement.setAttribute("id", this.popupUID);
    this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaControls, this.popupUID);
    this.setAriaActiveDescendant();
    this.popupRef.popupAnchorViewportLeave.subscribe(() => this.handleCancel());
    if (this.calendar.type === "infinite") {
      this.subscriptions.add(fromEvent(this.calendar.monthView.list.nativeElement, "keydown").subscribe((event2) => {
        const {
          keyCode,
          shiftKey
        } = event2;
        if (keyCode === Keys.Tab && !shiftKey) {
          event2.preventDefault();
          if (!this.calendarValue && !this.cancelButton) {
            this.dateTabButton.focus();
          } else if (this.calendarValue) {
            this.acceptButton.focus();
          } else if (this.cancelButton) {
            this.cancelButtonElement.focus();
          }
        }
      }));
    }
  }
  setAriaActiveDescendant() {
    const focusedCellChangeEvent = this.calendar.type === "infinite" ? this.calendar.monthView.focusedCellChange : this.calendar.multiViewCalendar.viewList.focusedCellChange;
    this.ariaActiveDescendantSubscription = focusedCellChangeEvent.subscribe((id2) => this.renderer.setAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant, id2));
  }
  closePopup() {
    if (!this.isOpen) {
      return;
    }
    this.ariaActiveDescendantSubscription.unsubscribe();
    if (this.dateInput) {
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaControls);
      this.renderer.removeAttribute(this.dateInput?.inputElement, attributeNames.ariaActiveDescendant);
    }
    this.popupRef.close();
    this.popupRef = null;
  }
  handleValueChange(value) {
    if (isEqual(this.value, value)) {
      if (this.incompleteDateValidation) {
        this.onControlChange(cloneDate(value));
      }
      return;
    }
    this.value = cloneDate(value);
    this.onControlChange(cloneDate(value));
    this.valueChange.emit(cloneDate(value));
  }
  /**
   * Indicates whether the focus target is part of this component,
   * that is, whether the focus target is inside the component or in the popup.
   */
  focusTargetInComponent(event2) {
    if (!isPresent3(event2)) {
      return false;
    }
    const relatedTarget = event2.relatedTarget || document.activeElement;
    const focusInPopup = isPresent3(this.popupRef) && this.popupRef.popupElement.contains(relatedTarget);
    const focusInWrapper = this.wrapper.nativeElement.contains(relatedTarget);
    const isInsideActionSheet = this.actionSheet && (this.actionSheet.element.nativeElement.contains(event2.target) || this.actionSheet.element.nativeElement.contains(relatedTarget));
    return focusInPopup || focusInWrapper || isInsideActionSheet;
  }
  setTimeSelectorMinMax(selectedDate) {
    const minDateSelected = isPresent3(selectedDate) && isPresent3(this.min) && isEqual(getDate(selectedDate), getDate(this.min));
    this.timeSelectorMin = cloneDate(minDateSelected ? this.min : MIN_TIME);
    const maxDateSelected = isPresent3(selectedDate) && isPresent3(this.max) && isEqual(getDate(selectedDate), getDate(this.max));
    this.timeSelectorMax = cloneDate(maxDateSelected ? this.max : MAX_TIME);
  }
  setCalendarValue(value) {
    const isInCalendarRange = isPresent3(value) && isInRange(value, this.calendarMin, this.calendarMax);
    this.calendarValue = isInCalendarRange ? getDate(value) : null;
  }
  /**
   * If the popup is available, runs a popup change detection.
   */
  detectPopupChanges() {
    if (!this.isOpen || this.isAdaptive) {
      return;
    }
    this.popupRef.popup.changeDetectorRef.detectChanges();
  }
  /**
   * Depending on the predicate `runInZone` value that is passed,
   * runs the provided function either in the Angular or in the current zone.
   */
  run(runInZone, fn) {
    if (runInZone) {
      this.ngZone.run(() => fn());
    } else {
      fn();
    }
  }
  handleDateCompletenessChange() {
    this.cdr.markForCheck();
    this.ngZone.run(() => this.onValidatorChange());
  }
  setComponentClasses() {
    if (this.size) {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass("input", this.size));
      this.renderer.addClass(this.toggleButton.nativeElement, getSizeClass("button", this.size));
    }
    if (this.rounded) {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode) {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, getFillModeClass("button", this.fillMode));
      this.renderer.addClass(this.toggleButton.nativeElement, `k-button-${this.fillMode}-base`);
    }
  }
  static ɵfac = function DateTimePickerComponent_Factory(t) {
    return new (t || _DateTimePickerComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PickerService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(DisabledDatesService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateTimePickerComponent,
    selectors: [["kendo-datetimepicker"]],
    contentQueries: function DateTimePickerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MonthCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, YearCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DecadeCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CenturyCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, WeekNumberCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTitleTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.monthCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.yearCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decadeCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.centuryCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.weekNumberTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTitleTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    viewQuery: function DateTimePickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(_c14, 7, ViewContainerRef);
        ɵɵviewQuery(_c15, 7, TemplateRef);
        ɵɵviewQuery(_c17, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DateTimePickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-datetimepicker", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      focusableId: "focusableId",
      weekDaysFormat: "weekDaysFormat",
      showOtherMonthDays: "showOtherMonthDays",
      value: "value",
      format: "format",
      twoDigitYearMax: "twoDigitYearMax",
      tabindex: "tabindex",
      disabledDates: "disabledDates",
      popupSettings: "popupSettings",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      disabled: "disabled",
      readonly: "readonly",
      readOnlyInput: "readOnlyInput",
      cancelButton: "cancelButton",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      steps: "steps",
      focusedDate: "focusedDate",
      calendarType: "calendarType",
      animateCalendarNavigation: "animateCalendarNavigation",
      weekNumber: "weekNumber",
      min: "min",
      max: "max",
      rangeValidation: "rangeValidation",
      disabledDatesValidation: "disabledDatesValidation",
      incompleteDateValidation: "incompleteDateValidation",
      autoCorrectParts: "autoCorrectParts",
      autoSwitchParts: "autoSwitchParts",
      autoSwitchKeys: "autoSwitchKeys",
      enableMouseWheel: "enableMouseWheel",
      allowCaretMode: "allowCaretMode",
      clearButton: "clearButton",
      autoFill: "autoFill",
      adaptiveMode: "adaptiveMode",
      inputAttributes: "inputAttributes",
      defaultTab: "defaultTab",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      headerTemplateRef: [InputFlags.None, "headerTemplate", "headerTemplateRef"],
      footerTemplateRef: [InputFlags.None, "footerTemplate", "footerTemplateRef"],
      footer: "footer"
    },
    outputs: {
      valueChange: "valueChange",
      open: "open",
      close: "close",
      onFocus: "focus",
      onBlur: "blur",
      escape: "escape"
    },
    exportAs: ["kendo-datetimepicker"],
    standalone: true,
    features: [ɵɵProvidersFeature([PickerService, LocalizationService, DisabledDatesService, {
      provide: L10N_PREFIX,
      useValue: "kendo.datetimepicker"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DateTimePickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _DateTimePickerComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DateTimePickerComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _DateTimePickerComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 17,
    vars: 51,
    consts: () => {
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_38 = goog.getMsg("Date");
        i18n_38 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header:Date`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_39 = goog.getMsg("Date tab");
        i18n_39 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header:Date tab`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_40 = goog.getMsg("Time");
        i18n_40 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header:Time`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_41 = goog.getMsg("Time tab");
        i18n_41 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header:Time tab`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_42 = goog.getMsg("Toggle popup");
        i18n_42 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component:Toggle popup`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_43 = goog.getMsg("Set");
        i18n_43 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.datetimepicker.accept|The Accept button text in the datetimepicker component:Set`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_44 = goog.getMsg("Set");
        i18n_44 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component:Set`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_45 = goog.getMsg("Cancel");
        i18n_45 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component:Cancel`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_46 = goog.getMsg("Cancel");
        i18n_46 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component:Cancel`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_47 = goog.getMsg("NOW");
        i18n_47 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.datetimepicker.now|The Now button text in the timepicker component:NOW`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_48 = goog.getMsg("Select now");
        i18n_48 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component:Select now`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_49 = goog.getMsg("Today");
        i18n_49 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.datetimepicker.today|The label for the today button in the calendar header:Today`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_50 = goog.getMsg("Navigate to previous view");
        i18n_50 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar:Navigate to previous view`;
      }
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_51 = goog.getMsg("Navigate to next view");
        i18n_51 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar:Navigate to next view`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_52 = goog.getMsg("Navigate to parent view");
        i18n_52 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.datetimepicker.parentViewButtonTitle|The title of the parent view button in the calendar header:Navigate to parent view`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_53 = goog.getMsg("Hour");
        i18n_53 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.datetimepicker.hour|The label for the hour part in the timepicker component:Hour`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_54 = goog.getMsg("Minute");
        i18n_54 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.datetimepicker.minute|The label for the minute part in the timepicker component:Minute`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_55 = goog.getMsg("Second");
        i18n_55 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.datetimepicker.second|The label for the second part in the timepicker component:Second`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_56 = goog.getMsg("Millisecond");
        i18n_56 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.datetimepicker.millisecond|The label for the millisecond part in the timepicker component:Millisecond`;
      }
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_57 = goog.getMsg("Dayperiod");
        i18n_57 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.datetimepicker.dayperiod|The label for the dayperiod part in the timepicker component:Dayperiod`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_58 = goog.getMsg("clear");
        i18n_58 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.datetimepicker.clearTitle|The title of the clear button:clear`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_59 = goog.getMsg("Close");
        i18n_59 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.datetimepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["toggleButton", ""], ["container", ""], ["popupTemplate", ""], ["actionSheet", ""], ["dateTimeTemplate", ""], ["dateTimeSelector", ""], ["calendar", ""], ["kendoDateTimePickerLocalizedMessages", "", "dateTab", i18n_38, "dateTabLabel", i18n_39, "timeTab", i18n_40, "timeTabLabel", i18n_41, "toggle", i18n_42, "accept", i18n_43, "acceptLabel", i18n_44, "cancel", i18n_45, "cancelLabel", i18n_46, "now", i18n_47, "nowLabel", i18n_48, "today", i18n_49, "prevButtonTitle", i18n_50, "nextButtonTitle", i18n_51, "parentViewButtonTitle", i18n_52, "hour", i18n_53, "minute", i18n_54, "second", i18n_55, "millisecond", i18n_56, "dayperiod", i18n_57, "clearTitle", i18n_58, "adaptiveCloseButtonTitle", i18n_59], ["pickerType", "datetimepicker", "hasPopup", "dialog", "fillMode", "none", "rounded", "none", "size", "none", 3, "valueChange", "click", "value", "format", "clearButton", "twoDigitYearMax", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "formatPlaceholder", "placeholder", "disabled", "focusableId", "readonly", "role", "ariaReadOnly", "steps", "tabindex", "isRequired", "title", "inputAttributes", "isPopupOpen", "kendoEventsOutsideAngular", "scope"], [3, "clearTitle"], ["type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "tabindex", "kendoEventsOutsideAngular", "scope"], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon", 4, "ngIf"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon", 4, "ngIf"], [3, "resize", 4, "ngIf"], [3, "overlayClick", "collapse", "titleId", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], ["name", "calendar", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["name", "clock", "innerCssClass", "k-button-icon", 3, "svgIcon"], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], ["class", "k-text-center", 4, "ngIf"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "fillMode", "flat", "themeColor", "primary", "aria-hidden", "true", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "class", "k-time-cancel", "type", "button", "size", "large", 3, "click", 4, "ngIf"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click", "disabled"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], [3, "ngClass", "kendoEventsOutsideAngular", "scope"], [1, "k-datetime-buttongroup", 3, "kendoEventsOutsideAngular", "scope"], ["role", "group", 1, "k-button-group", "k-button-group-solid", "k-button-group-stretched"], ["kendoButton", "", "type", "button", 1, "k-group-start", 3, "size", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", 1, "k-group-end", 3, "size", "kendoEventsOutsideAngular", "scope"], [1, "k-datetime-selector", 3, "kendoEventsOutsideAngular"], [1, "k-datetime-calendar-wrap"], [3, "valueChange", "focusedDate", "size", "value", "type", "min", "max", "weekDaysFormat", "weekNumber", "navigation", "animateNavigation", "showOtherMonthDays", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "disabled", "disabledDates"], [3, "today", "prevButtonTitle", "nextButtonTitle", "parentViewButtonTitle"], [1, "k-datetime-time-wrap"], [3, "tabOutLastPart", "tabOutFirstPart", "tabOutNow", "ngClass", "value", "format", "min", "max", "setButton", "cancelButton", "steps", "disabled", "isAdaptiveEnabled", "isDateTimePicker"], [3, "acceptLabel", "accept", "cancelLabel", "cancel", "nowLabel", "now", "hour", "minute", "second", "millisecond", "dayperiod"], ["class", "k-datetime-footer k-actions k-actions-stretched k-actions-horizontal", 3, "kendoEventsOutsideAngular", "scope", 4, "ngIf"], [1, "k-datetime-footer", "k-actions", "k-actions-stretched", "k-actions-horizontal", 3, "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", "themeColor", "primary", 1, "k-time-accept", 3, "disabled", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", "class", "k-time-cancel", 3, "kendoEventsOutsideAngular", "scope", 4, "ngIf"], ["kendoButton", "", "type", "button", 1, "k-time-cancel", 3, "kendoEventsOutsideAngular", "scope"]];
    },
    template: function DateTimePickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 7);
        ɵɵelementStart(1, "kendo-dateinput", 8);
        ɵɵlistener("valueChange", function DateTimePickerComponent_Template_kendo_dateinput_valueChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputValueChange($event));
        })("click", function DateTimePickerComponent_Template_kendo_dateinput_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDateInputClick());
        });
        ɵɵelement(2, "kendo-dateinput-messages", 9);
        ɵɵelementEnd();
        ɵɵelementStart(3, "button", 10, 0);
        ɵɵtemplate(5, DateTimePickerComponent_kendo_icon_wrapper_5_Template, 1, 1, "kendo-icon-wrapper", 11)(6, DateTimePickerComponent_kendo_icon_wrapper_6_Template, 1, 1, "kendo-icon-wrapper", 12);
        ɵɵelementEnd();
        ɵɵelementContainer(7, null, 1);
        ɵɵtemplate(9, DateTimePickerComponent_ng_template_9_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor)(11, DateTimePickerComponent_kendo_resize_sensor_11_Template, 1, 0, "kendo-resize-sensor", 13);
        ɵɵelementStart(12, "kendo-actionsheet", 14, 3);
        ɵɵlistener("overlayClick", function DateTimePickerComponent_Template_kendo_actionsheet_overlayClick_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleActionSheet(false));
        })("collapse", function DateTimePickerComponent_Template_kendo_actionsheet_collapse_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleActionSheetCollapse());
        });
        ɵɵtemplate(14, DateTimePickerComponent_ng_template_14_Template, 13, 11, "ng-template", 15);
        ɵɵelementEnd();
        ɵɵtemplate(15, DateTimePickerComponent_ng_template_15_Template, 17, 98, "ng-template", null, 4, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("value", ctx.value)("format", ctx.format)("clearButton", ctx.clearButton)("twoDigitYearMax", ctx.twoDigitYearMax)("min", ctx.min)("max", ctx.max)("incompleteDateValidation", ctx.incompleteDateValidation)("autoCorrectParts", ctx.autoCorrectParts)("autoSwitchParts", ctx.autoSwitchParts)("autoSwitchKeys", ctx.autoSwitchKeys)("enableMouseWheel", ctx.enableMouseWheel)("allowCaretMode", ctx.allowCaretMode)("autoFill", ctx.autoFill)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("disabled", ctx.disabled)("focusableId", ctx.focusableId)("readonly", ctx.readonly || ctx.readOnlyInput)("role", "combobox")("ariaReadOnly", ctx.readonly)("steps", ctx.steps)("tabindex", ctx.tabindex)("isRequired", ctx.isControlRequired)("title", ctx.adaptiveTitle)("inputAttributes", ctx.inputAttributes)("isPopupOpen", ctx.isOpen)("kendoEventsOutsideAngular", ɵɵpureFunction1(41, _c21, ctx.handleKeyDown))("scope", ctx);
        ɵɵadvance();
        ɵɵproperty("clearTitle", ctx.localization.get("clearTitle"));
        ɵɵadvance();
        ɵɵproperty("tabindex", -1)("kendoEventsOutsideAngular", ɵɵpureFunction2(43, _c29, ctx.preventMouseDown, ctx.handleIconClick))("scope", ctx);
        ɵɵattribute("title", ctx.localization.get("toggle"))("aria-label", ctx.localization.get("toggle"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.activeTab === "date");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.activeTab === "time");
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("titleId", ctx.calendar == null ? null : ctx.calendar.headerId)("cssClass", ɵɵpureFunction2(46, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(49, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [LocalizedMessagesDirective2, DateInputComponent, EventsOutsideAngularDirective, DateInputCustomMessagesComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgClass, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-datetimepicker",
      exportAs: "kendo-datetimepicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [PickerService, LocalizationService, DisabledDatesService, {
        provide: L10N_PREFIX,
        useValue: "kendo.datetimepicker"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DateTimePickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => DateTimePickerComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DateTimePickerComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => DateTimePickerComponent)
      }],
      template: `
        <ng-container
            kendoDateTimePickerLocalizedMessages

            i18n-dateTab="kendo.datetimepicker.dateTab|The Date tab text in the datetimepicker popup header"
            dateTab="Date"

            i18n-dateTabLabel="kendo.datetimepicker.dateTabLabel|The label for the Date tab in the datetimepicker popup header"
            dateTabLabel="Date tab"

            i18n-timeTab="kendo.datetimepicker.timeTab|The Time tab text in the datetimepicker popup header"
            timeTab="Time"

            i18n-timeTabLabel="kendo.datetimepicker.timeTabLabel|The label for the Time tab in the datetimepicker popup header"
            timeTabLabel="Time tab"

            i18n-toggle="kendo.datetimepicker.toggle|The title of the toggle button in the datetimepicker component"
            toggle="Toggle popup"

            i18n-accept="kendo.datetimepicker.accept|The Accept button text in the datetimepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.datetimepicker.acceptLabel|The label for the Accept button in the datetimepicker component"
            acceptLabel="Set"

            i18n-cancel="kendo.datetimepicker.cancel|The Cancel button text in the datetimepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.datetimepicker.cancelLabel|The label for the Cancel button in the datetimepicker component"
            cancelLabel="Cancel"

            i18n-now="kendo.datetimepicker.now|The Now button text in the timepicker component"
            now="NOW"

            i18n-nowLabel="kendo.datetimepicker.nowLabel|The label for the Now button in the timepicker component"
            nowLabel="Select now"

            i18n-today="kendo.datetimepicker.today|The label for the today button in the calendar header"
            today="Today"

            i18n-prevButtonTitle="kendo.datetimepicker.prevButtonTitle|The title of the previous button in the Classic calendar"
            prevButtonTitle="Navigate to previous view"

            i18n-nextButtonTitle="kendo.datetimepicker.nextButtonTitle|The title of the next button in the Classic calendar"
            nextButtonTitle="Navigate to next view"

            i18n-parentViewButtonTitle="kendo.datetimepicker.parentViewButtonTitle|The title of the parent view button in the calendar header"
            parentViewButtonTitle="Navigate to parent view"

            i18n-hour="kendo.datetimepicker.hour|The label for the hour part in the timepicker component"
            hour="Hour"

            i18n-minute="kendo.datetimepicker.minute|The label for the minute part in the timepicker component"
            minute="Minute"

            i18n-second="kendo.datetimepicker.second|The label for the second part in the timepicker component"
            second="Second"

            i18n-millisecond="kendo.datetimepicker.millisecond|The label for the millisecond part in the timepicker component"
            millisecond="Millisecond"

            i18n-dayperiod="kendo.datetimepicker.dayperiod|The label for the dayperiod part in the timepicker component"
            dayperiod="Dayperiod"

            i18n-clearTitle="kendo.datetimepicker.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-adaptiveCloseButtonTitle="kendo.datetimepicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"
        >
        </ng-container>

        <kendo-dateinput
            [value]="value"
            [format]="format"
            [clearButton]="clearButton"
            [twoDigitYearMax]="twoDigitYearMax"
            [min]="min"
            [max]="max"
            [incompleteDateValidation]="incompleteDateValidation"
            [autoCorrectParts]="autoCorrectParts"
            [autoSwitchParts]="autoSwitchParts"
            [autoSwitchKeys]="autoSwitchKeys"
            [enableMouseWheel]="enableMouseWheel"
            [allowCaretMode]="allowCaretMode"
            [autoFill]="autoFill"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [disabled]="disabled"
            [focusableId]="focusableId"
            [readonly]="readonly || readOnlyInput"
            [role]="'combobox'"
            [ariaReadOnly]="readonly"
            [steps]="steps"
            [tabindex]="tabindex"
            [isRequired]="isControlRequired"
            [title]="adaptiveTitle"
            pickerType="datetimepicker"
            hasPopup="dialog"
            [inputAttributes]="inputAttributes"
            [isPopupOpen]="isOpen"
            (valueChange)="handleInputValueChange($event)"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown
            }"
            [scope]="this"
            fillMode="none"
            rounded="none"
            size="none"
            (click)="handleDateInputClick()"
        >
            <kendo-dateinput-messages
                [clearTitle]="localization.get('clearTitle')"
            >
            </kendo-dateinput-messages>
        </kendo-dateinput>
        <button
            #toggleButton
            type="button"
            class="k-input-button k-button k-icon-button"
            [tabindex]="-1"
            [attr.title]="localization.get('toggle')"
            [attr.aria-label]="localization.get('toggle')"
            [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                mousedown: preventMouseDown,
                click: handleIconClick
            }"
            [scope]="this"
        >
            <kendo-icon-wrapper
                *ngIf="activeTab === 'date'"
                name="calendar"
                [svgIcon]="calendarIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="activeTab === 'time'"
                name="clock"
                [svgIcon]="clockIcon"
                innerCssClass="k-button-icon"
            >
            </kendo-icon-wrapper>
        </button>

        <ng-container #container></ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="dateTimeTemplate"></ng-container>
        </ng-template>

        <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>

        <kendo-actionsheet
            #actionSheet
            (overlayClick)="toggleActionSheet(false)"
            (collapse)="handleActionSheetCollapse()"
            [titleId]="calendar?.headerId"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center" *ngIf="adaptiveTitle">{{ adaptiveTitle }}</div>
                            <div class="k-actionsheet-subtitle k-text-center" *ngIf="adaptiveSubtitle">{{ adaptiveSubtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="check"
                                [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                                [svgIcon]="checkIcon"
                                fillMode="flat"
                                themeColor="primary"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="toggleActionSheet(false)">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content">
                    <ng-container *ngTemplateOutlet="dateTimeTemplate"></ng-container>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton
                        *ngIf="cancelButton"
                        class="k-time-cancel"
                        type="button"
                        (click)="handleCancel()"
                        size="large"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        type="button"
                        class="k-time-accept"
                        (click)="handleAccept()"
                        [disabled]="!calendarValue"
                        size="large"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>

        <ng-template #dateTimeTemplate>
            <div
                class="k-datetime-wrap k-{{activeTab}}-tab"
                [ngClass]="{
                    'k-datetime-wrap-md': !isAdaptive,
                    'k-datetime-wrap-lg': isAdaptive
                }"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventMouseDown,
                    keydown: handleKeyDown
                }"
                [scope]="this"
            >
                <div class="k-datetime-buttongroup"
                    [kendoEventsOutsideAngular]="{
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
                    [scope]="this"
                >
                    <div class="k-button-group k-button-group-solid k-button-group-stretched" role="group">
                        <button kendoButton
                            type="button"
                            class="k-group-start"
                            [size]="isAdaptive ? 'large' : size"
                            [class.k-selected]="activeTab === 'date'"
                            [attr.aria-pressed]="activeTab === 'date' ? 'true' : 'false'"
                            [attr.title]="localization.get('dateTabLabel')"
                            [attr.aria-label]="localization.get('dateTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'date'),
                                'keydown.shift.tab': handleTab
                            }"
                            [scope]="this"
                        >
                            {{localization.get('dateTab')}}
                        </button>
                        <button kendoButton
                            type="button"
                            class="k-group-end"
                            [size]="isAdaptive ? 'large' : size"
                            [class.k-selected]="activeTab === 'time'"
                            [attr.aria-pressed]="activeTab === 'time' ? 'true' : 'false'"
                            [attr.title]="localization.get('timeTabLabel')"
                            [attr.aria-label]="localization.get('timeTabLabel')"
                            [kendoEventsOutsideAngular]="{
                                click: changeActiveTab.bind(this, 'time'),
                                'keydown.tab': handleTab
                            }"
                            [scope]="this"
                        >
                            {{localization.get('timeTab')}}
                        </button>
                    </div>
                </div>
                <div
                    #dateTimeSelector
                    class="k-datetime-selector"
                    [style.transition]="tabSwitchTransition"
                    [kendoEventsOutsideAngular]="{
                        transitionend: handleTabChangeTransitionEnd.bind(this, dateTimeSelector)
                    }"
                >
                    <div class="k-datetime-calendar-wrap">
                        <kendo-calendar
                            #calendar
                            [focusedDate]="focusedDate"
                            [size]="isAdaptive ? 'large' : size"
                            [(value)]="calendarValue"
                            [type]="calendarType"
                            [min]="calendarMin"
                            [max]="calendarMax"
                            [weekDaysFormat]="weekDaysFormat"
                            [weekNumber]="weekNumber"
                            [navigation]="false"
                            [animateNavigation]="animateCalendarNavigation"
                            [showOtherMonthDays]="showOtherMonthDays"
                            [cellTemplate]="cellTemplate"
                            [monthCellTemplate]="monthCellTemplate"
                            [yearCellTemplate]="yearCellTemplate"
                            [decadeCellTemplate]="decadeCellTemplate"
                            [centuryCellTemplate]="centuryCellTemplate"
                            [weekNumberTemplate]="weekNumberTemplate"
                            [headerTitleTemplate]="headerTitleTemplate"
                            [headerTemplate]="headerTemplate"
                            [footerTemplate]="footerTemplate"
                            [footer]="footer"
                            [disabled]="disableCalendar"
                            [disabledDates]="disabledDates"
                            (valueChange)="handleCalendarValueChange()"
                        >
                            <kendo-calendar-messages
                                [today]="localization.get('today')"
                                [prevButtonTitle]="localization.get('prevButtonTitle')"
                                [nextButtonTitle]="localization.get('nextButtonTitle')"
                                [parentViewButtonTitle]="localization.get('parentViewButtonTitle')"
                            >
                            </kendo-calendar-messages>
                        </kendo-calendar>
                    </div>
                    <div class="k-datetime-time-wrap">
                        <kendo-timeselector
                            [ngClass]="{'k-timeselector-lg': isAdaptive}"
                            [value]="value"
                            [format]="timeSelectorFormat"
                            [min]="timeSelectorMin"
                            [max]="timeSelectorMax"
                            [setButton]="false"
                            [cancelButton]="false"
                            [steps]="steps"
                            [disabled]="disableTimeSelector"
                            [isAdaptiveEnabled]="isAdaptiveModeEnabled"
                            [isDateTimePicker]="true"
                            (tabOutLastPart)="onTabOutLastPart()"
                            (tabOutFirstPart)="onTabOutFirstPart()"
                            (tabOutNow)="onTabOutNow()"
                        >
                            <kendo-timeselector-messages
                                [acceptLabel]="localization.get('acceptLabel')"
                                [accept]="localization.get('accept')"
                                [cancelLabel]="localization.get('cancelLabel')"
                                [cancel]="localization.get('cancel')"
                                [nowLabel]="localization.get('nowLabel')"
                                [now]="localization.get('now')"
                                [hour]="localization.get('hour')"
                                [minute]="localization.get('minute')"
                                [second]="localization.get('second')"
                                [millisecond]="localization.get('millisecond')"
                                [dayperiod]="localization.get('dayperiod')"
                            >
                            </kendo-timeselector-messages>
                        </kendo-timeselector>
                    </div>
                </div>
                <div
                    *ngIf="!isAdaptive"
                    class="k-datetime-footer k-actions k-actions-stretched k-actions-horizontal"
                    [kendoEventsOutsideAngular]="{
                        focusin: handleFocus,
                        focusout: handleBlur
                    }"
                    [scope]="this"
                >
                    <button kendoButton
                        type="button"
                        class="k-time-accept"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                        [disabled]="!calendarValue"
                        [kendoEventsOutsideAngular]="{
                            click: handleAccept,
                            'keydown.tab': handleTab,
                            'keydown.shift.tab': handleTab
                        }"
                        [scope]="this"
                    >
                        {{localization.get('accept')}}
                    </button>

                    <button kendoButton
                        *ngIf="cancelButton"
                        type="button"
                        class="k-time-cancel"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                        [kendoEventsOutsideAngular]="{
                            click: handleCancel,
                            'keydown.tab': handleTab,
                            'keydown.shift.tab': handleTab
                        }"
                        [scope]="this"
                    >
                        {{localization.get('cancel')}}
                    </button>
                </div>
            </div>
        </ng-template>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, DateInputComponent, EventsOutsideAngularDirective, DateInputCustomMessagesComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgClass, CalendarComponent, CalendarCustomMessagesComponent, TimeSelectorComponent, TimeSelectorCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: PopupService
    }, {
      type: IntlService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PickerService
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: DisabledDatesService
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: AdaptiveService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-datetimepicker"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    toggleButton: [{
      type: ViewChild,
      args: ["toggleButton", {
        static: true
      }]
    }],
    focusableId: [{
      type: Input
    }],
    weekDaysFormat: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    twoDigitYearMax: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    readOnlyInput: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    steps: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    animateCalendarNavigation: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    disabledDatesValidation: [{
      type: Input
    }],
    incompleteDateValidation: [{
      type: Input
    }],
    autoCorrectParts: [{
      type: Input
    }],
    autoSwitchParts: [{
      type: Input
    }],
    autoSwitchKeys: [{
      type: Input
    }],
    enableMouseWheel: [{
      type: Input
    }],
    allowCaretMode: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    autoFill: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    escape: [{
      type: Output
    }],
    defaultTab: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    cellTemplate: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    monthCellTemplate: [{
      type: ContentChild,
      args: [MonthCellTemplateDirective, {
        static: false
      }]
    }],
    yearCellTemplate: [{
      type: ContentChild,
      args: [YearCellTemplateDirective, {
        static: false
      }]
    }],
    decadeCellTemplate: [{
      type: ContentChild,
      args: [DecadeCellTemplateDirective, {
        static: false
      }]
    }],
    centuryCellTemplate: [{
      type: ContentChild,
      args: [CenturyCellTemplateDirective, {
        static: false
      }]
    }],
    weekNumberTemplate: [{
      type: ContentChild,
      args: [WeekNumberCellTemplateDirective, {
        static: false
      }]
    }],
    headerTitleTemplate: [{
      type: ContentChild,
      args: [HeaderTitleTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective]
    }],
    headerTemplateRef: [{
      type: Input,
      args: ["headerTemplate"]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective]
    }],
    footerTemplateRef: [{
      type: Input,
      args: ["footerTemplate"]
    }],
    footer: [{
      type: Input
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        read: TemplateRef,
        static: true
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }]
  });
})();
var WeekNamesService = class _WeekNamesService {
  intl;
  constructor(intl) {
    this.intl = intl;
  }
  getWeekNames(includeWeekNumber = false, nameType) {
    const weekNames = shiftWeekNames(this.intl.dateFormatNames({
      nameType,
      type: "days"
    }), this.intl.firstDay());
    return includeWeekNumber ? [""].concat(weekNames) : weekNames;
  }
  static ɵfac = function WeekNamesService_Factory(t) {
    return new (t || _WeekNamesService)(ɵɵinject(IntlService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _WeekNamesService,
    factory: _WeekNamesService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekNamesService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var DateRangePopupTemplateDirective = class _DateRangePopupTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DateRangePopupTemplateDirective_Factory(t) {
    return new (t || _DateRangePopupTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupTemplateDirective,
    selectors: [["", "kendoDateRangePopupTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangePopupTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var isActive = (cmp) => cmp && cmp.isActive || false;
var hasActiveContent = (popup) => popup && popup.hasActiveContent();
var DateRangeService = class _DateRangeService {
  renderer;
  /**
   * An Observable instance that notifies when the `activeRangeEnd` state is changed.
   */
  activeRangeEnd$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the `focusedDate` is changed.
   */
  focusedDate$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the end `DateInput` component is changed.
   * For example, when a new end `DateInput` is attached or when the old one is detached.
   */
  endInput$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the start `DateInput` component is changed.
   * For example, when a new start `DateInput` is attached or the old one is detached.
   */
  startInput$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the `DateRangePopup` component is changed.
   */
  dateRangePopup$ = new BehaviorSubject(null);
  /**
   * An Observable instance that notifies when the state of the selection range is changed.
   */
  range$ = new BehaviorSubject(EMPTY_SELECTIONRANGE);
  /**
   * Gets the current `activeRangeEnd` value.
   */
  get activeRangeEnd() {
    return this.activeRangeEnd$.value;
  }
  /**
   * Gets the current `focusedDate` value.
   */
  get focusedDate() {
    return this.focusedDate$.value;
  }
  /**
   * Gets the `min` range value.
   * The `min` value is extracted from the `start` DateInput value or the `min` value of the Calendar.
   */
  get min() {
    return (this.startInput$.value || {}).min || null;
  }
  /**
   * Gets the `max` range value.
   * The `max` value is extracted from the `end` DateInput value or the `max` value of the Calendar.
   */
  get max() {
    return (this.endInput$.value || {}).max || null;
  }
  /**
   * Gets the current `selectionRange` value.
   */
  get selectionRange() {
    return this.range$.value;
  }
  /**
   * @hidden
   * Gets the start input element.
   */
  get inputStartElement() {
    return this.startInput$.value.inputElement;
  }
  /**
   * @hidden
   * Gets the end input element.
   */
  get inputEndElement() {
    return this.endInput$.value.inputElement;
  }
  /** @hidden */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Activates the registered `DateRangePopup` component.
   * The method opens the popup and focuses the calendar.
   */
  activatePopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (!dateRangePopup) {
      return;
    }
    if (this.startInput$.value) {
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaControls, dateRangePopup.popupUID);
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaExpanded, "true");
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaControls, dateRangePopup.popupUID);
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaExpanded, "true");
    }
    dateRangePopup.activate();
  }
  /**
   * Deactivates the registered `DateRangePopup` component.
   * The method closes the popup.
   */
  deactivatePopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (this.startInput$.value) {
      this.renderer.removeAttribute(this.inputStartElement, attributeNames.ariaControls);
      this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaExpanded, "false");
      this.renderer.removeAttribute(this.inputStartElement, attributeNames.ariaActiveDescendant);
      this.renderer.removeAttribute(this.inputEndElement, attributeNames.ariaControls);
      this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaExpanded, "false");
      this.renderer.removeAttribute(this.inputEndElement, attributeNames.ariaActiveDescendant);
    }
    if (!(dateRangePopup && dateRangePopup.show)) {
      return;
    }
    dateRangePopup.show = false;
  }
  /**
   * @hidden
   */
  setActiveDescendent(id2) {
    this.renderer.setAttribute(this.inputStartElement, attributeNames.ariaActiveDescendant, id2);
    this.renderer.setAttribute(this.inputEndElement, attributeNames.ariaActiveDescendant, id2);
  }
  /**
   * @hidden
   *
   * Deactivates the registered `DateRangePopup` component and fires the `cancel` event.
   * The method closes the popup.
   */
  cancelPopup() {
    const dateRangePopup = this.dateRangePopup$.value;
    if (!(dateRangePopup && dateRangePopup.show)) {
      return;
    }
    dateRangePopup.cancelPopup();
  }
  /**
   * Completes all observables to mitigate possible memory leaks.
   * Calls the method when a component that uses it is destroyed.
   */
  destroy() {
    this.activeRangeEnd$.complete();
    this.dateRangePopup$.complete();
    this.focusedDate$.complete();
    this.endInput$.complete();
    this.startInput$.complete();
    this.range$.complete();
  }
  /**
   * Returns `true` when an active component that is placed inside the `DateRangeComponent` is detected.
   * For example, the opened popup or the focused DateInput.
   *
   * @returns `true` if an active component is present.
   */
  hasActiveComponent() {
    const popup = this.dateRangePopup$.value;
    const isPopup = isActive(popup);
    const isStart = isActive(this.startInput$.value);
    const isEnd = isActive(this.endInput$.value);
    return isPopup || isStart || isEnd || hasActiveContent(popup) || false;
  }
  /**
   * Registers a new start `DateInput` component. Notifies all `startInput$` listeners.
   */
  registerStartInput(startInput) {
    this.startInput$.next(startInput);
  }
  /**
   * Registers a new end `DateInput` component. Notifies all `endInput$` listeners.
   */
  registerEndInput(endInput) {
    this.endInput$.next(endInput);
  }
  /**
   * Registers a new `DateRangePopup` component. Notifies all `dateRangePopup$` listeners.
   */
  registerPopup(dateRangePopup) {
    this.dateRangePopup$.next(dateRangePopup);
  }
  /**
   * Updates the `activeRangeEnd` value. Notifies all `activeRangeEnd$` listeners.
   */
  setActiveRangeEnd(activeRange) {
    if (!activeRange || this.activeRangeEnd === activeRange) {
      return;
    }
    this.activeRangeEnd$.next(activeRange);
  }
  /**
   * Updates the focused date. Notifies all `focusedDate$` listeners.
   */
  setFocusedDate(value) {
    if (isEqual(this.focusedDate$.value, value)) {
      return;
    }
    this.focusedDate$.next(value);
  }
  /**
   * Updates the selection range. Notifies all `range$` listeners.
   */
  setRange(range2 = EMPTY_SELECTIONRANGE) {
    this.range$.next(range2);
  }
  static ɵfac = function DateRangeService_Factory(t) {
    return new (t || _DateRangeService)(ɵɵinject(Renderer2, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DateRangeService,
    factory: _DateRangeService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DateRangeSelectionDirective = class _DateRangeSelectionDirective {
  calendar;
  cdr;
  element;
  dateRangeService;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date,
   * the directive fixes the date range to a single date either on input change or on blur
   * ([see example](slug:autocorrect_daterange#toc-calendar-selection-directive)).
   *
   * By default, the auto-correction is triggered on change.
   * To disable this behavior, set the `autoCorrectOn` property to `none`.
   */
  autoCorrectOn = "change";
  /**
   * Gets or sets the selection range of the calendar. When a new range is set,
   * the connected DateRangeService notifies all related parties.
   */
  get selectionRange() {
    return this.calendar ? this.calendar.selectionRange : null;
  }
  set selectionRange(range2) {
    if (!this.isEqualCalendarRange(range2)) {
      this.setSelectionRange(range2);
    }
    if (!isEqualRange(this.dateRangeService.selectionRange, range2)) {
      this.dateRangeService.setRange(range2);
    }
    this.updateFocusedDate(range2);
  }
  /**
   * Gets or sets the active end of the selection range. This option determines which range end will be updated on
   * user interaction. When a new active end is set, the connected DateRangeService notifies all related parties.
   */
  /**
   * Specifies which end of the selection range will be marked as active. The active end gets modified upon user
   * interaction. When a new active end is set, the wired DateRangeService notifies all related components. For
   * example, the start and end DateInput components.
   *
   * > If the selection range is undefined, the value is ignored.
   */
  get activeRangeEnd() {
    return this.calendar.activeRangeEnd;
  }
  set activeRangeEnd(activeRange) {
    if (this.dateRangeService.activeRangeEnd === activeRange) {
      return;
    }
    this.calendar.activeRangeEnd = activeRange;
    this.dateRangeService.setActiveRangeEnd(activeRange);
  }
  /**
   * @hidden
   * When in adaptive mode range should not be set automatically on calendar value change but only on accept
   */
  shouldSetRange = true;
  /**
   * Fires when the active range end is changed. For more information, refer to
   * the section on [events](slug:events_multiviewcalendar).
   */
  activeRangeEndChange = new EventEmitter();
  /**
   * Fires when the selection range is changed. For more information, refer to
   * the section on [events](slug:events_multiviewcalendar).
   */
  selectionRangeChange = new EventEmitter();
  get calendarRange() {
    return this.selectionRange || EMPTY_SELECTIONRANGE;
  }
  calendarSubscriptions = new Subscription();
  range;
  constructor(calendar, cdr, element, renderer, dateRangeService) {
    this.calendar = calendar;
    this.cdr = cdr;
    this.element = element;
    this.dateRangeService = dateRangeService;
    this.dateRangeService = this.dateRangeService || new DateRangeService(renderer);
    renderer.setAttribute(element.nativeElement, "aria-multiselectable", "true");
  }
  ngOnInit() {
    const calendar = this.calendar;
    const dateRangeService = this.dateRangeService;
    calendar.min = either(dateRangeService.min, calendar.min);
    calendar.max = either(dateRangeService.max, calendar.max);
    this.addSubscriptions(calendar.cellEnter.subscribe((value) => this.handleHover(value)), calendar.valueChange.subscribe((value) => this.handleChange(value)), dateRangeService.focusedDate$.subscribe((focusedDate) => {
      if (!isEqual(calendar.focusedDate, focusedDate)) {
        calendar.focusedDate = focusedDate;
      }
    }), dateRangeService.activeRangeEnd$.subscribe((rangeEnd) => {
      if (calendar.activeRangeEnd === rangeEnd) {
        return;
      }
      calendar.activeRangeEnd = rangeEnd;
      this.activeRangeEndChange.emit(rangeEnd);
      this.cdr.markForCheck();
    }), dateRangeService.range$.subscribe((range2) => {
      if (!this.isEqualCalendarRange(range2)) {
        this.acceptAndEmit(range2);
      }
      this.updateFocusedDate(range2);
    }), fromEvent(this.element.nativeElement, "blur").subscribe(() => this.handleBlur()));
  }
  ngOnDestroy() {
    this.calendarSubscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleChange(value) {
    const service = this.dateRangeService;
    const autoCorrect = this.autoCorrectOn === "change" && this.shouldAutoCorrect(value);
    const activeEnd = this.calendar.activeRangeEnd !== "end" ? "end" : autoCorrect ? "end" : "start";
    this.range = autoCorrect ? clampRange(value) : this.updateRange(value);
    if (!isEqualRange(service.selectionRange, this.range)) {
      this.acceptAndEmit(this.range);
      service.setActiveRangeEnd(activeEnd);
      if (this.shouldSetRange) {
        this.setRange();
      }
    }
  }
  setRange(range2) {
    this.dateRangeService.setRange(this.range ? this.range : range2);
  }
  addSubscriptions(...subscriptions) {
    subscriptions.map((s) => this.calendarSubscriptions.add(s));
  }
  isEqualCalendarRange(range2) {
    return isEqualRange(this.calendar.selectionRange, range2);
  }
  handleBlur() {
    const {
      start,
      end: end2
    } = this.calendarRange;
    const autoCorrect = this.autoCorrectOn === "blur" && start !== null && end2 !== null && end2 < start;
    if (autoCorrect) {
      this.dateRangeService.setRange(clampRange(start));
    }
  }
  handleHover(value) {
    if (this.hasCompleteRange()) {
      return;
    }
    const {
      start,
      end: end2
    } = this.calendarRange;
    const activeRangeEnd = this.calendar.activeRangeEnd;
    const updateRange = start && activeRangeEnd === "end" || end2 && activeRangeEnd === "start";
    if (updateRange) {
      this.setSelectionRange(this.updateRange(value));
    }
  }
  hasCompleteRange() {
    const {
      start,
      end: end2
    } = this.dateRangeService.selectionRange || EMPTY_SELECTIONRANGE;
    return Boolean(start) && Boolean(end2);
  }
  shouldAutoCorrect(value) {
    const {
      end: end2,
      start
    } = this.calendarRange;
    if (this.calendar.activeRangeEnd !== "end") {
      return end2 !== null && value > end2;
    } else {
      return start !== null && value < start;
    }
  }
  updateFocusedDate(range2) {
    if (!range2 || this.dateRangeService.focusedDate) {
      return;
    }
    this.dateRangeService.setFocusedDate(range2.start || range2.end);
  }
  updateRange(value) {
    const {
      end: end2,
      start
    } = this.calendarRange;
    return this.calendar.activeRangeEnd !== "end" ? {
      start: value,
      end: end2
    } : {
      start,
      end: value
    };
  }
  setSelectionRange(range2) {
    this.calendar.selectionRange = range2;
    this.calendar.writeValue(null);
  }
  acceptAndEmit(range2) {
    this.setSelectionRange(range2);
    this.selectionRangeChange.emit(range2);
  }
  static ɵfac = function DateRangeSelectionDirective_Factory(t) {
    return new (t || _DateRangeSelectionDirective)(ɵɵdirectiveInject(MultiViewCalendarComponent), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DateRangeService, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeSelectionDirective,
    selectors: [["", "kendoDateRangeSelection", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      selectionRange: "selectionRange",
      activeRangeEnd: "activeRangeEnd",
      shouldSetRange: "shouldSetRange"
    },
    outputs: {
      activeRangeEndChange: "activeRangeEndChange",
      selectionRangeChange: "selectionRangeChange"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeSelectionDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeSelection]",
      standalone: true
    }]
  }], function() {
    return [{
      type: MultiViewCalendarComponent
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DateRangeService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    autoCorrectOn: [{
      type: Input
    }],
    selectionRange: [{
      type: Input
    }],
    activeRangeEnd: [{
      type: Input
    }],
    shouldSetRange: [{
      type: Input
    }],
    activeRangeEndChange: [{
      type: Output
    }],
    selectionRangeChange: [{
      type: Output
    }]
  });
})();
var DateRangePopupMessages = class _DateRangePopupMessages extends ComponentMessages {
  /**
   * The text of the **Accept** button in the popup footer of the DateRange Popup.
   */
  accept;
  /**
   * The label of the **Accept** button in the popup footer of the DateRange Popup.
   */
  acceptLabel;
  /**
   * The text of the **Cancel** button in the popup footer of the DateRange Popup.
   */
  cancel;
  /**
   * The label of the **Cancel** button in the popup footer of the DateRange Popup.
   */
  cancelLabel;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateRangePopupMessages_BaseFactory;
    return function DateRangePopupMessages_Factory(t) {
      return (ɵDateRangePopupMessages_BaseFactory || (ɵDateRangePopupMessages_BaseFactory = ɵɵgetInheritedFactory(_DateRangePopupMessages)))(t || _DateRangePopupMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupMessages,
    selectors: [["kendo-daterangepopup-messages-base"]],
    inputs: {
      accept: "accept",
      acceptLabel: "acceptLabel",
      cancel: "cancel",
      cancelLabel: "cancelLabel",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "kendo-daterangepopup-messages-base"
    }]
  }], null, {
    accept: [{
      type: Input
    }],
    acceptLabel: [{
      type: Input
    }],
    cancel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }]
  });
})();
var DateRangePopupLocalizedMessagesDirective = class _DateRangePopupLocalizedMessagesDirective extends DateRangePopupMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function DateRangePopupLocalizedMessagesDirective_Factory(t) {
    return new (t || _DateRangePopupLocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangePopupLocalizedMessagesDirective,
    selectors: [["", "kendoDateRangePopupLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DateRangePopupMessages,
      useExisting: forwardRef(() => _DateRangePopupLocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupLocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: DateRangePopupMessages,
        useExisting: forwardRef(() => DateRangePopupLocalizedMessagesDirective)
      }],
      selector: "[kendoDateRangePopupLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateRangePopupComponent = class _DateRangePopupComponent {
  popupService;
  dateRangeService;
  zone;
  renderer;
  localization;
  cdr;
  rtl;
  adaptiveService;
  container;
  actionSheet;
  defaultTemplate;
  contentTemplate;
  dateRangeSelectionDirective;
  viewCalendar;
  contentCalendar;
  /**
   * @hidden
   *
   * Determines whether to display the MultiViewCalendar header.
   */
  showCalendarHeader = true;
  /**
   * Sets or gets the `focusedDate` property of the MultiViewCalendar and
   * defines the focused date of the component
   * ([see example]({% slug dates_multiviewcalendar %}#toc-focused-dates)).
   *
   * > If the MultiViewCalendar is out of the min or max range, it normalizes the defined `focusedDate`.
   */
  focusedDate;
  /**
   * Sets the dates of the MultiViewCalendar that will be disabled
   * ([see example]({% slug disabled_dates_multiviewcalendar %})).
   */
  disabledDates;
  /**
   * Defines the active view that the MultiViewCalendar initially renders
   * ([see example]({% slug viewoptions_multiviewcalendar %})).
   * By default, the active view is `month`.
   *
   * > You have to set `activeView` within the `topView`-`bottomView` range.
   */
  activeView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the bottommost view, to which the user can navigate
   * ([see example](slug:viewdepth_multiviewcalendar)).
   */
  bottomView = CalendarViewEnum[CalendarViewEnum.month];
  /**
   * Defines the topmost view, to which the user can navigate.
   */
  topView = CalendarViewEnum[CalendarViewEnum.century];
  /**
   * Sets or gets the `min` property of the MultiViewCalendar and
   * defines the minimum allowed date value.
   * By default, the `min` value is `1900-1-1`.
   */
  min;
  /**
   * Sets or gets the `max` property of the MultiViewCalendar and
   * defines the maximum allowed date value.
   * By default, the `max` value is `2099-12-31`.
   */
  max;
  /**
   * Allows reverse selection.
   * If `allowReverse` is set to `true`, the component skips the validation of whether the start date is after the end date.
   *
   * @default false
   */
  allowReverse = false;
  /**
   * Determines whether to enable animation when navigating to previous/next view.
   * @default false
   */
  animateNavigation = false;
  /**
   * Sets or gets the `disabled` property of the MultiViewCalendar and
   * determines whether the component is active
   * ([see example]({% slug disabled_multiviewcalendar %})).
   */
  disabled = false;
  /**
   * Sets or gets the `views` property of the MultiViewCalendar and
   * defines the number of rendered months.
   *
   * @default 2
   */
  views = 2;
  /**
   * Determines whether to display a week number column in the `month` view
   * ([see example]({% slug weeknumcolumn_multiviewcalendar %})).
   */
  weekNumber = false;
  /**
   * Controls the popup animation.
   * By default, the opening and closing animations are enabled.
   * For more information about controlling the popup animations,
   * refer to the article on [animations]({% slug animations_popup %}).
   */
  animate = true;
  /**
   * Specifies the element that will be used as an anchor. The popup opens next to that element.
   * For more information, refer to the section on
   * [aligning to specific components]({% slug alignmentpositioning_popup %}#toc-aligning-to-components).
   */
  anchor;
  /**
   * Specifies the anchor pivot point.
   * For more information, refer to the section on
   * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
   */
  anchorAlign;
  /**
   * Determines whether to display a header for every view (for example the month name).
   *
   * @default false
   */
  showViewHeader = false;
  /**
   * Displays the days that fall out of the current month ([see example]({% slug viewoptions_multiviewcalendar %}#toc-displaying-other-month-days)).
   * @default false
   */
  showOtherMonthDays = false;
  /**
   * Controls the popup container. By default, the popup is appended to the root component.
   */
  appendTo;
  /**
   * Configures the collision behavior of the popup.
   * For more information, refer to the article on
   * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).
   */
  collision = {
    horizontal: "fit",
    vertical: "flip"
  };
  /**
   * Specifies the pivot point of the popup.
   * For more information, refer to the section on
   * [positioning]({% slug alignmentpositioning_popup %}#toc-positioning).
   */
  popupAlign;
  /**
   * Specifies the margin value that will be added to the popup dimensions in pixels
   * and leaves a blank space between the popup and the anchor.
   */
  margin;
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the input element of the DateRangePopup and the title text rendered
   * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text rendered in the header of the popup(action sheet).
   * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
   */
  adaptiveSubtitle = "";
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  size;
  /**
   * Fires each time the popup is about to open
   * ([see example](slug:popup_daterange#toc-events)).
   * This event is preventable. If you cancel the event, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example](slug:popup_daterange#toc-events)).
   * This event is preventable. If you cancel the event, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires each time the calendar element is blurred
   * ([see example](slug:popup_daterange#toc-events)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the calendar element is focused
   * ([see example](slug:popup_daterange#toc-events)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport
   * ([see example](slug:popup_daterange#toc-events)).
   */
  cancel = new EventEmitter();
  /**
   * The active calendar that is visible in the popup
   *
   * > When the popup is closed, the property returns `null`.
   */
  get calendar() {
    return this._calendar;
  }
  set calendar(calendar) {
    this._calendar = calendar;
    this.subscribeFocusBlur(calendar);
  }
  /**
   * Gets the active state of the component.
   * When the opened calendar is active, returns `true`.
   */
  get isActive() {
    return this.calendar && this.calendar.isActive || this.actionSheet && this.actionSheet.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  popupRef;
  /**
   * @hidden
   */
  popupUID = guid();
  /**
   * @hidden
   */
  checkIcon = checkIcon;
  /**
   * @hidden
   */
  windowSize;
  /**
   * Gets or sets the visibility state of the component.
   */
  set show(show) {
    if (this._show === show) {
      return;
    }
    const event2 = new PreventableEvent3();
    if (show) {
      this.open.emit(event2);
    } else {
      this.close.emit(event2);
    }
    if (event2.isDefaultPrevented()) {
      return;
    }
    this.toggleDateRange(show);
  }
  get show() {
    return this._show;
  }
  /**
   * @hidden
   */
  handleAccept() {
    this.dateRangeService.setRange(this._rangeSelection);
    this.show = false;
  }
  activateSubscription;
  blurSubscription;
  focusSubscription;
  calendarSubscriptions = new Subscription();
  popupSubscriptions = new Subscription();
  windowBlurSubscription;
  localizationSubscriptions = new Subscription();
  resolvedPromise = Promise.resolve();
  _calendar;
  _show;
  _rangeSelection;
  constructor(popupService, dateRangeService, zone, renderer, localization, cdr, rtl, adaptiveService) {
    this.popupService = popupService;
    this.dateRangeService = dateRangeService;
    this.zone = zone;
    this.renderer = renderer;
    this.localization = localization;
    this.cdr = cdr;
    this.rtl = rtl;
    this.adaptiveService = adaptiveService;
  }
  ngOnInit() {
    this.dateRangeService.registerPopup(this);
    if (this.localization) {
      this.localizationSubscriptions.add(this.localization.changes.subscribe(() => this.cdr.markForCheck()));
    }
  }
  ngAfterViewInit() {
    this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe((changes) => {
      this.calendar = changes.first;
      this.actionSheet.titleId = changes.first?.headerId;
      this.cdr.detectChanges();
    }));
    this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe((changes) => {
      this.calendar = changes.first;
      this.actionSheet.titleId = changes.first?.headerId;
      this.cdr.detectChanges();
    }));
    this.calendarSubscriptions.add(this.dateRangeService.startInput$?.value?.valueChange.subscribe((res) => {
      if (this.calendar) {
        if (!res && this.dateRangeService.selectionRange.end) {
          this.calendar.shouldHoverWhenNoStart = true;
        } else {
          this.calendar.shouldHoverWhenNoStart = false;
        }
      }
    }));
    if (isWindowAvailable()) {
      this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, "blur").subscribe(this.handleWindowBlur.bind(this)));
    }
  }
  ngOnDestroy() {
    this.destroyPopup();
    this.calendarSubscriptions.unsubscribe();
    if (this.activateSubscription) {
      this.activateSubscription.unsubscribe();
    }
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
      this.focusSubscription.unsubscribe();
    }
    if (this.windowBlurSubscription) {
      this.windowBlurSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   *
   */
  onRangeSelectionChange(rangeSelection) {
    this.dateRangeService.setActiveRangeEnd(rangeSelection.activeRangeEnd);
    if (!this.isAdaptive) {
      this.dateRangeService.setRange(rangeSelection.selectionRange);
    } else {
      this._rangeSelection = rangeSelection.selectionRange;
    }
  }
  /**
   *  Opens the popup component and focuses the calendar.
   */
  activate() {
    if (this.show === true) {
      return;
    }
    if (this.activateSubscription) {
      this.activateSubscription.unsubscribe();
    }
    this.show = true;
    this.cdr.markForCheck();
    this.zone.runOutsideAngular(() => {
      this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes).pipe(filter((changes) => changes && changes.first), map((changes) => changes.first)).subscribe((calendar) => setTimeout(() => {
        calendar.focus();
        this.addCalendarSubscription(calendar);
      }));
    });
  }
  /**
   *  Focuses the calendar (if available).
   */
  focus() {
    if (this.calendar) {
      this.calendar.focus();
    }
  }
  /**
   * Checks if a focused element ids placed inside the popup.
   *
   * @return boolean;
   */
  hasActiveContent() {
    if (!isDocumentAvailable() || !this.popupRef) {
      return false;
    }
    return this.popupRef.popupElement.contains(document.activeElement);
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to show or hide the popup or actionSheet,
   * the `open` and `close` events do not fire.
   *
   * @param show The state of the popup.
   */
  toggle(show) {
    this.resolvedPromise.then(() => {
      this.toggleDateRange(show === void 0 ? !this.show : show);
    });
  }
  /**
   * @hidden
   *
   * Closes the popup and triggers the `cancel` event.
   */
  cancelPopup() {
    this.show = false;
    this.cancel.emit();
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (!this.show || this.windowSize === currentWindowSize) {
      return;
    }
    if (this.actionSheet.expanded) {
      this.toggleActionSheet(false);
    } else {
      this.togglePopup(false);
    }
    this.windowSize = currentWindowSize;
  }
  /**
   * @hidden
   */
  closePopup(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    this.toggle(false);
    if (this.dateRangeService.activeRangeEnd === "start" || !this.dateRangeService.activeRangeEnd) {
      this.dateRangeService.startInput$.value.focus();
    } else {
      this.dateRangeService.endInput$.value.focus();
    }
  }
  /**
   * @hidden
   */
  handleTab(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (this.dateRangeService.activeRangeEnd === "start" || !this.dateRangeService.activeRangeEnd) {
      this.dateRangeService.setActiveRangeEnd("end");
    } else {
      this.dateRangeService.endInput$.value.focus();
    }
  }
  /**
   * @hidden
   */
  handleShiftTab(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (this.dateRangeService.activeRangeEnd === "end") {
      this.dateRangeService.setActiveRangeEnd("start");
    } else {
      this.dateRangeService.startInput$.value.focus();
    }
  }
  handleWindowBlur() {
    if (!this.show || this.actionSheet.expanded) {
      return;
    }
    if (hasObservers(this.close)) {
      this.zone.run(() => this.show = false);
    } else {
      this.show = false;
    }
  }
  handleMouseLeave() {
    this.dateRangeService.setRange(this.dateRangeService.selectionRange);
  }
  handleKeydown(event2) {
    const {
      altKey,
      keyCode
    } = event2;
    if (keyCode === Keys.Escape || altKey && keyCode === Keys.ArrowUp) {
      this.zone.run(() => this.cancelPopup());
    }
  }
  subscribeFocusBlur(calendar) {
    if (this.blurSubscription) {
      this.blurSubscription.unsubscribe();
      this.focusSubscription.unsubscribe();
    }
    if (!calendar) {
      return;
    }
    const calendarElement = calendar.element.nativeElement.querySelector(".k-calendar-view");
    this.blurSubscription = fromEvent(calendarElement, "blur").subscribe(() => this.onBlur.emit());
    this.focusSubscription = fromEvent(calendarElement, "focus").subscribe(() => this.onFocus.emit());
  }
  addPopupSubscriptions(...subscriptions) {
    if (!isPresent3(this.popupSubscriptions)) {
      this.popupSubscriptions = new Subscription();
    }
    subscriptions.map((s) => this.popupSubscriptions.add(s));
  }
  get _appendTo() {
    const appendTo = this.appendTo;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  togglePopup(show) {
    this._show = show;
    if (this.popupRef) {
      this.destroyPopup();
    }
    if (this._show) {
      const direction = this.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchor: this.anchor,
        anchorAlign: this.anchorAlign || {
          vertical: "bottom",
          horizontal: direction
        },
        animate: this.animate,
        appendTo: this._appendTo,
        collision: this.collision,
        content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,
        margin: this.margin,
        popupClass: "k-calendar-container k-daterangepicker-popup",
        popupAlign: this.popupAlign || {
          vertical: "top",
          horizontal: direction
        },
        positionMode: "absolute"
      });
      const {
        popupElement,
        popupAnchorViewportLeave
      } = this.popupRef;
      this.renderer.setAttribute(popupElement.querySelector(".k-popup"), "id", this.popupUID);
      this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, "keydown").subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, "mouseleave").subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));
    }
  }
  destroyPopup() {
    if (isPresent3(this.popupRef)) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (isPresent3(this.popupSubscriptions)) {
      this.popupSubscriptions.unsubscribe();
    }
  }
  toggleDateRange(show) {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.toggleActionSheet(show);
    } else {
      this.togglePopup(show);
    }
  }
  toggleActionSheet(show) {
    if (show === this._show) {
      return;
    }
    if (show && !this.actionSheet.expanded) {
      this.actionSheet.toggle();
      this.renderer.setAttribute(this.actionSheet.element.nativeElement, "id", this.popupUID);
    } else if (!show && this.actionSheet.expanded) {
      this.actionSheet.toggle();
    }
    this._show = show;
  }
  addCalendarSubscription = (calendar) => {
    this.calendarSubscriptions.add(calendar.viewList.focusedCellChange.subscribe((id2) => {
      this.dateRangeService.setActiveDescendent(id2);
    }));
  };
  static ɵfac = function DateRangePopupComponent_Factory(t) {
    return new (t || _DateRangePopupComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(RTL, 8), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangePopupComponent,
    selectors: [["kendo-daterange-popup"]],
    contentQueries: function DateRangePopupComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DateRangePopupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, MultiViewCalendarComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentCalendar = _t);
      }
    },
    viewQuery: function DateRangePopupComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c14, 5, ViewContainerRef);
        ɵɵviewQuery(_c17, 5);
        ɵɵviewQuery(_c38, 5);
        ɵɵviewQuery(DateRangeSelectionDirective, 5);
        ɵɵviewQuery(MultiViewCalendarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateRangeSelectionDirective = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewCalendar = _t);
      }
    },
    inputs: {
      showCalendarHeader: "showCalendarHeader",
      focusedDate: "focusedDate",
      disabledDates: "disabledDates",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      min: "min",
      max: "max",
      allowReverse: "allowReverse",
      animateNavigation: "animateNavigation",
      disabled: "disabled",
      views: "views",
      weekNumber: "weekNumber",
      animate: "animate",
      anchor: "anchor",
      anchorAlign: "anchorAlign",
      showViewHeader: "showViewHeader",
      showOtherMonthDays: "showOtherMonthDays",
      appendTo: "appendTo",
      collision: "collision",
      popupAlign: "popupAlign",
      margin: "margin",
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      size: "size"
    },
    outputs: {
      open: "open",
      close: "close",
      onBlur: "blur",
      onFocus: "focus",
      cancel: "cancel"
    },
    exportAs: ["kendo-daterange-popup"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.daterangepopup"
    }]), ɵɵStandaloneFeature],
    decls: 8,
    vars: 7,
    consts: () => {
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_60 = goog.getMsg("Set");
        i18n_60 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.daterangepopup.accept|The Accept button text in the timepicker component:Set`;
      }
      let i18n_61;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_61 = goog.getMsg("Set time");
        i18n_61 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_61;
      } else {
        i18n_61 = $localize`:kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component:Set time`;
      }
      let i18n_62;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_62 = goog.getMsg("Cancel");
        i18n_62 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_62;
      } else {
        i18n_62 = $localize`:kendo.daterangepopup.cancel|The Cancel button text in the timepicker component:Cancel`;
      }
      let i18n_63;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_63 = goog.getMsg("Cancel changes");
        i18n_63 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_63;
      } else {
        i18n_63 = $localize`:kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component:Cancel changes`;
      }
      let i18n_64;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_64 = goog.getMsg("Close");
        i18n_64 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DATEINPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_DATEINPUTS_MJS_64;
      } else {
        i18n_64 = $localize`:kendo.daterangepopup.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["container", ""], ["defaultTemplate", ""], ["actionSheet", ""], ["kendoDateRangePopupLocalizedMessages", "", "accept", i18n_60, "acceptLabel", i18n_61, "cancel", i18n_62, "cancelLabel", i18n_63, "adaptiveCloseButtonTitle", i18n_64], [3, "overlayClick", "collapse", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], ["orientation", "horizontal", "selection", "range", 3, "onClosePopup", "onTabPress", "onShiftTabPress", "rangeSelectionChange", "activeView", "bottomView", "animateNavigation", "disabled", "views", "weekNumber", "topView", "disabledDates", "min", "max", "showCalendarHeader", "focusedDate", "allowReverse", "showViewHeader", "showOtherMonthDays", "size", "value"], [3, "resize", 4, "ngIf"], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], ["class", "k-text-center", 4, "ngIf"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-actionsheet-actions"], ["kendoButton", "", "type", "button", "icon", "check", "fillMode", "flat", "themeColor", "primary", "aria-hidden", "true", "size", "large", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], [1, "k-actionsheet-content"], [1, "k-scrollable-wrap"], ["size", "large", "orientation", "vertical", "selection", "range", 3, "rangeSelectionChange", "animateNavigation", "disabled", "views", "weekNumber", "disabledDates", "activeView", "bottomView", "topView", "min", "max", "showCalendarHeader", "focusedDate", "allowReverse", "showViewHeader", "showOtherMonthDays", "value"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "type", "button", "size", "large", 1, "k-time-cancel", 3, "click"], ["kendoButton", "", "type", "button", "size", "large", "themeColor", "primary", 1, "k-time-accept", 3, "click"], [3, "resize"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"]];
    },
    template: function DateRangePopupComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 3)(1, null, 0);
        ɵɵtemplate(3, DateRangePopupComponent_ng_template_3_Template, 1, 17, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementStart(5, "kendo-actionsheet", 4, 2);
        ɵɵlistener("overlayClick", function DateRangePopupComponent_Template_kendo_actionsheet_overlayClick_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.show = false);
        })("collapse", function DateRangePopupComponent_Template_kendo_actionsheet_collapse_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur.emit());
        });
        ɵɵtemplate(7, DateRangePopupComponent_ng_template_7_Template, 16, 29, "ng-template", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(5);
        ɵɵproperty("cssClass", ɵɵpureFunction2(2, _c19, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(5, _c20, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [DateRangePopupLocalizedMessagesDirective, MultiViewCalendarComponent, ActionSheetComponent, ActionSheetTemplateDirective, NgIf, ResizeSensorComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupComponent, [{
    type: Component,
    args: [{
      exportAs: "kendo-daterange-popup",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.daterangepopup"
      }],
      selector: "kendo-daterange-popup",
      template: `
        <ng-container kendoDateRangePopupLocalizedMessages
            i18n-accept="kendo.daterangepopup.accept|The Accept button text in the timepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component"
            acceptLabel="Set time"

            i18n-cancel="kendo.daterangepopup.cancel|The Cancel button text in the timepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component"
            cancelLabel="Cancel changes"

            i18n-adaptiveCloseButtonTitle="kendo.daterangepopup.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"
        >
        </ng-container> 
        <ng-container #container></ng-container>
        <ng-template #defaultTemplate>
            <kendo-multiviewcalendar
                [activeView]="activeView"
                [bottomView]="bottomView"
                [animateNavigation]="animateNavigation"
                [disabled]="disabled"
                orientation="horizontal"
                [views]="views"
                [weekNumber]="weekNumber"
                [topView]="topView"
                [disabledDates]="disabledDates"
                [min]="min"
                [max]="max"
                [showCalendarHeader]="showCalendarHeader"
                [focusedDate]="focusedDate"
                [allowReverse]="allowReverse"
                [showViewHeader]="showViewHeader"
                [showOtherMonthDays]="showOtherMonthDays"
                selection="range"
                [size]="size"
                [value]="dateRangeService.selectionRange"
                (onClosePopup)="closePopup($event)"
                (onTabPress)="handleTab($event)"
                (onShiftTabPress)="handleShiftTab($event)"
                (rangeSelectionChange)="onRangeSelectionChange($event)"
            ></kendo-multiviewcalendar>
        </ng-template>

        <kendo-actionsheet
            #actionSheet
            (overlayClick)="show=false"
            (collapse)="onBlur.emit()"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
        >
            <ng-template kendoActionSheetTemplate>
                <!-- Resize sensor needs to be inside the template because the date-range-popup
                element itself always has 0x0 size and does not trigger the sensor. 
                Note: The popup in non-adaptive mode closes on window blur -->
                <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center" *ngIf="adaptiveTitle">{{ adaptiveTitle }}</div>
                            <div class="k-actionsheet-subtitle k-text-center" *ngIf="adaptiveSubtitle">{{ adaptiveSubtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="check"
                                [attr.title]="localization.get('adaptiveCloseButtonTitle')"
                                [svgIcon]="checkIcon"
                                fillMode="flat"
                                themeColor="primary"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="handleAccept()">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content">
                    <div class="k-scrollable-wrap">
                        <kendo-multiviewcalendar
                            size="large"
                            [animateNavigation]="animateNavigation"
                            [disabled]="disabled"
                            orientation="vertical"
                            [views]="views"
                            [weekNumber]="weekNumber"
                            [disabledDates]="disabledDates"
                            [activeView]="activeView"
                            [bottomView]="bottomView"
                            [topView]="topView"
                            [min]="min"
                            [max]="max"
                            [showCalendarHeader]="showCalendarHeader"
                            [focusedDate]="focusedDate"
                            [allowReverse]="allowReverse"
                            [showViewHeader]="showViewHeader"
                            [showOtherMonthDays]="showOtherMonthDays"
                            [focusedDate]="dateRangeService.focusedDate"
                            [value]="dateRangeService.selectionRange"
                            selection="range"
                            (rangeSelectionChange)="onRangeSelectionChange($event)"
                        >
                        </kendo-multiviewcalendar>
                    </div>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton
                        class="k-time-cancel"
                        type="button"
                        size="large"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                        (click)="show=false"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        class="k-time-accept"
                        type="button"
                        size="large"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                        (click)="handleAccept()"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `,
      standalone: true,
      imports: [DateRangePopupLocalizedMessagesDirective, MultiViewCalendarComponent, ActionSheetComponent, ActionSheetTemplateDirective, NgIf, ResizeSensorComponent, ButtonComponent]
    }]
  }], function() {
    return [{
      type: PopupService
    }, {
      type: DateRangeService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: AdaptiveService
    }];
  }, {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    actionSheet: [{
      type: ViewChild,
      args: ["actionSheet"]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: false
      }]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [DateRangePopupTemplateDirective, {
        static: false
      }]
    }],
    dateRangeSelectionDirective: [{
      type: ViewChild,
      args: [DateRangeSelectionDirective, {
        static: false
      }]
    }],
    viewCalendar: [{
      type: ViewChildren,
      args: [MultiViewCalendarComponent]
    }],
    contentCalendar: [{
      type: ContentChildren,
      args: [MultiViewCalendarComponent]
    }],
    showCalendarHeader: [{
      type: Input
    }],
    focusedDate: [{
      type: Input
    }],
    disabledDates: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    allowReverse: [{
      type: Input
    }],
    animateNavigation: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    anchor: [{
      type: Input
    }],
    anchorAlign: [{
      type: Input
    }],
    showViewHeader: [{
      type: Input
    }],
    showOtherMonthDays: [{
      type: Input
    }],
    appendTo: [{
      type: Input
    }],
    collision: [{
      type: Input
    }],
    popupAlign: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    cancel: [{
      type: Output
    }]
  });
})();
var DateRangeComponent = class _DateRangeComponent {
  dateRangeService;
  /**
   * @hidden
   *
   * TODO: Make visible when the Infinite Calendar is fixed to set properly the size option.
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (Default)
   * * `large`
   * * `none`
   *
   */
  size;
  /**
  * @hidden
  */
  keydown(event2) {
    const shouldOpenPopup = event2.keyCode === Keys.ArrowDown && event2.altKey;
    if (shouldOpenPopup) {
      this.dateRangeService.activatePopup();
    }
    const shouldClosePopup = event2.keyCode === Keys.ArrowUp && event2.altKey || event2.keyCode === Keys.Escape;
    if (shouldClosePopup) {
      this.dateRangeService.deactivatePopup();
    }
  }
  wrapperClass = true;
  /**
   * @hidden
   */
  showDefault = false;
  contentPopup;
  get hasContentPopup() {
    return this.contentPopup.length > 0;
  }
  subscription;
  constructor(dateRangeService) {
    this.dateRangeService = dateRangeService;
    validatePackage(packageMetadata2);
  }
  ngAfterContentInit() {
    this.showDefault = !this.hasContentPopup;
    this.subscription = this.contentPopup.changes.subscribe(() => {
      this.showDefault = !this.hasContentPopup;
    });
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  static ɵfac = function DateRangeComponent_Factory(t) {
    return new (t || _DateRangeComponent)(ɵɵdirectiveInject(DateRangeService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangeComponent,
    selectors: [["kendo-daterange"]],
    contentQueries: function DateRangeComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DateRangePopupComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentPopup = _t);
      }
    },
    hostVars: 2,
    hostBindings: function DateRangeComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function DateRangeComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-daterangepicker", ctx.wrapperClass);
      }
    },
    inputs: {
      size: "size"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([DateRangeService]), ɵɵStandaloneFeature],
    ngContentSelectors: _c8,
    decls: 2,
    vars: 1,
    consts: [[3, "size", 4, "ngIf"], [3, "size"]],
    template: function DateRangeComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵtemplate(1, DateRangeComponent_kendo_daterange_popup_1_Template, 1, 1, "kendo-daterange-popup", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showDefault);
      }
    },
    dependencies: [NgIf, DateRangePopupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeComponent, [{
    type: Component,
    args: [{
      providers: [DateRangeService],
      selector: "kendo-daterange",
      template: `
        <ng-content></ng-content>
        <kendo-daterange-popup *ngIf="showDefault" [size]="size"></kendo-daterange-popup>
    `,
      standalone: true,
      imports: [NgIf, DateRangePopupComponent]
    }]
  }], function() {
    return [{
      type: DateRangeService
    }];
  }, {
    size: [{
      type: Input
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-daterangepicker"]
    }],
    contentPopup: [{
      type: ContentChildren,
      args: [DateRangePopupComponent]
    }]
  });
})();
var DateRangeInput = class _DateRangeInput {
  activeRangeEnd;
  dateRangeService;
  input;
  element;
  renderer;
  zone;
  navigateCalendarOnFocus = false;
  get isActiveEnd() {
    return this.dateRangeService.activeRangeEnd === this.activeRangeEnd;
  }
  popupSubscriptions = new Subscription();
  subscriptions = new Subscription();
  get popupCalendarActivated() {
    const popup = this.dateRangeService.dateRangePopup$.value;
    return isPresent3(popup) && isPresent3(popup.calendar);
  }
  constructor(activeRangeEnd, dateRangeService, input, element, renderer, zone) {
    this.activeRangeEnd = activeRangeEnd;
    this.dateRangeService = dateRangeService;
    this.input = input;
    this.element = element;
    this.renderer = renderer;
    this.zone = zone;
  }
  init() {
    this.input.role = "combobox";
    this.input.hasPopup = "grid";
    if (this.input.value) {
      this.dateRangeService.setRange(this.getRange(this.input.value));
    }
    [this.input.onBlur.subscribe(() => this.deactivate()), this.input.valueUpdate.subscribe((value) => this.updateRange(value, "change")), this.dateRangeService.activeRangeEnd$.subscribe(() => {
      if (this.navigateCalendarOnFocus) {
        this.focusActiveDate();
      }
      this.toggleActiveClass(this.isActiveEnd);
    }), this.dateRangeService.dateRangePopup$.subscribe((popup) => this.initPopup(popup)), this.dateRangeService.range$.subscribe((range2) => this.updateInputValue(range2)), fromEvent(this.element.nativeElement, "click").subscribe(() => this.activate()), fromEvent(this.element.nativeElement, "keydown").subscribe((event2) => this.togglePopup(event2 || {}))].map((s) => this.subscriptions.add(s));
  }
  destroy() {
    this.subscriptions.unsubscribe();
    this.unsubscribePopup();
  }
  initPopup(popup) {
    if (!popup) {
      this.unsubscribePopup();
      return;
    }
    if (!popup.anchor) {
      popup.anchor = this.element.nativeElement;
    }
    [popup.cancel.subscribe(() => this.isActiveEnd && this.input.focus()), popup.onFocus.subscribe(() => this.toggleActiveClass(this.isActiveEnd)), popup.onBlur.subscribe(() => this.deactivate()), popup.close?.subscribe(() => this.isActiveEnd && this.input.focus())].forEach((s) => this.popupSubscriptions.add(s));
  }
  unsubscribePopup() {
    this.popupSubscriptions.unsubscribe();
    this.popupSubscriptions = new Subscription();
  }
  activate() {
    this.dateRangeService.setActiveRangeEnd(this.activeRangeEnd);
    this.dateRangeService.activatePopup();
  }
  deactivate() {
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        this.updateRange(this.input.value, "blur");
        if (this.dateRangeService.hasActiveComponent()) {
          return;
        }
        this.toggleActiveClass(false);
        this.zone.run(() => this.dateRangeService.deactivatePopup());
      });
    });
  }
  updateRange(value, correctOn) {
    const range2 = this.getRange(value, correctOn);
    if (range2) {
      this.focusActiveDate();
      this.dateRangeService.setRange(range2);
    }
  }
  togglePopup({
    altKey,
    keyCode
  }) {
    if (keyCode === Keys.Escape) {
      this.dateRangeService.cancelPopup();
    } else if (altKey && keyCode === Keys.ArrowDown) {
      this.dateRangeService.activatePopup();
    }
  }
  focusActiveDate() {
    if (this.input.value && this.isActiveEnd) {
      this.dateRangeService.setFocusedDate(cloneDate(this.input.value));
    }
  }
  toggleActiveClass(show) {
    const action = show ? "addClass" : "removeClass";
    const nativeElement = this.element.nativeElement;
    if (nativeElement && nativeElement.querySelector) {
      this.renderer[action](nativeElement, "k-focus");
    }
  }
  static ɵfac = function DateRangeInput_Factory(t) {
    ɵɵinvalidFactory();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeInput
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeInput, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: void 0
    }, {
      type: DateRangeService
    }, {
      type: DateInputComponent
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, null);
})();
var DateRangeEndInputDirective = class _DateRangeEndInputDirective extends DateRangeInput {
  rangeService;
  dateInput;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date, the
   * directive fixes the date range to a single date either on input change or on blur
   * ([see example](slug:autocorrect_daterange#toc-input-directives)).
   *
   * By default, the component does not perform any auto-correction.
   */
  autoCorrectOn;
  /**
   * Specifies the navigation behavior of the calendar when the active end is changed on input focus. When enabled,
   * the calendar navigates to the value of the focused input. Otherwise, the calendar displays the last picked date.
   *
   * By default, the automatic navigation behavior on input focus is disabled.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
   *  <kendo-daterange>
   *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
   *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
   *  </kendo-daterange>
   * `
   * })
   * export class AppComponent {
   *   public start: Date = new Date(2018, 3, 10);
   *   public end: Date = new Date(2018, 10, 20);
   * }
   * ```
   */
  navigateCalendarOnFocus = false;
  constructor(rangeService, dateInput, element, renderer, zone) {
    super("end", rangeService, dateInput, element, renderer, zone);
    this.rangeService = rangeService;
    this.dateInput = dateInput;
  }
  ngOnInit() {
    this.rangeService.registerEndInput(this.dateInput);
    super.init();
    this.dateInput.pickerType = "daterangeend";
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.dateInput.inputElement, attributeNames.ariaExpanded, "false");
  }
  ngOnDestroy() {
    super.destroy();
  }
  getRange(value, correctOn) {
    const {
      min,
      max
    } = this.dateInput;
    if (!isInRange(value, min, max)) {
      return null;
    }
    const {
      start
    } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
    const shouldClamp = this.autoCorrectOn === correctOn && isPresent3(value) && value < start;
    return shouldClamp ? clampRange(value) : {
      start,
      end: cloneDate(value)
    };
  }
  updateInputValue(range2) {
    const {
      end: end2
    } = range2 || EMPTY_SELECTIONRANGE;
    const {
      min,
      max
    } = this.dateInput;
    if (isEqual(this.dateInput.value, end2) || !isInRange(end2, min, max)) {
      return;
    }
    this.dateInput.writeValue(cloneDate(end2));
    this.dateInput.notify();
  }
  static ɵfac = function DateRangeEndInputDirective_Factory(t) {
    return new (t || _DateRangeEndInputDirective)(ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(DateInputComponent), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeEndInputDirective,
    selectors: [["", "kendoDateRangeEndInput", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      navigateCalendarOnFocus: "navigateCalendarOnFocus"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeEndInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeEndInput]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DateRangeService
    }, {
      type: DateInputComponent
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    autoCorrectOn: [{
      type: Input
    }],
    navigateCalendarOnFocus: [{
      type: Input
    }]
  });
})();
var DateRangeStartInputDirective = class _DateRangeStartInputDirective extends DateRangeInput {
  rangeService;
  dateInput;
  renderer;
  /**
   * Specifies the auto-correction behavior. If the start date is greater than the end date,
   * the directive fixes the date range to a single date either on input change or on blur
   * ([see example](slug:autocorrect_daterange#toc-input-directives)).
   *
   * By default, the component does not perform any auto-correction.
   */
  autoCorrectOn;
  /**
   * Specifies the navigation behavior of the calendar when the active end is changed on input focus.
   * When enabled, the calendar navigates to the value of the focused input. Otherwise, the calendar
   * displays the last picked date.
   *
   * By default, the automatic navigation behavior on input focus is disabled.
   *
   * @example
   * ```ts
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <h5>Toggle input focus to see the calendar navigating between range ends.</h5>
   *  <kendo-daterange>
   *      <kendo-dateinput kendoDateRangeStartInput [navigateCalendarOnFocus]="true" [(value)]="start"></kendo-dateinput>
   *      <kendo-dateinput kendoDateRangeEndInput [navigateCalendarOnFocus]="true" [(value)]="end"></kendo-dateinput>
   *  </kendo-daterange>
   * `
   * })
   * export class AppComponent {
   *   public start: Date = new Date(2018, 3, 10);
   *   public end: Date = new Date(2018, 10, 20);
   * }
   * ```
   */
  navigateCalendarOnFocus = false;
  constructor(rangeService, dateInput, element, renderer, zone) {
    super("start", rangeService, dateInput, element, renderer, zone);
    this.rangeService = rangeService;
    this.dateInput = dateInput;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.rangeService.registerStartInput(this.dateInput);
    super.init();
    this.dateInput.pickerType = "daterangestart";
  }
  ngAfterViewInit() {
    this.renderer.setAttribute(this.dateInput.inputElement, attributeNames.ariaExpanded, "false");
  }
  ngOnDestroy() {
    super.destroy();
  }
  getRange(value, correctOn) {
    const {
      min,
      max
    } = this.dateInput;
    if (!isInRange(value, min, max)) {
      return null;
    }
    const {
      end: end2
    } = this.rangeService.selectionRange || EMPTY_SELECTIONRANGE;
    const shouldClamp = this.autoCorrectOn === correctOn && end2 && value > end2;
    return shouldClamp ? clampRange(value) : {
      start: cloneDate(value),
      end: end2
    };
  }
  updateInputValue(range2) {
    const {
      start
    } = range2 || EMPTY_SELECTIONRANGE;
    const {
      min,
      max
    } = this.dateInput;
    if (isEqual(this.dateInput.value, start) || !isInRange(start, min, max)) {
      return;
    }
    this.dateInput.writeValue(cloneDate(start));
    this.dateInput.notify();
  }
  static ɵfac = function DateRangeStartInputDirective_Factory(t) {
    return new (t || _DateRangeStartInputDirective)(ɵɵdirectiveInject(DateRangeService), ɵɵdirectiveInject(DateInputComponent), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DateRangeStartInputDirective,
    selectors: [["", "kendoDateRangeStartInput", ""]],
    inputs: {
      autoCorrectOn: "autoCorrectOn",
      navigateCalendarOnFocus: "navigateCalendarOnFocus"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeStartInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDateRangeStartInput]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DateRangeService
    }, {
      type: DateInputComponent
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    autoCorrectOn: [{
      type: Input
    }],
    navigateCalendarOnFocus: [{
      type: Input
    }]
  });
})();
var DatePickerCustomMessagesComponent = class _DatePickerCustomMessagesComponent extends DatePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DatePickerCustomMessagesComponent_Factory(t) {
    return new (t || _DatePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DatePickerCustomMessagesComponent,
    selectors: [["kendo-datepicker-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DatePickerMessages,
      useExisting: forwardRef(() => _DatePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function DatePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DatePickerMessages,
        useExisting: forwardRef(() => DatePickerCustomMessagesComponent)
      }],
      selector: "kendo-datepicker-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateRangePopupCustomMessagesComponent = class _DateRangePopupCustomMessagesComponent extends DateRangePopupMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateRangePopupCustomMessagesComponent_Factory(t) {
    return new (t || _DateRangePopupCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateRangePopupCustomMessagesComponent,
    selectors: [["kendo-daterange-popup-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DateRangePopupMessages,
      useExisting: forwardRef(() => _DateRangePopupCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function DateRangePopupCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangePopupCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateRangePopupMessages,
        useExisting: forwardRef(() => DateRangePopupCustomMessagesComponent)
      }],
      selector: "kendo-daterange-popup-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DateTimePickerCustomMessagesComponent = class _DateTimePickerCustomMessagesComponent extends DateTimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function DateTimePickerCustomMessagesComponent_Factory(t) {
    return new (t || _DateTimePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateTimePickerCustomMessagesComponent,
    selectors: [["kendo-datetimepicker-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: DateTimePickerMessages,
      useExisting: forwardRef(() => _DateTimePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function DateTimePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: DateTimePickerMessages,
        useExisting: forwardRef(() => DateTimePickerCustomMessagesComponent)
      }],
      selector: "kendo-datetimepicker-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var TimePickerCustomMessagesComponent = class _TimePickerCustomMessagesComponent extends TimePickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TimePickerCustomMessagesComponent_Factory(t) {
    return new (t || _TimePickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TimePickerCustomMessagesComponent,
    selectors: [["kendo-timepicker-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TimePickerMessages,
      useExisting: forwardRef(() => _TimePickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function TimePickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TimePickerMessages,
        useExisting: forwardRef(() => TimePickerCustomMessagesComponent)
      }],
      selector: "kendo-timepicker-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var KENDO_CALENDAR = [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective];
var KENDO_MULTIVIEWCALENDAR = [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective];
var KENDO_DATEINPUT = [DateInputCustomMessagesComponent, DateInputComponent];
var KENDO_DATEPICKER = [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective];
var KENDO_DATERANGE = [DateRangePopupCustomMessagesComponent, ...KENDO_DATEINPUT, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective];
var KENDO_DATETIMEPICKER = [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective];
var KENDO_TIMEPICKER = [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective];
var KENDO_DATEINPUTS = [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR, ...KENDO_DATEINPUT, ...KENDO_DATEPICKER, ...KENDO_DATERANGE, ...KENDO_DATETIMEPICKER, ...KENDO_TIMEPICKER];
var CalendarModule = class _CalendarModule {
  static ɵfac = function CalendarModule_Factory(t) {
    return new (t || _CalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CalendarModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService],
    imports: [CalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CALENDAR],
      imports: [...KENDO_CALENDAR],
      providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService]
    }]
  }], null, null);
})();
var CalendarsModule = class _CalendarsModule {
  static ɵfac = function CalendarsModule_Factory(t) {
    return new (t || _CalendarsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CalendarsModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService],
    imports: [CalendarComponent, MultiViewCalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR],
      imports: [...KENDO_CALENDAR, ...KENDO_MULTIVIEWCALENDAR],
      providers: [IconsService, ResizeBatchService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, PopupService, NavigationService]
    }]
  }], null, null);
})();
var DateInputModule = class _DateInputModule {
  static ɵfac = function DateInputModule_Factory(t) {
    return new (t || _DateInputModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateInputModule,
    imports: [DateInputCustomMessagesComponent, DateInputComponent],
    exports: [DateInputCustomMessagesComponent, DateInputComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [DateInputComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEINPUT],
      imports: [...KENDO_DATEINPUT],
      providers: [IconsService]
    }]
  }], null, null);
})();
var DatePickerModule = class _DatePickerModule {
  static ɵfac = function DatePickerModule_Factory(t) {
    return new (t || _DatePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DatePickerModule,
    imports: [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // DateInputModule providers
      IconsService,
      // CalendarModule providers
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      AdaptiveService
    ],
    imports: [DatePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // DateInputModule providers
        IconsService,
        // CalendarModule providers
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();
var DateInputsModule = class _DateInputsModule {
  static ɵfac = function DateInputsModule_Factory(t) {
    return new (t || _DateInputsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateInputsModule,
    imports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, DateInputCustomMessagesComponent, DateInputComponent, DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective, DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [CalendarCustomMessagesComponent, CalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, DateInputCustomMessagesComponent, DateInputComponent, DatePickerCustomMessagesComponent, DatePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, NavigationItemTemplateDirective, ToggleButtonTabStopDirective, DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective, DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // CalendarModule providers
      IconsService,
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      // TimePickerModule providers
      TimePickerDOMService,
      HoursService,
      MinutesService,
      SecondsService,
      MillisecondsService,
      DayPeriodService,
      AdaptiveService
    ],
    imports: [CalendarComponent, MultiViewCalendarComponent, DateInputComponent, DatePickerComponent, DateInputComponent, DateRangeComponent, DateRangePopupComponent, DateTimePickerComponent, TimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateInputsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATEINPUTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATEINPUTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // CalendarModule providers
        IconsService,
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        // TimePickerModule providers
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();
var TimePickerModule = class _TimePickerModule {
  static ɵfac = function TimePickerModule_Factory(t) {
    return new (t || _TimePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TimePickerModule,
    imports: [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [TimePickerCustomMessagesComponent, TimePickerComponent, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService, AdaptiveService],
    imports: [TimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_TIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_TIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [IconsService, PopupService, ResizeBatchService, TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService, AdaptiveService]
    }]
  }], null, null);
})();
var DateTimePickerModule = class _DateTimePickerModule {
  static ɵfac = function DateTimePickerModule_Factory(t) {
    return new (t || _DateTimePickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateTimePickerModule,
    imports: [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective],
    exports: [DateTimePickerCustomMessagesComponent, DateTimePickerComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective, ToggleButtonTabStopDirective, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // CalendarModule providers
      IconsService,
      ResizeBatchService,
      CalendarDOMService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      PopupService,
      NavigationService,
      // TimePickerModule providers
      TimePickerDOMService,
      HoursService,
      MinutesService,
      SecondsService,
      MillisecondsService,
      DayPeriodService,
      AdaptiveService
    ],
    imports: [DateTimePickerComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTimePickerModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATETIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DATETIMEPICKER, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [
        // CalendarModule providers
        IconsService,
        ResizeBatchService,
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        PopupService,
        NavigationService,
        // TimePickerModule providers
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();
var MultiViewCalendarModule = class _MultiViewCalendarModule {
  static ɵfac = function MultiViewCalendarModule_Factory(t) {
    return new (t || _MultiViewCalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MultiViewCalendarModule,
    imports: [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective],
    exports: [MultiViewCalendarCustomMessagesComponent, MultiViewCalendarComponent, CellTemplateDirective, CenturyCellTemplateDirective, DecadeCellTemplateDirective, FooterTemplateDirective, HeaderTemplateDirective, HeaderTitleTemplateDirective, MonthCellTemplateDirective, NavigationItemTemplateDirective, WeekNumberCellTemplateDirective, YearCellTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService],
    imports: [MultiViewCalendarComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiViewCalendarModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_MULTIVIEWCALENDAR],
      imports: [...KENDO_MULTIVIEWCALENDAR],
      providers: [PopupService, NavigationService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService]
    }]
  }], null, null);
})();
var DateRangeModule = class _DateRangeModule {
  static ɵfac = function DateRangeModule_Factory(t) {
    return new (t || _DateRangeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DateRangeModule,
    imports: [DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective],
    exports: [DateRangePopupCustomMessagesComponent, DateInputCustomMessagesComponent, DateInputComponent, DateRangeEndInputDirective, DateRangePopupTemplateDirective, DateRangeComponent, DateRangePopupComponent, DateRangeSelectionDirective, DateRangeStartInputDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [
      // MultiViewCalendarModule providers
      PopupService,
      NavigationService,
      CenturyViewService,
      DecadeViewService,
      MonthViewService,
      YearViewService,
      // DateInputModule providers
      IconsService,
      // AdaptiveModule providers
      ResizeBatchService,
      AdaptiveService
    ],
    imports: [DateInputComponent, DateRangeComponent, DateRangePopupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateRangeModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DATERANGE],
      imports: [...KENDO_DATERANGE],
      providers: [
        // MultiViewCalendarModule providers
        PopupService,
        NavigationService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        // DateInputModule providers
        IconsService,
        // AdaptiveModule providers
        ResizeBatchService,
        AdaptiveService
      ]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-file-saver/dist/es/save-as.js
function saveAs(data, fileName, options) {
  if (options === void 0) options = {};
  var save = postToProxy;
  if (options.forceProxy && !options.proxyURL) {
    throw new Error("No proxyURL is set, but forceProxy is true");
  }
  if (!options.forceProxy) {
    if (canDownload()) {
      save = saveAsDataURI;
    }
    if (navigator.msSaveBlob) {
      save = saveAsBlob;
    }
  }
  save(data, fileName, options);
}
var anchor = function() {
  return document.createElement("a");
};
var canDownload = function() {
  return "download" in anchor();
};
function saveAsBlob(data, fileName) {
  var blob2 = data;
  if (typeof data === "string") {
    var parts = data.split(";base64,");
    var contentType = parts[0];
    var base642 = atob(parts[1]);
    var array = new Uint8Array(base642.length);
    for (var idx2 = 0; idx2 < base642.length; idx2++) {
      array[idx2] = base642.charCodeAt(idx2);
    }
    blob2 = new Blob([array.buffer], { type: contentType });
  }
  navigator.msSaveBlob(blob2, fileName);
}
function saveAsDataURI(data, fileName) {
  var dataURI = data;
  if (window.Blob && data instanceof Blob) {
    dataURI = URL.createObjectURL(data);
  }
  var fileSaver = anchor();
  fileSaver.download = fileName;
  fileSaver.href = dataURI;
  var e = document.createEvent("MouseEvents");
  e.initMouseEvent(
    "click",
    true,
    false,
    window,
    0,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null
  );
  fileSaver.dispatchEvent(e);
  setTimeout(function() {
    return URL.revokeObjectURL(dataURI);
  });
}
function postToProxy(dataURI, fileName, options) {
  if (!options.proxyURL) {
    return;
  }
  var form = document.createElement("form");
  form.setAttribute("action", options.proxyURL);
  form.setAttribute("method", "POST");
  form.setAttribute("target", options.proxyTarget || "_self");
  var formData = options.proxyData || {};
  formData.fileName = fileName;
  var parts = dataURI.split(";base64,");
  formData.contentType = parts[0].replace("data:", "");
  formData.base64 = parts[1];
  for (var name in formData) {
    if (formData.hasOwnProperty(name)) {
      var input = document.createElement("input");
      input.setAttribute("type", "hidden");
      input.setAttribute("name", name);
      input.setAttribute("value", formData[name]);
      form.appendChild(input);
    }
  }
  document.body.appendChild(form);
  form.submit();
  document.body.removeChild(form);
}

// node_modules/@progress/kendo-file-saver/dist/es/base64.js
var fromCharCode = String.fromCharCode;

// node_modules/@progress/kendo-ooxml/dist/es/services/template-service.js
var current = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = class {
  static register(userImplementation) {
    current = userImplementation;
  }
  static compile(template) {
    return current.compile(template);
  }
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-ooxml/dist/es/utils/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
var UNDEFINED = "undefined";
getterCache[UNDEFINED] = function(obj) {
  return obj;
};
function getter2(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  const fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(typeof index !== UNDEFINED ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    let result = obj;
    for (let idx2 = 0; idx2 < fields.length && result; idx2++) {
      result = result[fields[idx2]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/map.js
function map2(array, func) {
  return array.reduce((result, el, i) => {
    const val = func(el, i);
    if (val != null) {
      result.push(val);
    }
    return result;
  }, []);
}

// node_modules/@progress/kendo-ooxml/dist/es/excel-exporter.js
function defaultGroupHeaderTemplate(data) {
  return `${data.title}: ${data.value}`;
}
function createArray(length2, callback) {
  const result = [];
  for (let idx2 = 0; idx2 < length2; idx2++) {
    result.push(callback(idx2));
  }
  return result;
}
function defaultItemId(item) {
  return item.id;
}
var ExcelExporter = class {
  constructor(options) {
    options.columns = this._trimColumns(options.columns || []);
    this.allColumns = map2(this._leafColumns(options.columns || []), this._prepareColumn);
    this.columns = this._visibleColumns(this.allColumns);
    this.options = options;
    this.data = options.data || [];
    this.aggregates = options.aggregates || {};
    this.groups = [].concat(options.groups || []);
    this.hasGroups = this.groups.length > 0;
    this.hierarchy = options.hierarchy;
    this.hasGroupHeaderColumn = this.columns.some((column) => column.groupHeaderColumnTemplate);
    this.collapsible = this.options.collapsible;
  }
  workbook() {
    const workbook = {
      sheets: [{
        columns: this._columns(),
        rows: this.hierarchy ? this._hierarchyRows() : this._rows(),
        freezePane: this._freezePane(),
        filter: this._filter()
      }]
    };
    return workbook;
  }
  _trimColumns(columns) {
    return columns.filter((column) => {
      let result = Boolean(column.field);
      if (!result && column.columns) {
        result = this._trimColumns(column.columns).length > 0;
      }
      return result;
    });
  }
  _leafColumns(columns) {
    let result = [];
    for (let idx2 = 0; idx2 < columns.length; idx2++) {
      if (!columns[idx2].columns) {
        result.push(columns[idx2]);
      } else {
        result = result.concat(this._leafColumns(columns[idx2].columns));
      }
    }
    return result;
  }
  _prepareColumn(column) {
    if (!column.field) {
      return null;
    }
    let value = function(dataItem) {
      return getter2(column.field, true)(dataItem);
    };
    let values = null;
    if (column.values) {
      values = {};
      column.values.forEach(function(item) {
        values[item.value] = item.text;
      });
      value = function(dataItem) {
        return values[getter2(column.field, true)(dataItem)];
      };
    }
    return Object.assign({}, column, {
      value,
      values,
      groupHeaderTemplate: column.groupHeaderTemplate ? template_service_default.compile(column.groupHeaderTemplate) : defaultGroupHeaderTemplate,
      groupHeaderColumnTemplate: column.groupHeaderColumnTemplate ? template_service_default.compile(column.groupHeaderColumnTemplate) : null,
      groupFooterTemplate: column.groupFooterTemplate ? template_service_default.compile(column.groupFooterTemplate) : null,
      footerTemplate: column.footerTemplate ? template_service_default.compile(column.footerTemplate) : null
    });
  }
  _filter() {
    if (!this.options.filterable) {
      return null;
    }
    const depth = this._depth();
    return {
      from: depth,
      to: depth + this.columns.length - 1
    };
  }
  _createPaddingCells(length2) {
    return createArray(length2, () => Object.assign({
      background: "#dfdfdf",
      color: "#333"
    }, this.options.paddingCellOptions));
  }
  _dataRow(dataItem, level, depth) {
    let cells = this._createPaddingCells(level);
    if (this.hasGroups && depth && dataItem.items) {
      cells = cells.concat(this._groupHeaderCells(dataItem, level, depth));
      const rows = this._dataRows(dataItem.items, level + 1);
      rows.unshift({
        type: "group-header",
        cells,
        level: this.collapsible ? level : null
      });
      return rows.concat(this._footer(dataItem, level));
    }
    const dataCells = [];
    for (let cellIdx = 0; cellIdx < this.columns.length; cellIdx++) {
      dataCells[cellIdx] = this._cell(dataItem, this.columns[cellIdx]);
    }
    if (this.hierarchy) {
      dataCells[0].colSpan = depth - level + 1;
    }
    return [{
      type: "data",
      cells: cells.concat(dataCells),
      level: this.collapsible ? level : null
    }];
  }
  _groupHeaderCells(dataItem, level, depth) {
    const cells = [];
    const column = this.allColumns.filter(function(column2) {
      return column2.field === dataItem.field;
    })[0] || {};
    const title = column && column.title ? column.title : dataItem.field;
    const template = column ? column.groupHeaderTemplate || column.groupHeaderColumnTemplate : null;
    const group = Object.assign({
      title,
      field: dataItem.field,
      value: column && column.values ? column.values[dataItem.value] : dataItem.value,
      aggregates: dataItem.aggregates,
      items: dataItem.items
    }, dataItem.aggregates[dataItem.field]);
    const value = template ? template(group) : `${title}: ${dataItem.value}`;
    cells.push(Object.assign({
      value,
      background: "#dfdfdf",
      color: "#333",
      colSpan: (this.hasGroupHeaderColumn ? 1 : this.columns.length) + depth - level
    }, column.groupHeaderCellOptions));
    if (this.hasGroupHeaderColumn) {
      this.columns.forEach(function(column2, index) {
        if (index > 0) {
          cells.push(Object.assign({
            background: "#dfdfdf",
            color: "#333",
            value: column2.groupHeaderColumnTemplate ? column2.groupHeaderColumnTemplate(Object.assign({ group }, group, dataItem.aggregates[column2.field])) : void 0
          }, column2.groupHeaderCellOptions));
        }
      });
    }
    return cells;
  }
  _dataRows(dataItems, level) {
    const depth = this._depth();
    const rows = [];
    for (let idx2 = 0; idx2 < dataItems.length; idx2++) {
      rows.push.apply(rows, this._dataRow(dataItems[idx2], level, depth));
    }
    return rows;
  }
  _hierarchyRows() {
    const depth = this._depth();
    const data = this.data;
    const itemLevel = this.hierarchy.itemLevel;
    const itemId = this.hierarchy.itemId || defaultItemId;
    const hasFooter = this._hasFooterTemplate();
    const rows = [];
    const parents = [];
    let previousLevel = 0;
    let previousItemId;
    if (!hasFooter) {
      this.collapsible = false;
    }
    for (let idx2 = 0; idx2 < data.length; idx2++) {
      const item = data[idx2];
      const level = itemLevel(item, idx2);
      if (hasFooter) {
        if (level > previousLevel) {
          parents.push({ id: previousItemId, level: previousLevel });
        } else if (level < previousLevel) {
          rows.push.apply(rows, this._hierarchyFooterRows(parents, level, depth));
        }
        previousLevel = level;
        previousItemId = itemId(item, idx2);
      }
      rows.push.apply(rows, this._dataRow(item, level + 1, depth));
    }
    if (hasFooter) {
      rows.push.apply(rows, this._hierarchyFooterRows(parents, 0, depth));
      const rootAggregate = data.length ? this.aggregates[data[0].parentId] : {};
      rows.push(this._hierarchyFooter(rootAggregate, 0, depth));
    }
    this._prependHeaderRows(rows);
    return rows;
  }
  _hierarchyFooterRows(parents, currentLevel, depth) {
    const rows = [];
    while (parents.length && parents[parents.length - 1].level >= currentLevel) {
      const parent = parents.pop();
      rows.push(this._hierarchyFooter(this.aggregates[parent.id], parent.level + 1, depth));
    }
    return rows;
  }
  _hasFooterTemplate() {
    const columns = this.columns;
    for (let idx2 = 0; idx2 < columns.length; idx2++) {
      if (columns[idx2].footerTemplate) {
        return true;
      }
    }
  }
  _hierarchyFooter(aggregates, level, depth) {
    const cells = this.columns.map(function(column, index) {
      const colSpan = index ? 1 : depth - level + 1;
      if (column.footerTemplate) {
        const fieldAggregates = (aggregates || {})[column.field];
        return Object.assign({
          background: "#dfdfdf",
          color: "#333",
          colSpan,
          value: column.footerTemplate(Object.assign({ aggregates }, fieldAggregates))
        }, column.footerCellOptions);
      }
      return Object.assign({
        background: "#dfdfdf",
        color: "#333",
        colSpan
      }, column.footerCellOptions);
    });
    return {
      type: "footer",
      cells: this._createPaddingCells(level).concat(cells),
      level: this.collapsible ? level : null
    };
  }
  _footer(dataItem, level) {
    const rows = [];
    const footer = this.columns.some((column) => column.groupFooterTemplate);
    let templateData, group;
    if (footer) {
      group = {
        group: {
          items: dataItem.items,
          field: dataItem.field,
          value: dataItem.value
        }
      };
      templateData = {};
      Object.keys(dataItem.aggregates).forEach((key) => {
        templateData[key] = Object.assign({}, dataItem.aggregates[key], group);
      });
    }
    const cells = this.columns.map((column) => {
      if (column.groupFooterTemplate) {
        let data = Object.assign({}, templateData, dataItem.aggregates[column.field], group);
        return Object.assign({
          background: "#dfdfdf",
          color: "#333",
          value: column.groupFooterTemplate(data)
        }, column.groupFooterCellOptions);
      }
      return Object.assign({
        background: "#dfdfdf",
        color: "#333"
      }, column.groupFooterCellOptions);
    });
    if (footer) {
      rows.push({
        type: "group-footer",
        cells: this._createPaddingCells(this.groups.length).concat(cells),
        level: this.collapsible ? level : null
      });
    }
    return rows;
  }
  _isColumnVisible(column) {
    return this._visibleColumns([column]).length > 0 && (column.field || column.columns);
  }
  _visibleColumns(columns) {
    return columns.filter((column) => {
      let exportable = column.exportable;
      if (typeof exportable === "object") {
        exportable = column.exportable.excel;
      }
      const visibleInExport = !column.hidden && exportable !== false;
      const visibleInExportOnly = column.hidden && exportable === true;
      let visible = visibleInExport || visibleInExportOnly;
      if (visible && column.columns) {
        visible = this._visibleColumns(column.columns).length > 0;
      }
      return visible;
    });
  }
  _headerRow(row2, groups) {
    const headers = row2.cells.map(function(cell2) {
      return Object.assign(cell2, {
        colSpan: cell2.colSpan > 1 ? cell2.colSpan : 1,
        rowSpan: row2.rowSpan > 1 && !cell2.colSpan ? row2.rowSpan : 1
      });
    });
    if (this.hierarchy && headers[0].firstCell) {
      headers[0].colSpan += this._depth();
    }
    return {
      type: "header",
      cells: createArray(groups.length, () => Object.assign({
        background: "#7a7a7a",
        color: "#fff"
      }, this.options.headerPaddingCellOptions)).concat(headers)
    };
  }
  _prependHeaderRows(rows) {
    const groups = this.groups;
    const headerRows = [{ rowSpan: 1, cells: [], index: 0 }];
    this._prepareHeaderRows(headerRows, this.options.columns);
    for (let idx2 = headerRows.length - 1; idx2 >= 0; idx2--) {
      rows.unshift(this._headerRow(headerRows[idx2], groups));
    }
  }
  _prepareHeaderRows(rows, columns, parentCell, parentRow) {
    const row2 = parentRow || rows[rows.length - 1];
    let childRow = rows[row2.index + 1];
    let totalColSpan = 0;
    for (let idx2 = 0; idx2 < columns.length; idx2++) {
      const column = columns[idx2];
      if (this._isColumnVisible(column)) {
        const cell2 = Object.assign({
          background: "#7a7a7a",
          color: "#fff",
          value: column.title || column.field,
          colSpan: 0,
          firstCell: idx2 === 0 && (!parentCell || parentCell.firstCell)
        }, column.headerCellOptions);
        row2.cells.push(cell2);
        if (column.columns && column.columns.length) {
          if (!childRow) {
            childRow = { rowSpan: 0, cells: [], index: rows.length };
            rows.push(childRow);
          }
          cell2.colSpan = this._trimColumns(this._visibleColumns(column.columns)).length;
          this._prepareHeaderRows(rows, column.columns, cell2, childRow);
          totalColSpan += cell2.colSpan - 1;
          row2.rowSpan = rows.length - row2.index;
        }
      }
    }
    if (parentCell) {
      parentCell.colSpan += totalColSpan;
    }
  }
  _rows() {
    const rows = this._dataRows(this.data, 0);
    if (this.columns.length) {
      this._prependHeaderRows(rows);
      let footer = false;
      const cells = this.columns.map((column) => {
        if (column.footerTemplate) {
          footer = true;
          return Object.assign({
            background: "#dfdfdf",
            color: "#333",
            value: column.footerTemplate(Object.assign({}, this.aggregates, this.aggregates[column.field]))
          }, column.footerCellOptions);
        }
        return Object.assign({
          background: "#dfdfdf",
          color: "#333"
        }, column.footerCellOptions);
      });
      if (footer) {
        rows.push({
          type: "footer",
          cells: this._createPaddingCells(this.groups.length).concat(cells)
        });
      }
    }
    return rows;
  }
  _headerDepth(columns) {
    const result = 1;
    let max = 0;
    for (let idx2 = 0; idx2 < columns.length; idx2++) {
      if (columns[idx2].columns) {
        const temp = this._headerDepth(columns[idx2].columns);
        if (temp > max) {
          max = temp;
        }
      }
    }
    return result + max;
  }
  _freezePane() {
    const columns = this._visibleColumns(this.options.columns || []);
    const colSplit = this._visibleColumns(this._trimColumns(this._leafColumns(columns.filter(function(column) {
      return column.locked;
    })))).length;
    return {
      rowSplit: this._headerDepth(columns),
      colSplit: colSplit ? colSplit + this.groups.length : 0
    };
  }
  _cell(dataItem, column) {
    return Object.assign({
      value: column.value(dataItem)
    }, column.cellOptions);
  }
  _depth() {
    let depth = 0;
    if (this.hierarchy) {
      depth = this.hierarchy.depth;
    } else {
      depth = this.groups.length;
    }
    return depth;
  }
  _columns() {
    const depth = this._depth();
    const columns = createArray(depth, () => ({ width: 20 }));
    return columns.concat(this.columns.map(function(column) {
      return {
        width: parseInt(column.width, 10),
        autoWidth: column.width ? false : true
      };
    }));
  }
};
var excel_exporter_default = ExcelExporter;

// node_modules/@progress/kendo-ooxml/dist/es/services/intl-service.js
var current2 = {
  toString: (value) => value
};
var IntlService2 = class {
  static register(userImplementation) {
    current2 = userImplementation;
  }
  static toString(value, format) {
    return current2.toString(value, format);
  }
};
var intl_service_default = IntlService2;

// node_modules/@progress/jszip-esm/dist/jszip-esm5.js
var external = {
  Promise
};
var support = {
  base64: true,
  array: true,
  string: true,
  nodebuffer: false,
  nodestream: false,
  get arraybuffer() {
    return typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  },
  // Returns true if JSZip can read/generate Uint8Array, false otherwise.
  get uint8array() {
    return typeof Uint8Array !== "undefined";
  },
  get blob() {
    return blob();
  }
};
var blob = function() {
  var supported;
  if (typeof ArrayBuffer === "undefined") {
    supported = false;
  } else {
    var buffer = new ArrayBuffer(0);
    try {
      supported = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      supported = false;
    }
  }
  blob = function() {
    return supported;
  };
  return supported;
};
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var encode = function(input) {
  var output = [];
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0, len = input.length, remainingBytes = len;
  var isArray2 = typeof input !== "string";
  while (i < input.length) {
    remainingBytes = len - i;
    if (!isArray2) {
      chr1 = input.charCodeAt(i++);
      chr2 = i < len ? input.charCodeAt(i++) : 0;
      chr3 = i < len ? input.charCodeAt(i++) : 0;
    } else {
      chr1 = input[i++];
      chr2 = i < len ? input[i++] : 0;
      chr3 = i < len ? input[i++] : 0;
    }
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
    enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
  }
  return output.join("");
};
var decode = function(input) {
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0, resultIndex = 0;
  var dataUrlPrefix = "data:";
  if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
    throw new Error("Invalid base64 input, it looks like a data url.");
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var totalLength = input.length * 3 / 4;
  if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (totalLength % 1 !== 0) {
    throw new Error("Invalid base64 input, bad content length.");
  }
  var output;
  if (support.uint8array) {
    output = new Uint8Array(totalLength | 0);
  } else {
    output = new Array(totalLength | 0);
  }
  while (i < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i++));
    enc2 = _keyStr.indexOf(input.charAt(i++));
    enc3 = _keyStr.indexOf(input.charAt(i++));
    enc4 = _keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output[resultIndex++] = chr1;
    if (enc3 !== 64) {
      output[resultIndex++] = chr2;
    }
    if (enc4 !== 64) {
      output[resultIndex++] = chr3;
    }
  }
  return output;
};
function string2binary(str) {
  var result = null;
  if (support.uint8array) {
    result = new Uint8Array(str.length);
  } else {
    result = new Array(str.length);
  }
  return stringToArrayLike(str, result);
}
var newBlob = function(part, type) {
  checkSupport("blob");
  return new Blob([part], {
    type
  });
};
function identity(input) {
  return input;
}
function stringToArrayLike(str, array) {
  for (var i = 0; i < str.length; ++i) {
    array[i] = str.charCodeAt(i) & 255;
  }
  return array;
}
function stringifyByChunk(array, type, chunk) {
  var result = [], k = 0, len = array.length;
  if (len <= chunk) {
    return String.fromCharCode.apply(null, array);
  }
  while (k < len) {
    if (type === "array") {
      result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
    } else {
      result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
    }
    k += chunk;
  }
  return result.join("");
}
function stringifyByChar(array) {
  var resultStr = "";
  for (var i = 0; i < array.length; i++) {
    resultStr += String.fromCharCode(array[i]);
  }
  return resultStr;
}
var fromCharCodeSupportsTypedArrays = function() {
  var supported;
  try {
    supported = support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
  } catch (e) {
    supported = false;
  }
  fromCharCodeSupportsTypedArrays = function() {
    return supported;
  };
  return supported;
};
function arrayLikeToString(array) {
  var chunk = 65536, type = getTypeOf(array), canUseApply = true;
  if (type === "uint8array") {
    canUseApply = fromCharCodeSupportsTypedArrays();
  }
  if (canUseApply) {
    while (chunk > 1) {
      try {
        return stringifyByChunk(array, type, chunk);
      } catch (e) {
        chunk = Math.floor(chunk / 2);
      }
    }
  }
  return stringifyByChar(array);
}
var applyFromCharCode = arrayLikeToString;
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
  for (var i = 0; i < arrayFrom.length; i++) {
    arrayTo[i] = arrayFrom[i];
  }
  return arrayTo;
}
var transform = {
  // string to ?
  "string": {
    "string": identity,
    "array": function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    }
  },
  // array to ?
  "array": {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
      return new Uint8Array(input).buffer;
    },
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // arraybuffer to ?
  "arraybuffer": {
    "string": function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // uint8array to ?
  "uint8array": {
    "string": arrayLikeToString,
    "array": function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return input.buffer;
    },
    "uint8array": identity
  }
};
var transformTo = function(outputType, input) {
  if (!input) {
    input = "";
  }
  if (!outputType) {
    return input;
  }
  checkSupport(outputType);
  var inputType = getTypeOf(input);
  var result = transform[inputType][outputType](input);
  return result;
};
var resolve = function(path) {
  var parts = path.split("/");
  var result = [];
  for (var index = 0; index < parts.length; index++) {
    var part = parts[index];
    if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
      continue;
    } else if (part === "..") {
      result.pop();
    } else {
      result.push(part);
    }
  }
  return result.join("/");
};
var getTypeOf = function(input) {
  if (typeof input === "string") {
    return "string";
  }
  if (Object.prototype.toString.call(input) === "[object Array]") {
    return "array";
  }
  if (support.uint8array && input instanceof Uint8Array) {
    return "uint8array";
  }
  if (support.arraybuffer && input instanceof ArrayBuffer) {
    return "arraybuffer";
  }
};
var checkSupport = function(type) {
  var supported = support[type.toLowerCase()];
  if (!supported) {
    throw new Error(type + " is not supported by this platform");
  }
};
var MAX_VALUE_16BITS = 65535;
var MAX_VALUE_32BITS = -1;
var pretty = function(str) {
  var res = "", code, i;
  for (i = 0; i < (str || "").length; i++) {
    code = str.charCodeAt(i);
    res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
  }
  return res;
};
var delay2 = function(callback, args, self) {
  setTimeout(function() {
    callback.apply(self || null, args || []);
  }, 0);
};
var extend2 = function() {
  var arguments$1 = arguments;
  var result = {}, i, attr;
  for (i = 0; i < arguments.length; i++) {
    for (attr in arguments[i]) {
      if (Object.hasOwnProperty.call(arguments$1[i], attr) && typeof result[attr] === "undefined") {
        result[attr] = arguments$1[i][attr];
      }
    }
  }
  return result;
};
var prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
  var promise = external.Promise.resolve(inputData).then(function(data) {
    var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
    if (isBlob && typeof FileReader !== "undefined") {
      return new external.Promise(function(resolve2, reject) {
        var reader = new FileReader();
        reader.onload = function(e) {
          resolve2(e.target.result);
        };
        reader.onerror = function(e) {
          reject(e.target.error);
        };
        reader.readAsArrayBuffer(data);
      });
    } else {
      return data;
    }
  });
  return promise.then(function(data) {
    var dataType = getTypeOf(data);
    if (!dataType) {
      return external.Promise.reject(
        new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
      );
    }
    if (dataType === "arraybuffer") {
      data = transformTo("uint8array", data);
    } else if (dataType === "string") {
      if (isBase64) {
        data = decode(data);
      } else if (isBinary) {
        if (isOptimizedBinaryString !== true) {
          data = string2binary(data);
        }
      }
    }
    return data;
  });
};
var GenericWorker = function GenericWorker2(name) {
  this.name = name || "default";
  this.streamInfo = {};
  this.generatedError = null;
  this.extraStreamInfo = {};
  this.isPaused = true;
  this.isFinished = false;
  this.isLocked = false;
  this._listeners = {
    "data": [],
    "end": [],
    "error": []
  };
  this.previous = null;
};
GenericWorker.prototype.push = function push(chunk) {
  this.emit("data", chunk);
};
GenericWorker.prototype.end = function end() {
  if (this.isFinished) {
    return false;
  }
  this.flush();
  try {
    this.emit("end");
    this.cleanUp();
    this.isFinished = true;
  } catch (e) {
    this.emit("error", e);
  }
  return true;
};
GenericWorker.prototype.error = function error(e) {
  if (this.isFinished) {
    return false;
  }
  if (this.isPaused) {
    this.generatedError = e;
  } else {
    this.isFinished = true;
    this.emit("error", e);
    if (this.previous) {
      this.previous.error(e);
    }
    this.cleanUp();
  }
  return true;
};
GenericWorker.prototype.on = function on(name, listener) {
  this._listeners[name].push(listener);
  return this;
};
GenericWorker.prototype.cleanUp = function cleanUp() {
  this.streamInfo = this.generatedError = this.extraStreamInfo = null;
  this._listeners = [];
};
GenericWorker.prototype.emit = function emit(name, arg) {
  if (this._listeners[name]) {
    for (var i = 0; i < this._listeners[name].length; i++) {
      this._listeners[name][i].call(this, arg);
    }
  }
};
GenericWorker.prototype.pipe = function pipe(next) {
  return next.registerPrevious(this);
};
GenericWorker.prototype.registerPrevious = function registerPrevious(previous) {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.streamInfo = previous.streamInfo;
  this.mergeStreamInfo();
  this.previous = previous;
  var self = this;
  previous.on("data", function(chunk) {
    self.processChunk(chunk);
  });
  previous.on("end", function() {
    self.end();
  });
  previous.on("error", function(e) {
    self.error(e);
  });
  return this;
};
GenericWorker.prototype.pause = function pause() {
  if (this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = true;
  if (this.previous) {
    this.previous.pause();
  }
  return true;
};
GenericWorker.prototype.resume = function resume() {
  if (!this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = false;
  var withError = false;
  if (this.generatedError) {
    this.error(this.generatedError);
    withError = true;
  }
  if (this.previous) {
    this.previous.resume();
  }
  return !withError;
};
GenericWorker.prototype.flush = function flush() {
};
GenericWorker.prototype.processChunk = function processChunk(chunk) {
  this.push(chunk);
};
GenericWorker.prototype.withStreamInfo = function withStreamInfo(key, value) {
  this.extraStreamInfo[key] = value;
  this.mergeStreamInfo();
  return this;
};
GenericWorker.prototype.mergeStreamInfo = function mergeStreamInfo() {
  for (var key in this.extraStreamInfo) {
    if (!this.extraStreamInfo.hasOwnProperty(key)) {
      continue;
    }
    this.streamInfo[key] = this.extraStreamInfo[key];
  }
};
GenericWorker.prototype.lock = function lock() {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.isLocked = true;
  if (this.previous) {
    this.previous.lock();
  }
};
GenericWorker.prototype.toString = function toString2() {
  var me = "Worker " + this.name;
  if (this.previous) {
    return this.previous + " -> " + me;
  } else {
    return me;
  }
};
var utf8len = function(c) {
  var _utf8len = new Array(256);
  for (var i = 0; i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  utf8len = function(c2) {
    return _utf8len[c2];
  };
  return _utf8len[c];
};
var string2buf = function(str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  if (support.uint8array) {
    buf = new Uint8Array(buf_len);
  } else {
    buf = new Array(buf_len);
  }
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var utf8border = function(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + utf8len(buf[pos]) > max ? pos : max;
};
var buf2string = function(buf) {
  var i, out, c, c_len;
  var len = buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = utf8len(c);
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  if (utf16buf.length !== out) {
    if (utf16buf.subarray) {
      utf16buf = utf16buf.subarray(0, out);
    } else {
      utf16buf.length = out;
    }
  }
  return applyFromCharCode(utf16buf);
};
var utf8encode = function utf8encode2(str) {
  return string2buf(str);
};
var utf8decode = function utf8decode2(buf) {
  buf = transformTo(support.uint8array ? "uint8array" : "array", buf);
  return buf2string(buf);
};
var Utf8DecodeWorker = function(GenericWorker3) {
  function Utf8DecodeWorker2() {
    GenericWorker3.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  Utf8DecodeWorker2.__proto__ = GenericWorker3;
  Utf8DecodeWorker2.prototype = Object.create(GenericWorker3.prototype);
  Utf8DecodeWorker2.prototype.constructor = Utf8DecodeWorker2;
  Utf8DecodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    var data = transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker2.prototype.flush = function flush2() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  return Utf8DecodeWorker2;
}(GenericWorker);
var Utf8EncodeWorker = function(GenericWorker3) {
  function Utf8EncodeWorker2() {
    GenericWorker3.call(this, "utf-8 encode");
  }
  Utf8EncodeWorker2.__proto__ = GenericWorker3;
  Utf8EncodeWorker2.prototype = Object.create(GenericWorker3.prototype);
  Utf8EncodeWorker2.prototype.constructor = Utf8EncodeWorker2;
  Utf8EncodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  return Utf8EncodeWorker2;
}(GenericWorker);
var ConvertWorker = function(GenericWorker3) {
  function ConvertWorker2(destType) {
    GenericWorker3.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  ConvertWorker2.__proto__ = GenericWorker3;
  ConvertWorker2.prototype = Object.create(GenericWorker3.prototype);
  ConvertWorker2.prototype.constructor = ConvertWorker2;
  ConvertWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  return ConvertWorker2;
}(GenericWorker);
function transformZipOutput(type, content2, mimeType) {
  switch (type) {
    case "blob":
      return newBlob(transformTo("arraybuffer", content2), mimeType);
    case "base64":
      return encode(content2);
    default:
      return transformTo(type, content2);
  }
}
function concat(type, dataArray) {
  var i, index = 0, res = null, totalLength = 0;
  for (i = 0; i < dataArray.length; i++) {
    totalLength += dataArray[i].length;
  }
  switch (type) {
    case "string":
      return dataArray.join("");
    case "array":
      return Array.prototype.concat.apply([], dataArray);
    case "uint8array":
      res = new Uint8Array(totalLength);
      for (i = 0; i < dataArray.length; i++) {
        res.set(dataArray[i], index);
        index += dataArray[i].length;
      }
      return res;
    default:
      throw new Error("concat : unsupported type '" + type + "'");
  }
}
function accumulate(helper, updateCallback) {
  return new external.Promise(function(resolve2, reject) {
    var dataArray = [];
    var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
    helper.on("data", function(data, meta) {
      dataArray.push(data);
      if (updateCallback) {
        updateCallback(meta);
      }
    }).on("error", function(err) {
      dataArray = [];
      reject(err);
    }).on("end", function() {
      try {
        var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
        resolve2(result);
      } catch (e) {
        reject(e);
      }
      dataArray = [];
    }).resume();
  });
}
var StreamHelper = function StreamHelper2(worker, outputType, mimeType) {
  var internalType = outputType;
  switch (outputType) {
    case "blob":
    case "arraybuffer":
      internalType = "uint8array";
      break;
    case "base64":
      internalType = "string";
      break;
  }
  try {
    this._internalType = internalType;
    this._outputType = outputType;
    this._mimeType = mimeType;
    checkSupport(internalType);
    this._worker = worker.pipe(new ConvertWorker(internalType));
    worker.lock();
  } catch (e) {
    this._worker = new GenericWorker("error");
    this._worker.error(e);
  }
};
StreamHelper.prototype.accumulate = function accumulate$1(updateCb) {
  return accumulate(this, updateCb);
};
StreamHelper.prototype.on = function on2(evt, fn) {
  var self = this;
  if (evt === "data") {
    this._worker.on(evt, function(chunk) {
      fn.call(self, chunk.data, chunk.meta);
    });
  } else {
    this._worker.on(evt, function() {
      delay2(fn, arguments, self);
    });
  }
  return this;
};
StreamHelper.prototype.resume = function resume2() {
  delay2(this._worker.resume, [], this._worker);
  return this;
};
StreamHelper.prototype.pause = function pause2() {
  this._worker.pause();
  return this;
};
var base64 = false;
var binary = false;
var dir = false;
var createFolders = true;
var date = null;
var compression = null;
var compressionOptions = null;
var comment = null;
var unixPermissions = null;
var dosPermissions = null;
var defaults = Object.freeze({
  __proto__: null,
  base64,
  binary,
  comment,
  compression,
  compressionOptions,
  createFolders,
  date,
  dir,
  dosPermissions,
  unixPermissions
});
var DEFAULT_BLOCK_SIZE = 16 * 1024;
var DataWorker = function(GenericWorker3) {
  function DataWorker2(dataP) {
    GenericWorker3.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self.dataIsReady = true;
      self.data = data;
      self.max = data && data.length || 0;
      self.type = getTypeOf(data);
      if (!self.isPaused) {
        self._tickAndRepeat();
      }
    }, function(e) {
      self.error(e);
    });
  }
  DataWorker2.__proto__ = GenericWorker3;
  DataWorker2.prototype = Object.create(GenericWorker3.prototype);
  DataWorker2.prototype.constructor = DataWorker2;
  DataWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      delay2(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker2.prototype._tickAndRepeat = function _tickAndRepeat() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      delay2(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker2.prototype._tick = function _tick() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  return DataWorker2;
}(GenericWorker);
var DataLengthProbe = function(GenericWorker3) {
  function DataLengthProbe2(propName) {
    GenericWorker3.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  DataLengthProbe2.__proto__ = GenericWorker3;
  DataLengthProbe2.prototype = Object.create(GenericWorker3.prototype);
  DataLengthProbe2.prototype.constructor = DataLengthProbe2;
  DataLengthProbe2.prototype.processChunk = function processChunk2(chunk) {
    if (chunk) {
      var length2 = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length2 + chunk.data.length;
    }
    GenericWorker3.prototype.processChunk.call(this, chunk);
  };
  return DataLengthProbe2;
}(GenericWorker);
var makeTable = function() {
  var table2 = [];
  for (var n = 0; n < 256; n++) {
    var c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table2[n] = c;
  }
  makeTable = function() {
    return table2;
  };
  return table2;
};
function crc32(crc, buf, len, pos) {
  var t = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i = pos; i < end2; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
function crc32str(crc, str, len, pos) {
  var t = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i = pos; i < end2; i++) {
    crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
  }
  return crc ^ -1;
}
function crc32wrapper(input, crc) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }
  var isArray2 = getTypeOf(input) !== "string";
  if (isArray2) {
    return crc32(crc | 0, input, input.length, 0);
  } else {
    return crc32str(crc | 0, input, input.length, 0);
  }
}
var Crc32Probe = function(GenericWorker3) {
  function Crc32Probe2() {
    GenericWorker3.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  Crc32Probe2.__proto__ = GenericWorker3;
  Crc32Probe2.prototype = Object.create(GenericWorker3.prototype);
  Crc32Probe2.prototype.constructor = Crc32Probe2;
  Crc32Probe2.prototype.processChunk = function processChunk2(chunk) {
    this.streamInfo.crc32 = crc32wrapper(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  return Crc32Probe2;
}(GenericWorker);
var CompressedObject = function CompressedObject2(compressedSize, uncompressedSize, crc322, compression2, data) {
  this.compressedSize = compressedSize;
  this.uncompressedSize = uncompressedSize;
  this.crc32 = crc322;
  this.compression = compression2;
  this.compressedContent = data;
};
CompressedObject.prototype.getContentWorker = function getContentWorker() {
  var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
  var that = this;
  worker.on("end", function() {
    if (this.streamInfo["data_length"] !== that.uncompressedSize) {
      throw new Error("Bug : uncompressed data size mismatch");
    }
  });
  return worker;
};
CompressedObject.prototype.getCompressedWorker = function getCompressedWorker() {
  return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
};
CompressedObject.createWorkerFrom = function createWorkerFrom(uncompressedWorker, compression2, compressionOptions2) {
  return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression2.compressWorker(compressionOptions2)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression2);
};
var ZipObject = function ZipObject2(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this._dataBinary = options.binary;
  this.options = {
    compression: options.compression,
    compressionOptions: options.compressionOptions
  };
};
ZipObject.prototype.internalStream = function internalStream(type) {
  var result = null, outputType = "string";
  try {
    if (!type) {
      throw new Error("No output type specified.");
    }
    outputType = type.toLowerCase();
    var askUnicodeString = outputType === "string" || outputType === "text";
    if (outputType === "binarystring" || outputType === "text") {
      outputType = "string";
    }
    result = this._decompressWorker();
    var isUnicodeString = !this._dataBinary;
    if (isUnicodeString && !askUnicodeString) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    if (!isUnicodeString && askUnicodeString) {
      result = result.pipe(new Utf8DecodeWorker());
    }
  } catch (e) {
    result = new GenericWorker("error");
    result.error(e);
  }
  return new StreamHelper(result, outputType, "");
};
ZipObject.prototype.async = function async(type, onUpdate) {
  return this.internalStream(type).accumulate(onUpdate);
};
ZipObject.prototype._compressWorker = function _compressWorker(compression2, compressionOptions2) {
  if (this._data instanceof CompressedObject && this._data.compression.magic === compression2.magic) {
    return this._data.getCompressedWorker();
  } else {
    var result = this._decompressWorker();
    if (!this._dataBinary) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    return CompressedObject.createWorkerFrom(result, compression2, compressionOptions2);
  }
};
ZipObject.prototype._decompressWorker = function _decompressWorker() {
  if (this._data instanceof CompressedObject) {
    return this._data.getContentWorker();
  } else if (this._data instanceof GenericWorker) {
    return this._data;
  } else {
    return new DataWorker(this._data);
  }
};
var arrayType = function() {
  var useTypedArray = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var resolved = useTypedArray ? "uint8array" : "array";
  arrayType = function() {
    return resolved;
  };
};
var FlateWorker = function(GenericWorker3) {
  function FlateWorker2(action, options) {
    GenericWorker3.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  FlateWorker2.__proto__ = GenericWorker3;
  FlateWorker2.prototype = Object.create(GenericWorker3.prototype);
  FlateWorker2.prototype.constructor = FlateWorker2;
  FlateWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(transformTo(arrayType(), chunk.data), false);
  };
  FlateWorker2.prototype.flush = function flush2() {
    GenericWorker3.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker2.prototype._createPako = function _createPako() {
    var this$1$1 = this;
    var params = {
      raw: true,
      level: this._pakoOptions.level || -1
      // default compression
    };
    this._pako = this._pakoAction === "Deflate" ? new Deflate(params) : new Inflate(params);
    this._pako.onData = function(data) {
      this$1$1.push({
        data,
        meta: this$1$1.meta
      });
    };
  };
  return FlateWorker2;
}(GenericWorker);
var DEFLATE = {
  magic: "\b\0",
  compressWorker: function(compressionOptions2) {
    return new FlateWorker("Deflate", compressionOptions2);
  },
  uncompressWorker: function() {
    return new FlateWorker("Inflate", {});
  }
};
var STORE = {
  magic: "\0\0",
  compressWorker: function() {
    return new GenericWorker("STORE compression");
  },
  uncompressWorker: function() {
    return new GenericWorker("STORE decompression");
  }
};
var compressions = {
  STORE,
  DEFLATE
};
var LOCAL_FILE_HEADER = "PK";
var CENTRAL_FILE_HEADER = "PK";
var CENTRAL_DIRECTORY_END = "PK";
var ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
var ZIP64_CENTRAL_DIRECTORY_END = "PK";
var DATA_DESCRIPTOR = "PK\x07\b";
var decToHex = function(dec, bytes) {
  var hex = "", i;
  for (i = 0; i < bytes; i++) {
    hex += String.fromCharCode(dec & 255);
    dec = dec >>> 8;
  }
  return hex;
};
var generateUnixExternalFileAttr = function(unixPermissions2, isDir) {
  var result = unixPermissions2;
  if (!unixPermissions2) {
    result = isDir ? 16893 : 33204;
  }
  return (result & 65535) << 16;
};
var generateDosExternalFileAttr = function(dosPermissions2, isDir) {
  return (dosPermissions2 || 0) & 63;
};
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset3, platform, encodeFileName) {
  var file2 = streamInfo["file"], compression2 = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8encode, encodedFileName = transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = transformTo("string", utf8encode(file2.name)), comment2 = file2.comment, encodedComment = transformTo("string", encodeFileName(comment2)), utfEncodedComment = transformTo("string", utf8encode(comment2)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment2.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir2 = file2.dir, date2 = file2.date;
  var dataInfo = {
    crc32: 0,
    compressedSize: 0,
    uncompressedSize: 0
  };
  if (!streamedContent || streamingEnded) {
    dataInfo.crc32 = streamInfo["crc32"];
    dataInfo.compressedSize = streamInfo["compressedSize"];
    dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
  }
  var bitflag = 0;
  if (streamedContent) {
    bitflag |= 8;
  }
  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
    bitflag |= 2048;
  }
  var extFileAttr = 0;
  var versionMadeBy = 0;
  if (dir2) {
    extFileAttr |= 16;
  }
  if (platform === "UNIX") {
    versionMadeBy = 798;
    extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir2);
  } else {
    versionMadeBy = 20;
    extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions);
  }
  dosTime = date2.getUTCHours();
  dosTime = dosTime << 6;
  dosTime = dosTime | date2.getUTCMinutes();
  dosTime = dosTime << 5;
  dosTime = dosTime | date2.getUTCSeconds() / 2;
  dosDate = date2.getUTCFullYear() - 1980;
  dosDate = dosDate << 4;
  dosDate = dosDate | date2.getUTCMonth() + 1;
  dosDate = dosDate << 5;
  dosDate = dosDate | date2.getUTCDate();
  if (useUTF8ForFileName) {
    unicodePathExtraField = // Version
    decToHex(1, 1) + // NameCRC32
    decToHex(crc32wrapper(encodedFileName), 4) + // UnicodeName
    utfEncodedFileName;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "up" + // size
    decToHex(unicodePathExtraField.length, 2) + // content
    unicodePathExtraField;
  }
  if (useUTF8ForComment) {
    unicodeCommentExtraField = // Version
    decToHex(1, 1) + // CommentCRC32
    decToHex(crc32wrapper(encodedComment), 4) + // UnicodeName
    utfEncodedComment;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "uc" + // size
    decToHex(unicodeCommentExtraField.length, 2) + // content
    unicodeCommentExtraField;
  }
  var header = "";
  header += "\n\0";
  header += decToHex(bitflag, 2);
  header += compression2.magic;
  header += decToHex(dosTime, 2);
  header += decToHex(dosDate, 2);
  header += decToHex(dataInfo.crc32, 4);
  header += decToHex(dataInfo.compressedSize, 4);
  header += decToHex(dataInfo.uncompressedSize, 4);
  header += decToHex(encodedFileName.length, 2);
  header += decToHex(extraFields.length, 2);
  var fileRecord = LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = CENTRAL_FILE_HEADER + // version made by (00: DOS)
  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
  header + // file comment length
  decToHex(encodedComment.length, 2) + // disk number start
  "\0\0\0\0" + // external file attributes
  decToHex(extFileAttr, 4) + // relative offset of local header
  decToHex(offset3, 4) + // file name
  encodedFileName + // extra field
  extraFields + // file comment
  encodedComment;
  return {
    fileRecord,
    dirRecord
  };
};
var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment2, encodeFileName) {
  var dirEnd = "";
  var encodedComment = transformTo("string", encodeFileName(comment2));
  dirEnd = CENTRAL_DIRECTORY_END + // number of this disk
  "\0\0\0\0" + // total number of entries in the central directory on this disk
  decToHex(entriesCount, 2) + // total number of entries in the central directory
  decToHex(entriesCount, 2) + // size of the central directory   4 bytes
  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
  decToHex(localDirLength, 4) + // .ZIP file comment length
  decToHex(encodedComment.length, 2) + // .ZIP file comment
  encodedComment;
  return dirEnd;
};
var generateDataDescriptors = function(streamInfo) {
  var descriptor = "";
  descriptor = DATA_DESCRIPTOR + // crc-32                          4 bytes
  decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
  decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
  decToHex(streamInfo["uncompressedSize"], 4);
  return descriptor;
};
var ZipFileWorker = function(GenericWorker3) {
  function ZipFileWorker2(streamFiles, comment2, platform, encodeFileName) {
    GenericWorker3.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment2;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  ZipFileWorker2.__proto__ = GenericWorker3;
  ZipFileWorker2.prototype = Object.create(GenericWorker3.prototype);
  ZipFileWorker2.prototype.constructor = ZipFileWorker2;
  ZipFileWorker2.prototype.push = function push2(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker3.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker2.prototype.openedSource = function openedSource(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker2.prototype.closedSource = function closedSource(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker2.prototype.flush = function flush2() {
    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker2.prototype.prepareNextSource = function prepareNextSource() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker2.prototype.registerPrevious = function registerPrevious2(previous) {
    this._sources.push(previous);
    var self = this;
    previous.on("data", function(chunk) {
      self.processChunk(chunk);
    });
    previous.on("end", function() {
      self.closedSource(self.previous.streamInfo);
      if (self._sources.length) {
        self.prepareNextSource();
      } else {
        self.end();
      }
    });
    previous.on("error", function(e) {
      self.error(e);
    });
    return this;
  };
  ZipFileWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker2.prototype.error = function error2(e) {
    var sources = this._sources;
    if (!GenericWorker3.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0; i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e$1) {
      }
    }
    return true;
  };
  ZipFileWorker2.prototype.lock = function lock2() {
    GenericWorker3.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
      sources[i].lock();
    }
  };
  return ZipFileWorker2;
}(GenericWorker);
var getCompression = function(fileCompression, zipCompression) {
  var compressionName = fileCompression || zipCompression;
  var compression2 = compressions[compressionName];
  if (!compression2) {
    throw new Error(compressionName + " is not a valid compression method !");
  }
  return compression2;
};
var generateWorker = function(zip3, options, comment2) {
  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment2, options.platform, options.encodeFileName);
  var entriesCount = 0;
  try {
    zip3.forEach(function(relativePath, file2) {
      entriesCount++;
      var compression2 = getCompression(file2.options.compression, options.compression);
      var compressionOptions2 = file2.options.compressionOptions || options.compressionOptions || {};
      var dir2 = file2.dir, date2 = file2.date;
      file2._compressWorker(compression2, compressionOptions2).withStreamInfo("file", {
        name: relativePath,
        dir: dir2,
        date: date2,
        comment: file2.comment || "",
        unixPermissions: file2.unixPermissions,
        dosPermissions: file2.dosPermissions
      }).pipe(zipFileWorker);
    });
    zipFileWorker.entriesCount = entriesCount;
  } catch (e) {
    zipFileWorker.error(e);
  }
  return zipFileWorker;
};
var DataReader = function DataReader2(data) {
  this.data = data;
  this.length = data.length;
  this.index = 0;
  this.zero = 0;
};
DataReader.prototype.checkOffset = function checkOffset(offset3) {
  this.checkIndex(this.index + offset3);
};
DataReader.prototype.checkIndex = function checkIndex(newIndex) {
  if (this.length < this.zero + newIndex || newIndex < 0) {
    throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
  }
};
DataReader.prototype.setIndex = function setIndex(newIndex) {
  this.checkIndex(newIndex);
  this.index = newIndex;
};
DataReader.prototype.skip = function skip2(n) {
  this.setIndex(this.index + n);
};
DataReader.prototype.byteAt = function byteAt(i) {
};
DataReader.prototype.readInt = function readInt(size) {
  var result = 0, i;
  this.checkOffset(size);
  for (i = this.index + size - 1; i >= this.index; i--) {
    result = (result << 8) + this.byteAt(i);
  }
  this.index += size;
  return result;
};
DataReader.prototype.readString = function readString(size) {
  return transformTo("string", this.readData(size));
};
DataReader.prototype.readData = function readData(size) {
};
DataReader.prototype.lastIndexOfSignature = function lastIndexOfSignature(sig) {
};
DataReader.prototype.readAndCheckSignature = function readAndCheckSignature(sig) {
};
DataReader.prototype.readDate = function readDate() {
  var dostime = this.readInt(4);
  return new Date(Date.UTC(
    (dostime >> 25 & 127) + 1980,
    // year
    (dostime >> 21 & 15) - 1,
    // month
    dostime >> 16 & 31,
    // day
    dostime >> 11 & 31,
    // hour
    dostime >> 5 & 63,
    // minute
    (dostime & 31) << 1
  ));
};
var ArrayReader = function(DataReader3) {
  function ArrayReader2(data) {
    DataReader3.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
      data[i] = data[i] & 255;
    }
  }
  ArrayReader2.__proto__ = DataReader3;
  ArrayReader2.prototype = Object.create(DataReader3.prototype);
  ArrayReader2.prototype.constructor = ArrayReader2;
  ArrayReader2.prototype.byteAt = function byteAt2(i) {
    return this.data[this.zero + i];
  };
  ArrayReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return ArrayReader2;
}(DataReader);
var StringReader = function(DataReader3) {
  function StringReader2(data) {
    DataReader3.call(this, data);
  }
  StringReader2.__proto__ = DataReader3;
  StringReader2.prototype = Object.create(DataReader3.prototype);
  StringReader2.prototype.constructor = StringReader2;
  StringReader2.prototype.byteAt = function byteAt2(i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return StringReader2;
}(DataReader);
var Uint8ArrayReader = function(ArrayReader2) {
  function Uint8ArrayReader2(data) {
    ArrayReader2.call(this, data);
  }
  Uint8ArrayReader2.__proto__ = ArrayReader2;
  Uint8ArrayReader2.prototype = Object.create(ArrayReader2.prototype);
  Uint8ArrayReader2.prototype.constructor = Uint8ArrayReader2;
  Uint8ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return Uint8ArrayReader2;
}(ArrayReader);
function readerFor(data) {
  var type = getTypeOf(data);
  checkSupport(type);
  if (type === "string" && !support.uint8array) {
    return new StringReader(data);
  }
  if (support.uint8array) {
    return new Uint8ArrayReader(transformTo("uint8array", data));
  }
  return new ArrayReader(transformTo("array", data));
}
var MADE_BY_DOS = 0;
var MADE_BY_UNIX = 3;
var findCompression = function(compressionMethod) {
  for (var method in compressions) {
    if (!compressions.hasOwnProperty(method)) {
      continue;
    }
    if (compressions[method].magic === compressionMethod) {
      return compressions[method];
    }
  }
  return null;
};
var ZipEntry = function ZipEntry2(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
};
ZipEntry.prototype.isEncrypted = function isEncrypted() {
  return (this.bitFlag & 1) === 1;
};
ZipEntry.prototype.useUTF8 = function useUTF8() {
  return (this.bitFlag & 2048) === 2048;
};
ZipEntry.prototype.readLocalPart = function readLocalPart(reader) {
  var compression2, localExtraFieldsLength;
  reader.skip(22);
  this.fileNameLength = reader.readInt(2);
  localExtraFieldsLength = reader.readInt(2);
  this.fileName = reader.readData(this.fileNameLength);
  reader.skip(localExtraFieldsLength);
  if (this.compressedSize === -1 || this.uncompressedSize === -1) {
    throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
  }
  compression2 = findCompression(this.compressionMethod);
  if (compression2 === null) {
    throw new Error("Corrupted zip : compression " + pretty(this.compressionMethod) + " unknown (inner file : " + transformTo("string", this.fileName) + ")");
  }
  this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression2, reader.readData(this.compressedSize));
};
ZipEntry.prototype.readCentralPart = function readCentralPart(reader) {
  this.versionMadeBy = reader.readInt(2);
  reader.skip(2);
  this.bitFlag = reader.readInt(2);
  this.compressionMethod = reader.readString(2);
  this.date = reader.readDate();
  this.crc32 = reader.readInt(4);
  this.compressedSize = reader.readInt(4);
  this.uncompressedSize = reader.readInt(4);
  var fileNameLength = reader.readInt(2);
  this.extraFieldsLength = reader.readInt(2);
  this.fileCommentLength = reader.readInt(2);
  this.diskNumberStart = reader.readInt(2);
  this.internalFileAttributes = reader.readInt(2);
  this.externalFileAttributes = reader.readInt(4);
  this.localHeaderOffset = reader.readInt(4);
  if (this.isEncrypted()) {
    throw new Error("Encrypted zip are not supported");
  }
  reader.skip(fileNameLength);
  this.readExtraFields(reader);
  this.parseZIP64ExtraField(reader);
  this.fileComment = reader.readData(this.fileCommentLength);
};
ZipEntry.prototype.processAttributes = function processAttributes() {
  this.unixPermissions = null;
  this.dosPermissions = null;
  var madeBy = this.versionMadeBy >> 8;
  this.dir = this.externalFileAttributes & 16 ? true : false;
  if (madeBy === MADE_BY_DOS) {
    this.dosPermissions = this.externalFileAttributes & 63;
  }
  if (madeBy === MADE_BY_UNIX) {
    this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
  }
  if (!this.dir && this.fileNameStr.slice(-1) === "/") {
    this.dir = true;
  }
};
ZipEntry.prototype.parseZIP64ExtraField = function parseZIP64ExtraField(reader) {
  if (!this.extraFields[1]) {
    return;
  }
  var extraReader = readerFor(this.extraFields[1].value);
  if (this.uncompressedSize === MAX_VALUE_32BITS) {
    this.uncompressedSize = extraReader.readInt(8);
  }
  if (this.compressedSize === MAX_VALUE_32BITS) {
    this.compressedSize = extraReader.readInt(8);
  }
  if (this.localHeaderOffset === MAX_VALUE_32BITS) {
    this.localHeaderOffset = extraReader.readInt(8);
  }
  if (this.diskNumberStart === MAX_VALUE_32BITS) {
    this.diskNumberStart = extraReader.readInt(4);
  }
};
ZipEntry.prototype.readExtraFields = function readExtraFields(reader) {
  var end2 = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
  if (!this.extraFields) {
    this.extraFields = {};
  }
  while (reader.index < end2) {
    extraFieldId = reader.readInt(2);
    extraFieldLength = reader.readInt(2);
    extraFieldValue = reader.readData(extraFieldLength);
    this.extraFields[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntry.prototype.handleUTF8 = function handleUTF8() {
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  if (this.useUTF8()) {
    this.fileNameStr = utf8decode(this.fileName);
    this.fileCommentStr = utf8decode(this.fileComment);
  } else {
    var upath = this.findExtraFieldUnicodePath();
    if (upath !== null) {
      this.fileNameStr = upath;
    } else {
      var fileNameByteArray = transformTo(decodeParamType, this.fileName);
      this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
    }
    var ucomment = this.findExtraFieldUnicodeComment();
    if (ucomment !== null) {
      this.fileCommentStr = ucomment;
    } else {
      var commentByteArray = transformTo(decodeParamType, this.fileComment);
      this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
    }
  }
};
ZipEntry.prototype.findExtraFieldUnicodePath = function findExtraFieldUnicodePath() {
  var upathField = this.extraFields[28789];
  if (upathField) {
    var extraReader = readerFor(upathField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileName) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(upathField.length - 5));
  }
  return null;
};
ZipEntry.prototype.findExtraFieldUnicodeComment = function findExtraFieldUnicodeComment() {
  var ucommentField = this.extraFields[25461];
  if (ucommentField) {
    var extraReader = readerFor(ucommentField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileComment) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(ucommentField.length - 5));
  }
  return null;
};
var ZipEntries = function ZipEntries2(loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
};
ZipEntries.prototype.checkSignature = function checkSignature(expectedSignature) {
  if (!this.reader.readAndCheckSignature(expectedSignature)) {
    this.reader.index -= 4;
    var signature = this.reader.readString(4);
    throw new Error("Corrupted zip or bug: unexpected signature (" + pretty(signature) + ", expected " + pretty(expectedSignature) + ")");
  }
};
ZipEntries.prototype.isSignature = function isSignature(askedIndex, expectedSignature) {
  var currentIndex = this.reader.index;
  this.reader.setIndex(askedIndex);
  var signature = this.reader.readString(4);
  var result = signature === expectedSignature;
  this.reader.setIndex(currentIndex);
  return result;
};
ZipEntries.prototype.readBlockEndOfCentral = function readBlockEndOfCentral() {
  this.diskNumber = this.reader.readInt(2);
  this.diskWithCentralDirStart = this.reader.readInt(2);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
  this.centralDirRecords = this.reader.readInt(2);
  this.centralDirSize = this.reader.readInt(4);
  this.centralDirOffset = this.reader.readInt(4);
  this.zipCommentLength = this.reader.readInt(2);
  var zipComment = this.reader.readData(this.zipCommentLength);
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  var decodeContent = transformTo(decodeParamType, zipComment);
  this.zipComment = this.loadOptions.decodeFileName(decodeContent);
};
ZipEntries.prototype.readBlockZip64EndOfCentral = function readBlockZip64EndOfCentral() {
  this.zip64EndOfCentralSize = this.reader.readInt(8);
  this.reader.skip(4);
  this.diskNumber = this.reader.readInt(4);
  this.diskWithCentralDirStart = this.reader.readInt(4);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
  this.centralDirRecords = this.reader.readInt(8);
  this.centralDirSize = this.reader.readInt(8);
  this.centralDirOffset = this.reader.readInt(8);
  this.zip64ExtensibleData = {};
  var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
  while (index < extraDataSize) {
    extraFieldId = this.reader.readInt(2);
    extraFieldLength = this.reader.readInt(4);
    extraFieldValue = this.reader.readData(extraFieldLength);
    this.zip64ExtensibleData[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntries.prototype.readBlockZip64EndOfCentralLocator = function readBlockZip64EndOfCentralLocator() {
  this.diskWithZip64CentralDirStart = this.reader.readInt(4);
  this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
  this.disksCount = this.reader.readInt(4);
  if (this.disksCount > 1) {
    throw new Error("Multi-volumes zip are not supported");
  }
};
ZipEntries.prototype.readLocalFiles = function readLocalFiles() {
  var i, file2;
  for (i = 0; i < this.files.length; i++) {
    file2 = this.files[i];
    this.reader.setIndex(file2.localHeaderOffset);
    this.checkSignature(LOCAL_FILE_HEADER);
    file2.readLocalPart(this.reader);
    file2.handleUTF8();
    file2.processAttributes();
  }
};
ZipEntries.prototype.readCentralDir = function readCentralDir() {
  var file2;
  this.reader.setIndex(this.centralDirOffset);
  while (this.reader.readAndCheckSignature(CENTRAL_FILE_HEADER)) {
    file2 = new ZipEntry({
      zip64: this.zip64
    }, this.loadOptions);
    file2.readCentralPart(this.reader);
    this.files.push(file2);
  }
  if (this.centralDirRecords !== this.files.length) {
    if (this.centralDirRecords !== 0 && this.files.length === 0) {
      throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
    }
  }
};
ZipEntries.prototype.readEndOfCentral = function readEndOfCentral() {
  var offset3 = this.reader.lastIndexOfSignature(CENTRAL_DIRECTORY_END);
  if (offset3 < 0) {
    var isGarbage = !this.isSignature(0, LOCAL_FILE_HEADER);
    if (isGarbage) {
      throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
    } else {
      throw new Error("Corrupted zip: can't find end of central directory");
    }
  }
  this.reader.setIndex(offset3);
  var endOfCentralDirOffset = offset3;
  this.checkSignature(CENTRAL_DIRECTORY_END);
  this.readBlockEndOfCentral();
  if (this.diskNumber === MAX_VALUE_16BITS || this.diskWithCentralDirStart === MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === MAX_VALUE_16BITS || this.centralDirRecords === MAX_VALUE_16BITS || this.centralDirSize === MAX_VALUE_32BITS || this.centralDirOffset === MAX_VALUE_32BITS) {
    this.zip64 = true;
    offset3 = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    if (offset3 < 0) {
      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
    }
    this.reader.setIndex(offset3);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    this.readBlockZip64EndOfCentralLocator();
    if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, ZIP64_CENTRAL_DIRECTORY_END)) {
      this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_END);
      if (this.relativeOffsetEndOfZip64CentralDir < 0) {
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
      }
    }
    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_END);
    this.readBlockZip64EndOfCentral();
  }
  var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
  if (this.zip64) {
    expectedEndOfCentralDirOffset += 20;
    expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
  }
  var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
  if (extraBytes > 0) {
    if (this.isSignature(endOfCentralDirOffset, CENTRAL_FILE_HEADER)) ;
    else {
      this.reader.zero = extraBytes;
    }
  } else if (extraBytes < 0) {
    throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
  }
};
ZipEntries.prototype.prepareReader = function prepareReader(data) {
  this.reader = readerFor(data);
};
ZipEntries.prototype.load = function load(data) {
  this.prepareReader(data);
  this.readEndOfCentral();
  this.readCentralDir();
  this.readLocalFiles();
};
function checkEntryCRC32(zipEntry) {
  return new external.Promise(function(resolve2, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function(e) {
      reject(e);
    }).on("end", function() {
      if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
        reject(new Error("Corrupted zip : CRC32 mismatch"));
      } else {
        resolve2();
      }
    }).resume();
  });
}
function load2(data, options) {
  var zip3 = this;
  options = extend2(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8decode
  });
  return prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data2);
    return zipEntries;
  }).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
      for (var i = 0; i < files.length; i++) {
        promises.push(checkEntryCRC32(files[i]));
      }
    }
    return external.Promise.all(promises);
  }).then(function addFiles(results) {
    var zipEntries = results.shift();
    var files = zipEntries.files;
    for (var i = 0; i < files.length; i++) {
      var input = files[i];
      var unsafeName = input.fileNameStr;
      var safeName = resolve(input.fileNameStr);
      zip3.file(safeName, input.decompressed, {
        binary: true,
        optimizedBinaryString: true,
        date: input.date,
        dir: input.dir,
        comment: input.fileCommentStr.length ? input.fileCommentStr : null,
        unixPermissions: input.unixPermissions,
        dosPermissions: input.dosPermissions,
        createFolders: options.createFolders
      });
      if (!input.dir) {
        zip3.file(safeName).unsafeOriginalName = unsafeName;
      }
    }
    if (zipEntries.zipComment.length) {
      zip3.comment = zipEntries.zipComment;
    }
    return zip3;
  });
}
var fileAdd = function(name, data, originalOptions) {
  var dataType = getTypeOf(data), parent;
  var o = extend2(originalOptions || {}, defaults);
  o.date = o.date || /* @__PURE__ */ new Date();
  if (o.compression !== null) {
    o.compression = o.compression.toUpperCase();
  }
  if (typeof o.unixPermissions === "string") {
    o.unixPermissions = parseInt(o.unixPermissions, 8);
  }
  if (o.unixPermissions && o.unixPermissions & 16384) {
    o.dir = true;
  }
  if (o.dosPermissions && o.dosPermissions & 16) {
    o.dir = true;
  }
  if (o.dir) {
    name = forceTrailingSlash(name);
  }
  if (o.createFolders && (parent = parentFolder(name))) {
    folderAdd.call(this, parent, true);
  }
  var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
  if (!originalOptions || typeof originalOptions.binary === "undefined") {
    o.binary = !isUnicodeString;
  }
  var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
  if (isCompressedEmpty || o.dir || !data || data.length === 0) {
    o.base64 = false;
    o.binary = true;
    data = "";
    o.compression = "STORE";
    dataType = "string";
  }
  var zipObjectContent = null;
  if (data instanceof CompressedObject || data instanceof GenericWorker) {
    zipObjectContent = data;
  } else {
    zipObjectContent = prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
  }
  var object = new ZipObject(name, zipObjectContent, o);
  this.files[name] = object;
};
var parentFolder = function(path) {
  if (path.slice(-1) === "/") {
    path = path.substring(0, path.length - 1);
  }
  var lastSlash = path.lastIndexOf("/");
  return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};
var forceTrailingSlash = function(path) {
  if (path.slice(-1) !== "/") {
    path += "/";
  }
  return path;
};
var folderAdd = function(name, createFolders$1) {
  createFolders$1 = typeof createFolders$1 !== "undefined" ? createFolders$1 : createFolders;
  name = forceTrailingSlash(name);
  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders: createFolders$1
    });
  }
  return this.files[name];
};
function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var JSZip = function JSZip2() {
  if (arguments.length) {
    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
  }
  this.files = /* @__PURE__ */ Object.create(null);
  this.comment = null;
  this.root = "";
  this.clone = function() {
    var newObj = new JSZip2();
    for (var i in this) {
      if (typeof this[i] !== "function") {
        newObj[i] = this[i];
      }
    }
    return newObj;
  };
};
var staticAccessors = { support: { configurable: true }, defaults: { configurable: true }, version: { configurable: true }, external: { configurable: true } };
JSZip.prototype.load = function load3() {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.forEach = function forEach(cb) {
  var filename, relativePath, file2;
  for (filename in this.files) {
    file2 = this.files[filename];
    relativePath = filename.slice(this.root.length, filename.length);
    if (relativePath && filename.slice(0, this.root.length) === this.root) {
      cb(relativePath, file2);
    }
  }
};
JSZip.prototype.filter = function filter2(search) {
  var result = [];
  this.forEach(function(relativePath, entry) {
    if (search(relativePath, entry)) {
      result.push(entry);
    }
  });
  return result;
};
JSZip.prototype.file = function file(name, data, o) {
  if (arguments.length === 1) {
    if (isRegExp(name)) {
      var regexp = name;
      return this.filter(function(relativePath, file2) {
        return !file2.dir && regexp.test(relativePath);
      });
    } else {
      var obj = this.files[this.root + name];
      if (obj && !obj.dir) {
        return obj;
      } else {
        return null;
      }
    }
  } else {
    name = this.root + name;
    fileAdd.call(this, name, data, o);
  }
  return this;
};
JSZip.prototype.folder = function folder(arg) {
  if (!arg) {
    return this;
  }
  if (isRegExp(arg)) {
    return this.filter(function(relativePath, file2) {
      return file2.dir && arg.test(relativePath);
    });
  }
  var name = this.root + arg;
  var newFolder = folderAdd.call(this, name);
  var ret = this.clone();
  ret.root = newFolder.name;
  return ret;
};
JSZip.prototype.remove = function remove(name) {
  name = this.root + name;
  var file2 = this.files[name];
  if (!file2) {
    if (name.slice(-1) !== "/") {
      name += "/";
    }
    file2 = this.files[name];
  }
  if (file2 && !file2.dir) {
    delete this.files[name];
  } else {
    var kids = this.filter(function(relativePath, file3) {
      return file3.name.slice(0, name.length) === name;
    });
    for (var i = 0; i < kids.length; i++) {
      delete this.files[kids[i].name];
    }
  }
  return this;
};
JSZip.prototype.generate = function generate(options) {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.generateInternalStream = function generateInternalStream(options) {
  var worker, opts = {};
  try {
    opts = extend2(options || {}, {
      streamFiles: false,
      compression: "STORE",
      compressionOptions: null,
      type: "",
      platform: "DOS",
      comment: null,
      mimeType: "application/zip",
      encodeFileName: utf8encode
    });
    opts.type = opts.type.toLowerCase();
    opts.compression = opts.compression.toUpperCase();
    if (opts.type === "binarystring") {
      opts.type = "string";
    }
    if (!opts.type) {
      throw new Error("No output type specified.");
    }
    checkSupport(opts.type);
    if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
      opts.platform = "UNIX";
    }
    if (opts.platform === "win32") {
      opts.platform = "DOS";
    }
    var comment2 = opts.comment || this.comment || "";
    worker = generateWorker(this, opts, comment2);
  } catch (e) {
    worker = new GenericWorker("error");
    worker.error(e);
  }
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
};
JSZip.prototype.generateAsync = function generateAsync(options, onUpdate) {
  return this.generateInternalStream(options).accumulate(onUpdate);
};
JSZip.prototype.loadAsync = function loadAsync(data, options) {
  return load2.apply(this, [data, options]);
};
JSZip.loadAsync = function loadAsync2(content2, options) {
  return new JSZip().loadAsync(content2, options);
};
staticAccessors.support.get = function() {
  return support;
};
staticAccessors.defaults.get = function() {
  return defaults;
};
staticAccessors.version.get = function() {
  return "3.2.2-esm";
};
staticAccessors.external.get = function() {
  return external;
};
Object.defineProperties(JSZip, staticAccessors);

// node_modules/@progress/kendo-ooxml/dist/es/utils/create-zip.js
function createZip() {
  return new JSZip();
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/time.js
function dateToJulianDays(y, m, d) {
  return (1461 * (y + 4800 + ((m - 13) / 12 | 0)) / 4 | 0) + (367 * (m - 1 - 12 * ((m - 13) / 12 | 0)) / 12 | 0) - (3 * ((y + 4900 + ((m - 13) / 12 | 0)) / 100 | 0) / 4 | 0) + d - 32075;
}
var BASE_DATE = dateToJulianDays(1900, 0, -1);
function packDate(year, month, date2) {
  return dateToJulianDays(year, month, date2) - BASE_DATE;
}
function packTime(hh, mm, ss, ms) {
  return (hh + (mm + (ss + ms / 1e3) / 60) / 60) / 24;
}
function dateToSerial(date2) {
  const time = packTime(
    date2.getHours(),
    date2.getMinutes(),
    date2.getSeconds(),
    date2.getMilliseconds()
  );
  const serial = packDate(
    date2.getFullYear(),
    date2.getMonth(),
    date2.getDate()
  );
  return serial < 0 ? serial - 1 + time : serial + time;
}

// node_modules/@progress/kendo-ooxml/dist/es/ooxml.js
var MIME_TYPE = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
var DATA_URL_PREFIX = `data:${MIME_TYPE};base64,`;
var DATA_URL_OPTIONS = { compression: "DEFLATE", type: "base64" };
var BLOB_OPTIONS = { compression: "DEFLATE", type: "blob" };
var ARRAYBUFFER_OPTIONS = { compression: "DEFLATE", type: "arraybuffer" };
function toDataURI(content2) {
  return DATA_URL_PREFIX + content2;
}
function indexOf(thing, array) {
  return array.indexOf(thing);
}
var parseJSON = JSON.parse.bind(JSON);
function ESC(val) {
  return String(val).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\'/g, "&#39;");
}
function repeat2(count2, func) {
  let str = "";
  for (let i = 0; i < count2; ++i) {
    str += func(i);
  }
  return str;
}
function foreach(arr, func) {
  let str = "";
  if (arr != null) {
    if (Array.isArray(arr)) {
      for (let i = 0; i < arr.length; ++i) {
        str += func(arr[i], i);
      }
    } else if (typeof arr == "object") {
      Object.keys(arr).forEach((key, i) => {
        str += func(arr[key], key, i);
      });
    }
  }
  return str;
}
var XMLHEAD = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r';
var RELS = `${XMLHEAD}
            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
               <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
               <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
               <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
            </Relationships>`;
var CORE = ({ creator, lastModifiedBy, created, modified }) => `${XMLHEAD}
 <cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
   xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/"
   xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <dc:creator>${ESC(creator)}</dc:creator>
   <cp:lastModifiedBy>${ESC(lastModifiedBy)}</cp:lastModifiedBy>
   <dcterms:created xsi:type="dcterms:W3CDTF">${ESC(created)}</dcterms:created>
   <dcterms:modified xsi:type="dcterms:W3CDTF">${ESC(modified)}</dcterms:modified>
</cp:coreProperties>`;
var APP = ({ sheets }) => `${XMLHEAD}
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>Microsoft Excel</Application>
  <DocSecurity>0</DocSecurity>
  <ScaleCrop>false</ScaleCrop>
  <HeadingPairs>
    <vt:vector size="2" baseType="variant">
      <vt:variant>
        <vt:lpstr>Worksheets</vt:lpstr>
      </vt:variant>
      <vt:variant>
        <vt:i4>${sheets.length}</vt:i4>
      </vt:variant>
    </vt:vector>
  </HeadingPairs>
  <TitlesOfParts>
    <vt:vector size="${sheets.length}" baseType="lpstr">${foreach(
  sheets,
  (sheet, i) => sheet.options.title ? `<vt:lpstr>${ESC(sheet.options.title)}</vt:lpstr>` : `<vt:lpstr>Sheet${i + 1}</vt:lpstr>`
)}</vt:vector>
  </TitlesOfParts>
  <LinksUpToDate>false</LinksUpToDate>
  <SharedDoc>false</SharedDoc>
  <HyperlinksChanged>false</HyperlinksChanged>
  <AppVersion>14.0300</AppVersion>
</Properties>`;
var CONTENT_TYPES = ({ sheetCount, commentFiles, drawingFiles }) => `${XMLHEAD}
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="png" ContentType="image/png"/>
  <Default Extension="gif" ContentType="image/gif"/>
  <Default Extension="jpg" ContentType="image/jpeg"/>
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="xml" ContentType="application/xml" />
  <Default Extension="vml" ContentType="application/vnd.openxmlformats-officedocument.vmlDrawing"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" />
  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>
  ${repeat2(sheetCount, (idx2) => `<Override PartName="/xl/worksheets/sheet${idx2 + 1}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />`)}
  ${foreach(commentFiles, (filename) => `<Override PartName="/xl/${filename}" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"/>`)}
  ${foreach(drawingFiles, (filename) => `<Override PartName="/xl/drawings/${filename}" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>`)}
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml" />
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" />
</Types>`;
var WORKBOOK = ({ sheets, filterNames, userNames }) => `${XMLHEAD}
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="9303" />
  <workbookPr defaultThemeVersion="124226" />
  <bookViews>
    <workbookView xWindow="240" yWindow="45" windowWidth="18195" windowHeight="7995" />
  </bookViews>
  <sheets>
  ${foreach(sheets, ({ options }, i) => {
  const name = options.name || options.title || `Sheet${i + 1}`;
  const state2 = options.state || "visible";
  return `<sheet name="${ESC(name)}" state="${state2}" sheetId="${i + 1}" r:id="rId${i + 1}" />`;
})}
  </sheets>
  ${filterNames.length || userNames.length ? `
    <definedNames>
      ${foreach(filterNames, (f) => `
         <definedName name="_xlnm._FilterDatabase" hidden="1" localSheetId="${f.localSheetId}">${ESC(quoteSheet(f.name))}!${ESC(f.from)}:${ESC(f.to)}</definedName>`)}
      ${foreach(userNames, (f) => `
         <definedName name="${f.name}" hidden="${f.hidden ? 1 : 0}" ${f.localSheetId != null ? `localSheetId="${f.localSheetId}"` : ""}>${ESC(f.value)}</definedName>`)}
    </definedNames>` : ""}
  <calcPr fullCalcOnLoad="1" calcId="145621" />
</workbook>`;
var WORKSHEET = ({
  frozenColumns,
  frozenRows,
  columns,
  defaults: defaults2,
  data,
  index,
  mergeCells,
  autoFilter,
  filter: filter3,
  showGridLines,
  hyperlinks,
  validations,
  defaultCellStyleId,
  rtl,
  legacyDrawing,
  drawing,
  lastRow,
  lastCol,
  hasDisabledCells
}) => `${XMLHEAD}
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" mc:Ignorable="x14ac">
   ${lastRow && lastCol ? `<dimension ref="A1:${ref(lastRow - 1, lastCol - 1)}" />` : ""}

   <sheetViews>
     <sheetView ${rtl ? 'rightToLeft="1"' : ""} ${index === 0 ? 'tabSelected="1"' : ""} workbookViewId="0" ${showGridLines === false ? 'showGridLines="0"' : ""}>
     ${frozenRows || frozenColumns ? `
       <pane state="frozen"
         ${frozenColumns ? `xSplit="${frozenColumns}"` : ""}
         ${frozenRows ? `ySplit="${frozenRows}"` : ""}
         topLeftCell="${String.fromCharCode(65 + (frozenColumns || 0)) + ((frozenRows || 0) + 1)}"
       />` : ""}
     </sheetView>
   </sheetViews>

   <sheetFormatPr x14ac:dyDescent="0.25" ${!defaults2.skipCustomHeight ? 'customHeight="1"' : ""} defaultRowHeight="${defaults2.rowHeight ? defaults2.rowHeight * 0.75 : 15}"
     ${defaults2.columnWidth ? `defaultColWidth="${toWidth(defaults2.columnWidth)}"` : ""} />

   ${defaultCellStyleId != null || columns && columns.length > 0 ? `
     <cols>
       ${!columns || !columns.length ? `
         <col min="1" max="16384" style="${defaultCellStyleId}"
              ${defaults2.columnWidth ? `width="${toWidth(defaults2.columnWidth)}"` : ""} /> ` : ""}
       ${foreach(columns, (column, ci) => {
  const columnIndex = typeof column.index === "number" ? column.index + 1 : ci + 1;
  if (column.width === 0) {
    return `<col ${defaultCellStyleId != null ? `style="${defaultCellStyleId}"` : ""}
                        min="${columnIndex}" max="${columnIndex}" hidden="1" customWidth="1" />`;
  }
  return `<col ${defaultCellStyleId != null ? `style="${defaultCellStyleId}"` : ""}
                      min="${columnIndex}" max="${columnIndex}" customWidth="1"
                      ${column.autoWidth ? `width="${(column.width * 7 + 5) / 7 * 256 / 256}" bestFit="1"` : `width="${toWidth(column.width)}"`} />`;
})}
     </cols>` : ""}

   <sheetData>
     ${foreach(data, (row2, ri) => {
  const rowIndex = typeof row2.index === "number" ? row2.index + 1 : ri + 1;
  return `
         <row r="${rowIndex}" x14ac:dyDescent="0.25"
              ${row2.level ? `outlineLevel="${row2.level}"` : ""}
              ${row2.height === 0 ? 'hidden="1"' : row2.height ? `ht="${toHeight(row2.height)}" customHeight="1"` : ""}>
           ${foreach(row2.data, (cell2) => `
             <c r="${cell2.ref}" ${cell2.style ? `s="${cell2.style}"` : ""} ${cell2.type ? `t="${cell2.type}"` : ""}>
               ${cell2.formula != null ? writeFormula(cell2.formula) : ""}
               ${cell2.value != null ? `<v>${ESC(cell2.value)}</v>` : ""}
             </c>`)}
         </row>
       `;
})}
   </sheetData>

   ${hasDisabledCells ? `<sheetProtection sheet="1" objects="1" scenarios="1"/>` : ""}

   ${autoFilter ? `<autoFilter ref="${autoFilter.from}:${autoFilter.to}"/>` : filter3 ? spreadsheetFilters(filter3) : ""}

   ${mergeCells.length ? `
     <mergeCells count="${mergeCells.length}">
       ${foreach(mergeCells, (ref2) => `<mergeCell ref="${ref2}"/>`)}
     </mergeCells>` : ""}

   ${validations.length ? `
     <dataValidations>
       ${foreach(validations, (val) => `
         <dataValidation sqref="${val.sqref.join(" ")}"
                         showErrorMessage="${val.showErrorMessage}"
                         type="${ESC(val.type)}"
                         ${val.type !== "list" ? `operator="${ESC(val.operator)}"` : ""}
                         allowBlank="${val.allowBlank}"
                         showDropDown="${val.showDropDown}"
                         ${val.error ? `error="${ESC(val.error)}"` : ""}
                         ${val.errorTitle ? `errorTitle="${ESC(val.errorTitle)}"` : ""}>
           ${val.formula1 ? `<formula1>${ESC(val.formula1)}</formula1>` : ""}
           ${val.formula2 ? `<formula2>${ESC(val.formula2)}</formula2>` : ""}
         </dataValidation>`)}
     </dataValidations>` : ""}

   ${hyperlinks.length ? `
     <hyperlinks>
       ${foreach(hyperlinks, (link) => `
         <hyperlink ref="${link.ref}" r:id="${link.rId}"/>`)}
     </hyperlinks>` : ""}

   <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
   ${drawing ? `<drawing r:id="${drawing}"/>` : ""}
   ${legacyDrawing ? `<legacyDrawing r:id="${legacyDrawing}"/>` : ""}
</worksheet>`;
var WORKBOOK_RELS = ({ count: count2 }) => `${XMLHEAD}
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  ${repeat2(count2, (idx2) => `
    <Relationship Id="rId${idx2 + 1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${idx2 + 1}.xml" />`)}
  <Relationship Id="rId${count2 + 1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml" />
  <Relationship Id="rId${count2 + 2}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />
</Relationships>`;
var WORKSHEET_RELS = ({ hyperlinks, comments, sheetIndex, drawings }) => `${XMLHEAD}
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  ${foreach(hyperlinks, (link) => `
    <Relationship Id="${link.rId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink" Target="${ESC(link.target)}" TargetMode="External" />`)}
  ${!comments.length ? "" : `
    <Relationship Id="comment${sheetIndex}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments" Target="../comments${sheetIndex}.xml"/>
    <Relationship Id="vml${sheetIndex}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing" Target="../drawings/vmlDrawing${sheetIndex}.vml"/>`}
  ${!drawings.length ? "" : `
    <Relationship Id="drw${sheetIndex}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing${sheetIndex}.xml"/>`}
</Relationships>`;
var COMMENTS_XML = ({ comments }) => `${XMLHEAD}
<comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <authors>
    <author></author>
  </authors>
  <commentList>
    ${foreach(comments, (comment2) => `
      <comment ref="${comment2.ref}" authorId="0">
        <text>
          <r>
            <rPr>
              <sz val="8"/>
              <color indexed="81"/>
              <rFont val="Tahoma"/>
              <charset val="1"/>
            </rPr>
            <t>${ESC(comment2.text)}</t>
          </r>
        </text>
      </comment>`)}
  </commentList>
</comments>`;
var LEGACY_DRAWING = ({ comments }) => `<xml xmlns:v="urn:schemas-microsoft-com:vml"
     xmlns:o="urn:schemas-microsoft-com:office:office"
     xmlns:x="urn:schemas-microsoft-com:office:excel">
  <v:shapetype coordsize="21600,21600" id="_x0000_t202" path="m,l,21600r21600,l21600,xe">
    <v:stroke joinstyle="miter"/>
    <v:path gradientshapeok="t" o:connecttype="rect"/>
  </v:shapetype>
  ${foreach(comments, (comment2) => `
    <v:shape type="#_x0000_t202" style="visibility: hidden" fillcolor="#ffffe1" o:insetmode="auto">
      <v:shadow on="t" color="black" obscured="t"/>
      <x:ClientData ObjectType="Note">
        <x:MoveWithCells/>
        <x:SizeWithCells/>
        <x:Anchor>${comment2.anchor}</x:Anchor>
        <x:AutoFill>False</x:AutoFill>
        <x:Row>${comment2.row}</x:Row>
        <x:Column>${comment2.col}</x:Column>
      </x:ClientData>
    </v:shape>`)}
</xml>`;
var DRAWINGS_XML = (drawings) => `${XMLHEAD}
<xdr:wsDr xmlns:xdr="http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"
          xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  ${foreach(drawings, (drawing, index) => `
    <xdr:oneCellAnchor editAs="oneCell">
      <xdr:from>
        <xdr:col>${drawing.col}</xdr:col>
        <xdr:colOff>${drawing.colOffset}</xdr:colOff>
        <xdr:row>${drawing.row}</xdr:row>
        <xdr:rowOff>${drawing.rowOffset}</xdr:rowOff>
      </xdr:from>
      <xdr:ext cx="${drawing.width}" cy="${drawing.height}" />
      <xdr:pic>
        <xdr:nvPicPr>
          <xdr:cNvPr id="${index + 1}" name="Picture ${index + 1}"/>
          <xdr:cNvPicPr/>
        </xdr:nvPicPr>
        <xdr:blipFill>
          <a:blip r:embed="${drawing.imageId}"/>
          <a:stretch>
            <a:fillRect/>
          </a:stretch>
        </xdr:blipFill>
        <xdr:spPr>
          <a:prstGeom prst="rect">
            <a:avLst/>
          </a:prstGeom>
        </xdr:spPr>
      </xdr:pic>
      <xdr:clientData/>
    </xdr:oneCellAnchor>`)}
</xdr:wsDr>`;
var DRAWINGS_RELS_XML = (rels) => `${XMLHEAD}
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  ${foreach(rels, (rel) => `
    <Relationship Id="${rel.rId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="${rel.target}"/>`)}
</Relationships>`;
var SHARED_STRINGS = ({ count: count2, uniqueCount, indexes }) => `${XMLHEAD}
<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${count2}" uniqueCount="${uniqueCount}">
  ${foreach(Object.keys(indexes), (index) => `
    <si><t xml:space="preserve">${ESC(index.substring(1))}</t></si>`)}
</sst>`;
var STYLES = ({
  formats,
  fonts,
  fills,
  borders,
  styles
}) => `${XMLHEAD}
<styleSheet
    xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="x14ac"
    xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">
  <numFmts count="${formats.length}">
  ${foreach(formats, (format, fi) => `
    <numFmt formatCode="${ESC(format.format)}" numFmtId="${165 + fi}" />`)}
  </numFmts>
  <fonts count="${fonts.length + 1}" x14ac:knownFonts="1">
    <font>
       <sz val="11" />
       <color theme="1" />
       <name val="Calibri" />
       <family val="2" />
       <scheme val="minor" />
    </font>
    ${foreach(fonts, (font) => `
    <font>
      ${font.bold ? "<b/>" : ""}
      ${font.italic ? "<i/>" : ""}
      ${font.underline ? "<u/>" : ""}
      <sz val="${font.fontSize || 11}" />
      ${font.color ? `<color rgb="${ESC(font.color)}" />` : '<color theme="1" />'}
      ${font.fontFamily ? `
        <name val="${ESC(font.fontFamily)}" />
        <family val="2" />
      ` : `
        <name val="Calibri" />
        <family val="2" />
        <scheme val="minor" />
      `}
    </font>`)}
  </fonts>
  <fills count="${fills.length + 2}">
      <fill><patternFill patternType="none"/></fill>
      <fill><patternFill patternType="gray125"/></fill>
    ${foreach(fills, (fill) => `
      ${fill.background ? `
        <fill>
          <patternFill patternType="solid">
              <fgColor rgb="${ESC(fill.background)}"/>
          </patternFill>
        </fill>
      ` : ""}`)}
  </fills>
  <borders count="${borders.length + 1}">
    <border><left/><right/><top/><bottom/><diagonal/></border>
    ${foreach(borders, borderTemplate)}
  </borders>
  <cellStyleXfs count="1">
    <xf borderId="0" fillId="0" fontId="0" />
  </cellStyleXfs>
  <cellXfs count="${styles.length + 1}">
    <xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" />
    ${foreach(styles, (style2) => `
      <xf xfId="0"
          ${style2.fontId ? `fontId="${style2.fontId}" applyFont="1"` : ""}
          ${style2.fillId ? `fillId="${style2.fillId}" applyFill="1"` : ""}
          ${style2.numFmtId ? `numFmtId="${style2.numFmtId}" applyNumberFormat="1"` : ""}
          ${style2.textAlign || style2.verticalAlign || style2.wrap ? 'applyAlignment="1"' : ""}
          ${style2.borderId ? `borderId="${style2.borderId}" applyBorder="1"` : ""}
          ${style2.disabled != null ? `applyProtection="1"` : ""}>
        ${style2.textAlign || style2.verticalAlign || style2.wrap ? `
        <alignment
          ${style2.textAlign ? `horizontal="${ESC(style2.textAlign)}"` : ""}
          ${style2.verticalAlign ? `vertical="${ESC(style2.verticalAlign)}"` : ""}
          ${style2.indent ? `indent="${ESC(style2.indent)}"` : ""}
          ${style2.wrap ? 'wrapText="1"' : ""} />
        ` : ""}
        ${style2.disabled != null ? `
        <protection locked="${style2.disabled ? 1 : 0}" />
        ` : ""}
      </xf>
    `)}
  </cellXfs>
  <cellStyles count="1">
    <cellStyle name="Normal" xfId="0" builtinId="0"/>
  </cellStyles>
  <dxfs count="0" />
  <tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleMedium9" />
</styleSheet>`;
function writeFormula(formula) {
  if (typeof formula == "string") {
    return `<f>${ESC(formula)}</f>`;
  }
  return `<f t="array" ref="${formula.ref}">${ESC(formula.src)}</f>`;
}
function numChar(colIndex) {
  const letter = Math.floor(colIndex / 26) - 1;
  return (letter >= 0 ? numChar(letter) : "") + String.fromCharCode(65 + colIndex % 26);
}
function ref(rowIndex, colIndex) {
  return numChar(colIndex) + (rowIndex + 1);
}
function $ref(rowIndex, colIndex) {
  return "$" + numChar(colIndex) + "$" + (rowIndex + 1);
}
function filterRowIndex(options) {
  const frozenRows = options.frozenRows || (options.freezePane || {}).rowSplit || 1;
  return frozenRows - 1;
}
function toWidth(px) {
  const maximumDigitWidth = 7;
  return px / maximumDigitWidth - Math.floor(128 / maximumDigitWidth) / 256;
}
function toHeight(px) {
  return px * 0.75;
}
function stripFunnyChars(value) {
  return String(value).replace(/[\x00-\x09\x0B\x0C\x0E-\x1F]/g, "").replace(/\r?\n/g, "\r\n");
}
var Worksheet = class {
  constructor(options, sharedStrings, styles, borders) {
    this.options = options;
    this._strings = sharedStrings;
    this._styles = styles;
    this._borders = borders;
    this._validations = {};
    this._comments = [];
    this._drawings = options.drawings || [];
    this._hyperlinks = (this.options.hyperlinks || []).map(
      (link, i) => Object.assign({}, link, { rId: `link${i}` })
    );
  }
  relsToXML() {
    const hyperlinks = this._hyperlinks;
    const comments = this._comments;
    const drawings = this._drawings;
    if (hyperlinks.length || comments.length || drawings.length) {
      return WORKSHEET_RELS({
        hyperlinks,
        comments,
        sheetIndex: this.options.sheetIndex,
        drawings
      });
    }
  }
  toXML(index) {
    const mergeCells = this.options.mergedCells || [];
    const rows = this.options.rows || [];
    const data = inflate(rows, mergeCells);
    this._readCells(data);
    let autoFilter = this.options.filter;
    let filter3;
    if (autoFilter && typeof autoFilter.from === "number" && typeof autoFilter.to === "number") {
      autoFilter = {
        from: ref(filterRowIndex(this.options), autoFilter.from),
        to: ref(filterRowIndex(this.options), autoFilter.to)
      };
    } else if (autoFilter && autoFilter.ref && autoFilter.columns) {
      filter3 = autoFilter;
      autoFilter = null;
    }
    const validations = [];
    for (let i in this._validations) {
      if (Object.prototype.hasOwnProperty.call(this._validations, i)) {
        validations.push(this._validations[i]);
      }
    }
    let defaultCellStyleId = null;
    let defaultCellStyle = this.options.defaultCellStyle;
    if (this._hasDisabledCells) {
      if (!defaultCellStyle) {
        defaultCellStyle = { disabled: false };
      } else {
        defaultCellStyle = Object.assign({ disabled: false }, defaultCellStyle);
      }
    }
    if (defaultCellStyle) {
      defaultCellStyleId = this._lookupStyle(defaultCellStyle);
    }
    const freezePane = this.options.freezePane || {};
    const defaults2 = this.options.defaults || {};
    const lastRow = this.options.rows ? this._getLastRow() : 1;
    const lastCol = this.options.rows ? this._getLastCol() : 1;
    return WORKSHEET({
      frozenColumns: this.options.frozenColumns || freezePane.colSplit,
      frozenRows: this.options.frozenRows || freezePane.rowSplit,
      columns: this.options.columns,
      defaults: defaults2,
      data,
      index,
      mergeCells,
      autoFilter,
      filter: filter3,
      showGridLines: this.options.showGridLines,
      hyperlinks: this._hyperlinks,
      validations,
      defaultCellStyleId,
      rtl: this.options.rtl !== void 0 ? this.options.rtl : defaults2.rtl,
      legacyDrawing: this._comments.length ? `vml${this.options.sheetIndex}` : null,
      drawing: this._drawings.length ? `drw${this.options.sheetIndex}` : null,
      lastRow,
      lastCol,
      hasDisabledCells: this._hasDisabledCells
    });
  }
  commentsXML() {
    if (this._comments.length) {
      return COMMENTS_XML({ comments: this._comments });
    }
  }
  drawingsXML(images) {
    if (this._drawings.length) {
      let rels = {};
      let main = this._drawings.map((drw) => {
        let ref2 = parseRef(drw.topLeftCell);
        let img = rels[drw.image];
        if (!img) {
          img = rels[drw.image] = {
            rId: `img${drw.image}`,
            target: images[drw.image].target
          };
        }
        return {
          col: ref2.col,
          colOffset: pixelsToExcel(drw.offsetX),
          row: ref2.row,
          rowOffset: pixelsToExcel(drw.offsetY),
          width: pixelsToExcel(drw.width),
          height: pixelsToExcel(drw.height),
          imageId: img.rId
        };
      });
      return {
        main: DRAWINGS_XML(main),
        rels: DRAWINGS_RELS_XML(rels)
      };
    }
  }
  legacyDrawing() {
    if (this._comments.length) {
      return LEGACY_DRAWING({ comments: this._comments });
    }
  }
  _lookupString(value) {
    const key = "$" + value;
    const index = this._strings.indexes[key];
    let result;
    if (index !== void 0) {
      result = index;
    } else {
      result = this._strings.indexes[key] = this._strings.uniqueCount;
      this._strings.uniqueCount++;
    }
    this._strings.count++;
    return result;
  }
  _lookupStyle(style2) {
    const json = JSON.stringify(style2);
    if (json === "{}") {
      return 0;
    }
    let index = indexOf(json, this._styles);
    if (index < 0) {
      index = this._styles.push(json) - 1;
    }
    return index + 1;
  }
  _lookupBorder(border) {
    const json = JSON.stringify(border);
    if (json === "{}") {
      return;
    }
    let index = indexOf(json, this._borders);
    if (index < 0) {
      index = this._borders.push(json) - 1;
    }
    return index + 1;
  }
  _readCells(rowData) {
    for (let i = 0; i < rowData.length; i++) {
      const row2 = rowData[i];
      const cells = row2.cells;
      row2.data = [];
      for (let j = 0; j < cells.length; j++) {
        const cellData = this._cell(cells[j], row2.index, j);
        if (cellData) {
          row2.data.push(cellData);
        }
      }
    }
  }
  _cell(data, rowIndex, cellIndex) {
    if (!data || data === EMPTY_CELL) {
      return null;
    }
    let value = data.value;
    let border = {};
    if (data.borderLeft) {
      border.left = data.borderLeft;
    }
    if (data.borderRight) {
      border.right = data.borderRight;
    }
    if (data.borderTop) {
      border.top = data.borderTop;
    }
    if (data.borderBottom) {
      border.bottom = data.borderBottom;
    }
    if (data.dBorders) {
      border.diagonal = data.dBorders;
    }
    border = this._lookupBorder(border);
    const defStyle = this.options.defaultCellStyle || {};
    let style2 = { borderId: border };
    ((add) => {
      add("color");
      add("background");
      add("bold");
      add("italic");
      add("underline");
      if (!add("fontFamily")) {
        add("fontName", "fontFamily");
      }
      add("fontSize");
      add("format");
      if (!add("textAlign")) {
        add("hAlign", "textAlign");
      }
      if (!add("verticalAlign")) {
        add("vAlign", "verticalAlign");
      }
      add("wrap");
      add("indent");
      if (!add("disabled")) {
        if (add("enable")) {
          style2.disabled = !style2.enable;
          delete style2.enable;
        }
      }
      if (style2.disabled) {
        this._hasDisabledCells = true;
      }
    })((prop, target) => {
      let val = data[prop];
      if (val === void 0) {
        val = defStyle[prop];
      }
      if (val !== void 0) {
        style2[target || prop] = val;
        return true;
      }
    });
    const columns = this.options.columns || [];
    const column = columns[cellIndex];
    let type = typeof value;
    if (column && column.autoWidth && (!data.colSpan || data.colSpan === 1)) {
      let displayValue = value;
      if (type === "number") {
        displayValue = intl_service_default.toString(value, data.format);
      }
      column.width = Math.max(column.width || 0, String(displayValue).length);
    }
    if (type === "string") {
      value = stripFunnyChars(value);
      value = this._lookupString(value);
      type = "s";
    } else if (type === "number") {
      type = "n";
    } else if (type === "boolean") {
      type = "b";
      value = Number(value);
    } else if (value && value.getTime) {
      type = null;
      value = dateToSerial(value);
      if (!style2.format) {
        style2.format = "mm-dd-yy";
      }
    } else {
      type = null;
      value = null;
    }
    style2 = this._lookupStyle(style2);
    const cellName = ref(rowIndex, cellIndex);
    if (data.validation) {
      this._addValidation(data.validation, cellName);
    }
    if (data.comment) {
      let anchor2 = [
        cellIndex + 1,
        // start column
        15,
        // start column offset
        rowIndex,
        // start row
        10,
        // start row offset
        cellIndex + 3,
        // end column
        15,
        // end column offset
        rowIndex + 3,
        // end row
        4
        // end row offset
      ];
      this._comments.push({
        ref: cellName,
        text: data.comment,
        row: rowIndex,
        col: cellIndex,
        anchor: anchor2.join(", ")
      });
    }
    return {
      value,
      formula: data.formula,
      type,
      style: style2,
      ref: cellName
    };
  }
  _addValidation(v, ref2) {
    const tmp = {
      showErrorMessage: v.type === "reject" ? 1 : 0,
      formula1: v.from,
      formula2: v.to,
      type: MAP_EXCEL_TYPE[v.dataType] || v.dataType,
      operator: MAP_EXCEL_OPERATOR[v.comparerType] || v.comparerType,
      allowBlank: v.allowNulls ? 1 : 0,
      showDropDown: v.showButton ? 0 : 1,
      // LOL, Excel!
      error: v.messageTemplate,
      errorTitle: v.titleTemplate
    };
    const json = JSON.stringify(tmp);
    if (!this._validations[json]) {
      this._validations[json] = tmp;
      tmp.sqref = [];
    }
    this._validations[json].sqref.push(ref2);
  }
  _getLastRow() {
    return countData(this.options.rows);
  }
  _getLastCol() {
    let last2 = 0;
    this.options.rows.forEach(function(row2) {
      if (row2.cells) {
        last2 = Math.max(last2, countData(row2.cells));
      }
    });
    return last2;
  }
};
function countData(data) {
  let last2 = data.length;
  data.forEach(function(el) {
    if (el.index && el.index >= last2) {
      last2 = el.index + 1;
    }
  });
  return last2;
}
var MAP_EXCEL_OPERATOR = {
  // includes only what differs; key is our operator, value is Excel
  // operator.
  greaterThanOrEqualTo: "greaterThanOrEqual",
  lessThanOrEqualTo: "lessThanOrEqual"
};
var MAP_EXCEL_TYPE = {
  // eslint-disable-next-line id-denylist
  number: "decimal"
};
var defaultFormats = {
  "General": 0,
  "0": 1,
  "0.00": 2,
  "#,##0": 3,
  "#,##0.00": 4,
  "0%": 9,
  "0.00%": 10,
  "0.00E+00": 11,
  "# ?/?": 12,
  "# ??/??": 13,
  "mm-dd-yy": 14,
  "d-mmm-yy": 15,
  "d-mmm": 16,
  "mmm-yy": 17,
  "h:mm AM/PM": 18,
  "h:mm:ss AM/PM": 19,
  "h:mm": 20,
  "h:mm:ss": 21,
  "m/d/yy h:mm": 22,
  "#,##0 ;(#,##0)": 37,
  "#,##0 ;[Red](#,##0)": 38,
  "#,##0.00;(#,##0.00)": 39,
  "#,##0.00;[Red](#,##0.00)": 40,
  "mm:ss": 45,
  "[h]:mm:ss": 46,
  "mmss.0": 47,
  "##0.0E+0": 48,
  "@": 49,
  "[$-404]e/m/d": 27,
  "m/d/yy": 30,
  "t0": 59,
  "t0.00": 60,
  "t#,##0": 61,
  "t#,##0.00": 62,
  "t0%": 67,
  "t0.00%": 68,
  "t# ?/?": 69,
  "t# ??/??": 70
};
function maybeRGB(value) {
  function hex(val) {
    let x = parseInt(val, 10).toString(16);
    return x.length < 2 ? "0" + x : x;
  }
  let m = /^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+)\s*)?\)/i.exec(value.trim());
  if (m) {
    let opacity = (m[4] ? parseFloat(m[4]) : 1) * 255 | 0;
    return "#" + hex(opacity) + hex(m[1]) + hex(m[2]) + hex(m[3]);
  }
  return value;
}
function convertColor(value) {
  let color = maybeRGB(value);
  if (color.length < 6) {
    color = color.replace(/(\w)/g, function($0, $1) {
      return $1 + $1;
    });
  }
  color = color.substring(1).toUpperCase();
  if (color.length < 8) {
    color = "FF" + color;
  }
  return color;
}
var Workbook = class {
  constructor(options) {
    this.options = options || {};
    this._strings = {
      indexes: {},
      count: 0,
      uniqueCount: 0
    };
    this._styles = [];
    this._borders = [];
    this._images = this.options.images;
    this._imgId = 0;
    this._sheets = map2(this.options.sheets || [], (options2, i) => {
      options2.defaults = this.options;
      options2.sheetIndex = i + 1;
      return new Worksheet(options2, this._strings, this._styles, this._borders);
    });
  }
  imageFilename(mimeType) {
    const id2 = ++this._imgId;
    switch (mimeType) {
      case "image/jpg":
      case "image/jpeg":
        return `image${id2}.jpg`;
      case "image/png":
        return `image${id2}.png`;
      case "image/gif":
        return `image${id2}.gif`;
      default:
        return `image${id2}.bin`;
    }
  }
  toZIP() {
    const zip3 = createZip();
    const docProps = zip3.folder("docProps");
    docProps.file("core.xml", CORE({
      creator: this.options.creator || "Kendo UI",
      lastModifiedBy: this.options.creator || "Kendo UI",
      created: this.options.date || (/* @__PURE__ */ new Date()).toJSON(),
      modified: this.options.date || (/* @__PURE__ */ new Date()).toJSON()
    }));
    const sheetCount = this._sheets.length;
    docProps.file("app.xml", APP({ sheets: this._sheets }));
    const rels = zip3.folder("_rels");
    rels.file(".rels", RELS);
    const xl = zip3.folder("xl");
    const xlRels = xl.folder("_rels");
    xlRels.file("workbook.xml.rels", WORKBOOK_RELS({ count: sheetCount }));
    if (this._images) {
      const media = xl.folder("media");
      Object.keys(this._images).forEach((id2) => {
        const img = this._images[id2];
        const filename = this.imageFilename(img.type);
        media.file(filename, img.data);
        img.target = `../media/${filename}`;
      });
    }
    const sheetIds = {};
    xl.file("workbook.xml", WORKBOOK({
      sheets: this._sheets,
      filterNames: map2(this._sheets, function(sheet, index) {
        const options = sheet.options;
        const sheetName = options.name || options.title || "Sheet" + (index + 1);
        sheetIds[sheetName.toLowerCase()] = index;
        const filter3 = options.filter;
        if (filter3) {
          if (filter3.ref) {
            let a = filter3.ref.split(":");
            let from2 = parseRef(a[0]);
            let to = parseRef(a[1]);
            return {
              localSheetId: index,
              name: sheetName,
              from: $ref(from2.row, from2.col),
              to: $ref(to.row, to.col)
            };
          } else if (typeof filter3.from !== "undefined" && typeof filter3.to !== "undefined") {
            return {
              localSheetId: index,
              name: sheetName,
              from: $ref(filterRowIndex(options), filter3.from),
              to: $ref(filterRowIndex(options), filter3.to)
            };
          }
        }
      }),
      userNames: map2(this.options.names || [], function(def) {
        return {
          name: def.localName,
          localSheetId: def.sheet ? sheetIds[def.sheet.toLowerCase()] : null,
          value: def.value,
          hidden: def.hidden
        };
      })
    }));
    const worksheets = xl.folder("worksheets");
    const drawings = xl.folder("drawings");
    const drawingsRels = drawings.folder("_rels");
    const sheetRels = worksheets.folder("_rels");
    const commentFiles = [];
    const drawingFiles = [];
    let hasDisabledCells = false;
    for (let idx2 = 0; idx2 < sheetCount; idx2++) {
      const sheet = this._sheets[idx2];
      const sheetName = `sheet${idx2 + 1}.xml`;
      const sheetXML = sheet.toXML(idx2);
      const relsXML = sheet.relsToXML();
      const commentsXML = sheet.commentsXML();
      const legacyDrawing = sheet.legacyDrawing();
      const drawingsXML = sheet.drawingsXML(this._images);
      if (sheet._hasDisabledCells) {
        hasDisabledCells = true;
      }
      if (relsXML) {
        sheetRels.file(sheetName + ".rels", relsXML);
      }
      if (commentsXML) {
        let name = `comments${sheet.options.sheetIndex}.xml`;
        xl.file(name, commentsXML);
        commentFiles.push(name);
      }
      if (legacyDrawing) {
        drawings.file(`vmlDrawing${sheet.options.sheetIndex}.vml`, legacyDrawing);
      }
      if (drawingsXML) {
        let name = `drawing${sheet.options.sheetIndex}.xml`;
        drawings.file(name, drawingsXML.main);
        drawingsRels.file(`${name}.rels`, drawingsXML.rels);
        drawingFiles.push(name);
      }
      worksheets.file(sheetName, sheetXML);
    }
    const borders = map2(this._borders, parseJSON);
    const styles = map2(this._styles, parseJSON);
    const hasFont = function(style2) {
      return style2.underline || style2.bold || style2.italic || style2.color || style2.fontFamily || style2.fontSize;
    };
    const convertFontSize = function(value) {
      let fontInPx = Number(value);
      let fontInPt;
      if (fontInPx) {
        fontInPt = fontInPx * 3 / 4;
      }
      return fontInPt;
    };
    const fonts = map2(styles, function(style2) {
      if (style2.fontSize) {
        style2.fontSize = convertFontSize(style2.fontSize);
      }
      if (style2.color) {
        style2.color = convertColor(style2.color);
      }
      if (hasFont(style2)) {
        return style2;
      }
    });
    const formats = map2(styles, function(style2) {
      if (style2.format && defaultFormats[style2.format] === void 0) {
        return style2;
      }
    });
    const fills = map2(styles, function(style2) {
      if (style2.background) {
        style2.background = convertColor(style2.background);
        return style2;
      }
    });
    xl.file("styles.xml", STYLES({
      fonts,
      fills,
      formats,
      borders,
      styles: map2(styles, function(style2) {
        const result = {};
        if (hasFont(style2)) {
          result.fontId = indexOf(style2, fonts) + 1;
        }
        if (style2.background) {
          result.fillId = indexOf(style2, fills) + 2;
        }
        result.textAlign = style2.textAlign;
        result.indent = style2.indent;
        result.verticalAlign = style2.verticalAlign;
        result.wrap = style2.wrap;
        result.borderId = style2.borderId;
        if (style2.format) {
          if (defaultFormats[style2.format] !== void 0) {
            result.numFmtId = defaultFormats[style2.format];
          } else {
            result.numFmtId = 165 + indexOf(style2, formats);
          }
        }
        if (hasDisabledCells) {
          result.disabled = !!style2.disabled;
        }
        return result;
      })
    }));
    xl.file("sharedStrings.xml", SHARED_STRINGS(this._strings));
    zip3.file("[Content_Types].xml", CONTENT_TYPES({
      sheetCount,
      commentFiles,
      drawingFiles
    }));
    return zip3;
  }
  toDataURL() {
    const zip3 = this.toZIP();
    return zip3.generateAsync ? zip3.generateAsync(DATA_URL_OPTIONS).then(toDataURI) : toDataURI(zip3.generate(DATA_URL_OPTIONS));
  }
  toBlob() {
    const zip3 = this.toZIP();
    if (zip3.generateAsync) {
      return zip3.generateAsync(BLOB_OPTIONS);
    }
    return new Blob([zip3.generate(ARRAYBUFFER_OPTIONS)], { type: MIME_TYPE });
  }
};
function borderStyle(width2) {
  let alias = "thin";
  if (width2 === 2) {
    alias = "medium";
  } else if (width2 === 3) {
    alias = "thick";
  }
  return alias;
}
function borderSideTemplate(name, style2) {
  let result = "";
  if (style2) {
    result += "<" + name + ' style="' + borderStyle(style2.size) + '">';
    if (style2.color) {
      result += '<color rgb="' + convertColor(style2.color) + '"/>';
    }
    result += "</" + name + ">";
  }
  return result;
}
function borderTemplate(border) {
  let diag = border.diagonal ? border.diagonal.type : 0;
  return `<border ${diag & 2 ? 'diagonalUp="true"' : ""} ${diag & 1 ? 'diagonalDown="true"' : ""}>
      ${borderSideTemplate("left", border.left)}
      ${borderSideTemplate("right", border.right)}
      ${borderSideTemplate("top", border.top)}
      ${borderSideTemplate("bottom", border.bottom)}
      ${borderSideTemplate("diagonal", border.diagonal)}
    </border>`;
}
var EMPTY_CELL = {};
function inflate(rows, mergedCells) {
  const rowData = [];
  const rowsByIndex = [];
  indexRows(rows, function(row2, index) {
    const data = {
      _source: row2,
      index,
      height: row2.height,
      level: row2.level,
      cells: []
    };
    rowData.push(data);
    rowsByIndex[index] = data;
  });
  const sorted = sortByIndex(rowData).slice(0);
  const ctx = {
    rowData,
    rowsByIndex,
    mergedCells
  };
  for (let i = 0; i < sorted.length; i++) {
    fillCells(sorted[i], ctx);
    delete sorted[i]._source;
  }
  return sortByIndex(rowData);
}
function indexRows(rows, callback) {
  for (let i = 0; i < rows.length; i++) {
    const row2 = rows[i];
    if (!row2) {
      continue;
    }
    let index = row2.index;
    if (typeof index !== "number") {
      index = i;
    }
    callback(row2, index);
  }
}
function sortByIndex(items) {
  return items.sort(function(a, b) {
    return a.index - b.index;
  });
}
function pushUnique(array, el) {
  if (array.indexOf(el) < 0) {
    array.push(el);
  }
}
function getSpan(mergedCells, ref2) {
  for (let i = 0; i < mergedCells.length; ++i) {
    const range2 = mergedCells[i];
    const a = range2.split(":");
    let topLeft = a[0];
    if (topLeft === ref2) {
      let bottomRight = a[1];
      topLeft = parseRef(topLeft);
      bottomRight = parseRef(bottomRight);
      return {
        rowSpan: bottomRight.row - topLeft.row + 1,
        colSpan: bottomRight.col - topLeft.col + 1
      };
    }
  }
}
function parseRef(ref2) {
  function getcol(str) {
    let upperStr = str.toUpperCase();
    let col = 0;
    for (let i = 0; i < upperStr.length; ++i) {
      col = col * 26 + upperStr.charCodeAt(i) - 64;
    }
    return col - 1;
  }
  function getrow(str) {
    return parseInt(str, 10) - 1;
  }
  const m = /^([a-z]+)(\d+)$/i.exec(ref2);
  return {
    row: getrow(m[2]),
    col: getcol(m[1])
  };
}
function pixelsToExcel(px) {
  return Math.round(px * 9525);
}
function fillCells(data, ctx) {
  const row2 = data._source;
  const rowIndex = data.index;
  const cells = row2.cells;
  const cellData = data.cells;
  if (!cells) {
    return;
  }
  for (let i = 0; i < cells.length; i++) {
    const cell2 = cells[i] || EMPTY_CELL;
    let rowSpan = cell2.rowSpan || 1;
    let colSpan = cell2.colSpan || 1;
    const cellIndex = insertCell(cellData, cell2);
    const topLeftRef = ref(rowIndex, cellIndex);
    if (rowSpan === 1 && colSpan === 1) {
      const tmp = getSpan(ctx.mergedCells, topLeftRef);
      if (tmp) {
        colSpan = tmp.colSpan;
        rowSpan = tmp.rowSpan;
      }
    }
    spanCell(cell2, cellData, cellIndex, colSpan);
    if (rowSpan > 1 || colSpan > 1) {
      pushUnique(
        ctx.mergedCells,
        topLeftRef + ":" + ref(
          rowIndex + rowSpan - 1,
          cellIndex + colSpan - 1
        )
      );
    }
    if (rowSpan > 1) {
      for (let ri = rowIndex + 1; ri < rowIndex + rowSpan; ri++) {
        let nextRow = ctx.rowsByIndex[ri];
        if (!nextRow) {
          nextRow = ctx.rowsByIndex[ri] = { index: ri, cells: [] };
          ctx.rowData.push(nextRow);
        }
        spanCell(cell2, nextRow.cells, cellIndex - 1, colSpan + 1);
      }
    }
  }
}
function insertCell(data, cell2) {
  let index;
  if (typeof cell2.index === "number") {
    index = cell2.index;
    insertCellAt(data, cell2, cell2.index);
  } else {
    index = appendCell(data, cell2);
  }
  return index;
}
function insertCellAt(data, cell2, index) {
  data[index] = cell2;
}
function appendCell(data, cell2) {
  let index = data.length;
  for (let i = 0; i < data.length + 1; i++) {
    if (!data[i]) {
      data[i] = cell2;
      index = i;
      break;
    }
  }
  return index;
}
function spanCell(cell2, row2, startIndex, colSpan) {
  for (let i = 1; i < colSpan; i++) {
    const tmp = {
      borderTop: cell2.borderTop,
      borderRight: cell2.borderRight,
      borderBottom: cell2.borderBottom,
      borderLeft: cell2.borderLeft
    };
    insertCellAt(row2, tmp, startIndex + i);
  }
}
var SPREADSHEET_FILTERS = ({ ref: ref2, columns, generators }) => `
<autoFilter ref="${ref2}">
  ${foreach(columns, (col) => `
    <filterColumn colId="${col.index}">
      ${generators[col.filter](col)}
    </filterColumn>
  `)}
</autoFilter>`;
var SPREADSHEET_CUSTOM_FILTER = ({ logic, criteria }) => `
<customFilters ${logic === "and" ? 'and="1"' : ""}>
${foreach(criteria, (f) => {
  let op = spreadsheetFilters.customOperator(f);
  let val = spreadsheetFilters.customValue(f);
  return `<customFilter ${op ? `operator="${op}"` : ""} val="${val}"/>`;
})}
</customFilters>`;
var SPREADSHEET_DYNAMIC_FILTER = ({ type }) => `<dynamicFilter type="${spreadsheetFilters.dynamicFilterType(type)}" />`;
var SPREADSHEET_TOP_FILTER = ({ type, value }) => `<top10 percent="${/percent$/i.test(type) ? 1 : 0}"
       top="${/^top/i.test(type) ? 1 : 0}"
       val="${value}" />`;
var SPREADSHEET_VALUE_FILTER = ({ blanks, values }) => `<filters ${blanks ? 'blank="1"' : ""}>
    ${foreach(values, (value) => `
      <filter val="${value}" />`)}
  </filters>`;
function spreadsheetFilters(filter3) {
  return SPREADSHEET_FILTERS({
    ref: filter3.ref,
    columns: filter3.columns,
    generators: {
      custom: SPREADSHEET_CUSTOM_FILTER,
      dynamic: SPREADSHEET_DYNAMIC_FILTER,
      top: SPREADSHEET_TOP_FILTER,
      value: SPREADSHEET_VALUE_FILTER
    }
  });
}
spreadsheetFilters.customOperator = function(f) {
  return {
    eq: "equal",
    gt: "greaterThan",
    gte: "greaterThanOrEqual",
    lt: "lessThan",
    lte: "lessThanOrEqual",
    ne: "notEqual",
    // These are not in the spec, but seems to be how Excel does
    // it (see customValue below).  For the non-negated versions,
    // the operator attribute is missing completely.
    doesnotstartwith: "notEqual",
    doesnotendwith: "notEqual",
    doesnotcontain: "notEqual",
    doesnotmatch: "notEqual"
  }[f.operator.toLowerCase()];
};
function quoteSheet(name) {
  if (/^\'/.test(name)) {
    return name;
  }
  if (/^[a-z_][a-z0-9_]*$/i.test(name)) {
    return name;
  }
  return "'" + name.replace(/\x27/g, "\\'") + "'";
}
spreadsheetFilters.customValue = function(f) {
  function esc(str) {
    return str.replace(/([*?])/g, "~$1");
  }
  switch (f.operator.toLowerCase()) {
    case "startswith":
    case "doesnotstartwith":
      return esc(f.value) + "*";
    case "endswith":
    case "doesnotendwith":
      return "*" + esc(f.value);
    case "contains":
    case "doesnotcontain":
      return "*" + esc(f.value) + "*";
    default:
      return f.value;
  }
};
spreadsheetFilters.dynamicFilterType = function(type) {
  return {
    quarter1: "Q1",
    quarter2: "Q2",
    quarter3: "Q3",
    quarter4: "Q4",
    january: "M1",
    february: "M2",
    march: "M3",
    april: "M4",
    may: "M5",
    june: "M6",
    july: "M7",
    august: "M8",
    september: "M9",
    october: "M10",
    november: "M11",
    december: "M12"
  }[type.toLowerCase()] || type;
};

// node_modules/@progress/kendo-angular-excel-export/fesm2022/progress-kendo-angular-excel-export.mjs
var compileTemplate = (templateRef, context, updateContext) => {
  let embeddedView = templateRef.createEmbeddedView(context);
  const result = (data) => {
    updateContext(context, data);
    embeddedView.detectChanges();
    return embeddedView.rootNodes.reduce((content2, rootNode) => {
      return content2 + rootNode.textContent;
    }, "").trim();
  };
  result.destroy = () => {
    embeddedView.destroy();
    embeddedView = null;
  };
  return result;
};
var updateGroupHeaderContext = (context, data) => {
  context.$implicit = context.group = data;
  context.field = data.field;
  context.value = data.value;
  context.aggregates = data.aggregates;
};
var updateGroupFooterContext = (context, data) => {
  context.group = data.group;
  context.$implicit = context.aggregates = data;
};
var updateFooterContext = (context, data) => {
  context.aggregates = data.aggregates;
};
var toExporterColumns = (sourceColumns) => {
  const exporterColumns = [];
  let columnIndex = 0;
  const addColumns = (columns, result, level) => {
    columns.forEach((column) => {
      if (column.level === level) {
        const exporterColumn = new ExporterColumn(column, columnIndex);
        result.push(exporterColumn);
        if (column.children && column.children.some((c) => c !== column)) {
          const children2 = exporterColumn.columns = [];
          addColumns(column.children, children2, level + 1);
        } else {
          columnIndex++;
        }
      }
    });
  };
  addColumns(sourceColumns, exporterColumns, 0);
  return exporterColumns;
};
var destroyColumns = (columns) => {
  if (columns) {
    columns.forEach((column) => {
      column.destroy();
    });
  }
};
var ExporterColumn = class {
  title;
  field;
  hidden;
  locked;
  width;
  columns;
  groupHeaderTemplate;
  groupHeaderColumnTemplate;
  groupFooterTemplate;
  footerTemplate;
  headerCellOptions;
  cellOptions;
  groupHeaderCellOptions;
  groupFooterCellOptions;
  footerCellOptions;
  constructor(column, columnIndex) {
    this.title = column.title;
    this.field = column.field;
    this.hidden = column.hidden;
    this.locked = column.locked;
    this.width = column.width;
    this.headerCellOptions = column.headerCellOptions;
    this.cellOptions = column.cellOptions;
    this.groupHeaderCellOptions = column.groupHeaderCellOptions;
    this.groupFooterCellOptions = column.groupFooterCellOptions;
    this.footerCellOptions = column.footerCellOptions;
    if (column.footerTemplate) {
      this.footerTemplate = compileTemplate(column.footerTemplate.templateRef, {
        $implicit: column,
        column,
        columnIndex
      }, updateFooterContext);
    }
    if (column.groupFooterTemplate) {
      this.groupFooterTemplate = compileTemplate(column.groupFooterTemplate.templateRef, {
        column,
        field: column.field
      }, updateGroupFooterContext);
    }
    if (column.groupHeaderTemplate) {
      this.groupHeaderTemplate = compileTemplate(column.groupHeaderTemplate.templateRef, {}, updateGroupHeaderContext);
    }
    if (column.groupHeaderColumnTemplate) {
      this.groupHeaderColumnTemplate = compileTemplate(column.groupHeaderColumnTemplate.templateRef, {}, updateGroupHeaderContext);
    }
  }
  destroy() {
    if (this.footerTemplate) {
      this.footerTemplate.destroy();
    }
    if (this.groupFooterTemplate) {
      this.groupFooterTemplate.destroy();
    }
    if (this.groupHeaderTemplate) {
      this.groupHeaderTemplate.destroy();
    }
    if (this.groupHeaderColumnTemplate) {
      this.groupHeaderColumnTemplate.destroy();
    }
    destroyColumns(this.columns);
  }
};
intl_service_default.register({
  toString
});
var workbookOptions = (options) => {
  const columns = toExporterColumns(options.columns);
  const exporter = new excel_exporter_default({
    columns,
    data: options.data,
    filterable: options.filterable,
    groups: options.group,
    paddingCellOptions: options.paddingCellOptions,
    headerPaddingCellOptions: options.headerPaddingCellOptions,
    collapsible: options.collapsible,
    hierarchy: options.hierarchy,
    aggregates: options.aggregates
  });
  const result = exporter.workbook();
  result.creator = options.creator;
  result.date = options.date;
  result.rtl = options.rtl;
  destroyColumns(columns);
  return result;
};
var toDataURL = (options) => {
  const workbook = new Workbook(options);
  return workbook.toDataURL();
};
var isWorkbookOptions = (value) => {
  return value && value.sheets;
};
var ColumnBase = class _ColumnBase {
  parent;
  /**
   * The title of the column.
   */
  title;
  /**
   * The width of the column in pixels.
   */
  width;
  /**
   * Toggles the locked (frozen) state of the column ([see example]({% slug columns_excel-export %}#toc-locked-state)).
   *
   * @default false
   */
  locked;
  /**
   * Sets the visibility of the column ([see example]({% slug columns_excel-export %}#toc-hidden-state)).
   *
   * @default false
   */
  hidden;
  /**
   * The options of the column header cell.
   */
  headerCellOptions;
  /**
   * @hidden
   */
  children;
  /**
   * @hidden
   */
  get level() {
    return this.parent ? this.parent.level + 1 : 0;
  }
  constructor(parent) {
    this.parent = parent;
  }
  static ɵfac = function ColumnBase_Factory(t) {
    return new (t || _ColumnBase)(ɵɵdirectiveInject(_ColumnBase));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnBase,
    selectors: [["ng-component"]],
    contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, _ColumnBase, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
      }
    },
    inputs: {
      title: "title",
      width: "width",
      locked: "locked",
      hidden: "hidden",
      headerCellOptions: "headerCellOptions"
    },
    decls: 0,
    vars: 0,
    template: function ColumnBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnBase, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], function() {
    return [{
      type: ColumnBase
    }];
  }, {
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    locked: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    headerCellOptions: [{
      type: Input
    }],
    children: [{
      type: ContentChildren,
      args: [ColumnBase]
    }]
  });
})();
var packageMetadata3 = {
  name: "@progress/kendo-angular-excel-export",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1749540182,
  version: "19.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var ExcelExportComponent = class _ExcelExportComponent {
  localization;
  zone;
  /**
   * Specifies the name of the file that is exported to Excel.
   * @default "Export.xlsx"
   */
  fileName = "Export.xlsx";
  /**
   * Enables or disables the column filtering in the Excel file
   * ([see example]({% slug filtering_excelexport %})).
   */
  filterable;
  /**
   * Specifies if groups are collapsible in the excel file.
   */
  collapsible;
  /**
   * The author of the workbook.
   */
  creator;
  /**
   * The date on which the workbook is created.
   * The default value is `new Date()`.
   */
  date;
  /**
   * If `forceProxy` is set to `true`, the content is forwarded to `proxyURL`
   * even if the browser supports the local saving of files.
   */
  forceProxy;
  /**
   * The URL of the server-side proxy which will stream the file to the end user. When the browser is not
   * capable of saving files locally&mdash;for example, Internet Explorer 9 and earlier, and Safari&mdash;a
   * proxy is used. The implementation of the server-side proxy has to be done by you.
   *
   * The proxy receives a POST request with the following parameters in the request body:
   * - `contentType`&mdash;The MIME type of the file.
   * - `base64`&mdash;The base-64 encoded file content.
   * - `fileName`&mdash;The file name, as requested by the caller.
   * The proxy is expected to return the decoded file with the **Content-Disposition** header set to `attachment; filename="<fileName.xslx>"`.
   */
  proxyURL;
  /**
   * The exported data. If grouped, the data must be structured as described by the
   * [`GroupResult`]({% slug api_kendo-data-query_groupresult %}) option of the Kendo UI Data Query component.
   */
  data;
  /**
   * The exported data groups. The groups must be compatible with the
   * [`GroupDescriptor`]({% slug api_kendo-data-query_groupdescriptor %}) option of the Kendo UI Data Query component.
   */
  group;
  /**
   * The options of the cells that are inserted before the data, group, and footer cells
   * to indicate the group hierarchy when the data is grouped
   * ([see example]({% slug cells_excelexport %}#toc-padding-cells)).
   */
  paddingCellOptions;
  /**
   * The options of the cells that are inserted before the header cells
   * to align the headers and the column values when the data is grouped
   * ([see example]({% slug cells_excelexport %}#toc-header-padding-cells)).
   */
  headerPaddingCellOptions;
  /**
   * @hidden
   */
  columns = new QueryList();
  constructor(localization, zone) {
    this.localization = localization;
    this.zone = zone;
    validatePackage(packageMetadata3);
    this.saveFile = this.saveFile.bind(this);
  }
  /**
   * Saves the data to Excel.
   *
   * @param exportData - An optional parameter. Can be the data that will be exported or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}).
   */
  save(exportData) {
    this.toDataURL(exportData).then(this.saveFile);
  }
  /**
   * Based on the specified columns and data, returns
   * [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %})
   * ([see example]({% slug customrowsandcells_excelexport %})).
   *
   * @param exportData - The optional data to be exported.
   * @returns {WorkbookOptions} - The workbook options.
   */
  workbookOptions(exportData) {
    const currentData = this.getExportData(exportData);
    const options = workbookOptions({
      columns: this.columns,
      data: currentData.data,
      group: currentData.group,
      filterable: this.filterable,
      creator: this.creator,
      date: this.date,
      rtl: this.localization.rtl,
      paddingCellOptions: this.paddingCellOptions,
      headerPaddingCellOptions: this.headerPaddingCellOptions,
      collapsible: this.collapsible
    });
    return options;
  }
  /**
   * Returns a promise which will be resolved with the file data URI
   * ([see example]({% slug filesaving_excelexport %})).
   *
   * @param exportData - The optional data or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}) that will be used to generate the data URI.
   * @returns {Promise<string>} - The promise that will be resolved by the file data URI.
   */
  toDataURL(exportData) {
    const options = isWorkbookOptions(exportData) ? exportData : this.workbookOptions(exportData);
    return this.zone.runOutsideAngular(() => toDataURL(options));
  }
  getExportData(exportData) {
    let result;
    if (exportData) {
      if (Array.isArray(exportData)) {
        result = {
          data: exportData
        };
      } else {
        result = exportData;
      }
    } else {
      result = {
        data: this.data,
        group: this.group
      };
    }
    return result;
  }
  saveFile(dataURL) {
    saveAs(dataURL, this.fileName, {
      forceProxy: this.forceProxy,
      proxyURL: this.proxyURL
    });
  }
  static ɵfac = function ExcelExportComponent_Factory(t) {
    return new (t || _ExcelExportComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ExcelExportComponent,
    selectors: [["kendo-excelexport"]],
    contentQueries: function ExcelExportComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnBase, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      }
    },
    inputs: {
      fileName: "fileName",
      filterable: "filterable",
      collapsible: "collapsible",
      creator: "creator",
      date: "date",
      forceProxy: "forceProxy",
      proxyURL: "proxyURL",
      data: "data",
      group: "group",
      paddingCellOptions: "paddingCellOptions",
      headerPaddingCellOptions: "headerPaddingCellOptions"
    },
    exportAs: ["kendoExcelExport"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.excelexport"
    }]), ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ExcelExportComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelExportComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoExcelExport",
      selector: "kendo-excelexport",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.excelexport"
      }],
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    fileName: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    collapsible: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    paddingCellOptions: [{
      type: Input
    }],
    headerPaddingCellOptions: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase, {
        descendants: true
      }]
    }]
  });
})();
var FooterTemplateDirective2 = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(t) {
    return new (t || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoExcelExportFooterTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupHeaderTemplateDirective = class _GroupHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupHeaderTemplateDirective_Factory(t) {
    return new (t || _GroupHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupHeaderTemplateDirective,
    selectors: [["", "kendoExcelExportGroupHeaderTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportGroupHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupHeaderColumnTemplateDirective = class _GroupHeaderColumnTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) {
    return new (t || _GroupHeaderColumnTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupHeaderColumnTemplateDirective,
    selectors: [["", "kendoExcelExportGroupHeaderColumnTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderColumnTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportGroupHeaderColumnTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupFooterTemplateDirective = class _GroupFooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupFooterTemplateDirective_Factory(t) {
    return new (t || _GroupFooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupFooterTemplateDirective,
    selectors: [["", "kendoExcelExportGroupFooterTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupFooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportGroupFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ColumnComponent = class _ColumnComponent extends ColumnBase {
  /**
   * The field to which the column is bound.
   */
  field;
  /**
   * The options of the column data cells
   * ([see example]({% slug cells_excelexport %}#toc-data-cells)).
   */
  cellOptions;
  /**
   * The options of the column group header cells
   * ([see example]({% slug cells_excelexport %}#toc-header-cells)).
   */
  groupHeaderCellOptions;
  /**
   * The options of the column group footer cells
   * ([see example]({% slug cells_excelexport %}#toc-group-footer-cells)).
   */
  groupFooterCellOptions;
  /**
   * The options of the column footer cell
   * ([see example]({% slug cells_excelexport %}#toc-footer-cells)).
   */
  footerCellOptions;
  /**
   * @hidden
   */
  groupHeaderTemplate;
  /**
   * @hidden
   */
  groupHeaderColumnTemplate;
  /**
   * @hidden
   */
  groupFooterTemplate;
  /**
   * @hidden
   */
  footerTemplate;
  constructor(parent) {
    super(parent);
  }
  static ɵfac = function ColumnComponent_Factory(t) {
    return new (t || _ColumnComponent)(ɵɵdirectiveInject(ColumnBase, 13));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnComponent,
    selectors: [["kendo-excelexport-column"]],
    contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      }
    },
    inputs: {
      field: "field",
      cellOptions: "cellOptions",
      groupHeaderCellOptions: "groupHeaderCellOptions",
      groupFooterCellOptions: "groupFooterCellOptions",
      footerCellOptions: "footerCellOptions"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase,
      useExisting: forwardRef(() => _ColumnComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase,
        useExisting: forwardRef(() => ColumnComponent)
      }],
      selector: "kendo-excelexport-column",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnBase,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }];
  }, {
    field: [{
      type: Input
    }],
    cellOptions: [{
      type: Input
    }],
    groupHeaderCellOptions: [{
      type: Input
    }],
    groupFooterCellOptions: [{
      type: Input
    }],
    footerCellOptions: [{
      type: Input
    }],
    groupHeaderTemplate: [{
      type: ContentChild,
      args: [GroupHeaderTemplateDirective, {
        static: false
      }]
    }],
    groupHeaderColumnTemplate: [{
      type: ContentChild,
      args: [GroupHeaderColumnTemplateDirective, {
        static: false
      }]
    }],
    groupFooterTemplate: [{
      type: ContentChild,
      args: [GroupFooterTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective2, {
        static: false
      }]
    }]
  });
})();
var ColumnGroupComponent = class _ColumnGroupComponent extends ColumnBase {
  parent;
  constructor(parent) {
    super(parent);
    this.parent = parent;
  }
  static ɵfac = function ColumnGroupComponent_Factory(t) {
    return new (t || _ColumnGroupComponent)(ɵɵdirectiveInject(ColumnBase, 13));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnGroupComponent,
    selectors: [["kendo-excelexport-column-group"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase,
      useExisting: forwardRef(() => _ColumnGroupComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ColumnGroupComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnGroupComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase,
        useExisting: forwardRef(() => ColumnGroupComponent)
      }],
      selector: "kendo-excelexport-column-group",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnBase,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }];
  }, null);
})();
var KENDO_EXCELEXPORT = [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective2, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective];
var ExcelExportModule = class _ExcelExportModule {
  static ɵfac = function ExcelExportModule_Factory(t) {
    return new (t || _ExcelExportModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ExcelExportModule,
    imports: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective2, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective],
    exports: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective2, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelExportModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_EXCELEXPORT],
      exports: [...KENDO_EXCELEXPORT]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-pdf-export/fesm2022/progress-kendo-angular-pdf-export.mjs
var _c03 = ["*"];
var packageMetadata4 = {
  name: "@progress/kendo-angular-pdf-export",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1749540166,
  version: "19.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var PDFExportTemplateDirective = class _PDFExportTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PDFExportTemplateDirective_Factory(t) {
    return new (t || _PDFExportTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PDFExportTemplateDirective,
    selectors: [["", "kendoPDFTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPDFTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FIELDS = ["bottom", "left", "right", "top"];
var PDFExportMarginComponent = class _PDFExportMarginComponent {
  /**
   * The bottom margin. The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"` (default).
   * Numbers are considered to be points (`"pt"`).
   */
  left;
  /**
   * The top margin. The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"` (default).
   * Numbers are considered to be points (`"pt"`).
   */
  top;
  /**
   * The right margin. The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"` (default).
   * Numbers are considered to be points (`"pt"`).
   */
  right;
  /**
   * The bottom margin. The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"` (default).
   * Numbers are considered to be points (`"pt"`).
   */
  bottom;
  /**
   * @hidden
   */
  get options() {
    const options = {};
    for (let idx2 = 0; idx2 < FIELDS.length; idx2++) {
      const field = FIELDS[idx2];
      const value = this[field];
      if (typeof value !== "undefined") {
        options[field] = value;
      }
    }
    return options;
  }
  static ɵfac = function PDFExportMarginComponent_Factory(t) {
    return new (t || _PDFExportMarginComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFExportMarginComponent,
    selectors: [["kendo-pdf-export-margin"]],
    inputs: {
      left: "left",
      top: "top",
      right: "right",
      bottom: "bottom"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function PDFExportMarginComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportMarginComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pdf-export-margin",
      template: ``,
      standalone: true
    }]
  }], null, {
    left: [{
      type: Input
    }],
    top: [{
      type: Input
    }],
    right: [{
      type: Input
    }],
    bottom: [{
      type: Input
    }]
  });
})();
var compileTemplate2 = (templateRef) => {
  const context = {};
  let embeddedView = templateRef.createEmbeddedView(context);
  const result = (data) => {
    Object.assign(context, data);
    embeddedView.detectChanges();
    const templateWrap = document.createElement("span");
    embeddedView.rootNodes.forEach((rootNode) => {
      templateWrap.appendChild(rootNode.cloneNode(true));
    });
    return templateWrap;
  };
  result.destroy = () => {
    embeddedView.destroy();
    embeddedView = null;
  };
  return result;
};
var PDFExportComponent = class _PDFExportComponent {
  element;
  /**
   * Specifies if the Print dialog should be opened immediately after loading the document ([see example](slug:autoprint_pdfexport)).
   * Requires `@progress/kendo-drawing` v1.9.0 or later.
   * @default false
   */
  autoPrint;
  /**
   * The author (metadata) of the PDF document.
   */
  author;
  /**
   * A flag that indicates whether to produce actual hyperlinks in the exported PDF file ([see example](slug:hyperlinks_pdfexport)).
   * It is also possible to set a CSS selector. All matching links will be ignored.
   */
  avoidLinks;
  /**
   * An optional CSS selector that specifies the elements which cause the page breaks
   * ([see example]({% slug multipagecontent_pdfexport %}#toc-manual-page-breaking)).
   */
  forcePageBreak;
  /**
   * An optional CSS selector that specifies the elements which should not be split across the pages
   * ([see example]({% slug multipagecontent_pdfexport %}#toc-preventing-page-breaking-in-elements)).
   */
  keepTogether;
  /**
   * The creator of the PDF document.
   * @default "Kendo UI PDF Generator"
   */
  creator = "Kendo UI PDF Generator";
  /**
   * The date when the PDF document is created. Defaults to `new Date()`.
   */
  date;
  /**
   * The forced resolution of the images in the exported PDF document
   * ([see example]({% slug embeddedimages_pdfexport %})).
   * By default, the images are exported at their full resolution.
   */
  imageResolution;
  /**
   * Specifies the name of the exported PDF file.
   * @default "export.pdf"
   */
  fileName = "export.pdf";
  /**
   * If set to `true`, the content is forwarded to `proxyURL` even if the
   * browser supports local saving of files.
   */
  forceProxy;
  /**
   * The keywords (metadata) of the PDF document.
   */
  keywords;
  /**
   * A flag that indicates if the page will be in a landscape orientation.
   * By default, the page is in a portrait orientation.
   *
   * @default false
   */
  landscape;
  /**
   * Specifies the margins of the page. Numbers are treated as points (`"pt"`).
   *
   */
  margin;
  /**
   * Specifies the paper size of the PDF document ([see example]({% slug multipagecontent_pdfexport %}#toc-automatic-page-breaking)).
   * Defaults to `"auto"` which means that the paper size is determined by the content.
   * The size of the content in pixels matches the size of the output in points (1 pixel = 1/72 inch).
   * If `paperSize` is set, the content is split across multiple pages. This enables the `repeatHeaders` and
   * `scale` options, and allows you to specify a template.
   *
   * The paper size can be a `PaperSize`, an array of two numbers which specify the width and height in points (1 pt = 1/72 in), or an
   * array of two strings which specify the width and height in units. The supported units are `"mm"`, `"cm"`, `"in"`, and `"pt"`.
   * @default 'auto'
   */
  paperSize;
  /**
   * Specifies if the `<thead>` elements of the tables will be repeated on each page
   * ([see example]({% slug recurrenttableheaders_pdfexport %})).
   */
  repeatHeaders;
  /**
   * A scale factor ([see example]({% slug scalingofcontent_pdfexport %})).
   * The text size on the screen might be too big for printing.
   * To scale down the output in PDF, use this option.
   *
   * @default 1
   */
  scale;
  /**
   * A key/value dictionary of form values which will be sent to the proxy.
   * Can be used to submit Anti-Forgery tokens and other metadata.
   */
  proxyData;
  /**
   * The URL of the server-side proxy which streams the file to the end user. You need to use a proxy if
   * the browser is not capable of saving files locally.
   * It is your responsibility to implement the server-side proxy. The proxy returns the decoded file with
   * the `"Content-Disposition"` header set to `attachment; filename="<fileName.pdf>"`.
   *
   * In the request body, the proxy receives a POST request with the specific parameters.
   * [See example](slug:server_proxy#toc-implementations).
   */
  proxyURL;
  /**
   * A name or keyword which indicates where to display the document that is returned from the proxy.
   * To display the document in a new window or iframe,
   * the proxy has to have the `"Content-Disposition"` header set to `inline; filename="<fileName.pdf>"`.
   * @default "_self"
   */
  proxyTarget;
  /**
   * The producer (metadata) of the PDF document.
   */
  producer;
  /**
   * The subject (metadata) of the PDF document.
   */
  subject;
  /**
   * The title (metadata) of the PDF document.
   */
  title;
  /**
   * @hidden
   */
  pageTemplateDirective;
  /**
   * @hidden
   */
  marginComponent;
  get drawMargin() {
    const marginComponent = this.marginComponent;
    let margin = this.margin;
    if (marginComponent) {
      margin = Object.assign(margin || {}, marginComponent.options);
    }
    return margin;
  }
  pageTemplate;
  constructor(element) {
    this.element = element;
    validatePackage(packageMetadata4);
  }
  /**
   * Saves the content as a PDF file with the specified name.
   * @param fileName - The name of the exported file.
   */
  saveAs(fileName = this.fileName) {
    this.save(this.element.nativeElement, fileName);
  }
  /**
   * Exports the content as a `Group` for further processing.
   *
   * @return The root group of the exported scene.
   */
  export() {
    return this.exportElement(this.element.nativeElement);
  }
  save(element, fileName) {
    this.exportElement(element).then((group) => this.exportGroup(group, this.pdfOptions())).then((dataUri) => this.saveDataUri(dataUri, fileName, this.saveOptions()));
  }
  exportElement(element) {
    const promise = this.drawElement(element, this.drawOptions());
    const cleanup = this.cleanup.bind(this);
    promise.then(cleanup, cleanup);
    return promise;
  }
  cleanup() {
    if (this.pageTemplate) {
      this.pageTemplate.destroy();
      delete this.pageTemplate;
    }
  }
  drawOptions() {
    if (this.pageTemplateDirective) {
      this.pageTemplate = compileTemplate2(this.pageTemplateDirective.templateRef);
    }
    return {
      avoidLinks: this.avoidLinks,
      forcePageBreak: this.forcePageBreak,
      keepTogether: this.keepTogether,
      margin: this.drawMargin,
      paperSize: this.paperSize,
      landscape: this.landscape,
      repeatHeaders: this.repeatHeaders,
      scale: this.scale,
      template: this.pageTemplate
    };
  }
  pdfOptions() {
    return {
      autoPrint: this.autoPrint,
      author: this.author,
      creator: this.creator,
      date: this.date,
      imgDPI: this.imageResolution,
      keywords: this.keywords,
      landscape: this.landscape,
      margin: this.drawMargin,
      multiPage: true,
      paperSize: this.paperSize,
      producer: this.producer,
      subject: this.subject,
      title: this.title
    };
  }
  saveOptions() {
    return {
      forceProxy: this.forceProxy,
      proxyData: this.proxyData,
      proxyTarget: this.proxyTarget,
      proxyURL: this.proxyURL
    };
  }
  drawElement(element, options) {
    return drawDOM(element, options);
  }
  exportGroup(group, options) {
    return exportPDF(group, options);
  }
  saveDataUri(dataUri, fileName, options) {
    saveAs(dataUri, fileName, options);
  }
  static ɵfac = function PDFExportComponent_Factory(t) {
    return new (t || _PDFExportComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFExportComponent,
    selectors: [["kendo-pdf-export"]],
    contentQueries: function PDFExportComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PDFExportTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PDFExportMarginComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
      }
    },
    inputs: {
      autoPrint: "autoPrint",
      author: "author",
      avoidLinks: "avoidLinks",
      forcePageBreak: "forcePageBreak",
      keepTogether: "keepTogether",
      creator: "creator",
      date: "date",
      imageResolution: "imageResolution",
      fileName: "fileName",
      forceProxy: "forceProxy",
      keywords: "keywords",
      landscape: "landscape",
      margin: "margin",
      paperSize: "paperSize",
      repeatHeaders: "repeatHeaders",
      scale: "scale",
      proxyData: "proxyData",
      proxyURL: "proxyURL",
      proxyTarget: "proxyTarget",
      producer: "producer",
      subject: "subject",
      title: "title"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    ngContentSelectors: _c03,
    decls: 2,
    vars: 0,
    template: function PDFExportComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div");
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pdf-export",
      template: `<div><ng-content></ng-content></div>`,
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    autoPrint: [{
      type: Input
    }],
    author: [{
      type: Input
    }],
    avoidLinks: [{
      type: Input
    }],
    forcePageBreak: [{
      type: Input
    }],
    keepTogether: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    imageResolution: [{
      type: Input
    }],
    fileName: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    keywords: [{
      type: Input
    }],
    landscape: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    paperSize: [{
      type: Input
    }],
    repeatHeaders: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    proxyData: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    proxyTarget: [{
      type: Input
    }],
    producer: [{
      type: Input
    }],
    subject: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    pageTemplateDirective: [{
      type: ContentChild,
      args: [PDFExportTemplateDirective, {
        static: false
      }]
    }],
    marginComponent: [{
      type: ContentChild,
      args: [PDFExportMarginComponent, {
        static: false
      }]
    }]
  });
})();
var KENDO_PDFEXPORT = [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective];
var PDFExportModule = class _PDFExportModule {
  static ɵfac = function PDFExportModule_Factory(t) {
    return new (t || _PDFExportModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PDFExportModule,
    imports: [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective],
    exports: [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_PDFEXPORT],
      exports: [...KENDO_PDFEXPORT]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-grid/fesm2022/progress-kendo-angular-grid.mjs
var _c04 = ["kendoGridColGroup", ""];
function ColGroupComponent_col_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    ɵɵclassProp("k-group-col", true);
  }
}
function ColGroupComponent_col_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    ɵɵclassProp("k-hierarchy-col", true);
  }
}
function ColGroupComponent_col_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", column_r1.width, "px");
    ɵɵclassProp("k-sorted", ctx_r1.isSorted(ctx_r1.getColumnComponent(column_r1)));
  }
}
var _c110 = ["kendoGridLoading", ""];
function LoadingComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 1);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 2)(4, "div", 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.loadingText);
  }
}
function LoadingComponent_1_ng_template_0_Template(rf, ctx) {
}
function LoadingComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, LoadingComponent_1_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.loadingTemplate == null ? null : ctx_r0.loadingTemplate.templateRef);
  }
}
var _c210 = ["kendoGridGroupHeader", ""];
var _c39 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({
  templateRef: a0,
  group: a1,
  aggregates: a2,
  value: a3,
  field: a4,
  index: a5,
  expanded: a6,
  $implicit: a7
});
var _c43 = (a0, a1, a2, a3, a4, a5) => ({
  group: a0,
  aggregates: a1,
  value: a2,
  field: a3,
  index: a4,
  $implicit: a5
});
function GroupHeaderComponent_ng_container_0_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
}
function GroupHeaderComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, GroupHeaderComponent_ng_container_0_td_1_Template, 1, 0, "td", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.prefixGroupCell(ctx_r0.item));
  }
}
function GroupHeaderComponent_td_1_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "valueOf");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate2(" ", ctx_r0.groupTitle(ctx_r0.item), ": ", ɵɵpipeBind3(2, 2, ctx_r0.item.data, "value", ctx_r0.formatForGroup(ctx_r0.item)), " ");
  }
}
function GroupHeaderComponent_td_1_ng_container_2_ng_template_4_Template(rf, ctx) {
}
function GroupHeaderComponent_td_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "a", 6);
    ɵɵlistener("click", function GroupHeaderComponent_td_1_ng_container_2_Template_a_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.toggleGroup(ctx_r0.item));
    });
    ɵɵelement(2, "kendo-icon-wrapper", 7);
    ɵɵelementEnd();
    ɵɵtemplate(3, GroupHeaderComponent_td_1_ng_container_2_ng_container_3_Template, 3, 6, "ng-container", 0)(4, GroupHeaderComponent_td_1_ng_container_2_ng_template_4_Template, 0, 0, "ng-template", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.groupButtonTitle)("aria-label", ctx_r0.groupButtonTitle);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.arrowIcon)("svgIcon", ctx_r0.arrowSVGIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.groupHeaderTemplate(ctx_r0.item));
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction8(6, _c39, ctx_r0.groupHeaderTemplate(ctx_r0.item), ctx_r0.item.data, ctx_r0.item.data == null ? null : ctx_r0.item.data.aggregates, ctx_r0.item.data == null ? null : ctx_r0.item.data.value, ctx_r0.item.data == null ? null : ctx_r0.item.data.field, ctx_r0.item.index, ctx_r0.isExpanded, ctx_r0.item.data));
  }
}
function GroupHeaderComponent_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 4)(1, "p", 5);
    ɵɵtemplate(2, GroupHeaderComponent_td_1_ng_container_2_Template, 5, 15, "ng-container", 0);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", 0)("logicalSlaveCell", ctx_r0.skipGroupDecoration)("groupItem", ctx_r0.item)("colSpan", ctx_r0.logicalColSpan());
    ɵɵattribute("colspan", ctx_r0.groupSpan(ctx_r0.item))("role", ctx_r0.ariaRole())("aria-expanded", ctx_r0.isExpanded);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
  }
}
function GroupHeaderComponent_ng_container_2_td_1_1_ng_template_0_Template(rf, ctx) {
}
function GroupHeaderComponent_ng_container_2_td_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, GroupHeaderComponent_ng_container_2_td_1_1_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    const column_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", column_r3.groupHeaderColumnTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction6(2, _c43, ctx_r0.item.data, ctx_r0.item.data == null ? null : ctx_r0.item.data.aggregates, ctx_r0.item.data == null ? null : ctx_r0.item.data.value, ctx_r0.item.data == null ? null : ctx_r0.item.data.field, ctx_r0.item.index, ctx_r0.item.data));
  }
}
function GroupHeaderComponent_ng_container_2_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 10);
    ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_1_Template, 1, 9, null, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", index_r4 + 1)("logicalSlaveCell", false)("groupItem", ctx_r0.item)("colSpan", 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r3.groupHeaderColumnTemplateRef);
  }
}
function GroupHeaderComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_Template, 2, 6, "td", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groupHeaderColumns);
  }
}
var _c53 = ["defaultTemplate"];
var _c62 = () => ({
  lastTarget: true
});
var _c72 = (a0, a1, a2) => ({
  field: a0,
  type: "groupIndicator",
  hint: a1,
  target: a2
});
var _c82 = (a0, a1) => ({
  keydown: a0,
  click: a1
});
function GroupPanelComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("context", ɵɵpureFunction0(2, _c62));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.text, " ");
  }
}
function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chip", 7, 1);
    ɵɵlistener("contentClick", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_contentClick_0_listener() {
      const group_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.directionChange(group_r3));
    })("remove", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_remove_0_listener() {
      const group_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.remove(group_r3));
    })("menuToggle", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_menuToggle_0_listener() {
      const ctx_r3 = ɵɵrestoreView(_r2);
      const group_r3 = ctx_r3.$implicit;
      const first_r5 = ctx_r3.first;
      const last_r6 = ctx_r3.last;
      const chip_r7 = ɵɵreference(1);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.toggleMenu(chip_r7, first_r5, last_r6, group_r3.field));
    })("keydown.alt.arrowdown", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_keydown_alt_arrowdown_0_listener($event) {
      const ctx_r7 = ɵɵrestoreView(_r2);
      const group_r3 = ctx_r7.$implicit;
      const first_r5 = ctx_r7.first;
      const last_r6 = ctx_r7.last;
      const chip_r7 = ɵɵreference(1);
      const ctx_r0 = ɵɵnextContext(2);
      $event.preventDefault();
      return ɵɵresetView(ctx_r0.toggleMenu(chip_r7, first_r5, last_r6, group_r3.field));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const group_r3 = ctx.$implicit;
    const index_r9 = ctx.index;
    const chip_r7 = ɵɵreference(1);
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("title", ctx_r0.getTitle(group_r3))("enableDrag", true)("context", ɵɵpureFunction3(11, _c72, group_r3.field, ctx_r0.groupTitles[index_r9], chip_r7))("label", ctx_r0.groupTitles[index_r9])("removable", true)("hasMenu", true)("icon", ctx_r0.getDirectionIcon(group_r3))("svgIcon", ctx_r0.getDirectionSvgIcon(group_r3));
    ɵɵattribute("aria-haspopup", "menu")("aria-expanded", ctx_r0.isChipMenuOpen)("aria-controls", ctx_r0.gridId);
  }
}
function GroupPanelComponent_kendo_chiplist_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-chiplist", 5);
    ɵɵtemplate(1, GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template, 2, 15, "kendo-chip", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r0.navigable);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function GroupPanelComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1, " ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("context", ɵɵpureFunction0(1, _c62));
  }
}
function GroupPanelComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 8)(1, "li", 9)(2, "span", 10);
    ɵɵelement(3, "kendo-icon-wrapper", 11);
    ɵɵelementStart(4, "span", 12);
    ɵɵtext(5);
    ɵɵelementEnd()()();
    ɵɵelementStart(6, "li", 9)(7, "span", 10);
    ɵɵelement(8, "kendo-icon-wrapper", 11);
    ɵɵelementStart(9, "span", 12);
    ɵɵtext(10);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(13, _c82, ctx_r0.handleKeyDown, ctx_r0.handleClick));
    ɵɵadvance();
    ɵɵattribute("aria-disabled", ctx_r0.first);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ctx_r0.first);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.rtl ? "arrow-right" : "arrow-left")("svgIcon", ctx_r0.rtl ? ctx_r0.arrowRightIcon : ctx_r0.arrowLeftIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.messageFor("groupChipMenuPrevious"));
    ɵɵadvance();
    ɵɵattribute("aria-disabled", ctx_r0.last);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ctx_r0.last);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.rtl ? "arrow-left" : "arrow-right")("svgIcon", ctx_r0.rtl ? ctx_r0.arrowLeftIcon : ctx_r0.arrowRightIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.messageFor("groupChipMenuNext"));
  }
}
var _c92 = ["dropdown"];
var _c102 = () => ({
  width: "auto"
});
function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3, 0);
    ɵɵlistener("valueChange", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChange($event));
    })("keydown", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.dropdownKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("data", ctx_r1.operators)("value", ctx_r1.value)("svgIcon", ctx_r1.filterSVGIcon)("valuePrimitive", true)("popupSettings", ɵɵpureFunction0(7, _c102))("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.column && ctx_r1.columnLabel);
  }
}
function FilterCellOperatorsComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function FilterCellOperatorsComponent_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearClick());
    })("keydown", function FilterCellOperatorsComponent_button_1_Template_button_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.filterClearIcon)("title", ctx_r1.clearText)("size", ctx_r1.size);
  }
}
var _c112 = ["*"];
function StringFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function StringFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("adaptiveTitle", ctx_r1.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.adaptiveMode)("size", (ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-string-filter-menu-input", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("placeholder", ctx_r1.extraPlaceholder)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function NumericFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function NumericFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("adaptiveTitle", ctx_r1.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.adaptiveMode)("size", (ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("format", ctx_r1.format)("decimals", ctx_r1.decimals)("spinners", ctx_r1.spinners)("min", ctx_r1.min)("max", ctx_r1.max)("step", ctx_r1.step)("menuTabbingService", ctx_r1.menuTabbingService)("placeholder", ctx_r1.extraPlaceholder);
  }
}
function DateFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function DateFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("adaptiveTitle", ctx_r1.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.adaptiveMode)("size", (ctx_r1.ctx.grid == null ? null : ctx_r1.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-date-filter-menu-input", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("activeView", ctx_r1.activeView)("bottomView", ctx_r1.bottomView)("topView", ctx_r1.topView)("format", ctx_r1.format)("formatPlaceholder", ctx_r1.formatPlaceholder)("placeholder", ctx_r1.placeholder)("min", ctx_r1.min)("max", ctx_r1.max)("weekNumber", ctx_r1.weekNumber)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function BooleanFilterMenuComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li")(1, "kendo-radiobutton", 3, 0);
    ɵɵlistener("change", function BooleanFilterMenuComponent_li_1_Template_kendo_radiobutton_change_1_listener() {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const input_r3 = ɵɵreference(2);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onChange(item_r2.value, input_r3));
    })("keydown.shift.tab", function BooleanFilterMenuComponent_li_1_Template_kendo_radiobutton_keydown_shift_tab_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onShiftTab($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 4);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const input_r3 = ɵɵreference(2);
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("columnLabel", ctx_r3.columnLabel)("size", (ctx_r3.ctx.grid == null ? null : ctx_r3.ctx.grid.isActionSheetExpanded) ? "large" : null)("name", ctx_r3.idPrefix)("checked", ctx_r3.isSelected(item_r2.value));
    ɵɵattribute("id", ctx_r3.radioId(item_r2.value));
    ɵɵadvance(2);
    ɵɵattribute("for", input_r3.focusableId);
    ɵɵadvance();
    ɵɵtextInterpolate(item_r2.text);
  }
}
var _c123 = ["resetButton"];
var _c132 = ["filterButton"];
function FilterMenuContainerComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementContainer(1, 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("filterService", ctx_r0.childService)("column", ctx_r0.column)("filter", ctx_r0.childFilter)("menuTabbingService", ctx_r0.menuTabbingService);
  }
}
function FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template(rf, ctx) {
}
function FilterMenuContainerComponent_ng_container_4_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.filterMenuTemplateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function FilterMenuContainerComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FilterMenuContainerComponent_ng_container_4_1_Template, 1, 2, null, 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.filterMenuTemplateRef);
  }
}
function FilterMenuContainerComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10)(1, "button", 11, 0);
    ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_div_5_Template_button_keydown_tab_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onTab($event, "filter"));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 12, 1);
    ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_div_5_Template_button_keydown_tab_4_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onTab($event, "reset"));
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.actionsClass);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r0.disabled);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.filterText);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.clearText);
  }
}
var _c142 = ["anchor"];
var _c152 = ["template"];
function FilterMenuComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 4);
    ɵɵlistener("close", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close());
    })("keydown.escape", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close());
    })("keydown.enter", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r4.column)("filter", ctx_r4.filter);
  }
}
var _c162 = ["kendoGridFilterCell", ""];
function FilterCellComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementContainer(1, 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("column", ctx_r0.column)("filter", ctx_r0.filter);
  }
}
function FilterCellComponent_ng_container_0_ng_container_3_1_ng_template_0_Template(rf, ctx) {
}
function FilterCellComponent_ng_container_0_ng_container_3_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FilterCellComponent_ng_container_0_ng_container_3_1_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.filterCellTemplateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function FilterCellComponent_ng_container_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FilterCellComponent_ng_container_0_ng_container_3_1_Template, 1, 2, null, 0);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.filterCellTemplateRef);
  }
}
function FilterCellComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0)(1, 1);
    ɵɵtemplate(2, FilterCellComponent_ng_container_0_ng_container_2_Template, 2, 2, "ng-container", 2)(3, FilterCellComponent_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 2);
    ɵɵelementContainerEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngSwitch", ctx_r0.hasTemplate);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", false);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", true);
  }
}
var _c172 = ["kendoGridFilterRow", ""];
function FilterRowComponent_td_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
}
function FilterRowComponent_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 4);
  }
}
function FilterRowComponent_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 5);
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const columnIndex_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-grid-header-sticky", column_r1.sticky);
    ɵɵproperty("ngStyle", ctx_r2.addStickyStyles(column_r1))("ngClass", column_r1.filterClass)("column", column_r1)("filter", ctx_r2.filter)("logicalRowIndex", ctx_r2.logicalRowIndex)("logicalColIndex", ctx_r2.getLogicalColIndex(columnIndex_r2));
    ɵɵattribute("aria-label", ctx_r2.filterLabel(column_r1));
  }
}
var _c182 = ["applyButton"];
var _c192 = (a0) => ({
  "data-index": a0
});
function ColumnListComponent_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 5);
    ɵɵelement(1, "kendo-checkbox", 6);
    ɵɵelementStart(2, "span", 7);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const index_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("kendoColumnMenuChooserItemChecked", !column_r1.hidden);
    ɵɵadvance();
    ɵɵproperty("inputAttributes", ɵɵpureFunction1(6, _c192, index_r2.toString()))("tabindex", -1)("checkedState", !column_r1.hidden)("disabled", ctx_r2.isDisabled(column_r1));
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r1.displayTitle);
  }
}
function ColumnListComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8)(1, "button", 9, 0);
    ɵɵlistener("click", function ColumnListComponent_div_2_Template_button_click_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.applyChanges());
    })("keydown.enter", function ColumnListComponent_div_2_Template_button_keydown_enter_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r2.applyChanges());
    })("keydown.space", function ColumnListComponent_div_2_Template_button_keydown_space_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r2.applyChanges());
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 10, 1);
    ɵɵlistener("keydown.tab", function ColumnListComponent_div_2_Template_button_keydown_tab_4_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onTab($event));
    })("click", function ColumnListComponent_div_2_Template_button_click_4_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.cancelChanges());
    })("keydown.enter", function ColumnListComponent_div_2_Template_button_keydown_enter_4_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r2.cancelChanges());
    })("keydown.space", function ColumnListComponent_div_2_Template_button_keydown_space_4_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation();
      return ɵɵresetView(ctx_r2.cancelChanges());
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r2.actionsClass);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r2.checkIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.applyText);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r2.arrowRotateCcwIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.resetText);
  }
}
var _c202 = ["columnList"];
function ColumnChooserComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnlist", 4, 2);
    ɵɵlistener("apply", function ColumnChooserComponent_ng_template_2_Template_kendo_grid_columnlist_apply_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onApply($event));
    })("columnChange", function ColumnChooserComponent_ng_template_2_Template_kendo_grid_columnlist_columnChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r4.columns)("ariaLabel", ctx_r4.messageFor("columns"))("isLast", true)("applyText", ctx_r4.messageFor("columnsApply"))("resetText", ctx_r4.messageFor("columnsReset"))("autoSync", ctx_r4.autoSync)("allowHideAll", ctx_r4.allowHideAll);
  }
}
function ColumnMenuItemComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelementContainer(1, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const content_r1 = ɵɵreference(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", content_r1);
  }
}
function ColumnMenuItemComponent_ng_template_1_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 11);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("name", ctx_r2.icon)("svgIcon", ctx_r2.svgIcon);
  }
}
function ColumnMenuItemComponent_ng_template_1_span_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.column.field));
  }
}
function ColumnMenuItemComponent_ng_template_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵelement(1, "kendo-icon-wrapper", 11);
    ɵɵtemplate(2, ColumnMenuItemComponent_ng_template_1_span_3_span_2_Template, 2, 1, "span", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r2.sortDescriptor(ctx_r2.column.field).dir === "asc" ? "sort-asc-small" : "sort-desc-small")("svgIcon", ctx_r2.sortDescriptor(ctx_r2.column.field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showSortNumbering(ctx_r2.column));
  }
}
function ColumnMenuItemComponent_ng_template_1_kendo_icon_wrapper_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 15);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r2.filterIcon);
  }
}
function ColumnMenuItemComponent_ng_template_1_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 16);
  }
}
function ColumnMenuItemComponent_ng_template_1_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵelement(1, "kendo-icon-wrapper", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r2.expandedIcon)("svgIcon", ctx_r2.expandedSvgIcon);
  }
}
function ColumnMenuItemComponent_ng_template_1_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵelementContainer(1, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵstyleProp("overflow", "hidden");
    ɵɵproperty("@state", ctx_r2.contentState);
    ɵɵattribute("id", ctx_r2.contentId);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.contentTemplate.templateRef);
  }
}
function ColumnMenuItemComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("click", function ColumnMenuItemComponent_ng_template_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick($event));
    })("keydown.enter", function ColumnMenuItemComponent_ng_template_1_Template_div_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick($event));
    });
    ɵɵtemplate(1, ColumnMenuItemComponent_ng_template_1_kendo_icon_wrapper_1_Template, 1, 2, "kendo-icon-wrapper", 5);
    ɵɵtext(2);
    ɵɵtemplate(3, ColumnMenuItemComponent_ng_template_1_span_3_Template, 3, 3, "span", 6)(4, ColumnMenuItemComponent_ng_template_1_kendo_icon_wrapper_4_Template, 1, 1, "kendo-icon-wrapper", 7)(5, ColumnMenuItemComponent_ng_template_1_span_5_Template, 1, 0, "span", 8)(6, ColumnMenuItemComponent_ng_template_1_span_6_Template, 2, 2, "span", 9);
    ɵɵelementEnd();
    ɵɵtemplate(7, ColumnMenuItemComponent_ng_template_1_div_7_Template, 2, 5, "div", 10);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-selected", ctx_r2.selected)("k-disabled", ctx_r2.disabled)("k-focus", ctx_r2.focused);
    ɵɵattribute("aria-expanded", ctx_r2.expanded)("aria-controls", ctx_r2.expanded ? ctx_r2.contentId : void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.icon || ctx_r2.svgIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.text, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.ctx.grid.isActionSheetExpanded && ctx_r2.adaptiveGridService.viewType === "sortToolbarTool" && ctx_r2.sortDescriptor(ctx_r2.column.field).dir);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.ctx.grid.isActionSheetExpanded && ctx_r2.adaptiveGridService.viewType === "filterToolbarTool" && ctx_r2.hasFilters || ctx_r2.indicatorIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.contentTemplate && ctx_r2.adaptiveGridService.viewType !== "sortToolbarTool");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.contentTemplate && ctx_r2.adaptiveGridService.viewType !== "sortToolbarTool");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.contentTemplate);
  }
}
function ColumnMenuAutoSizeAllColumnsComponent_kendo_grid_columnmenu_item_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 1);
    ɵɵlistener("itemClick", function ColumnMenuAutoSizeAllColumnsComponent_kendo_grid_columnmenu_item_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.autoSizeAllColumns());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r1.ctx.localization.get("autosizeAllColumns"))("svgIcon", ctx_r1.displayInlineFlexIcon);
  }
}
function ColumnMenuAutoSizeColumnComponent_kendo_grid_columnmenu_item_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 1);
    ɵɵlistener("itemClick", function ColumnMenuAutoSizeColumnComponent_kendo_grid_columnmenu_item_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.autoSizeColumn());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r1.ctx.localization.get("autosizeThisColumn"))("svgIcon", ctx_r1.maxWidthIcon);
  }
}
function ColumnMenuChooserComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnlist", 2);
    ɵɵlistener("apply", function ColumnMenuChooserComponent_ng_template_1_Template_kendo_grid_columnlist_apply_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onApply($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("applyText", ctx_r1.ctx.localization.get("columnsApply"))("resetText", ctx_r1.ctx.localization.get("columnsReset"))("ariaLabel", ctx_r1.ctx.localization.get("columns"))("columns", ctx_r1.columns)("autoSync", false)("allowHideAll", false)("actionsClass", ctx_r1.actionsClass)("isLast", ctx_r1.isLast)("isExpanded", ctx_r1.expanded)("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-lock", 3);
    ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template_kendo_grid_columnmenu_lock_keydown_tab_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onTab($event, !ctx_r1.showStick));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-stick", 3);
    ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template_kendo_grid_columnmenu_stick_keydown_tab_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onTab($event, true));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template, 1, 1, "kendo-grid-columnmenu-lock", 2)(1, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template, 1, 1, "kendo-grid-columnmenu-stick", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.showLock);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showStick);
  }
}
function ColumnMenuFilterComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 2);
    ɵɵlistener("keydown.shift.tab", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r1.service.column)("menuTabbingService", ctx_r1.service.menuTabbingService)("filter", ctx_r1.service.filter)("actionsClass", ctx_r1.actionsClass)("isLast", ctx_r1.isLast)("isExpanded", ctx_r1.expanded);
  }
}
var _c212 = ["tabbedInterfaceTemplate"];
var _c223 = (a0) => ({
  "k-active": a0
});
var _c232 = (a0, a1) => ({
  service: a0,
  column: a1
});
function ColumnMenuComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-container", 15);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    })("keydown.enter", function ColumnMenuComponent_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementContainer(1, 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const defaultTemplate_r6 = ɵɵreference(6);
    const tabbedInterfaceTemplate_r7 = ɵɵreference(8);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r4.column.columnMenuTemplateRef || ctx_r4.columnMenuTemplate || (ctx_r4.settings.view === "tabbed" ? tabbedInterfaceTemplate_r7 : defaultTemplate_r6))("ngTemplateOutletContext", ɵɵpureFunction2(2, _c232, ctx_r4.service, ctx_r4.column));
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 23, 4);
  }
  if (rf & 2) {
    const sortItem_r9 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r9)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 23, 5);
  }
  if (rf & 2) {
    const lockItem_r10 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r10)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 23, 6);
  }
  if (rf & 2) {
    const stickItem_r11 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r11)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-position", 24, 7);
  }
  if (rf & 2) {
    const positionItem_r12 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r12)("service", ctx_r4.service)("expanded", ctx_r4.expandedPosition);
  }
}
function ColumnMenuComponent_ng_template_5_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-chooser", 26, 8);
  }
  if (rf & 2) {
    const chooserItem_r13 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", chooserItem_r13)("service", ctx_r4.service)("expanded", ctx_r4.expandedColumns);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_column_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 27, 9);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r14 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeColumnItem_r14)("column", ctx_r4.column);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_all_columns_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 28, 10);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r15 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r15);
  }
}
function ColumnMenuComponent_ng_template_5_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-filter", 26, 11);
  }
  if (rf & 2) {
    const filterItem_r16 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", filterItem_r16)("service", ctx_r4.service)("expanded", ctx_r4.expandedFilter);
  }
}
function ColumnMenuComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-container", 15);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    })("keydown.enter", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r8);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template, 2, 2, "kendo-grid-columnmenu-sort", 17)(2, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template, 2, 2, "kendo-grid-columnmenu-lock", 17)(3, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template, 2, 2, "kendo-grid-columnmenu-stick", 17)(4, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template, 2, 5, "kendo-grid-columnmenu-position", 18)(5, ColumnMenuComponent_ng_template_5_span_5_Template, 1, 2, "span", 19)(6, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_6_Template, 2, 3, "kendo-grid-columnmenu-chooser", 20)(7, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_column_7_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 21)(8, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_all_columns_8_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 22)(9, ColumnMenuComponent_ng_template_5_span_9_Template, 1, 2, "span", 19)(10, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_10_Template, 2, 3, "kendo-grid-columnmenu-filter", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasSort);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasLock && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasStick && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeAllColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasFilter);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 33);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.filterIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuFilterTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 34);
    ɵɵlistener("keydown.shift.tab", function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r18);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r18);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("column", ctx_r4.service.column)("menuTabbingService", ctx_r4.service.menuTabbingService)("filter", ctx_r4.service.filter)("actionsClass", ctx_r4.actionsClass);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_1_Template, 1, 2, "ng-template", 31)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template, 1, 4, "ng-template", 32);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 35);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.slidersIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuGeneralTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_sort_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 23, 4);
  }
  if (rf & 2) {
    const sortItem_r19 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r19)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 23, 5);
  }
  if (rf & 2) {
    const lockItem_r20 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r20)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 23, 6);
  }
  if (rf & 2) {
    const stickItem_r21 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r21)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_position_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-position", 24, 7);
  }
  if (rf & 2) {
    const positionItem_r22 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r22)("service", ctx_r4.service)("expanded", ctx_r4.expandedPosition);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_column_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 27, 9);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r23 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeColumnItem_r23)("column", ctx_r4.column);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 28, 10);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r24 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r24);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_sort_0_Template, 2, 2, "kendo-grid-columnmenu-sort", 17)(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_1_Template, 1, 2, "span", 19)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_lock_2_Template, 2, 2, "kendo-grid-columnmenu-lock", 17)(3, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_stick_3_Template, 2, 2, "kendo-grid-columnmenu-stick", 17)(4, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_4_Template, 1, 2, "span", 19)(5, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_position_5_Template, 2, 5, "kendo-grid-columnmenu-position", 18)(6, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_6_Template, 1, 2, "span", 19)(7, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_column_7_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 21)(8, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_8_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 22);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("ngIf", ctx_r4.hasSort);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasSort && (ctx_r4.hasLock || ctx_r4.hasStick || ctx_r4.hasPosition || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasLock && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasStick && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", (ctx_r4.hasLock || ctx_r4.hasStick) && !ctx_r4.hasPosition && (ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasPosition && (ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeAllColumns);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_1_Template, 1, 2, "ng-template", 31)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_Template, 9, 9, "ng-template", 32);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 36);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.columnsIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuColumnsTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnlist", 37);
    ɵɵlistener("apply", function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template_kendo_grid_columnlist_apply_0_listener($event) {
      ɵɵrestoreView(_r25);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.onApply($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("applyText", ctx_r4.ctx.localization.get("columnsApply"))("resetText", ctx_r4.ctx.localization.get("columnsReset"))("columns", ctx_r4.columns)("autoSync", false)("allowHideAll", false)("actionsClass", ctx_r4.actionsClass)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_1_Template, 1, 2, "ng-template", 31)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template, 1, 7, "ng-template", 32);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-tabstrip", 29, 12);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_7_Template_kendo_tabstrip_keydown_escape_0_listener() {
      ɵɵrestoreView(_r17);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    });
    ɵɵtemplate(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_Template, 3, 0, "kendo-tabstrip-tab", 30)(3, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_Template, 3, 0, "kendo-tabstrip-tab", 30)(4, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_Template, 3, 0, "kendo-tabstrip-tab", 30);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.hasFilter);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.showGeneralTab);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser);
  }
}
var _c242 = ["kendoGridExcelCommand", ""];
function ExcelCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function ExcelCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function ExcelCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c252 = ["kendoGridPDFCommand", ""];
function PDFCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function PDFCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function PDFCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c262 = ["kendoGridHeader", ""];
var _c272 = (a0, a1, a2, a3) => ({
  field: a0,
  type: "column",
  column: a1,
  hint: a2,
  lastColumn: a3
});
var _c282 = (a0, a1, a2, a3) => ({
  templateRef: a0,
  columnIndex: a1,
  column: a2,
  $implicit: a3
});
var _c292 = (a0) => ({
  "aria-label": a0
});
var _c302 = (a0, a1, a2) => ({
  type: "columnGroup",
  column: a0,
  hint: a1,
  lastColumn: a2
});
function HeaderComponent_tr_0_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 7);
  }
}
function HeaderComponent_tr_0_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 8);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_ng_template_3_Template(rf, ctx) {
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-filter-menu", 20);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r2))("filter", ctx_r2.filter)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 21);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate)("sort", ctx_r2.sort)("filter", ctx_r2.filter)("sortable", ctx_r2.sortable)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 14)(2, "span", 15);
    ɵɵtemplate(3, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_ng_template_3_Template, 0, 0, "ng-template", 16)(4, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_ng_container_4_Template, 3, 1, "ng-container", 12);
    ɵɵelementEnd();
    ɵɵtemplate(5, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_5_Template, 1, 3, "kendo-grid-filter-menu", 17)(6, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_6_Template, 1, 8, "kendo-grid-column-menu", 18);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵclassProp("!k-cursor-default", !ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "groupable") && !ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "reorderable"));
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(6, _c282, column_r2.headerTemplateRef, column_r2.leafIndex, column_r2, column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r2.headerTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showColumnMenu(column_r2));
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_ng_template_4_Template(rf, ctx) {
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_kendo_icon_wrapper_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 25);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate1("name", "sort-", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir, "-small");
    ɵɵproperty("svgIcon", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
    ɵɵattribute("aria-label", ctx_r2.sortableLabel);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 26);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.getColumnComponent(column_r2).field));
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-filter-menu", 20);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r2))("filter", ctx_r2.filter)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 21);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate)("sort", ctx_r2.sort)("filter", ctx_r2.filter)("sortable", ctx_r2.sortable)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 14)(2, "span", 22, 0);
    ɵɵlistener("click", function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_Template_span_click_2_listener($event) {
      ɵɵrestoreView(_r4);
      const link_r5 = ɵɵreference(3);
      const column_r2 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onSortClick(ctx_r2.getColumnComponent(column_r2), $event, link_r5));
    });
    ɵɵtemplate(4, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_ng_template_4_Template, 0, 0, "ng-template", 16)(5, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_ng_container_5_Template, 3, 1, "ng-container", 12);
    ɵɵelementStart(6, "span");
    ɵɵtemplate(7, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_kendo_icon_wrapper_7_Template, 1, 4, "kendo-icon-wrapper", 23);
    ɵɵelementEnd();
    ɵɵtemplate(8, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_span_8_Template, 2, 1, "span", 24);
    ɵɵelementEnd();
    ɵɵtemplate(9, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template, 1, 3, "kendo-grid-filter-menu", 17)(10, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template, 1, 8, "kendo-grid-column-menu", 18);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(4);
    ɵɵproperty("templateContext", ɵɵpureFunction4(8, _c282, column_r2.headerTemplateRef, column_r2.leafIndex, column_r2, column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r2.headerTemplateRef);
    ɵɵadvance();
    ɵɵclassProp("k-sort-icon", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showSortNumbering(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showColumnMenu(column_r2));
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "kendo-checkbox", 27);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("inputAttributes", ɵɵpureFunction1(2, _c292, ctx_r2.selectAllCheckboxLabel));
    ɵɵattribute("id", ctx_r2.selectAllCheckboxId());
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 28);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    const column_r2 = ctx_r5.$implicit;
    const last_r7 = ctx_r5.last;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("isLast", last_r7)("column", column_r2)("columns", ctx_r2.columns);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 11);
    ɵɵlistener("keydown", function HeaderComponent_tr_0_ng_container_3_th_1_Template_th_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const column_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onHeaderKeydown(ctx_r2.getColumnComponent(column_r2), $event));
    });
    ɵɵtemplate(1, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_1_Template, 7, 11, "ng-container", 12)(2, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_2_Template, 11, 13, "ng-container", 12)(3, HeaderComponent_tr_0_ng_container_3_th_1_ng_container_3_Template, 2, 4, "ng-container", 12)(4, HeaderComponent_tr_0_ng_container_3_th_1_span_4_Template, 1, 3, "span", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const column_r2 = ctx_r5.$implicit;
    const columnIndex_r8 = ctx_r5.index;
    const last_r7 = ctx_r5.last;
    const levelIndex_r9 = ɵɵnextContext().index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-sorted", ctx_r2.sortState(ctx_r2.getColumnComponent(column_r2)))("k-filterable", ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)) || ctx_r2.showColumnMenu(column_r2))("k-first", ctx_r2.isFirstOnRow(ctx_r2.getColumnComponent(column_r2), columnIndex_r8))("k-grid-header-sticky", column_r2.sticky);
    ɵɵproperty("logicalRowIndex", levelIndex_r9)("logicalColIndex", ctx_r2.logicalColumnIndex(column_r2))("headerLabelText", column_r2.title || ctx_r2.getColumnComponent(column_r2).field)("colSpan", column_r2.colspan)("rowSpan", column_r2.rowspan(ctx_r2.totalColumnLevels))("enableDrag", ctx_r2.shouldActivate(column_r2))("context", ɵɵpureFunction4(27, _c272, ctx_r2.getColumnComponent(column_r2).field, column_r2, column_r2.title || ctx_r2.getColumnComponent(column_r2).field, last_r7 && columnIndex_r8 === 0))("ngClass", column_r2.headerClass)("ngStyle", column_r2.sticky ? ctx_r2.addStickyStyles(column_r2) : column_r2.headerStyle);
    ɵɵattribute("aria-sort", ctx_r2.sortState(ctx_r2.getColumnComponent(column_r2)))("rowspan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colspan", column_r2.colspan)("aria-haspopup", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? "dialog" : void 0)("aria-expanded", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? false : void 0)("aria-keyshortcuts", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? "Alt + ArrowDown" : void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "sortable"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "sortable"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.isCheckboxColumn(column_r2) && !column_r2.headerTemplateRef && column_r2.showSelectAll);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.resizable);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_2_ng_template_3_Template(rf, ctx) {
}
function HeaderComponent_tr_0_ng_container_3_th_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_2_kendo_grid_column_menu_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 31);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 28);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    const column_r2 = ctx_r5.$implicit;
    const last_r7 = ctx_r5.last;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("isLast", last_r7)("column", column_r2)("columns", ctx_r2.columns);
  }
}
function HeaderComponent_tr_0_ng_container_3_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 29)(1, "span", 14)(2, "span", 15);
    ɵɵtemplate(3, HeaderComponent_tr_0_ng_container_3_th_2_ng_template_3_Template, 0, 0, "ng-template", 16)(4, HeaderComponent_tr_0_ng_container_3_th_2_ng_container_4_Template, 3, 1, "ng-container", 12);
    ɵɵelementEnd();
    ɵɵtemplate(5, HeaderComponent_tr_0_ng_container_3_th_2_kendo_grid_column_menu_5_Template, 1, 4, "kendo-grid-column-menu", 30);
    ɵɵelementEnd();
    ɵɵtemplate(6, HeaderComponent_tr_0_ng_container_3_th_2_span_6_Template, 1, 3, "span", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const column_r2 = ctx_r5.$implicit;
    const columnIndex_r8 = ctx_r5.index;
    const last_r7 = ctx_r5.last;
    const levelIndex_r9 = ɵɵnextContext().index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-first", ctx_r2.isFirstOnRow(ctx_r2.getColumnComponent(column_r2), columnIndex_r8))("k-filterable", ctx_r2.showColumnMenu(column_r2))("k-grid-content-sticky", column_r2.sticky);
    ɵɵproperty("logicalRowIndex", levelIndex_r9)("logicalColIndex", ctx_r2.logicalColumnIndex(column_r2))("rowSpan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colSpan", column_r2.colspan)("headerLabelText", column_r2.title || ctx_r2.getColumnComponent(column_r2).field)("enableDrag", ctx_r2.shouldActivate(column_r2))("context", ɵɵpureFunction3(26, _c302, column_r2, column_r2.title, last_r7 && columnIndex_r8 === 0))("ngClass", column_r2.headerClass)("ngStyle", column_r2.headerStyle);
    ɵɵattribute("aria-haspopup", ctx_r2.isNavigable && ctx_r2.showColumnMenu(column_r2) ? "dialog" : void 0)("aria-expanded", ctx_r2.isNavigable && ctx_r2.showColumnMenu(column_r2) ? false : void 0)("aria-keyshortcuts", ctx_r2.isNavigable && ctx_r2.showColumnMenu(column_r2) ? "Alt + ArrowDown" : void 0)("rowspan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colspan", column_r2.colspan);
    ɵɵadvance(2);
    ɵɵclassProp("!k-cursor-default", !ctx_r2.isInteractive(ctx_r2.getColumnComponent(column_r2), "reorderable"));
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(30, _c282, column_r2.headerTemplateRef, ctx_r2.lockedColumnsCount + columnIndex_r8, column_r2, column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r2.headerTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showColumnMenu(column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.resizable);
  }
}
function HeaderComponent_tr_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, HeaderComponent_tr_0_ng_container_3_th_1_Template, 5, 32, "th", 9)(2, HeaderComponent_tr_0_ng_container_3_th_2_Template, 7, 35, "th", 10);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.isColumnGroupComponent(column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.isColumnGroupComponent(column_r2));
  }
}
function HeaderComponent_tr_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 3);
    ɵɵtemplate(1, HeaderComponent_tr_0_th_1_Template, 1, 0, "th", 4)(2, HeaderComponent_tr_0_th_2_Template, 1, 0, "th", 5)(3, HeaderComponent_tr_0_ng_container_3_Template, 3, 2, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const levelIndex_r9 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", levelIndex_r9)("logicalSlaveRow", ctx_r2.lockedColumnsCount > 0)("logicalCellsCount", ctx_r2.columns.length)("logicalSlaveCellsCount", ctx_r2.unlockedColumnsCount)("totalColumns", ctx_r2.totalColumns);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.groups);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.detailTemplate == null ? null : ctx_r2.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.columnsForLevel(levelIndex_r9));
  }
}
function HeaderComponent_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 32);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r2.leafColumns)("filter", ctx_r2.filter)("groups", ctx_r2.groups)("detailTemplate", ctx_r2.detailTemplate)("lockedColumnsCount", ctx_r2.lockedColumnsCount)("logicalRowIndex", ctx_r2.totalColumnLevels + 1)("logicalSlaveRow", ctx_r2.lockedColumnsCount > 0)("logicalCellsCount", ctx_r2.columns.length)("logicalSlaveCellsCount", ctx_r2.unlockedColumnsCount)("totalColumns", ctx_r2.totalColumns);
  }
}
var _c312 = ["kendoGridFooter", ""];
function FooterComponent_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 4);
  }
}
function FooterComponent_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 5);
  }
}
function FooterComponent_ng_container_4_td_1_ng_template_1_Template(rf, ctx) {
}
function FooterComponent_ng_container_4_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 7);
    ɵɵtemplate(1, FooterComponent_ng_container_4_td_1_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("k-grid-footer-sticky", column_r1.sticky);
    ɵɵproperty("logicalRowIndex", ctx_r1.logicalRowIndex)("logicalColIndex", ctx_r1.logicalColumnIndex(column_r1))("ngClass", column_r1.footerClass)("ngStyle", column_r1.sticky ? ctx_r1.addStickyStyles(column_r1) : column_r1.footerStyle);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(7, _c282, column_r1.footerTemplateRef, column_r1.leafIndex, column_r1, column_r1));
  }
}
function FooterComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FooterComponent_ng_container_4_td_1_Template, 2, 12, "td", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isColumnGroupComponent(column_r1));
  }
}
var _c323 = ["kendoGridCell", ""];
var _c332 = (a0) => ({
  $implicit: a0
});
function CellComponent_ng_container_1_ng_container_1_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_container_1_ng_container_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.templateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "valueOf");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const childColumn_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind3(2, 1, ctx_r0.dataItem, childColumn_r2.field, childColumn_r2.format), " ");
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template, 3, 5, "ng-container", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.children);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "valueOf");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind3(2, 1, ctx_r0.dataItem, ctx_r0.column.field, ctx_r0.column.format));
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "kendo-checkbox", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("kendoGridSelectionCheckbox", ctx_r0.rowIndex)("inputAttributes", ɵɵpureFunction1(3, _c292, ctx_r0.selectionCheckboxLabel));
    ɵɵattribute("id", ctx_r0.selectionCheckboxId);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_4_ng_template_2_kendo_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(5);
    ɵɵproperty("kendoGridSelectionCheckbox", ctx_r0.rowIndex)("inputAttributes", ɵɵpureFunction1(4, _c292, ctx_r0.selectionCheckboxLabel))("disabled", true);
    ɵɵattribute("id", ctx_r0.selectionCheckboxId);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_container_1_ng_container_4_ng_template_2_kendo_checkbox_0_Template, 1, 6, "kendo-checkbox", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngIf", ctx_r0.column.showDisabledCheckbox);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_ng_container_4_ng_container_1_Template, 2, 5, "ng-container", 4)(2, CellComponent_ng_container_1_ng_container_1_ng_container_4_ng_template_2_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const nonSelectableRow_r3 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isRowSelectable)("ngIfElse", nonSelectableRow_r3);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_5_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("svgIcon", ctx_r0.reorderIcon);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_5_2_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_container_1_ng_container_1_ng_container_5_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_container_1_ng_container_5_2_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.rowDragHandleTemplateRef)("ngTemplateOutletContext", ctx_r0.rowReorderTemplateContext);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_ng_container_5_kendo_icon_wrapper_1_Template, 1, 1, "kendo-icon-wrapper", 11)(2, CellComponent_ng_container_1_ng_container_1_ng_container_5_2_Template, 1, 2, null, 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r0.column.dragHandleTemplate == null ? null : ctx_r0.column.dragHandleTemplate.first));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.dragHandleTemplate == null ? null : ctx_r0.column.dragHandleTemplate.first);
  }
}
function CellComponent_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_1_Template, 1, 2, null, 5)(2, CellComponent_ng_container_1_ng_container_1_ng_container_2_Template, 2, 1, "ng-container", 5)(3, CellComponent_ng_container_1_ng_container_1_ng_container_3_Template, 3, 5, "ng-container", 5)(4, CellComponent_ng_container_1_ng_container_1_ng_container_4_Template, 4, 2, "ng-container", 5)(5, CellComponent_ng_container_1_ng_container_1_ng_container_5_Template, 3, 2, "ng-container", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isSpanColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isBoundColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isCheckboxColumn && !ctx_r0.isNew);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isRowReorderColumn && !ctx_r0.isNew);
  }
}
function CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_container_1_ng_template_2_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.loadingTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c332, ctx_r0.column));
  }
}
function CellComponent_ng_container_1_ng_template_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 14);
  }
}
function CellComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_Template, 1, 4, null, 5)(1, CellComponent_ng_container_1_ng_template_2_div_1_Template, 1, 0, "div", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngIf", ctx_r0.loadingTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.loadingTemplate);
  }
}
function CellComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_Template, 6, 5, "ng-container", 4)(2, CellComponent_ng_container_1_ng_template_2_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const loading_r4 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.showLoading)("ngIfElse", loading_r4);
  }
}
function CellComponent_ng_container_2_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_container_2_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.editTemplateRef)("ngTemplateOutletContext", ctx_r0.editTemplateContext);
  }
}
function CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 19);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("format", ctx_r0.format)("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 19);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("format", ctx_r0.format)("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_kendo_checkbox_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-checkbox", 20);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_kendo_textbox_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-textbox", 20);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 2);
    ɵɵtemplate(1, CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template, 1, 2, "kendo-numerictextbox", 16)(2, CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template, 1, 2, "kendo-datepicker", 16)(3, CellComponent_ng_container_2_ng_container_2_kendo_checkbox_3_Template, 1, 1, "kendo-checkbox", 17)(4, CellComponent_ng_container_2_ng_container_2_kendo_textbox_4_Template, 1, 1, "kendo-textbox", 18);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngSwitch", ctx_r0.column.editor);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "numeric");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "boolean");
  }
}
function CellComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_2_1_Template, 1, 2, null, 5)(2, CellComponent_ng_container_2_ng_container_2_Template, 5, 4, "ng-container", 15);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.editTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.column.editTemplateRef);
  }
}
var _c342 = ["kendoGridTableBody", ""];
var _c352 = (a0) => ({
  templateRef: a0
});
var _c362 = (a0, a1) => ({
  dataItem: a0,
  index: a1
});
var _c372 = (a0, a1) => ({
  index: a0,
  dataItem: a1
});
var _c382 = (a0, a1, a2) => ({
  dataItem: a0,
  rowIndex: a1,
  $implicit: a2
});
var _c392 = (a0, a1, a2, a3, a4, a5) => ({
  templateRef: a0,
  group: a1,
  field: a2,
  column: a3,
  aggregates: a4,
  $implicit: a5
});
function TableBodyComponent_ng_container_0_ng_container_2_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 8);
  }
}
function TableBodyComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_0_ng_container_2_td_1_Template, 1, 0, "td", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function TableBodyComponent_ng_container_0_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalColIndex", 0);
  }
}
function TableBodyComponent_ng_container_0_td_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 10);
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const columnIndex_r3 = ctx.index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleProp("left", column_r2.sticky ? "0" : void 0);
    ɵɵclassProp("k-grid-content-sticky", column_r2.sticky);
    ɵɵproperty("rowIndex", -1)("columnIndex", ctx_r0.lockedColumnsCount + columnIndex_r3)("isNew", true)("column", column_r2)("dataItem", ctx_r0.newDataItem)("ngClass", column_r2.cssClass)("ngStyle", column_r2.sticky ? ctx_r0.addStickyColumnStyles(column_r2) : column_r2.style)("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalColIndex", ctx_r0.logicalColIndex(column_r2))("colSpan", column_r2.colspan);
    ɵɵattribute("colspan", column_r2.colspan)("role", column_r2.tableCellsRole);
  }
}
function TableBodyComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "tr", 4);
    ɵɵtemplate(2, TableBodyComponent_ng_container_0_ng_container_2_Template, 2, 1, "ng-container", 0)(3, TableBodyComponent_ng_container_0_td_3_Template, 1, 2, "td", 5)(4, TableBodyComponent_ng_container_0_td_4_Template, 1, 16, "td", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount())("totalColumns", ctx_r0.totalColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.trackByColumns);
  }
}
function TableBodyComponent_tr_1_2_ng_template_0_Template(rf, ctx) {
}
function TableBodyComponent_tr_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TableBodyComponent_tr_1_2_ng_template_0_Template, 0, 0, "ng-template", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c352, ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef));
  }
}
function TableBodyComponent_tr_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.noRecordsText, " ");
  }
}
function TableBodyComponent_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 11)(1, "td", 12);
    ɵɵtemplate(2, TableBodyComponent_tr_1_2_Template, 1, 3, null, 0)(3, TableBodyComponent_tr_1_ng_container_3_Template, 2, 1, "ng-container", 0);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("colspan", ctx_r0.colSpan);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef));
  }
}
function TableBodyComponent_ng_container_2_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 18);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r0.columns)("groups", ctx_r0.groups)("item", item_r5)("hasDetails", !!(ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef))("skipGroupDecoration", ctx_r0.skipGroupDecoration)("hasGroupHeaderColumn", ctx_r0.hasGroupHeaderColumn)("groupHeaderColumns", ctx_r0.groupHeaderColumns)("rowIndex", rowIndex_r6 + 1)("totalColumnsCount", ctx_r0.totalColumnsCount)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.groupHeaderSlaveCellsCount);
  }
}
function TableBodyComponent_ng_container_2_tr_2_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 8);
  }
}
function TableBodyComponent_ng_container_2_tr_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_ng_container_1_td_1_Template, 1, 0, "td", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 23);
    ɵɵlistener("click", function TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r7);
      const item_r5 = ɵɵnextContext(3).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.toggleRow(item_r5.index, item_r5.data));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.detailButtonTitle(item_r5))("aria-label", ctx_r0.detailButtonTitle(item_r5));
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.detailButtonIconName(item_r5))("svgIcon", ctx_r0.detailButtonSvgIcon(item_r5));
  }
}
function TableBodyComponent_ng_container_2_tr_2_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 21);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template, 2, 4, "a", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("detailExpandCell", true);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate.showIf(item_r5.data, item_r5.index));
  }
}
function TableBodyComponent_ng_container_2_tr_2_ng_container_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 26);
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext();
    const column_r9 = ctx_r7.$implicit;
    const columnIndex_r10 = ctx_r7.index;
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-grid-content-sticky", column_r9.sticky)("k-touch-action-none", ctx_r0.isSelectable(ɵɵpureFunction2(28, _c362, item_r5.data, item_r5.index)) && ctx_r0.selectable.drag)("k-grid-edit-cell", ctx_r0.isEditingCell(item_r5.index, column_r9))("k-selected", ctx_r0.isSelectable && ctx_r0.cellSelectionService.isCellSelected(item_r5, column_r9));
    ɵɵproperty("rowIndex", item_r5.index)("columnIndex", ctx_r0.lockedColumnsCount + columnIndex_r10)("column", column_r9)("dataItem", item_r5.data)("isLoading", ctx_r0.isLoading)("isVirtual", ctx_r0.isVirtual)("loadingTemplate", ctx_r0.cellLoadingTemplate)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", ctx_r0.logicalColIndex(column_r9))("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", columnIndex_r10)("colSpan", column_r9.colspan)("rowSpan", column_r9.cellRowspan ? ctx_r0.getRowspan(ɵɵpureFunction2(31, _c372, rowIndex_r6, item_r5), column_r9, ctx_r0.lockedColumnsCount + columnIndex_r10) : 1)("ngClass", column_r9.cssClass)("ngStyle", column_r9.sticky ? ctx_r0.addStickyColumnStyles(column_r9) : column_r9.style);
    ɵɵattribute("data-kendo-grid-column-index", ctx_r0.lockedColumnsCount + columnIndex_r10)("role", column_r9.tableCellsRole)("aria-selected", ctx_r0.lockedColumnsCount < 1 && ctx_r0.isSelectable(ɵɵpureFunction2(34, _c362, item_r5.data, item_r5.index)) ? ctx_r0.isAriaSelected(item_r5, column_r9) : void 0)("colspan", column_r9.colspan);
  }
}
function TableBodyComponent_ng_container_2_tr_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_ng_container_3_td_1_Template, 1, 37, "td", 25);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r9 = ctx.$implicit;
    const columnIndex_r10 = ctx.index;
    const rowIndex_r6 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r9.cellRowspan ? !ctx_r0.shouldSkipCell(rowIndex_r6, ctx_r0.lockedColumnsCount + columnIndex_r10) : true);
  }
}
function TableBodyComponent_ng_container_2_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 19);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_ng_container_1_Template, 2, 1, "ng-container", 0)(2, TableBodyComponent_ng_container_2_tr_2_td_2_Template, 2, 6, "td", 20)(3, TableBodyComponent_ng_container_2_tr_2_ng_container_3_Template, 2, 1, "ng-container", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0.isOdd(item_r5) ? "k-table-alt-row" : "");
    ɵɵclassProp("k-grid-row-sticky", ctx_r0.rowSticky ? ctx_r0.rowSticky(ɵɵpureFunction2(27, _c362, item_r5.data, item_r5.index)) : false)("k-master-row", true)("k-expanded", ctx_r0.isDataItem(item_r5) && ctx_r0.isExpanded(item_r5))("k-grid-edit-row", ctx_r0.isEditingRow(item_r5.index))("k-selected", ctx_r0.isSelectable(ɵɵpureFunction2(30, _c362, item_r5.data, item_r5.index)) && ctx_r0.isRowSelected(item_r5));
    ɵɵproperty("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount(item_r5))("ngClass", ctx_r0.rowClass(ɵɵpureFunction2(33, _c362, item_r5.data, item_r5.index)));
    ɵɵattribute("aria-selected", ctx_r0.lockedColumnsCount < 1 ? ctx_r0.isSelectable(ɵɵpureFunction2(36, _c362, item_r5.data, item_r5.index)) && ctx_r0.isRowSelected(item_r5) : void 0)("data-kendo-grid-item-index", item_r5.index);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.trackByColumns);
  }
}
function TableBodyComponent_ng_container_2_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 32);
  }
}
function TableBodyComponent_ng_container_2_tr_3_ng_template_4_Template(rf, ctx) {
}
function TableBodyComponent_ng_container_2_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 27);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_3_td_1_Template, 1, 0, "td", 28);
    ɵɵelement(2, "td", 29);
    ɵɵelementStart(3, "td", 30);
    ɵɵtemplate(4, TableBodyComponent_ng_container_2_tr_3_ng_template_4_Template, 0, 0, "ng-template", 31);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6) + 1)("logicalSlaveRow", false)("logicalCellsCount", 1);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
    ɵɵadvance(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6) + 1)("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", 0)("colSpan", ctx_r0.allColumnsSpan + 1);
    ɵɵattribute("colspan", ctx_r0.columnsSpan);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.detailTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(15, _c382, item_r5.data, item_r5.index, item_r5.data));
  }
}
function TableBodyComponent_ng_container_2_tr_4_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 32);
  }
}
function TableBodyComponent_ng_container_2_tr_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_ng_container_1_td_1_Template, 1, 0, "td", 28);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function TableBodyComponent_ng_container_2_tr_4_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 9);
  }
  if (rf & 2) {
    const rowIndex_r6 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", 0);
  }
}
function TableBodyComponent_ng_container_2_tr_4_td_3_ng_template_1_Template(rf, ctx) {
}
function TableBodyComponent_ng_container_2_tr_4_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 35);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_td_3_ng_template_1_Template, 0, 0, "ng-template", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r11 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", ctx_r0.logicalColIndex(column_r11));
    ɵɵattribute("data-skip", ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction6(4, _c392, column_r11.groupFooterTemplateRef, item_r5.data, column_r11.field, column_r11, item_r5.data == null ? null : item_r5.data.aggregates, item_r5.data == null ? null : item_r5.data.aggregates));
  }
}
function TableBodyComponent_ng_container_2_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 33);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_ng_container_1_Template, 2, 1, "ng-container", 0)(2, TableBodyComponent_ng_container_2_tr_4_td_2_Template, 1, 2, "td", 5)(3, TableBodyComponent_ng_container_2_tr_4_td_3_Template, 2, 11, "td", 34);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount(item_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.footerColumns)("ngForTrackBy", ctx_r0.trackByColumns);
  }
}
function TableBodyComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_1_Template, 1, 14, "tr", 14)(2, TableBodyComponent_ng_container_2_tr_2_Template, 4, 39, "tr", 15)(3, TableBodyComponent_ng_container_2_tr_3_Template, 5, 19, "tr", 16)(4, TableBodyComponent_ng_container_2_tr_4_Template, 4, 9, "tr", 17);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isGroup(item_r5) && ctx_r0.isParentGroupExpanded(item_r5) && ctx_r0.showGroupHeader(item_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isDataItem(item_r5) && (!item_r5.group || ctx_r0.isDataItemInExpandedGroup(item_r5)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isDataItem(item_r5) && (!item_r5.group || ctx_r0.isDataItemInExpandedGroup(item_r5)) && (ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef) && ctx_r0.detailTemplate.showIf(item_r5.data, item_r5.index) && ctx_r0.isExpanded(item_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isFooter(item_r5) && item_r5.group && (ctx_r0.isFooterItemInExpandedGroup(item_r5) || ctx_r0.showGroupFooters && ctx_r0.isParentGroupExpanded(item_r5.group)) && !item_r5.data.hideFooter);
  }
}
function TableBodyComponent_kendo_resize_sensor_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 36);
    ɵɵlistener("resize", function TableBodyComponent_kendo_resize_sensor_3_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.resizeHandler());
    });
    ɵɵelementEnd();
  }
}
var _c40 = ["kendoGridEditCommand", ""];
function EditCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function EditCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function EditCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c41 = ["kendoGridCancelCommand", ""];
function CancelCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function CancelCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function CancelCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c422 = ["kendoGridSaveCommand", ""];
function SaveCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function SaveCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function SaveCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c432 = ["kendoGridRemoveCommand", ""];
function RemoveCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function RemoveCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function RemoveCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c44 = ["kendoGridAddCommand", ""];
function AddCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function AddCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function AddCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c45 = (a0) => ({
  aggregates: a0
});
function StatusBarComponent_0_ng_template_0_Template(rf, ctx) {
}
function StatusBarComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StatusBarComponent_0_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.statusBarTemplate == null ? null : ctx_r0.statusBarTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c45, ctx_r0.aggregates));
  }
}
var _c46 = ["container"];
var _c47 = ["lockedContainer"];
var _c48 = ["lockedTable"];
var _c49 = ["table"];
var _c50 = () => [];
var _c51 = (a0, a1, a2, a3) => ({
  keydown: a0,
  scroll: a1,
  mousewheel: a2,
  DOMMouseScroll: a3
});
function ListComponent_div_0_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵstyleProp("height", ctx_r0.totalHeight, "px");
  }
}
function ListComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13, 2)(2, "div", 6)(3, "table", 14, 3);
    ɵɵelement(5, "colgroup", 8)(6, "tbody", 15);
    ɵɵelementEnd();
    ɵɵelement(7, "kendo-resize-sensor");
    ɵɵelementEnd();
    ɵɵtemplate(8, ListComponent_div_0_div_8_Template, 2, 2, "div", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(30, _c51, ctx_r0.lockedKeydown, ctx_r0.lockedScroll, ctx_r0.lockedMousewheel, ctx_r0.lockedMousewheel))("scope", ctx_r0);
    ɵɵadvance(3);
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r0.size);
    ɵɵadvance(2);
    ɵɵproperty("groups", ctx_r0.groups)("columns", ctx_r0.lockedLeafColumns)("detailTemplate", ctx_r0.detailTemplate)("sort", ctx_r0.sort);
    ɵɵadvance();
    ɵɵproperty("groups", ctx_r0.groups)("isLocked", true)("data", ctx_r0.data)("noRecordsText", "")("columns", ctx_r0.lockedLeafColumns)("totalColumnsCount", ctx_r0.leafColumns.length)("totalColumns", ctx_r0.columns)("detailTemplate", ctx_r0.detailTemplate)("showGroupFooters", ctx_r0.showFooter)("skip", ctx_r0.skip)("selectable", ctx_r0.selectable)("trackBy", ctx_r0.trackBy)("filterable", ctx_r0.filterable)("rowClass", ctx_r0.rowClass)("isLoading", ctx_r0.loading)("isVirtual", ctx_r0.isVirtual)("cellLoadingTemplate", ctx_r0.cellLoadingTemplate);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.isVirtual);
  }
}
function ListComponent_kendo_resize_sensor_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-resize-sensor");
  }
}
function ListComponent_kendo_resize_sensor_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-resize-sensor");
  }
}
function ListComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("height", ctx_r0.totalHeight, "px");
  }
}
function ListComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r0.totalWidth, "px");
  }
}
function ToolbarComponent_0_ng_template_0_Template(rf, ctx) {
}
function ToolbarComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ToolbarComponent_0_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.toolbarTemplateRef)("ngTemplateOutletContext", ctx_r0.context);
  }
}
var _c522 = ["filterItem"];
var _c532 = ["filterContainer"];
function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 5, 1);
    ɵɵlistener("keydown.shift.tab", function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r6);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r6);
      ɵɵnextContext();
      const filterItem_r2 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleClose(filterItem_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r5 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r5))("filter", ctx_r2.filter)("isExpanded", false);
  }
}
function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 3, 0);
    ɵɵlistener("focus", function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_Template_kendo_grid_columnmenu_item_focus_0_listener() {
      ɵɵrestoreView(_r1);
      const filterItem_r2 = ɵɵreference(1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onItemFocus(filterItem_r2));
    })("focusout", function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_Template_kendo_grid_columnmenu_item_focusout_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onItemFocusOut());
    })("keydown.enter", function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_Template_kendo_grid_columnmenu_item_keydown_enter_0_listener($event) {
      const i_r4 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleItem($event, i_r4));
    })("itemClick", function FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      const column_r5 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.navigateView(ctx_r2.getColumnComponent(column_r5)));
    });
    ɵɵtemplate(2, FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_ng_template_2_Template, 2, 3, "ng-template", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const filterItem_r2 = ɵɵreference(1);
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r5))("text", column_r5.title || ctx_r2.getColumnComponent(column_r5).field)("indicatorIcon", ctx_r2.isFilterApplied(column_r5))("expanded", false)("focused", ctx_r2.isItemFocused(filterItem_r2));
  }
}
var _c54 = ["sortItem"];
function SortToolbarToolComponent_div_1_kendo_icon_wrapper_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 9);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵpropertyInterpolate1("name", "sort-", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir, "-small");
    ɵɵproperty("svgIcon", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
  }
}
function SortToolbarToolComponent_div_1_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.getColumnComponent(column_r2).field));
  }
}
function SortToolbarToolComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5, 0);
    ɵɵlistener("click", function SortToolbarToolComponent_div_1_Template_div_click_0_listener($event) {
      const column_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleSort(column_r2, $event));
    })("keydown.enter", function SortToolbarToolComponent_div_1_Template_div_keydown_enter_0_listener($event) {
      const column_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleSort(column_r2, $event));
    });
    ɵɵtext(2);
    ɵɵelementStart(3, "span", 6);
    ɵɵtemplate(4, SortToolbarToolComponent_div_1_kendo_icon_wrapper_4_Template, 1, 3, "kendo-icon-wrapper", 7)(5, SortToolbarToolComponent_div_1_span_5_Template, 2, 1, "span", 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("tabindex", "0");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", column_r2.title || ctx_r2.getColumnComponent(column_r2).field, " ");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showSortNumbering(ctx_r2.getColumnComponent(column_r2)));
  }
}
var _c55 = ["input"];
function FormFormFieldComponent_kendo_floatinglabel_1_kendo_textbox_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-textbox", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_kendo_floatinglabel_1_kendo_numerictextbox_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_kendo_floatinglabel_1_kendo_datepicker_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_kendo_floatinglabel_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-floatinglabel", 8);
    ɵɵtemplate(1, FormFormFieldComponent_kendo_floatinglabel_1_kendo_textbox_1_Template, 1, 1, "kendo-textbox", 5)(2, FormFormFieldComponent_kendo_floatinglabel_1_kendo_numerictextbox_2_Template, 1, 1, "kendo-numerictextbox", 5)(3, FormFormFieldComponent_kendo_floatinglabel_1_kendo_datepicker_3_Template, 1, 1, "kendo-datepicker", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r0.control.label);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.control.dataType === "text");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.control.dataType === "numeric");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.control.dataType === "date");
  }
}
function FormFormFieldComponent_kendo_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-label", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("align-items", "start");
    ɵɵproperty("text", ctx_r0.control.label)("for", ctx_r0.input);
  }
}
function FormFormFieldComponent_kendo_textbox_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-textbox", 9, 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_kendo_numerictextbox_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 9, 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_kendo_datepicker_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 9, 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
  }
}
function FormFormFieldComponent_div_6_kendo_label_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-label", 13);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const cb_r2 = ɵɵreference(2);
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("for", cb_r2)("text", ctx_r0.control.label);
  }
}
function FormFormFieldComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "kendo-checkbox", 9, 1);
    ɵɵtemplate(3, FormFormFieldComponent_div_6_kendo_label_3_Template, 1, 2, "kendo-label", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("formControl", ctx_r0.control.formControl);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.control.label);
  }
}
function FormFormFieldComponent_kendo_formhint_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formhint");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.control.hint);
  }
}
function FormFormFieldComponent_ng_container_8_kendo_formerror_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-formerror");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const err_r3 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.control.errors ? ctx_r0.control.errors[err_r3.key] : ctx_r0.messageFor("formValidationError", err_r3.key, ctx_r0.control.name));
  }
}
function FormFormFieldComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FormFormFieldComponent_ng_container_8_kendo_formerror_1_Template, 2, 1, "kendo-formerror", 14);
    ɵɵpipe(2, "keyvalue");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind1(2, 1, ctx_r0.control == null ? null : ctx_r0.control.formControl == null ? null : ctx_r0.control.formControl.errors));
  }
}
function FormComponent_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "kendo-form-formfield", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const control_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("control", control_r1)("showError", ctx_r1.formSettings.showErrors)("floatingLabel", ctx_r1.formSettings.floatingLabels);
  }
}
function FormComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 6);
  }
  if (rf & 2) {
    const control_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", control_r1.template)("ngTemplateOutletContext", control_r1.templateContext);
  }
}
function FormComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FormComponent_ng_container_1_ng_container_1_Template, 2, 3, "ng-container", 4)(2, FormComponent_ng_container_1_ng_template_2_Template, 1, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const control_r1 = ctx.$implicit;
    const template_r3 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !control_r1.template)("ngIfElse", template_r3);
  }
}
function FormComponent_div_2_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const button_r4 = ctx.$implicit;
    ɵɵclassProp("k-form-submit", button_r4.actionType === "submit");
    ɵɵproperty("size", button_r4.size)("themeColor", button_r4.themeColor || button_r4.actionType === "submit" ? "primary" : void 0)("rounded", button_r4.rounded)("svgIcon", button_r4.svgIcon)("icon", button_r4.icon);
    ɵɵattribute("type", button_r4.actionType);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", button_r4.text, " ");
  }
}
function FormComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, FormComponent_div_2_button_1_Template, 2, 9, "button", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.actionButtons);
  }
}
var _c56 = ["groupItem"];
function GroupToolbarToolComponent_div_0_div_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9)(1, "span", 12);
    ɵɵlistener("click", function GroupToolbarToolComponent_div_0_div_1_span_2_Template_span_click_1_listener($event) {
      ɵɵrestoreView(_r6);
      const column_r3 = ɵɵnextContext().$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.moveGroupUp(column_r3, $event));
    });
    ɵɵelement(2, "kendo-icon-wrapper", 13);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 14);
    ɵɵlistener("click", function GroupToolbarToolComponent_div_0_div_1_span_2_Template_span_click_3_listener($event) {
      ɵɵrestoreView(_r6);
      const column_r3 = ɵɵnextContext().$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.moveGroupDown(column_r3, $event));
    });
    ɵɵelement(4, "kendo-icon-wrapper", 15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const i_r4 = ɵɵnextContext().index;
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", i_r4 === 0);
    ɵɵattribute("aria-disabled", i_r4 === 0);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.upIcon)("size", ctx_r4.iconSize);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", i_r4 === ctx_r4.groupedColumns.length - 1);
    ɵɵattribute("aria-disabled", i_r4 === ctx_r4.groupedColumns.length - 1);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.downIcon)("size", ctx_r4.iconSize);
  }
}
function GroupToolbarToolComponent_div_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5, 0);
    ɵɵlistener("keydown", function GroupToolbarToolComponent_div_0_div_1_Template_div_keydown_0_listener($event) {
      const ctx_r1 = ɵɵrestoreView(_r1);
      const column_r3 = ctx_r1.$implicit;
      const i_r4 = ctx_r1.index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.handleGroupedKeydown(column_r3, i_r4, $event));
    })("focus", function GroupToolbarToolComponent_div_0_div_1_Template_div_focus_0_listener() {
      const i_r4 = ɵɵrestoreView(_r1).index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.onItemFocus(i_r4, 0));
    });
    ɵɵtemplate(2, GroupToolbarToolComponent_div_0_div_1_span_2_Template, 5, 10, "span", 6);
    ɵɵelementStart(3, "span", 7);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelement(5, "span", 8);
    ɵɵelementStart(6, "span", 9)(7, "span", 10);
    ɵɵlistener("click", function GroupToolbarToolComponent_div_0_div_1_Template_span_click_7_listener($event) {
      const column_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.removeGroup(column_r3, $event));
    });
    ɵɵelement(8, "kendo-icon-wrapper", 11);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const column_r3 = ctx.$implicit;
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.groupedColumns.length > 1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r3.title || ctx_r4.getColumnComponent(column_r3).field);
    ɵɵadvance(4);
    ɵɵproperty("svgIcon", ctx_r4.removeIcon)("size", ctx_r4.iconSize);
  }
}
function GroupToolbarToolComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, GroupToolbarToolComponent_div_0_div_1_Template, 9, 4, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r4.groupedColumns);
  }
}
function GroupToolbarToolComponent_div_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5, 0);
    ɵɵlistener("keydown", function GroupToolbarToolComponent_div_1_div_1_Template_div_keydown_0_listener($event) {
      const ctx_r7 = ɵɵrestoreView(_r7);
      const column_r9 = ctx_r7.$implicit;
      const i_r10 = ctx_r7.index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.handleUngroupedKeydown(column_r9, i_r10, $event));
    })("focus", function GroupToolbarToolComponent_div_1_div_1_Template_div_focus_0_listener() {
      const i_r10 = ɵɵrestoreView(_r7).index;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.onItemFocus(null, i_r10));
    });
    ɵɵelementStart(2, "span", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelement(4, "span", 8);
    ɵɵelementStart(5, "span", 9)(6, "span", 16);
    ɵɵlistener("click", function GroupToolbarToolComponent_div_1_div_1_Template_span_click_6_listener($event) {
      const column_r9 = ɵɵrestoreView(_r7).$implicit;
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.addGroup(column_r9, $event));
    });
    ɵɵelement(7, "kendo-icon-wrapper", 17);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const column_r9 = ctx.$implicit;
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵtextInterpolate(column_r9.title || ctx_r4.getColumnComponent(column_r9).field);
    ɵɵadvance(4);
    ɵɵproperty("svgIcon", ctx_r4.addIcon)("size", ctx_r4.iconSize);
  }
}
function GroupToolbarToolComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, GroupToolbarToolComponent_div_1_div_1_Template, 8, 3, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r4.ungroupedColumns);
  }
}
function GroupToolbarToolComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18)(1, "button", 19);
    ɵɵlistener("click", function GroupToolbarToolComponent_div_2_Template_button_click_1_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.clear());
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.clearIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.ctx == null ? null : ctx_r4.ctx.localization.get("groupClearButton"), " ");
  }
}
var _c57 = ["filterToolbarToolTemplate"];
var _c58 = ["filterMenuContainer"];
var _c59 = (a0, a1) => ({
  "k-adaptive-actionsheet": true,
  "k-actionsheet-fullscreen": a0,
  "k-actionsheet-bottom": a1
});
var _c60 = (a0) => ({
  height: a0
});
var _c61 = (a0) => ({
  transitionend: a0
});
var _c622 = (a0) => ({
  "keydown.escape": a0
});
var _c63 = (a0, a1, a2, a3) => ({
  click: a0,
  "keydown.enter": a1,
  "keydown.space": a2,
  "keydown.tab": a3
});
var _c64 = (a0, a1, a2) => ({
  click: a0,
  "keydown.enter": a1,
  "keydown.space": a2
});
function AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_2_kendo_grid_columnmenu_item_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 26);
    ɵɵlistener("itemClick", function AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_2_kendo_grid_columnmenu_item_2_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      const column_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.sortBy(column_r4));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r4 = ctx.$implicit;
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("column", ctx_r4.getColumnComponent(column_r4))("text", column_r4.title || ctx_r4.getColumnComponent(column_r4).field);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 23)(1, "div", 24);
    ɵɵtemplate(2, AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_2_kendo_grid_columnmenu_item_2_Template, 1, 2, "kendo-grid-columnmenu-item", 25);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r4.columns);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 27);
    ɵɵlistener("click", function AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.clearSorting());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 28);
    ɵɵlistener("click", function AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_3_Template_button_click_2_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.xIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("sortClearButton"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("sortDoneButton"), " ");
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_2_Template, 3, 1, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_1_ng_template_3_Template, 4, 4, "ng-template", 21);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnlist", 29, 3);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("columns", ctx_r4.adaptiveGridService.columns)("ariaLabel", ctx_r4.messageFor("columns"))("isLast", true)("showActions", false)("applyText", ctx_r4.messageFor("columnsApply"))("resetText", ctx_r4.messageFor("columnsReset"))("autoSync", false)("actionsClass", ctx_r4.actionsClass)("allowHideAll", false);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_2_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetFooterTemplate_r7 = ɵɵreference(13);
    ɵɵproperty("ngTemplateOutlet", actionSheetFooterTemplate_r7);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_2_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_2_ng_template_2_Template, 2, 9, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_2_ng_template_3_Template, 1, 1, "ng-template", 21);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 23);
    ɵɵelement(1, "kendo-filter-toolbar-tool");
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 31);
    ɵɵlistener("click", function AdaptiveRendererComponent_kendo_actionsheet_view_3_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.clearFilters());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.filterClearIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("filterClearAllButton"), " ");
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view", 30);
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_3_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_3_ng_template_2_Template, 2, 0, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_3_ng_template_3_Template, 2, 2, "ng-template", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(2, _c61, ctx_r4.onAnimationEnd))("scope", ctx_r4);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, null, 4);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_4_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const filterFooterButtons_r9 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", filterFooterButtons_r9);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_4_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_4_ng_template_2_Template, 2, 0, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_4_ng_template_3_Template, 1, 1, "ng-template", 21);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 32, 5);
    ɵɵlistener("close", function AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.close());
    })("keydown.enter", function AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r10);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r4.adaptiveGridService.column)("filter", ctx_r4.ctx.grid.filter);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const filterFooterButtons_r9 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", filterFooterButtons_r9);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_2_Template, 2, 2, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_5_ng_template_3_Template, 1, 1, "ng-template", 21);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_sort_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 39, 6);
  }
  if (rf & 2) {
    const sortItem_r11 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r11)("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_lock_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 39, 7);
  }
  if (rf & 2) {
    const lockItem_r12 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r12)("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_stick_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 39, 8);
  }
  if (rf & 2) {
    const stickItem_r13 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r13)("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_position_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-position", 40, 9);
    ɵɵlistener("collapse", function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_position_5_Template_kendo_grid_columnmenu_position_collapse_0_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.navigateToPositionView());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const positionItem_r15 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r15)("service", ctx_r4.adaptiveGridService.columnMenuService)("expanded", false);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 41);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_chooser_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-chooser", 42, 10);
    ɵɵlistener("collapse", function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_chooser_7_Template_kendo_grid_columnmenu_chooser_collapse_0_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.navigateToColumnsView());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const chooserItem_r17 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", chooserItem_r17)("service", ctx_r4.adaptiveGridService.columnMenuService)("expanded", false);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_autosize_column_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 43, 11);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r18 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService)("kendoGridColumnMenuItem", autoSizeColumnItem_r18)("column", ctx_r4.adaptiveGridService.column);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 44, 12);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r19 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r19);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_span_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 41);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_filter_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-filter", 42, 13);
    ɵɵlistener("collapse", function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_filter_11_Template_kendo_grid_columnmenu_filter_collapse_0_listener() {
      ɵɵrestoreView(_r20);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.navigateToFilterView());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const filterItem_r21 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("kendoGridColumnMenuItem", filterItem_r21)("service", ctx_r4.adaptiveGridService.columnMenuService)("expanded", false);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 23)(1, "kendo-grid-columnmenu-container");
    ɵɵtemplate(2, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_sort_2_Template, 2, 2, "kendo-grid-columnmenu-sort", 33)(3, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_lock_3_Template, 2, 2, "kendo-grid-columnmenu-lock", 33)(4, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_stick_4_Template, 2, 2, "kendo-grid-columnmenu-stick", 33)(5, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_position_5_Template, 2, 5, "kendo-grid-columnmenu-position", 34)(6, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_span_6_Template, 1, 2, "span", 35)(7, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_chooser_7_Template, 2, 3, "kendo-grid-columnmenu-chooser", 36)(8, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_autosize_column_8_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 37)(9, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_9_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 38)(10, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_span_10_Template, 1, 2, "span", 35)(11, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_kendo_grid_columnmenu_filter_11_Template, 2, 3, "kendo-grid-columnmenu-filter", 36);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.hasSort);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasLock && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasStick && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasLock || ctx_r4.hasStick || ctx_r4.adaptiveGridService.column.sortable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeAllColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.column.filterable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasFilter);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view", 30);
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_6_ng_template_2_Template, 12, 10, "ng-template", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(2, _c61, ctx_r4.onAnimationEnd))("scope", ctx_r4);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_columnlist_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnlist", 29, 3);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("columns", ctx_r4.adaptiveGridService.columns)("ariaLabel", ctx_r4.messageFor("columns"))("isLast", true)("showActions", false)("applyText", ctx_r4.messageFor("columnsApply"))("resetText", ctx_r4.messageFor("columnsReset"))("autoSync", false)("actionsClass", ctx_r4.actionsClass)("allowHideAll", false);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_filter_menu_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 48);
    ɵɵlistener("close", function AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_filter_menu_container_1_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r22);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("column", ctx_r4.adaptiveGridService.column)("filter", ctx_r4.ctx.grid.filter)("kendoEventsOutsideAngular", ɵɵpureFunction1(4, _c622, ctx_r4.close))("scope", ctx_r4);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 49);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 49);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("service", ctx_r4.adaptiveGridService.columnMenuService);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_columnlist_0_Template, 2, 9, "kendo-grid-columnlist", 45)(1, AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_filter_menu_container_1_Template, 1, 6, "kendo-grid-filter-menu-container", 46)(2, AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_columnmenu_lock_2_Template, 1, 1, "kendo-grid-columnmenu-lock", 47)(3, AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_kendo_grid_columnmenu_stick_3_Template, 1, 1, "kendo-grid-columnmenu-stick", 47);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.secondaryView === "columnChooser");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.secondaryView === "columnFilter");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.secondaryView === "columnPosition" && ctx_r4.hasLock);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.secondaryView === "columnPosition" && ctx_r4.hasStick);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_3_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(3);
    const actionSheetFooterTemplate_r7 = ɵɵreference(13);
    ɵɵproperty("ngTemplateOutlet", actionSheetFooterTemplate_r7);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AdaptiveRendererComponent_kendo_actionsheet_view_7_3_ng_template_0_Template, 1, 1, "ng-template", 21);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_4_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(3);
    const filterFooterButtons_r9 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", filterFooterButtons_r9);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AdaptiveRendererComponent_kendo_actionsheet_view_7_4_ng_template_0_Template, 1, 1, "ng-template", 21);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_7_ng_template_2_Template, 4, 4, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_7_3_Template, 1, 0, null, 17)(4, AdaptiveRendererComponent_kendo_actionsheet_view_7_4_Template, 1, 0, null, 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.secondaryView === "columnChooser");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.secondaryView === "columnFilter");
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-external-form", 50);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("controls", ctx_r4.externalEditingSettings.formControls)("formGroup", ctx_r4.externalEditingSettings.formGroup)("formSettings", ctx_r4.externalEditingSettings.formSettings)("actionButtons", false);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 51);
    ɵɵlistener("click", function AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r23);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 52);
    ɵɵlistener("click", function AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_3_Template_button_click_2_listener() {
      ɵɵrestoreView(_r23);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.saveEditing());
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.cancelIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("externalEditingCancelText"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.saveIcon)("disabled", !ctx_r4.externalEditingSettings.formGroup.valid);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("externalEditingSaveText"), " ");
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_2_Template, 1, 4, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_8_ng_template_3_Template, 4, 5, "ng-template", 21);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const actionSheetHeaderTemplate_r2 = ɵɵreference(11);
    ɵɵproperty("ngTemplateOutlet", actionSheetHeaderTemplate_r2);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-group-toolbar-tool", 53);
  }
  if (rf & 2) {
    ɵɵproperty("adaptive", true);
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r24 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 27);
    ɵɵlistener("click", function AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r24);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.clearGrouping());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 28);
    ɵɵlistener("click", function AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_3_Template_button_click_2_listener() {
      ɵɵrestoreView(_r24);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r4.xIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("groupClearButton"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("groupDoneButton"), " ");
  }
}
function AdaptiveRendererComponent_kendo_actionsheet_view_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-actionsheet-view");
    ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_1_Template, 1, 1, "ng-template", 19)(2, AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_2_Template, 1, 1, "ng-template", 20)(3, AdaptiveRendererComponent_kendo_actionsheet_view_9_ng_template_3_Template, 4, 4, "ng-template", 21);
    ɵɵelementEnd();
  }
}
function AdaptiveRendererComponent_ng_template_10_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 59)(1, "button", 60);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_10_div_1_Template_button_click_1_listener() {
      ɵɵrestoreView(_r25);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.prevView());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.chevronLeft)("title", ctx_r4.messageFor("adaptiveBackButtonTitle"));
  }
}
function AdaptiveRendererComponent_ng_template_10_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 61);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.actionSheetTitle, " ");
  }
}
function AdaptiveRendererComponent_ng_template_10_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 62);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("columnsSubtitle"), " ");
  }
}
function AdaptiveRendererComponent_ng_template_10_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r26 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 59)(1, "button", 63);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_10_div_5_Template_button_click_1_listener() {
      ɵɵrestoreView(_r26);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.xIcon)("title", ctx_r4.messageFor("adaptiveCloseButtonTitle"));
  }
}
function AdaptiveRendererComponent_ng_template_10_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r27 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 59)(1, "button", 64);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_10_div_6_Template_button_click_1_listener() {
      ɵɵrestoreView(_r27);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.actionSheet.toggle(false));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon)("title", ctx_r4.messageFor("adaptiveCloseButtonTitle"));
  }
}
function AdaptiveRendererComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 54);
    ɵɵtemplate(1, AdaptiveRendererComponent_ng_template_10_div_1_Template, 2, 2, "div", 55);
    ɵɵelementStart(2, "div", 56);
    ɵɵtemplate(3, AdaptiveRendererComponent_ng_template_10_div_3_Template, 2, 1, "div", 57)(4, AdaptiveRendererComponent_ng_template_10_div_4_Template, 2, 1, "div", 58);
    ɵɵelementEnd();
    ɵɵtemplate(5, AdaptiveRendererComponent_ng_template_10_div_5_Template, 2, 2, "div", 55)(6, AdaptiveRendererComponent_ng_template_10_div_6_Template, 2, 2, "div", 55);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.adaptiveGridService.secondaryView);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.hasTitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasSubtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasXCloseIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasCheckCloseIcon);
  }
}
function AdaptiveRendererComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 65, 14);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 66, 15);
    ɵɵtext(5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r4.arrowRotateCcwIcon)("kendoEventsOutsideAngular", ɵɵpureFunction4(8, _c63, ctx_r4.cancelChanges, ctx_r4.cancelChanges, ctx_r4.cancelChanges, ctx_r4.onTab))("scope", ctx_r4);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("columnsReset"), " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r4.checkIcon)("kendoEventsOutsideAngular", ɵɵpureFunction3(13, _c64, ctx_r4.applyChanges, ctx_r4.applyChanges, ctx_r4.applyChanges))("scope", ctx_r4);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("columnsApply"), " ");
  }
}
function AdaptiveRendererComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 67);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_14_Template_button_click_0_listener() {
      ɵɵrestoreView(_r28);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.adaptiveGridService.resetFilter());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "button", 68);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_14_Template_button_click_2_listener() {
      ɵɵrestoreView(_r28);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.adaptiveGridService.submitFilter());
    });
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("filterClearButton"), " ");
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r4.adaptiveGridService.filterMenuContainer.disabled);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.messageFor("filterFilterButton"), " ");
  }
}
var _c65 = ["lockedHeader"];
var _c66 = ["header"];
var _c67 = ["ariaRoot"];
var _c68 = ["dialogContainer"];
var _c69 = ["footer"];
var _c70 = [[["kendo-toolbar"]]];
var _c71 = ["kendo-toolbar"];
var _c722 = (a0) => ({
  hintTemplate: a0
});
function GridComponent_kendo_grid_toolbar_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-toolbar", 21);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("navigable", ctx_r1.navigation.toolbarEnabled);
    ɵɵattribute("aria-label", ctx_r1.messageFor("topToolbarLabel"))("aria-controls", ctx_r1.ariaRootId);
  }
}
function GridComponent_kendo_pager_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 25);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const topPager_r4 = ɵɵreference(1);
    const ctx_r1 = ɵɵnextContext();
    const defaultPager_r5 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.pagerTemplate ? ctx_r1.pagerTemplate == null ? null : ctx_r1.pagerTemplate.templateRef : defaultPager_r5)("ngTemplateOutletContext", topPager_r4.templateContext);
  }
}
function GridComponent_kendo_pager_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-pager", 22, 4);
    ɵɵlistener("pageChange", function GridComponent_kendo_pager_4_Template_kendo_pager_pageChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyPageChange("pager", $event));
    })("pagerInputVisibilityChange", function GridComponent_kendo_pager_4_Template_kendo_pager_pagerInputVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerInput", $event));
    })("pageTextVisibilityChange", function GridComponent_kendo_pager_4_Template_kendo_pager_pageTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerPageText", $event));
    })("itemsTextVisibilityChange", function GridComponent_kendo_pager_4_Template_kendo_pager_itemsTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerItemsText", $event));
    });
    ɵɵtemplate(2, GridComponent_kendo_pager_4_ng_template_2_Template, 1, 2, "ng-template", 23);
    ɵɵelement(3, "kendo-pager-messages", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r1.navigation.pagerEnabled)("pageSize", ctx_r1.pageSize)("total", ctx_r1.view.total)("skip", ctx_r1.skip)("size", ctx_r1.size)("responsive", ctx_r1.normalizedPageableSettings.responsive && !ctx_r1.pagerTemplate)("buttonCount", ctx_r1.normalizedPageableSettings.buttonCount)("info", ctx_r1.normalizedPageableSettings.info)("pageSizeValues", ctx_r1.normalizedPageableSettings.pageSizes)("previousNext", ctx_r1.normalizedPageableSettings.previousNext)("type", ctx_r1.normalizedPageableSettings.type);
    ɵɵadvance(3);
    ɵɵproperty("ariaLabel", ctx_r1.messageFor("pagerLabel"))("firstPage", ctx_r1.messageFor("pagerFirstPage"))("inputLabel", ctx_r1.messageFor("pagerInputLabel"))("previousPage", ctx_r1.messageFor("pagerPreviousPage"))("nextPage", ctx_r1.messageFor("pagerNextPage"))("lastPage", ctx_r1.messageFor("pagerLastPage"))("selectPage", ctx_r1.messageFor("pagerSelectPage"))("page", ctx_r1.messageFor("pagerPage"))("itemsPerPage", ctx_r1.messageFor("pagerItemsPerPage"))("items", ctx_r1.messageFor("pagerItems"))("of", ctx_r1.messageFor("pagerOf"))("pageNumberInputTitle", ctx_r1.messageFor("pagerPageNumberInputTitle"));
  }
}
function GridComponent_kendo_grid_group_panel_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-group-panel", 26);
    ɵɵlistener("change", function GridComponent_kendo_grid_group_panel_5_Template_kendo_grid_group_panel_change_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.groupChange.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r1.navigation.toolbarEnabled)("text", ctx_r1.groupableEmptyText)("groups", ctx_r1.group);
    ɵɵattribute("aria-label", ctx_r1.messageFor("groupPanelLabel"))("aria-controls", ctx_r1.ariaRootId);
  }
}
function GridComponent_ng_container_8_div_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 37, 6)(2, "table", 38);
    ɵɵelement(3, "colgroup", 34)(4, "thead", 39);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.lockedLeafColumns)("groups", ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("resizable", ctx_r1.resizable)("scrollable", true)("columns", ctx_r1.lockedColumns)("totalColumnLevels", ctx_r1.totalColumnLevels)("sort", ctx_r1.sort)("groups", ctx_r1.group)("filter", ctx_r1.filter)("filterable", ctx_r1.filterable)("groupable", ctx_r1.showGroupPanel)("reorderable", ctx_r1.reorderable)("sortable", ctx_r1.sortable)("columnMenu", ctx_r1.columnMenuOptions)("columnMenuTemplate", ctx_r1.columnMenuTemplate)("totalColumnsCount", ctx_r1.leafColumns.length)("totalColumns", ctx_r1.columnsContainer)("detailTemplate", ctx_r1.detailTemplate)("tabIndex", ctx_r1.navigation.tableEnabled ? "-1" : "0");
  }
}
function GridComponent_ng_container_8_div_1_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 40);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r1.columnsContainer.unlockedWidth, "px");
  }
}
function GridComponent_ng_container_8_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30);
    ɵɵtemplate(1, GridComponent_ng_container_8_div_1_div_1_Template, 5, 26, "div", 31);
    ɵɵelementStart(2, "div", 32, 5)(4, "table", 33);
    ɵɵelement(5, "colgroup", 34)(6, "thead", 35);
    ɵɵelementEnd();
    ɵɵtemplate(7, GridComponent_ng_container_8_div_1_div_7_Template, 2, 2, "div", 36);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("padding", ctx_r1.headerPadding);
    ɵɵclassProp("k-grid-draggable-header", ctx_r1.groupable || ctx_r1.reorderable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isLocked);
    ɵɵadvance();
    ɵɵproperty("kendoGridResizableContainer", ctx_r1.lockedLeafColumns.length > 0)("lockedWidth", ctx_r1.lockedWidth + ctx_r1.scrollbarWidth + 2);
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r1.nonLockedWidth, "px");
    ɵɵproperty("virtualColumns", ctx_r1.virtualColumns)("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.headerLeafColumns)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(33, _c50) : ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("resizable", ctx_r1.resizable)("scrollable", true)("columns", ctx_r1.headerColumns)("totalColumnLevels", ctx_r1.totalColumnLevels)("sort", ctx_r1.sort)("filter", ctx_r1.filter)("filterable", ctx_r1.filterable)("groupable", ctx_r1.showGroupPanel)("reorderable", ctx_r1.reorderable)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(34, _c50) : ctx_r1.group)("sortable", ctx_r1.sortable)("columnMenu", ctx_r1.columnMenuOptions)("columnMenuTemplate", ctx_r1.columnMenuTemplate)("lockedColumnsCount", ctx_r1.lockedLeafColumns.length)("totalColumnsCount", ctx_r1.leafColumns.length)("totalColumns", ctx_r1.columnsContainer)("detailTemplate", ctx_r1.detailTemplate)("tabIndex", ctx_r1.navigation.tableEnabled ? "-1" : "0");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.virtualColumns);
  }
}
function GridComponent_ng_container_8_div_3_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 46)(1, "table", 47);
    ɵɵelement(2, "colgroup", 34)(3, "tfoot", 48);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r1.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.lockedLeafColumns)("groups", ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("scrollable", true)("groups", ctx_r1.group)("columns", ctx_r1.lockedLeafColumns)("detailTemplate", ctx_r1.detailTemplate)("logicalRowIndex", ctx_r1.ariaRowCount)("totalColumns", ctx_r1.columnsContainer)("totalColumnsCount", ctx_r1.leafColumns.length);
  }
}
function GridComponent_ng_container_8_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 41);
    ɵɵtemplate(1, GridComponent_ng_container_8_div_3_div_1_Template, 4, 16, "div", 42);
    ɵɵelementStart(2, "div", 43, 7)(4, "table", 44);
    ɵɵelement(5, "colgroup", 34)(6, "tfoot", 45);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("padding", ctx_r1.headerPadding);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.lockedLeafColumns.length);
    ɵɵadvance();
    ɵɵproperty("kendoGridResizableContainer", ctx_r1.lockedLeafColumns.length > 0)("lockedWidth", ctx_r1.lockedWidth + ctx_r1.scrollbarWidth + 3);
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r1.nonLockedWidth, "px");
    ɵɵproperty("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.headerLeafColumns)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(19, _c50) : ctx_r1.group)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("logicalRowIndex", ctx_r1.ariaRowCount)("scrollable", true)("groups", ctx_r1.isLocked ? ɵɵpureFunction0(20, _c50) : ctx_r1.group)("columns", ctx_r1.headerColumns)("lockedColumnsCount", ctx_r1.lockedLeafColumns.length)("detailTemplate", ctx_r1.detailTemplate)("totalColumns", ctx_r1.columnsContainer)("totalColumnsCount", ctx_r1.leafColumns.length);
  }
}
function GridComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, GridComponent_ng_container_8_div_1_Template, 8, 35, "div", 27);
    ɵɵelementStart(2, "kendo-grid-list", 28);
    ɵɵlistener("pageChange", function GridComponent_ng_container_8_Template_kendo_grid_list_pageChange_2_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyPageChange("list", $event));
    })("scrollBottom", function GridComponent_ng_container_8_Template_kendo_grid_list_scrollBottom_2_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyScrollBottom());
    })("contentScroll", function GridComponent_ng_container_8_Template_kendo_grid_list_contentScroll_2_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.contentScroll.emit($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, GridComponent_ng_container_8_div_3_Template, 7, 21, "div", 29);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideHeader);
    ɵɵadvance();
    ɵɵproperty("data", ctx_r1.view)("rowHeight", ctx_r1.rowHeight)("detailRowHeight", ctx_r1.detailRowHeight)("total", ctx_r1.totalCount)("take", ctx_r1.pageSize)("groups", ctx_r1.group)("groupable", ctx_r1.groupable)("skip", ctx_r1.skip)("trackBy", ctx_r1.trackBy)("columns", ctx_r1.columnsContainer)("selectable", ctx_r1.selectable)("filterable", ctx_r1.filterable)("detailTemplate", ctx_r1.detailTemplate)("noRecordsTemplate", ctx_r1.noRecordsTemplate)("size", ctx_r1.size)("rowClass", ctx_r1.rowClass)("rowSticky", ctx_r1.rowSticky)("loading", ctx_r1.loading)("isVirtual", ctx_r1.isVirtual)("cellLoadingTemplate", ctx_r1.cellLoadingTemplate == null ? null : ctx_r1.cellLoadingTemplate.templateRef)("loadingTemplate", ctx_r1.loadingTemplate == null ? null : ctx_r1.loadingTemplate.templateRef)("virtualColumns", ctx_r1.virtualColumns)("enableDrag", ctx_r1.marqueeSelection)("sort", ctx_r1.sort);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showFooter);
  }
}
function GridComponent_ng_container_9_thead_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "thead", 54);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("k-grid-draggable-header", ctx_r1.groupable || ctx_r1.reorderable);
    ɵɵproperty("resizable", ctx_r1.resizable)("scrollable", false)("columns", ctx_r1.visibleColumns)("totalColumnLevels", ctx_r1.totalColumnLevels)("totalColumns", ctx_r1.columnsContainer)("groups", ctx_r1.group)("groupable", ctx_r1.showGroupPanel)("reorderable", ctx_r1.reorderable)("sort", ctx_r1.sort)("sortable", ctx_r1.sortable)("filter", ctx_r1.filter)("filterable", ctx_r1.filterable)("columnMenu", ctx_r1.columnMenuOptions)("columnMenuTemplate", ctx_r1.columnMenuTemplate)("detailTemplate", ctx_r1.detailTemplate)("tabIndex", ctx_r1.navigation.tableEnabled ? "-1" : "0");
  }
}
function GridComponent_ng_container_9_tfoot_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tfoot", 55);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("scrollable", false)("logicalRowIndex", ctx_r1.ariaRowCount)("groups", ctx_r1.group)("columns", ctx_r1.leafColumns)("detailTemplate", ctx_r1.detailTemplate)("totalColumns", ctx_r1.columnsContainer)("totalColumnsCount", ctx_r1.leafColumns.length);
  }
}
function GridComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "table", 49);
    ɵɵelement(2, "colgroup", 50);
    ɵɵtemplate(3, GridComponent_ng_container_9_thead_3_Template, 1, 18, "thead", 51);
    ɵɵelement(4, "tbody", 52);
    ɵɵtemplate(5, GridComponent_ng_container_9_tfoot_5_Template, 1, 7, "tfoot", 53);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("table-layout", ctx_r1.resizable ? "fixed" : null);
    ɵɵproperty("size", ctx_r1.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r1.leafColumns)("groups", ctx_r1.group)("sort", ctx_r1.sort)("detailTemplate", ctx_r1.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideHeader);
    ɵɵadvance();
    ɵɵproperty("isLoading", ctx_r1.loading)("groups", ctx_r1.group)("data", ctx_r1.view)("skip", ctx_r1.skip)("columns", ctx_r1.leafColumns)("selectable", ctx_r1.selectable)("filterable", ctx_r1.filterable)("noRecordsTemplate", ctx_r1.noRecordsTemplate)("detailTemplate", ctx_r1.detailTemplate)("showGroupFooters", ctx_r1.showGroupFooters)("trackBy", ctx_r1.trackBy)("rowClass", ctx_r1.rowClass)("enableDrag", ctx_r1.marqueeSelection);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showFooter);
  }
}
function GridComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 56);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("loadingTemplate", ctx_r1.loadingTemplate);
  }
}
function GridComponent_kendo_grid_status_bar_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-status-bar", 57);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("statusBarTemplate", ctx_r1.statusBarTemplate);
  }
}
function GridComponent_kendo_pager_12_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 25);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const bottomPager_r9 = ɵɵreference(1);
    const ctx_r1 = ɵɵnextContext();
    const defaultPager_r5 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.pagerTemplate ? ctx_r1.pagerTemplate == null ? null : ctx_r1.pagerTemplate.templateRef : defaultPager_r5)("ngTemplateOutletContext", bottomPager_r9.templateContext);
  }
}
function GridComponent_kendo_pager_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-pager", 58, 8);
    ɵɵlistener("pageChange", function GridComponent_kendo_pager_12_Template_kendo_pager_pageChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.notifyPageChange("pager", $event));
    })("pagerInputVisibilityChange", function GridComponent_kendo_pager_12_Template_kendo_pager_pagerInputVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerInput", $event));
    })("pageTextVisibilityChange", function GridComponent_kendo_pager_12_Template_kendo_pager_pageTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerPageText", $event));
    })("itemsTextVisibilityChange", function GridComponent_kendo_pager_12_Template_kendo_pager_itemsTextVisibilityChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePagerVisibilityChange("showPagerItemsText", $event));
    });
    ɵɵtemplate(2, GridComponent_kendo_pager_12_ng_template_2_Template, 1, 2, "ng-template", 23);
    ɵɵelement(3, "kendo-pager-messages", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r1.navigation.pagerEnabled)("pageSize", ctx_r1.pageSize)("total", ctx_r1.view.total)("skip", ctx_r1.skip)("size", ctx_r1.size)("responsive", ctx_r1.normalizedPageableSettings.responsive && !ctx_r1.pagerTemplate)("buttonCount", ctx_r1.normalizedPageableSettings.buttonCount)("info", ctx_r1.normalizedPageableSettings.info)("pageSizeValues", ctx_r1.normalizedPageableSettings.pageSizes)("previousNext", ctx_r1.normalizedPageableSettings.previousNext)("type", ctx_r1.normalizedPageableSettings.type);
    ɵɵadvance(3);
    ɵɵproperty("ariaLabel", ctx_r1.messageFor("pagerLabel"))("firstPage", ctx_r1.messageFor("pagerFirstPage"))("inputLabel", ctx_r1.messageFor("pagerInputLabel"))("previousPage", ctx_r1.messageFor("pagerPreviousPage"))("nextPage", ctx_r1.messageFor("pagerNextPage"))("lastPage", ctx_r1.messageFor("pagerLastPage"))("selectPage", ctx_r1.messageFor("pagerSelectPage"))("page", ctx_r1.messageFor("pagerPage"))("itemsPerPage", ctx_r1.messageFor("pagerItemsPerPage"))("items", ctx_r1.messageFor("pagerItems"))("of", ctx_r1.messageFor("pagerOf"))("pageNumberInputTitle", ctx_r1.messageFor("pagerPageNumberInputTitle"));
  }
}
function GridComponent_kendo_grid_toolbar_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-toolbar", 59);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("navigable", ctx_r1.navigation.toolbarEnabled);
    ɵɵattribute("aria-label", ctx_r1.messageFor("bottomToolbarLabel"))("aria-controls", ctx_r1.ariaRootId);
  }
}
function GridComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 60);
    ɵɵtext(1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.getHintSettings("hintIcon"))("svgIcon", ctx_r1.getHintSettings("hintSVGIcon"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.hintText, " ");
  }
}
function GridComponent_ng_template_16_kendo_pager_prev_buttons_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-prev-buttons", 66);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size);
  }
}
function GridComponent_ng_template_16_kendo_pager_numeric_buttons_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-numeric-buttons", 67);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("buttonCount", ctx_r1.normalizedPageableSettings.buttonCount);
  }
}
function GridComponent_ng_template_16_kendo_pager_input_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-input", 68);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("showPageText", ctx_r1.showPagerPageText);
  }
}
function GridComponent_ng_template_16_kendo_pager_next_buttons_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-next-buttons", 66);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size);
  }
}
function GridComponent_ng_template_16_kendo_pager_page_sizes_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-page-sizes", 69);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("pageSizes", ctx_r1.normalizedPageableSettings.pageSizes)("showItemsText", ctx_r1.showPagerItemsText);
  }
}
function GridComponent_ng_template_16_kendo_pager_info_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-info");
  }
}
function GridComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 61);
    ɵɵtemplate(1, GridComponent_ng_template_16_kendo_pager_prev_buttons_1_Template, 1, 1, "kendo-pager-prev-buttons", 62)(2, GridComponent_ng_template_16_kendo_pager_numeric_buttons_2_Template, 1, 2, "kendo-pager-numeric-buttons", 63)(3, GridComponent_ng_template_16_kendo_pager_input_3_Template, 1, 2, "kendo-pager-input", 64)(4, GridComponent_ng_template_16_kendo_pager_next_buttons_4_Template, 1, 1, "kendo-pager-next-buttons", 62);
    ɵɵelementEnd();
    ɵɵtemplate(5, GridComponent_ng_template_16_kendo_pager_page_sizes_5_Template, 1, 3, "kendo-pager-page-sizes", 65)(6, GridComponent_ng_template_16_kendo_pager_info_6_Template, 1, 0, "kendo-pager-info", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.normalizedPageableSettings.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.normalizedPageableSettings.type === "numeric" && ctx_r1.normalizedPageableSettings.buttonCount > 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.normalizedPageableSettings.type === "input" || ctx_r1.showPagerInput);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.normalizedPageableSettings.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.normalizedPageableSettings.pageSizes);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.normalizedPageableSettings.info);
  }
}
function GridComponent_kendo_grid_adaptive_renderer_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-adaptive-renderer");
  }
}
function GridComponent_div_21_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 70);
  }
}
var append = (element) => {
  if (!isDocumentAvailable()) {
    return;
  }
  let appended = false;
  return () => {
    if (!appended) {
      document.body.appendChild(element);
      appended = true;
    }
    return element;
  };
};
var getDocument$1 = (element) => element.ownerDocument.documentElement;
var getWindow$1 = (element) => element.ownerDocument.defaultView;
var offset2 = (element) => {
  const {
    clientTop,
    clientLeft
  } = getDocument$1(element);
  const {
    pageYOffset,
    pageXOffset
  } = getWindow$1(element);
  const {
    top,
    left: left2
  } = element.getBoundingClientRect();
  return {
    top: top + pageYOffset - clientTop,
    left: left2 + pageXOffset - clientLeft
  };
};
var isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;
var contains$2 = (element, container) => element === container || (container.compareDocumentPosition(element) & 16) !== 0;
var position = (target, before) => {
  const targetRect = offset2(target);
  const {
    offsetWidth: offsetWidth2,
    offsetHeight
  } = target;
  const left2 = targetRect.left + (before ? 0 : offsetWidth2);
  const top = targetRect.top;
  const height2 = offsetHeight;
  return {
    left: left2,
    top,
    height: height2
  };
};
var DragAndDropService = class _DragAndDropService {
  changes = new EventEmitter();
  register = [];
  lastTarget = null;
  add(target) {
    this.register.push(target);
  }
  remove(target) {
    this.register = this.register.filter((current3) => current3 !== target);
  }
  notifyDrag(draggable, element, mouseEvent) {
    const target = this.targetFor(element);
    if (this.lastTarget === target) {
      return;
    }
    this.changes.next({
      draggable,
      mouseEvent,
      target: this.lastTarget,
      type: "leave"
    });
    if (target) {
      this.changes.next({
        draggable,
        mouseEvent,
        target,
        type: "enter"
      });
    }
    this.lastTarget = target;
  }
  notifyDrop(draggable, mouseEvent) {
    const target = draggable && draggable.element && this.targetFor(draggable.element.nativeElement);
    if (target && this.lastTarget === target) {
      this.lastTarget = null;
      return;
    }
    this.changes.next({
      draggable,
      mouseEvent,
      target: this.lastTarget,
      type: "drop"
    });
    this.lastTarget = null;
  }
  targetFor(element) {
    const comparer = contains$2.bind(null, element);
    return this.register.find(({
      element: {
        nativeElement
      }
    }) => comparer(nativeElement));
  }
  static ɵfac = function DragAndDropService_Factory(t) {
    return new (t || _DragAndDropService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragAndDropService,
    factory: _DragAndDropService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropService, [{
    type: Injectable
  }], null, null);
})();
var updateClass = (element, valid, svg) => {
  const icon = element.querySelector(".k-icon");
  if (svg) {
    const svg2 = icon.firstElementChild;
    svg2.removeChild(svg2.firstElementChild);
    const path = valid ? plusIcon.content : cancelIcon.content;
    icon.firstElementChild.innerHTML = path + icon.firstElementChild.innerHTML;
  }
  icon.setAttribute("class", icon.getAttribute("class").replace(/(plus|cancel)/, valid ? "plus" : "cancel"));
};
var updateLock = (element, locked = null, svg) => {
  const icon = element.querySelectorAll(".k-icon")[1];
  const value = locked === null ? "" : locked ? `k${svg ? "-svg" : ""}-i-lock` : `k${svg ? "-svg" : ""}-i-unlock`;
  if (svg) {
    icon.setAttribute("class", icon.getAttribute("class").replace(/(k-svg-i-unlock|k-svg-i-lock)/, "").trim() + ` ${value}`);
    icon.firstElementChild.innerHTML = locked ? lockIcon.content : unlockIcon.content;
  } else {
    icon.setAttribute("class", icon.getAttribute("class").replace(/(k-i-unlock|k-i-lock)/, "").trim() + ` ${value}`);
  }
};
var decorate = (element) => {
  element.className = "k-header k-drag-clue";
  element.style.position = "absolute";
  element.style.zIndex = "20000";
};
var svgIconsMarkup = (viewBox, content2, safeTitle) => `
    <span class="k-icon k-svg-icon k-drag-status k-svg-i-cancel">
        <svg 
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            viewBox="${viewBox}"
            aria-hidden="true">
            ${content2}
        </svg>
        <span class="k-icon k-svg-icon k-icon-modifier">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                viewBox="${viewBox}"
                aria-hidden="true">
            </svg>
        </span>
    </span>
    ${safeTitle}`;
var fontIconsMarkup = (safeTitle) => `
    <span class="k-icon k-font-icon k-drag-status k-i-cancel">
        <span class="k-icon k-font-icon k-icon-modifier"></span>
    </span>
    ${safeTitle}`;
var DragHintService = class _DragHintService {
  sanitizer;
  iconsService;
  dom;
  cancelIcon = cancelIcon;
  constructor(sanitizer, iconsService) {
    this.sanitizer = sanitizer;
    this.iconsService = iconsService;
  }
  ngOnDestroy() {
    this.remove();
  }
  create(title) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dom = document.createElement("div");
    decorate(this.dom);
    const safeTitle = this.sanitizer.sanitize(SecurityContext.HTML, title);
    const innerHtml = this.isSVG ? svgIconsMarkup(this.cancelIcon.viewBox, this.cancelIcon.content, safeTitle) : fontIconsMarkup(safeTitle);
    this.dom.innerHTML = innerHtml;
  }
  attach() {
    return append(this.dom);
  }
  remove() {
    if (this.dom && this.dom.parentNode) {
      (function(el) {
        setTimeout(() => document.body.removeChild(el));
      })(this.dom);
      this.dom = null;
    }
  }
  show() {
    this.dom.style.display = "";
  }
  hide() {
    this.dom.style.display = "none";
  }
  enable() {
    updateClass(this.dom, true, this.isSVG);
  }
  disable() {
    updateClass(this.dom, false, this.isSVG);
  }
  removeLock() {
    updateLock(this.dom, false, this.isSVG);
  }
  toggleLock(locked) {
    updateLock(this.dom, locked, this.isSVG);
  }
  move(move) {
    this.dom.style.top = move.pageY + "px";
    this.dom.style.left = move.pageX + "px";
  }
  get isSVG() {
    return (this.iconsService.iconSettings?.type || this.iconsService.changes.value.type) === "svg";
  }
  static ɵfac = function DragHintService_Factory(t) {
    return new (t || _DragHintService)(ɵɵinject(DomSanitizer), ɵɵinject(IconsService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragHintService,
    factory: _DragHintService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragHintService, [{
    type: Injectable
  }], function() {
    return [{
      type: DomSanitizer
    }, {
      type: IconsService
    }];
  }, null);
})();
var DropCueService = class _DropCueService {
  dom;
  create() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dom = document.createElement("div");
    this.dom.className = "k-grouping-dropclue";
    this.hide();
  }
  attach() {
    return append(this.dom);
  }
  remove() {
    if (this.dom && this.dom.parentElement) {
      document.body.removeChild(this.dom);
      this.dom = null;
    }
  }
  hide() {
    this.dom.style.display = "none";
  }
  position({
    left: left2,
    top,
    height: height2
  }) {
    this.dom.style.display = "block";
    this.dom.style.height = height2 + "px";
    this.dom.style.top = top + "px";
    const width2 = this.dom.offsetWidth / 2;
    this.dom.style.left = left2 - width2 + "px";
  }
  static ɵfac = function DropCueService_Factory(t) {
    return new (t || _DropCueService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DropCueService,
    factory: _DropCueService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropCueService, [{
    type: Injectable
  }], null, null);
})();
var EMPTY_REGEX = /^\s*$/;
var isPresent4 = (value) => value !== null && value !== void 0;
var isBlank = (value) => value === null || value === void 0;
var isArray = (value) => Array.isArray(value);
var isTruthy = (value) => !!value;
var isNullOrEmptyString = (value) => isBlank(value) || EMPTY_REGEX.test(value);
var observe = (list2) => merge(of(list2), list2.changes);
var isUniversal = () => typeof document === "undefined";
var isString = (value) => typeof value === "string";
var isNumber2 = (value) => typeof value === "number" && !isNaN(value);
var extractFormat = (format) => {
  if (isString(format) && !isNullOrEmptyString(format) && format.startsWith("{0:")) {
    return format.slice(3, format.length - 1);
  }
  return format;
};
var not = (fn) => (...args) => !fn(...args);
var or = (...conditions) => (value) => conditions.reduce((acc, x) => acc || x(value), false);
var and = (...conditions) => (value) => conditions.reduce((acc, x) => acc && x(value), true);
var Skip = new InjectionToken("Skip");
var createPromise = () => {
  let resolveFn, rejectFn;
  const promise = new Promise((resolve2, reject) => {
    resolveFn = (data) => {
      resolve2(data);
      return promise;
    };
    rejectFn = (data) => {
      reject(data);
      return promise;
    };
  });
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  return promise;
};
var iterator = getIterator$1();
function getIterator$1() {
  if (typeof Symbol === "function" && Symbol.iterator) {
    return Symbol.iterator;
  }
  const keys = Object.getOwnPropertyNames(Map.prototype);
  const proto = Map.prototype;
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (key !== "entries" && key !== "size" && proto[key] === proto.entries) {
      return key;
    }
  }
}
var FRAME_DURATION2 = 1e3 / 60;
var wnd = typeof window !== "undefined" ? window : {};
var requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || ((callback) => setTimeout(callback, FRAME_DURATION2));
var cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;
var nodesToArray = (nodes) => [].slice.call(nodes);
var replaceMessagePlaceholder2 = (message, name, value) => (message ?? "").replace(new RegExp(`{\\s*${name}\\s*}`, "g"), value);
var recursiveFlatMap = (item) => isGroupResult(item) ? item.items.flatMap(recursiveFlatMap) : [__spreadValues({}, item)];
var mapColumnItemState = (c) => ({
  id: c.id,
  width: c.width,
  hidden: c.hidden,
  locked: c.locked,
  sticky: c.sticky,
  orderIndex: c.orderIndex
});
var recursiveColumnsFlatMap = (item) => item.isColumnGroup || item.isSpanColumn ? [mapColumnItemState(item), ...item.children.toArray().flatMap(recursiveColumnsFlatMap)] : [mapColumnItemState(item)];
var isGroupResult = (obj) => {
  return "aggregates" in obj && "items" in obj && "field" in obj && "value" in obj;
};
var roundDown = (value) => Math.floor(value * 100) / 100;
var defaultCellRowSpan = (row2, column, data) => {
  const field = column.field;
  let rowspan = 1;
  const rowIndex = row2.index;
  if (!data[0].items) {
    rowspan = findRowSpan(data, rowIndex, field);
  } else {
    const group = row2.dataItem.group;
    if (field === group.data.field) {
      rowspan = group.data.items.length;
    } else {
      const rowIndex2 = row2.dataItem.group.data.items.indexOf(row2.dataItem.data);
      const groupItems = row2.dataItem.group.data.items;
      rowspan = findRowSpan(groupItems, rowIndex2, field);
    }
  }
  return rowspan;
};
var findRowSpan = (data, index, field) => {
  let rowspan = 1;
  if (typeof data[index][field]?.getTime === "function") {
    while (data[index][field].getTime() === data[index + 1]?.[field].getTime()) {
      rowspan++;
      index++;
    }
  } else {
    while (data[index][field] === data[index + 1]?.[field]) {
      rowspan++;
      index++;
    }
  }
  return rowspan;
};
var isMultipleRangesEnabled = (selectableSettings) => {
  return selectableSettings && typeof selectableSettings === "object" && selectableSettings.selectable.multipleRanges;
};
var FOCUS_ROOT_ACTIVE = new InjectionToken("focus-root-initial-active-state");
var FocusRoot = class _FocusRoot {
  active;
  groups = /* @__PURE__ */ new Set();
  constructor(active = false) {
    this.active = active;
  }
  registerGroup(group) {
    if (this.active) {
      this.groups.add(group);
    }
  }
  unregisterGroup(group) {
    if (this.active) {
      this.groups.delete(group);
    }
  }
  activate() {
    if (this.active) {
      this.groups.forEach((f) => f.activate());
    }
  }
  deactivate() {
    if (this.active) {
      this.groups.forEach((f) => f.deactivate());
    }
  }
  static ɵfac = function FocusRoot_Factory(t) {
    return new (t || _FocusRoot)(ɵɵinject(FOCUS_ROOT_ACTIVE, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusRoot,
    factory: _FocusRoot.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusRoot, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [FOCUS_ROOT_ACTIVE]
      }]
    }];
  }, null);
})();
var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
var NODE_NAME_PREDICATES = {};
var toClassList = (classNames) => String(classNames).trim().split(" ");
var hasClasses = (element, classNames) => {
  const namesList = toClassList(classNames);
  return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
var matchesClasses = (classNames) => (element) => hasClasses(element, classNames);
var matchesNodeName = (nodeName) => {
  if (!NODE_NAME_PREDICATES[nodeName]) {
    NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
  }
  return NODE_NAME_PREDICATES[nodeName];
};
var closest3 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var closestInScope2 = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var contains$1 = (parent, node, matchSelf = false) => {
  const outside = !closest3(node, (child) => child === parent);
  if (outside) {
    return false;
  }
  const el = closest3(node, (child) => child === node);
  return el && (matchSelf || el !== parent);
};
var isVisible = (element) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const rect = element.getBoundingClientRect();
  const hasSize = rect.width > 0 && rect.height > 0;
  const hasPosition2 = rect.x !== 0 && rect.y !== 0;
  return (hasSize || hasPosition2) && window.getComputedStyle(element).visibility !== "hidden";
};
var isFocusable2 = (element) => {
  if (!element.tagName) {
    return false;
  }
  const tagName = element.tagName.toLowerCase();
  const hasTabIndex = Boolean(element.getAttribute("tabIndex"));
  const focusable = !element.disabled && focusableRegex.test(tagName);
  return focusable || hasTabIndex;
};
var isFocusableWithTabKey = (element, checkVisibility = true) => {
  if (!isFocusable2(element)) {
    return false;
  }
  const visible = !checkVisibility || isVisible(element);
  const ariaHidden = element.getAttribute("aria-hidden") === "true";
  const tabIndex = element.getAttribute("tabIndex");
  return visible && !ariaHidden && tabIndex !== "-1";
};
var findElement = (node, predicate, matchSelf = true) => {
  if (!node) {
    return;
  }
  if (matchSelf && predicate(node)) {
    return node;
  }
  node = node.firstChild;
  while (node) {
    if (node.nodeType === 1) {
      const element = findElement(node, predicate);
      if (element) {
        return element;
      }
    }
    node = node.nextSibling;
  }
};
var findFocusable = (element, checkVisibility = true) => {
  return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};
var findFocusableChild = (element, checkVisibility = true) => {
  return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
function rtlScrollPosition(position2, element, initial) {
  let result = position2;
  if (initial < 0) {
    result = -position2;
  } else if (initial > 0) {
    result = element.scrollWidth - element.offsetWidth - position2;
  }
  return result;
}
var isButton = matchesNodeName("button");
var isInputTag = matchesNodeName("input");
var isKendoInputTag = matchesNodeName("kendo-checkbox") || matchesNodeName("kendo-textbox");
var navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;
var isNavigableInput = (element) => isInputTag(element) && navigableRegex.test(element.type);
var isNavigable = (element) => !element.disabled && (isButton(element) || isNavigableInput(element) || isKendoInputTag(element));
var DefaultFocusableElement = class {
  renderer;
  get enabled() {
    return this.focusable && !this.focusable.disabled;
  }
  get visible() {
    return this.focusable && isVisible(this.focusable);
  }
  element;
  focusable;
  constructor(host, renderer) {
    this.renderer = renderer;
    this.element = host.nativeElement;
    this.focusable = findFocusable(this.element, false) || this.element;
  }
  isNavigable() {
    return this.canFocus() && isNavigable(this.element);
  }
  toggle(active) {
    this.renderer.setAttribute(this.focusable, "tabIndex", active ? "0" : "-1");
  }
  focus() {
    if (this.focusable) {
      this.focusable.focus();
    }
  }
  canFocus() {
    return this.visible && this.enabled;
  }
  hasFocus() {
    return isDocumentAvailable() && document.activeElement !== this.element && closest3(document.activeElement, (e) => e === this.element);
  }
};
var CELL_CONTEXT = new InjectionToken("grid-cell-context");
var EMPTY_CELL_CONTEXT = {};
var GridToolbarNavigationService = class _GridToolbarNavigationService {
  renderer;
  navigableElements = [];
  currentActiveIndex = 0;
  defaultFocusableSelector = `
        [kendogridtoolbarfocusable],
        [kendogridaddcommand],
        [kendogridcancelcommand],
        [kendogrideditcommand],
        [kendogridremovecommand],
        [kendogridsavecommand],
        [kendogridexcelcommand],
        [kendogridpdfcommand]
    `;
  constructor(renderer) {
    this.renderer = renderer;
  }
  notify() {
    this.navigableElements = this.navigableElements.length && this.navigableElements[0]?.parentElement ? Array.from(this.navigableElements[0]?.parentElement?.querySelectorAll(this.defaultFocusableSelector) || []) : [];
    this.currentActiveIndex = 0;
    this.updateFocus();
  }
  focus() {
    this.navigableElements[this.currentActiveIndex]?.focus();
  }
  updateFocus() {
    if (!this.navigableElements.length) {
      return;
    }
    this.navigableElements.forEach((el) => {
      this.renderer.setAttribute(el, "tabindex", "-1");
    });
    this.renderer.setAttribute(this.navigableElements[this.currentActiveIndex], "tabindex", "0");
    if (isDocumentAvailable() && document.activeElement.closest(".k-toolbar")) {
      this.navigableElements[this.currentActiveIndex].focus();
    }
  }
  static ɵfac = function GridToolbarNavigationService_Factory(t) {
    return new (t || _GridToolbarNavigationService)(ɵɵinject(Renderer2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _GridToolbarNavigationService,
    factory: _GridToolbarNavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridToolbarNavigationService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, null);
})();
var ContextService = class _ContextService {
  renderer;
  localization;
  grid;
  topToolbarNavigation;
  bottomToolbarNavigation;
  navigable;
  groupBindingDirective;
  constructor(renderer, localization) {
    this.renderer = renderer;
    this.localization = localization;
    this.topToolbarNavigation = new GridToolbarNavigationService(this.renderer);
    this.bottomToolbarNavigation = new GridToolbarNavigationService(this.renderer);
  }
  static ɵfac = function ContextService_Factory(t) {
    return new (t || _ContextService)(ɵɵinject(Renderer2), ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContextService,
    factory: _ContextService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: LocalizationService
    }];
  }, null);
})();
var FocusableDirective = class _FocusableDirective {
  cellContext;
  hostElement;
  renderer;
  ctx;
  active = true;
  group;
  element;
  _enabled = true;
  /**
   * @hidden
   */
  set enabled(value) {
    if (value === "") {
      value = true;
    } else {
      value = Boolean(value);
    }
    if (value !== this.enabled) {
      this._enabled = value;
      if (this.element) {
        this.element.toggle(this.active && value);
      }
    }
  }
  get enabled() {
    return this._enabled;
  }
  constructor(cellContext, hostElement, renderer, ctx) {
    this.cellContext = cellContext;
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.ctx = ctx;
    if (this.cellContext) {
      this.group = this.cellContext.focusGroup;
    }
    if (this.group) {
      this.group.registerElement(this);
    }
  }
  ngAfterViewInit() {
    if (!this.element && this.ctx.navigable) {
      this.element = new DefaultFocusableElement(this.hostElement, this.renderer);
    }
    if (this.group && this.element) {
      this.toggle(this.group.isActive);
    }
  }
  ngOnDestroy() {
    if (this.group) {
      this.group.unregisterElement(this);
    }
  }
  /**
   * @hidden
   */
  toggle(active) {
    if (this.element && active !== this.active) {
      this.element.toggle(this.enabled && active);
      this.active = active;
    }
  }
  /**
   * @hidden
   */
  canFocus() {
    return this.enabled && this.element && this.element.canFocus();
  }
  /**
   * @hidden
   */
  isNavigable() {
    return this.enabled && this.element && this.element.isNavigable();
  }
  /**
   * @hidden
   */
  focus() {
    if (this.enabled && this.element) {
      this.element.focus();
    }
  }
  /**
   * @hidden
   */
  hasFocus() {
    return this.enabled && this.element && this.element.hasFocus();
  }
  /**
   * @hidden
   */
  registerElement(element) {
    this.element = element;
  }
  static ɵfac = function FocusableDirective_Factory(t) {
    return new (t || _FocusableDirective)(ɵɵdirectiveInject(CELL_CONTEXT, 12), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FocusableDirective,
    selectors: [["", "kendoGridFocusable", ""], ["", "kendoGridEditCommand", ""], ["", "kendoGridRemoveCommand", ""], ["", "kendoGridSaveCommand", ""], ["", "kendoGridCancelCommand", ""], ["", "kendoGridSelectionCheckbox", ""]],
    inputs: {
      enabled: [InputFlags.None, "kendoGridFocusable", "enabled"]
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusableDirective, [{
    type: Directive,
    args: [{
      selector: `[kendoGridFocusable],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridCancelCommand],
        [kendoGridSelectionCheckbox]
    `,
      standalone: true
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CELL_CONTEXT]
      }, {
        type: SkipSelf
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }];
  }, {
    enabled: [{
      type: Input,
      args: ["kendoGridFocusable"]
    }]
  });
})();
var GridFocusableElement = class {
  navigationService;
  constructor(navigationService) {
    this.navigationService = navigationService;
  }
  focus() {
    this.navigationService.focusCell();
  }
  toggle(active) {
    this.navigationService.toggle(active);
  }
  canFocus() {
    return true;
  }
  hasFocus() {
    return this.navigationService.hasFocus();
  }
  isNavigable() {
    return false;
  }
};
var NavigationCursor = class {
  model;
  changes = new Subject();
  set metadata(value) {
    this._metadata = value;
    if (isPresent4(value)) {
      const newActiveCol = value.hasDetailTemplate ? 1 : 0;
      const shouldChange = this.activeRow < value.headerRows && this.activeCol === 0;
      if (shouldChange && newActiveCol !== this.activeCol) {
        this.activeCol = newActiveCol;
        this.reset();
      }
    }
  }
  get metadata() {
    return this._metadata;
  }
  activeRow = 0;
  activeCol = 0;
  virtualCol = 0;
  virtualRow = 0;
  _metadata;
  get row() {
    return this.model.findRow(this.activeRow);
  }
  get cell() {
    const row2 = this.row;
    if (row2) {
      return this.model.findCell(this.activeCol, row2);
    }
  }
  get dataRowIndex() {
    const row2 = this.row;
    if (row2) {
      return row2.dataRowIndex;
    }
    return -1;
  }
  constructor(model) {
    this.model = model;
  }
  /**
   * Assumes and announces a new cursor position.
   */
  reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {
    if (this.activate(rowIndex, colIndex, force)) {
      this.virtualRow = rowIndex;
      this.virtualCol = colIndex;
    }
  }
  activate(rowIndex, colIndex, force) {
    if (!force && this.isActiveRange(rowIndex, colIndex)) {
      return false;
    }
    const prevColIndex = this.activeCol;
    const prevRowIndex = this.activeRow;
    this.activeCol = colIndex;
    this.activeRow = rowIndex;
    this.changes.next({
      colIndex,
      prevColIndex,
      prevRowIndex,
      rowIndex
    });
    return true;
  }
  isActiveRange(rowIndex, colIndex) {
    if (this.activeRow !== rowIndex) {
      return false;
    }
    const cell2 = this.cell;
    const {
      start,
      end: end2
    } = this.model.cellRange(cell2);
    return !cell2 || start <= colIndex && colIndex <= end2;
  }
  /**
   * Assumes a new cursor position without announcing it.
   */
  assume(rowIndex = this.activeRow, colIndex = this.activeCol) {
    this.virtualRow = rowIndex;
    this.virtualCol = colIndex;
    this.activeCol = colIndex;
    this.activeRow = rowIndex;
  }
  /**
   * Announces a current cursor position to subscribers.
   */
  announce() {
    this.changes.next({
      colIndex: this.activeCol,
      prevColIndex: this.activeCol,
      prevRowIndex: this.activeRow,
      rowIndex: this.activeRow
    });
  }
  activateVirtualCell(cell2) {
    const rowRange = this.model.rowRange(cell2);
    const cellRange = this.model.cellRange(cell2);
    const activeCol = this.activeCol;
    const activeRow = this.activeRow;
    if (rowRange.start <= activeRow && activeRow <= rowRange.end && cellRange.start <= activeCol && activeCol <= cellRange.end) {
      this.activeRow = cell2.rowIndex;
      this.activeCol = cell2.colIndex;
      return true;
    }
  }
  isActive(rowIndex, colIndex) {
    return this.activeCol === colIndex && this.activeRow === rowIndex;
  }
  moveUp(offset3 = 1) {
    return this.offsetRow(-offset3);
  }
  moveDown(offset3 = 1) {
    return this.offsetRow(offset3);
  }
  moveLeft(offset3 = 1) {
    return this.offsetCol(-offset3);
  }
  moveRight(offset3 = 1) {
    return this.offsetCol(offset3);
  }
  lastCellIndex(row2) {
    return this.metadata.columns.leafColumnsToRender.length - 1 + (this.metadata.hasDetailTemplate && (!row2 || !row2.groupItem) ? 1 : 0);
  }
  offsetCol(offset3) {
    const prevRow = this.model.findRow(this.virtualRow);
    const lastIndex = this.lastCellIndex(prevRow);
    const virtualCol = this.virtualCol;
    this.virtualCol = Math.max(0, Math.min(virtualCol + offset3, lastIndex));
    let nextColIndex = this.virtualCol;
    const nextRowIndex = this.virtualRow;
    let cell2 = this.model.findCell(this.virtualCol, prevRow);
    if (!cell2 && this.metadata.virtualColumns) {
      return this.activate(nextRowIndex, nextColIndex);
    }
    if (!cell2 && this.metadata.hasDetailTemplate) {
      this.virtualCol += 1;
      return false;
    }
    if (cell2.colSpan > 1 && cell2.colIndex <= virtualCol && virtualCol < cell2.colIndex + cell2.colSpan) {
      nextColIndex = offset3 > 0 ? Math.min(cell2.colIndex + cell2.colSpan, lastIndex) : Math.max(0, cell2.colIndex + offset3);
      const nextCell = this.model.findCell(nextColIndex, prevRow);
      if (!nextCell) {
        this.virtualCol = nextColIndex;
        return this.activate(cell2.rowIndex, nextColIndex);
      }
      if (cell2 !== nextCell) {
        cell2 = nextCell;
        this.virtualCol = cell2.colIndex;
      } else {
        this.virtualCol = virtualCol;
      }
      return this.activate(cell2.rowIndex, this.virtualCol);
    }
    this.virtualCol = cell2.colIndex;
    return this.activate(cell2.rowIndex, cell2.colIndex);
  }
  offsetRow(offset3) {
    let nextColIndex = this.virtualCol;
    if (this.metadata && this.metadata.isVirtual) {
      const maxIndex = this.metadata.maxLogicalRowIndex;
      let nextIndex = Math.max(0, Math.min(this.activeRow + offset3, maxIndex));
      if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {
        nextIndex = offset3 > 0 ? nextIndex + 1 : nextIndex - 1;
        nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));
      }
      if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {
        if (this.model.lastRow.index !== maxIndex) {
          nextIndex--;
        }
      }
      const nextRow2 = this.model.findRow(nextIndex);
      if (nextRow2) {
        let cell3 = this.model.findCell(this.virtualCol, nextRow2);
        if (!cell3) {
          return;
        }
        if (cell3.rowIndex <= this.virtualRow && offset3 > 0 && cell3.rowSpan > 1) {
          cell3 = this.model.findCell(this.virtualCol, this.model.findRow(cell3.rowIndex + cell3.rowSpan - 1 + offset3));
          if (!cell3) {
            return;
          }
        }
        nextIndex = cell3.rowIndex;
        nextColIndex = cell3.colIndex;
      }
      this.virtualRow = nextIndex;
      return this.activate(nextIndex, nextColIndex);
    }
    const nextRow = this.model.findRow(this.virtualRow + offset3) || this.model.nextRow(this.virtualRow, offset3);
    if (!nextRow) {
      return false;
    }
    let cell2 = this.model.findCell(this.virtualCol, nextRow);
    if (cell2 && cell2.rowIndex <= this.virtualRow && offset3 > 0 && cell2.rowSpan > 1) {
      const nextPos = cell2.rowIndex + cell2.rowSpan - 1 + offset3;
      cell2 = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));
    }
    if (!cell2 && (this.metadata.virtualColumns || this.metadata.hasDetailTemplate)) {
      return this.activate(this.virtualRow + offset3, this.virtualCol);
    }
    this.virtualRow = cell2.rowIndex;
    return this.activate(this.virtualRow, cell2.colIndex);
  }
};
var ItemMap = class {
  count = 0;
  items = {};
  get first() {
    if (this.count > 0) {
      let result;
      this.forEach((item) => {
        result = item;
        return true;
      });
      return result;
    }
  }
  get last() {
    if (this.count > 0) {
      const keys = Object.keys(this.items);
      return this.items[keys[keys.length - 1]];
    }
  }
  removeItem(key) {
    if (this.items[key]) {
      delete this.items[key];
      this.count--;
    }
  }
  setItem(key, item) {
    if (!this.items[key]) {
      this.count++;
    }
    this.items[key] = item;
  }
  getItem(key) {
    return this.items[key];
  }
  toArray() {
    const result = [];
    this.forEach((item) => {
      result.push(item);
    });
    return result;
  }
  forEach(callback) {
    for (const key in this.items) {
      if (this.items.hasOwnProperty(key) && callback(this.items[key])) {
        return this.items[key];
      }
    }
  }
  find(callback) {
    return this.forEach(callback);
  }
};
var NavigationModel = class {
  rows = new ItemMap();
  get firstRow() {
    return this.rows.first;
  }
  get lastRow() {
    return this.rows.last;
  }
  registerCell(cell2) {
    const row2 = this.rows.getItem(cell2.logicalRowIndex);
    if (!row2) {
      return;
    }
    const colIndex = cell2.logicalColIndex;
    const modelCell = {
      uid: cell2.uid,
      colIndex,
      rowIndex: row2.index,
      colSpan: cell2.colSpan,
      rowSpan: cell2.rowSpan,
      detailExpandCell: cell2.detailExpandCell,
      dataItem: row2.dataItem,
      dataRowIndex: row2.dataRowIndex,
      focusGroup: cell2.focusGroup
    };
    row2.cells.setItem(colIndex, modelCell);
    if (cell2.groupItem) {
      row2.groupItem = cell2.groupItem;
    }
    return modelCell;
  }
  unregisterCell(index, rowIndex, cell2) {
    const row2 = this.rows.getItem(rowIndex);
    if (row2) {
      const match = row2.cells.getItem(index);
      if (match && match.uid === cell2.uid) {
        row2.cells.removeItem(index);
      }
    }
  }
  registerRow(row2) {
    const modelRow = {
      uid: row2.uid,
      index: row2.logicalRowIndex,
      dataItem: row2.dataItem,
      dataRowIndex: row2.dataRowIndex,
      cells: new ItemMap()
    };
    this.rows.setItem(row2.logicalRowIndex, modelRow);
  }
  updateRow(row2) {
    const current3 = this.rows.getItem(row2.logicalRowIndex);
    if (current3) {
      Object.assign(current3, {
        dataItem: row2.dataItem,
        dataRowIndex: row2.dataRowIndex
      });
    }
  }
  unregisterRow(index, row2) {
    const match = this.rows.getItem(index);
    if (match && match.uid === row2.uid) {
      this.rows.removeItem(index);
    }
  }
  cellRange(cell2) {
    if (cell2) {
      const start = cell2.colIndex;
      const end2 = cell2.colIndex + (cell2.colSpan || 1) - 1;
      return {
        start,
        end: end2
      };
    }
    return {};
  }
  rowRange(cell2) {
    if (cell2) {
      const start = cell2.rowIndex;
      const end2 = cell2.rowIndex + (cell2.rowSpan || 1) - 1;
      return {
        start,
        end: end2
      };
    }
    return {};
  }
  nextRow(rowIndex, offset3) {
    const rows = this.rows.toArray();
    const row2 = this.rows.getItem(rowIndex);
    const position2 = rows.indexOf(row2);
    const next = rows[position2 + offset3];
    return next;
  }
  findRow(index) {
    return this.rows.getItem(index);
  }
  findCell(index, row2) {
    if (!row2) {
      return;
    }
    const rowIndex = row2.index;
    let cell2 = row2.cells.getItem(index);
    let currentIndex = rowIndex;
    while (!cell2 && row2) {
      row2 = this.rows.getItem(currentIndex);
      cell2 = this.rowCell(index, row2);
      currentIndex--;
    }
    if (cell2 && rowIndex <= row2.index + (cell2.rowSpan || 1) - 1) {
      return cell2;
    }
  }
  rowCell(index, row2) {
    if (!row2 || !row2.cells.count) {
      return;
    }
    const firstCell = row2.cells.first;
    let cell2, currentIndex = index;
    while (!cell2 && currentIndex >= firstCell.colIndex) {
      cell2 = row2.cells.getItem(currentIndex);
      currentIndex--;
    }
    if (cell2 && index <= cell2.colIndex + (cell2.colSpan || 1) - 1) {
      return cell2;
    }
  }
};
var DomEventsService = class _DomEventsService {
  cellClick = new EventEmitter();
  cellMousedown = new EventEmitter();
  cellMouseup = new EventEmitter();
  click = new EventEmitter();
  keydown = new EventEmitter();
  shiftKeyup = new EventEmitter();
  focus = new EventEmitter();
  focusIn = new EventEmitter();
  focusOut = new EventEmitter();
  windowBlur = new EventEmitter();
  paste = new EventEmitter();
  static ɵfac = function DomEventsService_Factory(t) {
    return new (t || _DomEventsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DomEventsService,
    factory: _DomEventsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsService, [{
    type: Injectable
  }], null, null);
})();
var PreventableEvent4 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses
   * the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns a respective boolean if the event was prevented
   * by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var CellCloseEvent = class extends PreventableEvent4 {
  isNew;
  dataItem;
  rowIndex;
  sender;
  /**
   * @hidden
   */
  action = "cellClose";
  /**
   * The Grid column that will be closed.
   */
  column;
  /**
   * The [FormGroup](link:site.data.urls.angular['formgroupapi']) that is used to edit the cell which will be closed.
   */
  formGroup;
  /**
   * The DOM event that caused the `cellClose` event.
   * May not be present if `cellClose` was caused by an API call.
   */
  originalEvent;
  constructor(options) {
    super();
    Object.assign(this, options);
  }
};
var isEqual2 = (index) => (item) => item.index === index;
var isNotEqual = (index) => (item) => item.index !== index;
var isNewRow = (index) => index === -1 || index === void 0;
var EditService = class _EditService {
  ngZone;
  changes = new EventEmitter();
  changed;
  editedIndices = [];
  newItemGroup;
  keepEditCell = false;
  keepCellTimeout;
  column;
  closingCell = false;
  changedSource = new Subject();
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));
  }
  editRow(index, group = void 0) {
    this.editedIndices.push({
      index,
      group
    });
    this.onChanged();
  }
  addRow(group) {
    this.newItemGroup = {
      group
    };
    this.onChanged();
  }
  editCell(rowIndex, column, group) {
    if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {
      return;
    }
    this.preventCellClose();
    if (!this.closeCell()) {
      this.editRow(rowIndex, group);
      this.column = column;
      this.onChanged();
    }
  }
  isEditing() {
    return this.editedIndices.length > 0;
  }
  isEditingCell() {
    return this.isEditing() && this.column !== void 0;
  }
  get hasNewItem() {
    return isPresent4(this.newItemGroup);
  }
  get newDataItem() {
    if (this.hasNewItem) {
      return this.newItemGroup.group.value;
    }
    return {};
  }
  close(index) {
    if (isNewRow(index)) {
      this.newItemGroup = void 0;
      return;
    }
    this.editedIndices = this.editedIndices.filter(isNotEqual(index));
    delete this.column;
    this.onChanged();
  }
  closeCell(originalEvent) {
    if (this.column && !this.closingCell) {
      return this.ngZone.run(() => {
        const {
          index,
          group
        } = this.editedIndices[0];
        const args = new CellCloseEvent({
          column: this.column,
          formGroup: group,
          originalEvent,
          rowIndex: index
        });
        this.closingCell = true;
        this.changes.emit(args);
        this.closingCell = false;
        if (!args.isDefaultPrevented()) {
          this.cancelCell();
        }
        return args.isDefaultPrevented();
      });
    }
  }
  cancelCell() {
    if (this.column) {
      this.editedIndices = [];
      delete this.column;
      this.onChanged();
    }
  }
  shouldCloseCell() {
    return this.column && !this.keepEditCell;
  }
  preventCellClose() {
    this.ngZone.runOutsideAngular(() => {
      window.clearTimeout(this.keepCellTimeout);
      this.keepEditCell = true;
      this.keepCellTimeout = window.setTimeout(() => {
        this.keepEditCell = false;
      }, 0);
    });
  }
  context(index) {
    if (isNewRow(index)) {
      return this.newItemGroup;
    }
    return this.findByIndex(index);
  }
  columnContext(index, column) {
    if (isNewRow(index)) {
      return this.newItemGroup;
    }
    if (!this.column || column === this.column) {
      return this.findByIndex(index);
    }
  }
  isEdited(index) {
    if (isNewRow(index) && isPresent4(this.newItemGroup)) {
      return true;
    }
    return !this.column && isPresent4(this.findByIndex(index));
  }
  hasEdited(index) {
    return isPresent4(this.context(index));
  }
  isEditedColumn(index, column) {
    if (this.column && this.column === column) {
      return isPresent4(this.findByIndex(index));
    }
    return false;
  }
  beginEdit(rowIndex) {
    this.changes.emit({
      action: "edit",
      rowIndex
    });
  }
  beginAdd() {
    this.changes.emit({
      action: "add",
      isNew: true
    });
  }
  endEdit(rowIndex) {
    const {
      group: formGroup
    } = this.context(rowIndex);
    this.changes.emit({
      action: "cancel",
      rowIndex,
      formGroup,
      isNew: isNewRow(rowIndex)
    });
  }
  save(rowIndex) {
    const {
      group: formGroup
    } = this.context(rowIndex);
    this.changes.emit({
      action: "save",
      rowIndex,
      formGroup,
      isNew: isNewRow(rowIndex)
    });
  }
  remove(rowIndex) {
    this.changes.emit({
      action: "remove",
      rowIndex
    });
  }
  findByIndex(index) {
    return this.editedIndices.find(isEqual2(index));
  }
  onChanged() {
    this.ngZone.runOutsideAngular(() => {
      this.changedSource.next();
    });
  }
  static ɵfac = function EditService_Factory(t) {
    return new (t || _EditService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _EditService,
    factory: _EditService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var getGroupRowArgs = (groupItem) => {
  if (!isPresent4(groupItem)) {
    return null;
  }
  return {
    group: groupItem.data,
    groupIndex: groupItem.index,
    parentGroup: getGroupRowArgs(groupItem.parentGroup)
  };
};
var isChildIndex = (targetIndex, parentIndex) => {
  const sameIndex = parentIndex === targetIndex;
  const lastSeparatorIndex = targetIndex.lastIndexOf("_");
  const sameSubGroupIndex = targetIndex.substring(0, lastSeparatorIndex) === parentIndex;
  return !sameIndex && sameSubGroupIndex;
};
var GroupsService = class _GroupsService {
  changes = new Subject();
  userCallback;
  rowState = /* @__PURE__ */ new Set();
  reset() {
    this.rowState.clear();
  }
  ngOnDestroy() {
    this.reset();
  }
  isExpanded(groupArgs) {
    if (this.userCallback) {
      return this.userCallback(groupArgs);
    }
    return !this.rowState.has(groupArgs.groupIndex);
  }
  isInExpandedGroup(groupItem) {
    let expanded = true;
    while (groupItem && expanded) {
      expanded = this.isExpanded({
        group: groupItem.data,
        groupIndex: groupItem.index,
        parentGroup: getGroupRowArgs(groupItem.parentGroup)
      });
      groupItem = groupItem.parentGroup;
    }
    return expanded;
  }
  toggleRow(groupItem, emit2 = true) {
    const parentGroup = getGroupRowArgs(groupItem.parentGroup);
    const expand = !this.isExpanded({
      group: groupItem.data,
      groupIndex: groupItem.index,
      parentGroup
    });
    this.changes.next({
      group: groupItem.data,
      expand,
      groupIndex: groupItem.index,
      parentGroup,
      emit: emit2
    });
    if (this.userCallback) {
      return;
    }
    if (expand) {
      this.rowState.delete(groupItem.index);
    } else {
      this.rowState.add(groupItem.index);
    }
  }
  expandChildren(parentIndex) {
    this.rowState.forEach((index) => isChildIndex(index, parentIndex) && this.rowState.delete(index));
  }
  static ɵfac = function GroupsService_Factory(t) {
    return new (t || _GroupsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _GroupsService,
    factory: _GroupsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupsService, [{
    type: Injectable
  }], null, null);
})();
var DetailCollapseEvent = class extends PreventableEvent4 {
  /**
   * The collapsed row `dataItem`.
   */
  dataItem;
  /**
   * The collapsed row index.
   */
  index;
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DetailExpandEvent = class extends PreventableEvent4 {
  /**
   * The expanded row `dataItem`.
   */
  dataItem;
  /**
   * The expanded row index.
   */
  index;
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DetailsService = class _DetailsService {
  userCallback;
  changes = new Subject();
  rowState = /* @__PURE__ */ new Set();
  ngOnDestroy() {
    this.rowState.clear();
  }
  isExpanded(index, dataItem) {
    if (this.userCallback) {
      return this.userCallback({
        index,
        dataItem
      });
    }
    return this.rowState.has(index);
  }
  toggleRow(index, dataItem) {
    if (this.isExpanded(index, dataItem)) {
      this.collapseRow(index, dataItem);
    } else {
      this.expandRow(index, dataItem);
    }
  }
  expandRow(index, dataItem) {
    const prevented = this.emitEvent({
      dataItem,
      index,
      expand: true
    });
    if (!prevented && !this.userCallback) {
      this.rowState.add(index);
    }
  }
  collapseRow(index, dataItem) {
    const prevented = this.emitEvent({
      dataItem,
      index,
      expand: false
    });
    if (!prevented && !this.userCallback) {
      this.rowState.delete(index);
    }
  }
  emitEvent(args) {
    const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);
    this.changes.next(eventArg);
    return eventArg.isDefaultPrevented();
  }
  static ɵfac = function DetailsService_Factory(t) {
    return new (t || _DetailsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DetailsService,
    factory: _DetailsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailsService, [{
    type: Injectable
  }], null, null);
})();
var ScrollRequestService = class _ScrollRequestService {
  requests = new Subject();
  scrollTo(request, adjustIndex = true) {
    this.requests.next({
      request,
      adjustIndex
    });
  }
  scrollToItem(request) {
    this.requests.next({
      request
    });
  }
  static ɵfac = function ScrollRequestService_Factory(t) {
    return new (t || _ScrollRequestService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollRequestService,
    factory: _ScrollRequestService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollRequestService, [{
    type: Injectable
  }], null, null);
})();
var CellTemplateDirective2 = class _CellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CellTemplateDirective_Factory(t) {
    return new (t || _CellTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CellTemplateDirective,
    selectors: [["", "kendoGridCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var EditTemplateDirective = class _EditTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function EditTemplateDirective_Factory(t) {
    return new (t || _EditTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditTemplateDirective,
    selectors: [["", "kendoGridEditTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var HeaderTemplateDirective2 = class _HeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTemplateDirective_Factory(t) {
    return new (t || _HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTemplateDirective,
    selectors: [["", "kendoGridHeaderTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FooterTemplateDirective3 = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(t) {
    return new (t || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoGridFooterTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective3, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ColumnMenuTemplateDirective = class _ColumnMenuTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnMenuTemplateDirective_Factory(t) {
    return new (t || _ColumnMenuTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnMenuTemplateDirective,
    selectors: [["", "kendoGridColumnMenuTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var sequence = 0;
var IdService = class _IdService {
  prefix;
  constructor() {
    this.prefix = `k-grid${sequence++}`;
  }
  gridId() {
    return this.prefix;
  }
  cellId(rowIndex, colIndex) {
    return `${this.prefix}-r${rowIndex}c${colIndex}`;
  }
  selectionCheckboxId(itemIndex) {
    return `${this.prefix}-checkbox${itemIndex}`;
  }
  selectAllCheckboxId() {
    return `${this.prefix}-select-all`;
  }
  static ɵfac = function IdService_Factory(t) {
    return new (t || _IdService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _IdService,
    factory: _IdService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IdService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var ColumnMenuErrorMessages = {
  autoSizeColumn: `The auto size column does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-column-item.`,
  autoSizeAllColumns: `The auto size all columns does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-all-columns-item.`,
  serviceInput: `The service input of the predefined column menu components is mandatory.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-customizing-the-content.`
};
var ClipboardErrorMessages = {
  activeCellNavigable: `Grid must be navigable to use "activeCell" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-active-cell.`,
  selectionSelectable: `Grid must be selectable to use "selection" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-current-selection.`
};
var ColumnConfigurationErrorMessages = {
  fieldName: (field) => `Grid column field name '${field}' does not look like a valid JavaScript identifier.
        Identifiers can contain only alphanumeric characters (including "$" or "_"), and may not start with a digit.
        Please use only valid identifier names to ensure error-free operation.`,
  width: (value, parsedValue) => `Expected numeric value for column width, but got a string "${value}". Treating as ${parsedValue}px.`,
  invalidColumn: (column) => `Invalid column ${column}.`,
  requiredWidth: (columnType) => `${columnType} columns feature requires all columns to have set width.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}.`,
  requiredScroll: (columnType) => `${columnType} columns are only supported when scrolling is enabled.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}/`,
  groupColumnContent: "ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.",
  lockedParent: "Locked child columns require their parent columns to be locked.",
  columnNested: "Columns can be nested only inside ColumnGroupComponent",
  nestedInside: (nestedColumnNameType, parentColumnType) => `${nestedColumnNameType} cannot be nested inside ${parentColumnType}.`,
  cellRowspanNonBoundColumns: "cellRowspan must be a function for non-bound columns.",
  cellRowspanSpanGroupedColumns: "cellRowspan is not supported for SpanColumn and GroupColumn.",
  cellRowspan: `cellRowspan must be a function or boolean.`
};
var GridConfigurationErrorMessages = {
  functionType: (propName, fn) => `${propName} must be a function, but received ${JSON.stringify(fn)}.`,
  incompatibleFeatures: (feat1Name, feat2Name) => `'Having both ${feat1Name} and ${feat2Name} is not supported.'`,
  nonLockedColumnPresent: "There should be at least one non-locked column. See https://www.telerik.com/kendo-angular-ui/components/grid/columns/locked/#toc-known-limitations",
  rowHeightVirtual: `The virtual scrolling functionality requires setting the rowHeight (and detailRowHeight when there are detail rows).
        Row height and detail row height settings should be set only when virtual scrolling mode is enabled.
        See https://www.telerik.com/kendo-angular-ui/components/grid/scroll-modes/virtual/#toc-getting-started.`,
  focusNavigable: "The Grid should be configured as navigable to control focus. See https://www.telerik.com/kendo-angular-ui/components/grid/keyboard-navigation/.",
  expandCollapseMethods: (expandMethodName, collapseMethodName, directiveName, callbackName) => `The ${expandMethodName} and ${collapseMethodName} methods should not be called
        when using the ${directiveName} directive or the ${callbackName} callback.
        These methods are provided only for backwards compatibility with legacy versions.`,
  requiredEditService: `The default edit service of the editing directives works only when binding to plain array.
        Please provide an editService. See https://www.telerik.com/kendo-angular-ui/components/grid/editing/editing-directives/#toc-custom-editing-service.`,
  requiredModule: (exportedType, moduleName, componentSelector) => `Creating ${exportedType} requires including the ${moduleName} and adding the ${componentSelector} component.`,
  groupBindingDirectives: `Using the "kendoGridGroupBinding" directive in combination with the "kendoGridExpandGroupBy" directive
        or the "isGroupExpanded" callback is not supported. To use grouping with the "kendoGridGroupBinding" directive,
        set the Grid "groupable" property to "true".`,
  unsupportedMethod: (methodName, suggestedMethodName) => `Using ${methodName} in this context is not supported. Use ${suggestedMethodName} instead.`,
  unsupportedToolbarConfig: `
        Defining both a toolbar template and a ToolBarComponent within the Grid is not supported.
        Please use either the ToolBarComponent or a custom template.`
};
var isSpanColumn = (column) => column.isSpanColumn;
var isCheckboxColumn = (column) => column.isCheckboxColumn;
var isRowReorderColumn = (column) => column.isRowReorderColumn;
var isColumnContainer = (column) => column.isColumnGroup || isSpanColumn(column);
var columnId = 0;
var ColumnBase2 = class _ColumnBase {
  parent;
  /**
   * @hidden
   */
  isReordered;
  /**
   * @hidden
   */
  initialMaxResizableWidth;
  /**
   * @hidden
   */
  initialMinResizableWidth;
  /**
   * @hidden
   */
  matchesMedia = true;
  /**
   * The column index after reordering. The `orderIndex` is a read-only property. Setting this field does not affect column order.
   *
   * @default 0
   */
  orderIndex = 0;
  /**
   * @hidden
   */
  set leafIndex(value) {
    this._leafIndex = value;
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this._leafIndex;
  }
  _leafIndex;
  /**
   * @hidden
   */
  isColumnGroup = false;
  /**
   * @hidden
   */
  isSpanColumn = false;
  /**
   * Indicates whether the column is resizable.
   * @default true
   */
  resizable = true;
  /**
   * Indicates whether the column is reorderable.
   * @default true
   */
  reorderable = true;
  /**
   * The width (in pixels) below which the user is not able to resize the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
   * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
   * @default 10
   */
  minResizableWidth = 10;
  /**
   * The width (in pixels) above which the user is not able to resize the column by using the UI ([see example]({% slug resizing_columns_grid %}#toc-limiting-the-resizing)).
   * By default, the maximum width is not restricted.
   * The `autoFitColumn` and `autoFitColumns` methods have higher priority.
   */
  maxResizableWidth;
  /**
   * The title of the column.
   */
  title;
  /**
   * The width of the column (in pixels).
   */
  set width(value) {
    if (typeof value === "string") {
      const parsedValue = this._width = parseInt(value, 10);
      if (isDevMode()) {
        console.warn(ColumnConfigurationErrorMessages.width(value, parsedValue));
      }
    } else {
      this._width = value;
    }
  }
  get width() {
    return this._width;
  }
  /**
   * Indicates whether the column will be resized during initialization so that it fits its header and row content.
   */
  autoSize;
  /**
   * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_grid %})).
   *
   * @default false
   *
   */
  set locked(value) {
    this._locked = value;
  }
  get locked() {
    return this._locked;
  }
  _locked = false;
  /**
   * Determines whether the column will be always visible when scrolling the Grid horizontally.
   *
   * @default false
   */
  sticky = false;
  /**
   * Sets the visibility of the column ([see example](slug:hidden_columns_grid#toc-using-the-built-in-options)).
   *
   * @default false
   */
  hidden;
  /**
   * Sets the condition that needs to be satisfied for a column to remain visible ([see example]({% slug styling_responsive_grid %}#toc-columns)).
   * If you set the `hidden` property, the behavior of `media` is overridden.
   *
   * Accepts the device identifiers that are [available in Bootstrap 4](https://v4-alpha.getbootstrap.com/layout/grid/#grid-options)
   * ([see example](slug:styling_responsive_grid)):
   */
  media;
  /**
   * Specifies if the column can be locked or unlocked from the column menu or by reordering the columns.
   * @default true
   */
  lockable = true;
  /**
   * Specifies if the column can be stuck or unstuck from the column menu.
   * @default true
   */
  stickable = true;
  /**
   * Specifies if the column menu will be shown for the column.
   * @default true
   */
  columnMenu = true;
  /**
   * Specifies if the column will be included in the column-chooser list.
   * @default true
   */
  includeInChooser = true;
  /**
   * Allows setting the `role` attribute for the table cells (excluding the footer and header ones) of the column.
   * @default "gridcell"
   */
  tableCellsRole = "gridcell";
  /**
   * Sets the custom styles for the table cells (excluding the footer and header ones) of the column. Under the hood,
   * to apply the property, the `style` option uses the
   * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
   *
   */
  style;
  /**
   * Sets the custom styles for the header cell of the column. Under the hood, to apply the property,
   * the `headerStyle` option uses the
   * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
   *
   */
  headerStyle;
  /**
   * Sets the custom styles for the filter row cell. Under the hood, to apply the property,
   * the `filterStyle` option uses the
   * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
   *
   */
  filterStyle;
  /**
   * Sets the custom styles for the footer cell of the column. Under the hood, to apply the property,
   * the `footerStyle` option uses the
   * [NgStyle](link:site.data.urls.angular['ngstyleapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
   *
   */
  footerStyle;
  /**
   * Sets the custom CSS classes to the column cells. Under the hood, to apply the property, the `class` option uses the
   * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-cells).
   * To customize header and footer column cells, use the [headerClass]({% slug api_grid_columncomponent %}#toc-headerclass)
   * and [footerClass]({% slug api_grid_columncomponent %}#toc-footerclass) inputs.
   *
   */
  cssClass;
  /**
   * Sets the custom CSS classes to the column header cell. Under the hood, to apply the property,
   * the `headerClass` option uses the
   * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-header).
   *
   */
  headerClass;
  /**
   * Sets the custom CSS classes to the filter row cell. Under the hood, to apply the property,
   * the `filterClass` option uses the
   * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-filter-row-cells).
   *
   */
  filterClass;
  /**
   * Sets the custom CSS classes to the column footer cell. Under the hood, to apply the property,
   * the `footerClass` option uses the
   * [NgClass](link:site.data.urls.angular['ngclassapi']) directive. [See example](slug:styling_grid_columns#toc-customizing-column-footer).
   *
   */
  footerClass;
  /**
   * Defines a function that is used to determine the rowspan of each column cell.
   * If set to `true`, a default function is used that spans adjacent cells containing equal values.
   * Cells have equal values when their data items' values for the respective field are equal.
   */
  set cellRowspan(cellRowspan) {
    if (isDevMode() && (this.isSpanColumn || this.isColumnGroup)) {
      throw new Error(ColumnConfigurationErrorMessages.cellRowspanSpanGroupedColumns);
    }
    if (cellRowspan) {
      const isFunction2 = typeof cellRowspan === "function";
      const isBoolean = typeof cellRowspan === "boolean";
      if (isDevMode() && !this.field && !isFunction2) {
        throw new Error(ColumnConfigurationErrorMessages.cellRowspanNonBoundColumns);
      }
      if (isDevMode() && !(isBoolean || isFunction2)) {
        throw new Error(ColumnConfigurationErrorMessages.cellRowspan);
      }
      this._cellRowspan = isBoolean ? defaultCellRowSpan : cellRowspan;
    }
  }
  get cellRowspan() {
    return this._cellRowspan;
  }
  /**
   * @hidden
   */
  headerTemplates = new QueryList();
  /**
   * @hidden
   */
  footerTemplate;
  /**
   * @hidden
   */
  columnMenuTemplates = new QueryList();
  /**
   * @hidden
   */
  resizeStartWidth;
  /**
   * @hidden
   */
  idService;
  /**
   * @hidden
   */
  _cellRowspan;
  /**
   * @hidden
   */
  implicitWidth;
  /**
   * @hidden
   */
  get level() {
    if (this.parent && isSpanColumn(this.parent)) {
      return this.parent.level;
    }
    return this.parent ? this.parent.level + 1 : 0;
  }
  /**
   * @hidden
   */
  get isLocked() {
    return this.parent ? this.parent.isLocked : this.locked;
  }
  _width;
  /**
   * @hidden
   */
  get id() {
    return this._id;
  }
  /**
   * @hidden
   */
  get colspan() {
    return 1;
  }
  /**
   * @hidden
   */
  rowspan(totalColumnLevels) {
    return this.level < totalColumnLevels ? totalColumnLevels - this.level + 1 : 1;
  }
  /**
   * @hidden
   */
  get headerTemplateRef() {
    const template = this.headerTemplates.first;
    return template ? template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get footerTemplateRef() {
    return this.footerTemplate ? this.footerTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get columnMenuTemplateRef() {
    const template = this.columnMenuTemplates.first;
    return template ? template.templateRef : null;
  }
  /**
   * @hidden
   */
  get displayTitle() {
    return this.title;
  }
  /**
   * @hidden
   */
  get isVisible() {
    return !this.hidden && this.matchesMedia;
  }
  _id;
  /**
   * @hidden
   */
  constructor(parent, idService) {
    this.parent = parent;
    this.idService = idService;
    if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {
      throw new Error(ColumnConfigurationErrorMessages.columnNested);
    }
    this._id = `k-grid-column-${columnId++}`;
  }
  ngAfterViewInit() {
    this.initialMaxResizableWidth = this.maxResizableWidth;
    this.initialMinResizableWidth = this.minResizableWidth;
  }
  static ɵfac = function ColumnBase_Factory(t) {
    return new (t || _ColumnBase)(ɵɵdirectiveInject(_ColumnBase), ɵɵdirectiveInject(IdService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnBase,
    selectors: [["kendo-grid-column-base"]],
    contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective3, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective2, 4);
        ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplates = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
      }
    },
    inputs: {
      resizable: "resizable",
      reorderable: "reorderable",
      minResizableWidth: "minResizableWidth",
      maxResizableWidth: "maxResizableWidth",
      title: "title",
      width: "width",
      autoSize: "autoSize",
      locked: "locked",
      sticky: "sticky",
      hidden: "hidden",
      media: "media",
      lockable: "lockable",
      stickable: "stickable",
      columnMenu: "columnMenu",
      includeInChooser: "includeInChooser",
      tableCellsRole: "tableCellsRole",
      style: "style",
      headerStyle: "headerStyle",
      filterStyle: "filterStyle",
      footerStyle: "footerStyle",
      cssClass: [InputFlags.None, "class", "cssClass"],
      headerClass: "headerClass",
      filterClass: "filterClass",
      footerClass: "footerClass",
      cellRowspan: "cellRowspan"
    },
    decls: 0,
    vars: 0,
    template: function ColumnBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnBase2, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-base",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2
    }, {
      type: IdService
    }];
  }, {
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    minResizableWidth: [{
      type: Input
    }],
    maxResizableWidth: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    autoSize: [{
      type: Input
    }],
    locked: [{
      type: Input
    }],
    sticky: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    media: [{
      type: Input
    }],
    lockable: [{
      type: Input
    }],
    stickable: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    includeInChooser: [{
      type: Input
    }],
    tableCellsRole: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    headerStyle: [{
      type: Input
    }],
    filterStyle: [{
      type: Input
    }],
    footerStyle: [{
      type: Input
    }],
    cssClass: [{
      type: Input,
      args: ["class"]
    }],
    headerClass: [{
      type: Input
    }],
    filterClass: [{
      type: Input
    }],
    footerClass: [{
      type: Input
    }],
    cellRowspan: [{
      type: Input
    }],
    headerTemplates: [{
      type: ContentChildren,
      args: [HeaderTemplateDirective2, {
        descendants: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective3, {
        static: false
      }]
    }],
    columnMenuTemplates: [{
      type: ContentChildren,
      args: [ColumnMenuTemplateDirective]
    }]
  });
})();
var GroupHeaderTemplateDirective2 = class _GroupHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupHeaderTemplateDirective_Factory(t) {
    return new (t || _GroupHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupHeaderTemplateDirective,
    selectors: [["", "kendoGridGroupHeaderTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupHeaderColumnTemplateDirective2 = class _GroupHeaderColumnTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) {
    return new (t || _GroupHeaderColumnTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupHeaderColumnTemplateDirective,
    selectors: [["", "kendoGridGroupHeaderColumnTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderColumnTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupHeaderColumnTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupFooterTemplateDirective2 = class _GroupFooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupFooterTemplateDirective_Factory(t) {
    return new (t || _GroupFooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupFooterTemplateDirective,
    selectors: [["", "kendoGridGroupFooterTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupFooterTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FilterCellTemplateDirective = class _FilterCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FilterCellTemplateDirective_Factory(t) {
    return new (t || _FilterCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterCellTemplateDirective,
    selectors: [["", "kendoGridFilterCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FilterMenuTemplateDirective = class _FilterMenuTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FilterMenuTemplateDirective_Factory(t) {
    return new (t || _FilterMenuTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterMenuTemplateDirective,
    selectors: [["", "kendoGridFilterMenuTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterMenuTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
function isColumnComponent(column) {
  return isPresent4(column.field);
}
var ColumnComponent2 = class _ColumnComponent extends ColumnBase2 {
  /**
   * The field to which the column is bound.
   */
  field;
  /**
   * The format that is applied to the value before it is displayed. For more information on the supported date and number formats,
   * refer to the [Column Formats](slug:formats_columns_grid) documentation article.
   */
  format;
  /**
   * Allows the user to click the column headers and emits the `sortChange` event. [See example](slug:sorting_grid).
   *
   * @default true
   */
  sortable = true;
  /**
   * Determines if the column can be dragged to the group panel.
   * If set to `false`, you can group the columns by the column field by using the API of the Grid.
   *
   * @default true
   */
  groupable = true;
  /**
   * Defines the editor type. [See example](slug:inline_editing_grid#toc-using-reactive-forms).
   * Used when the column enters the edit mode.
   *
   * @default 'text'
   */
  editor = "text";
  /**
   * Defines the filter type that is displayed inside the filter row. [See example](slug:filtering_grid#toc-filter-data-types).
   *
   * @default 'text'
   */
  filter = "text";
  /**
   * Defines if a filter UI will be displayed for this column. [See example](slug:filtering_grid).
   *
   * @default true
   */
  filterable = true;
  /**
   * Defines whether the column is editable. [See example](slug:make_fields_uneditable_grid).
   *
   * @default true
   */
  editable = true;
  template;
  groupHeaderTemplate;
  groupHeaderColumnTemplate;
  groupFooterTemplate;
  editTemplate;
  filterCellTemplate;
  filterMenuTemplate;
  constructor(parent, idService) {
    super(parent, idService);
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  get groupHeaderTemplateRef() {
    return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : void 0;
  }
  get groupHeaderColumnTemplateRef() {
    return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : void 0;
  }
  get groupFooterTemplateRef() {
    return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : void 0;
  }
  get editTemplateRef() {
    return this.editTemplate ? this.editTemplate.templateRef : void 0;
  }
  get filterCellTemplateRef() {
    return this.filterCellTemplate ? this.filterCellTemplate.templateRef : void 0;
  }
  get filterMenuTemplateRef() {
    return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : void 0;
  }
  get displayTitle() {
    return this.title === void 0 ? this.field : this.title;
  }
  static ɵfac = function ColumnComponent_Factory(t) {
    return new (t || _ColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnComponent,
    selectors: [["kendo-grid-column"]],
    contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, EditTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FilterCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FilterMenuTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.editTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenuTemplate = _t.first);
      }
    },
    inputs: {
      field: "field",
      format: "format",
      sortable: "sortable",
      groupable: "groupable",
      editor: "editor",
      filter: "filter",
      filterable: "filterable",
      editable: "editable"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _ColumnComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => ColumnComponent2)
      }],
      selector: "kendo-grid-column",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    field: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    editor: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective2, {
        static: false
      }]
    }],
    groupHeaderTemplate: [{
      type: ContentChild,
      args: [GroupHeaderTemplateDirective2, {
        static: false
      }]
    }],
    groupHeaderColumnTemplate: [{
      type: ContentChild,
      args: [GroupHeaderColumnTemplateDirective2, {
        static: false
      }]
    }],
    groupFooterTemplate: [{
      type: ContentChild,
      args: [GroupFooterTemplateDirective2, {
        static: false
      }]
    }],
    editTemplate: [{
      type: ContentChild,
      args: [EditTemplateDirective, {
        static: false
      }]
    }],
    filterCellTemplate: [{
      type: ContentChild,
      args: [FilterCellTemplateDirective, {
        static: false
      }]
    }],
    filterMenuTemplate: [{
      type: ContentChild,
      args: [FilterMenuTemplateDirective, {
        static: false
      }]
    }]
  });
})();
function isSpanColumnComponent(column) {
  return column.isSpanColumn;
}
var SpanColumnComponent = class _SpanColumnComponent extends ColumnBase2 {
  /*
   * @hidden
   */
  isSpanColumn = true;
  template = new QueryList();
  editTemplate = new QueryList();
  /**
   * @hidden
   */
  children = new QueryList();
  /**
   * @hidden
   */
  title;
  /**
   * @hidden
   */
  headerStyle;
  /**
   * @hidden
   */
  footerStyle;
  /**
   * @hidden
   */
  headerClass;
  /**
   * @hidden
   */
  footerClass;
  /**
   * @hidden
   */
  includeInChooser = false;
  /**
   * Defines whether the edit template of the column will be rendered.
   * To enable the editing functionality for a spanned column, set an edit template for it ([see example](slug:custom_reactive_editing_grid)).
   * @default false
   */
  set editable(value) {
    this._editable = value;
  }
  get editable() {
    return isPresent4(this.editTemplateRef) && this._editable;
  }
  /**
   * @hidden
   * added for backwards compitability
   */
  set width(_value) {
  }
  get width() {
    return this.children.reduce((total, column) => total + column.width, 0);
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this.children.first.leafIndex;
  }
  _editable = true;
  constructor(parent, idService) {
    super(parent, idService);
    if (parent && parent.isSpanColumn) {
      throw new Error(ColumnConfigurationErrorMessages.nestedInside("SpanColumnComponent", "SpanColumnComponent"));
    }
  }
  /**
   * @hidden
   */
  get templateRef() {
    const template = this.template.first;
    return template ? template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get editTemplateRef() {
    const editTemplate = this.editTemplate.first;
    return editTemplate ? editTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get colspan() {
    return this.children.filter((c) => c.isVisible).length;
  }
  /**
   * Toggles the locked (frozen) state of the columns ([see example](slug:locked_columns_grid)).
   * @default false
   */
  set locked(value) {
    this._locked = value;
  }
  get locked() {
    return this._locked || this.children.some((c) => c.locked);
  }
  get childrenArray() {
    return this.children.toArray();
  }
  get hasChildren() {
    return this.children.length > 0;
  }
  /**
   * @hidden
   *
   * Used to hide the cellRowspan property from the public API.
   */
  set cellRowspan(cellRowSpan) {
    super.cellRowspan = cellRowSpan;
  }
  static ɵfac = function SpanColumnComponent_Factory(t) {
    return new (t || _SpanColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SpanColumnComponent,
    selectors: [["kendo-grid-span-column"]],
    contentQueries: function SpanColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 4);
        ɵɵcontentQuery(dirIndex, EditTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, ColumnComponent2, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.editTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
      }
    },
    inputs: {
      editable: "editable",
      locked: "locked"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _SpanColumnComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function SpanColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SpanColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => SpanColumnComponent)
      }],
      selector: "kendo-grid-span-column",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    template: [{
      type: ContentChildren,
      args: [CellTemplateDirective2, {
        descendants: false
      }]
    }],
    editTemplate: [{
      type: ContentChildren,
      args: [EditTemplateDirective, {
        descendants: false
      }]
    }],
    children: [{
      type: ContentChildren,
      args: [ColumnComponent2]
    }],
    editable: [{
      type: Input
    }],
    locked: [{
      type: Input
    }]
  });
})();
var expandColumns = (columns) => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []);
var expandColumnsWithSpan = (columns) => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? [column].concat(column.childrenArray) : [column]), []);
var columnsToRender = (columns) => expandColumns(columns).filter((x) => x.isVisible);
var sumProp = (prop) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop] || 0), 0);
var sumColumnWidths = sumProp("width");
var columnsSpan = sumProp("colspan");
var validField = new RegExp(`^[$A-Z_a-z][$A-Z_a-z0-9\\.]*$`);
var isValidFieldName = (fieldName) => !isNullOrEmptyString(fieldName) && validField.test(fieldName) && fieldName[0] !== "." && fieldName[fieldName.length - 1] !== ".";
var children = (column) => column.children.filter((child) => child !== column);
var leafColumns = (columns) => {
  return columns.reduce((acc, column) => {
    if (column.isColumnGroup) {
      acc = acc.concat(leafColumns(children(column)));
    } else if (column.isSpanColumn) {
      acc = acc.concat(column.childrenArray);
    } else {
      acc.push(column);
    }
    return acc;
  }, []).filter((x) => x.isVisible);
};
var someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);
var resizableColumns = (columns) => columns.filter((column) => isTruthy(column.resizable) && column.isVisible);
var sortColumns = (columns) => orderBy(columns, [{
  field: "orderIndex",
  dir: "asc"
}]);
var isInSpanColumn$1 = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);
var isLocked = (column) => column.parent ? isLocked(column.parent) : !!column.locked;
var resizeArgs = (column, extra) => Object.assign({
  columns: leafColumns([column]),
  locked: isLocked(column)
}, extra);
var ColumnResizingService = class _ColumnResizingService {
  changes = new EventEmitter();
  adjacentColumn;
  areColumnsReordered = false;
  isShiftPressed = false;
  originalWidth;
  draggedGroupColumn;
  resizedColumns;
  autoFitResize = false;
  column;
  tables = [];
  batch = null;
  start(column) {
    this.trackColumns(column);
    const columns = (this.column.isColumnGroup ? [column] : []).concat(leafColumns([column]));
    this.changes.emit({
      columns,
      locked: isLocked(this.column),
      type: "start"
    });
  }
  resizeColumns(deltaPercent) {
    const action = resizeArgs(this.column, {
      deltaPercent,
      type: "resizeColumn"
    });
    this.changes.emit(action);
  }
  resizeTable(column, delta) {
    const action = resizeArgs(column, {
      delta,
      type: "resizeTable"
    });
    this.changes.emit(action);
  }
  resizedColumn(state2) {
    this.resizedColumns.push(state2);
  }
  end() {
    this.changes.emit({
      columns: [],
      resizedColumns: this.resizedColumns,
      type: "end"
    });
    this.restoreInitialMaxMinWidths();
    this.adjacentColumn = null;
    this.draggedGroupColumn = null;
    this.autoFitResize = false;
  }
  registerTable(tableMetadata) {
    this.tables.push(tableMetadata);
    const unregisterTable = () => {
      this.tables.splice(this.tables.indexOf(tableMetadata), 1);
    };
    return unregisterTable;
  }
  measureColumns(info) {
    if (this.batch !== null) {
      this.batch.push(...info);
    } else {
      this.autoFitBatch(info, () => this.end());
    }
  }
  autoFit(...columns) {
    const nonLockedColumns = columns.filter((column) => !column.isLocked);
    this.autoFitStart(nonLockedColumns);
    this.autoFitBatch(this.batch, () => {
      if (nonLockedColumns.length < columns.length) {
        const lockedColumns = columns.filter((column) => column.isLocked);
        this.autoFitStart(lockedColumns);
        this.autoFitBatch(this.batch, () => this.end());
      } else {
        this.end();
      }
    });
  }
  trackColumns(column) {
    this.resizedColumns = [];
    this.column = column;
  }
  autoFitStart(columns) {
    this.batch = [];
    this.resizedColumns = [];
    if (columns.length === 0) {
      return;
    }
    const locked = columns[0].isLocked;
    this.changes.emit({
      type: "start",
      columns,
      locked
    });
    this.changes.emit({
      type: "triggerAutoFit",
      columns,
      locked
    });
  }
  autoFitBatch(info, onComplete) {
    const locked = info.length > 0 ? info[0].column.isLocked : false;
    const observables = this.tables.filter((table2) => table2.locked === locked).map((table2) => table2.autoFit(info));
    zip(...observables).pipe(take(1)).subscribe((widths) => {
      this.changes.emit({
        columns: info.map((i) => i.column),
        type: "autoFitComplete",
        widths,
        locked
      });
      if (onComplete) {
        onComplete();
      }
    });
    this.batch = null;
  }
  restoreInitialMaxMinWidths() {
    if (this.adjacentColumn) {
      this.adjacentColumn.maxResizableWidth = this.adjacentColumn.initialMaxResizableWidth;
      this.adjacentColumn.minResizableWidth = this.adjacentColumn.initialMinResizableWidth;
    }
    if (this.column) {
      this.column.maxResizableWidth = this.column.initialMaxResizableWidth;
      this.column.minResizableWidth = this.column.initialMinResizableWidth;
    }
  }
  static ɵfac = function ColumnResizingService_Factory(t) {
    return new (t || _ColumnResizingService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnResizingService,
    factory: _ColumnResizingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizingService, [{
    type: Injectable
  }], null, null);
})();
var isInSameGrid = (element, gridElement) => closest3(element, matchesNodeName("kendo-grid")) === gridElement;
var matchHeaderCell = matchesNodeName("th");
var matchDataCell = matchesNodeName("td");
var matchFooterCell = matchesNodeName(".k-grid-footer td");
var matchCell = (element) => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);
var gridCell = (element, gridElement) => {
  let target = closest3(element, matchCell);
  while (target && !isInSameGrid(target, gridElement)) {
    target = closest3(target.parentElement, matchCell);
  }
  return target;
};
var targetCell = (target, gridElement) => {
  const cell2 = gridCell(target, gridElement);
  const row2 = closest3(cell2, matchesNodeName("tr"));
  if (cell2 && row2) {
    let rowIndex = row2.getAttribute("aria-rowindex") || row2.getAttribute("data-kendo-grid-row-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
    let colIndex = cell2.getAttribute("aria-colindex");
    colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
    if (rowIndex !== null && colIndex !== null) {
      return {
        colIndex,
        rowIndex,
        element: cell2
      };
    }
  }
};
var isArrowKey = (keyCode) => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight || keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
var isNavigationKey = (keyCode) => isArrowKey(keyCode) || keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;
var isInput = matchesNodeName("input");
var isTextInput = (element) => element && isInput(element) && element.type.toLowerCase() === "text";
var isPrintableCharacter = (str) => str.length === 1 && str.match(/\S/);
var resizeStep = 10;
var NavigationViewport = class {
  firstItemIndex;
  lastItemIndex;
  constructor(firstItemIndex, lastItemIndex) {
    this.firstItemIndex = firstItemIndex;
    this.lastItemIndex = lastItemIndex;
  }
  containsRow(dataRowIndex) {
    const headerRow2 = dataRowIndex < 0;
    return headerRow2 || dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex;
  }
  intersects(start, end2) {
    return start <= this.firstItemIndex && this.lastItemIndex <= end2 || this.firstItemIndex <= start && start <= this.lastItemIndex || this.firstItemIndex <= end2 && end2 <= this.lastItemIndex;
  }
};
var NavigationService2 = class _NavigationService {
  zone;
  domEvents;
  pagerContextService;
  scrollRequestService;
  groupsService;
  detailsService;
  focusRoot;
  editService;
  cd;
  ctx;
  resizeService;
  focusableParent;
  changes;
  cellKeydown = new EventEmitter();
  set metadata(value) {
    this.meta = value;
    this.cursor.metadata = value;
  }
  get metadata() {
    return this.meta;
  }
  get enabled() {
    return this.alive;
  }
  get pagerEnabled() {
    return this.alive && this.pagerIsNavigable;
  }
  get tableEnabled() {
    return this.alive && this.tableIsNavigable;
  }
  get toolbarEnabled() {
    return this.alive && this.toolbarIsNavigable;
  }
  get activeCell() {
    if (this.mode !== 0) {
      return this.cursor.cell;
    }
  }
  get activeRow() {
    if (this.mode !== 0) {
      return Object.assign({}, this.cursor.row, {
        cells: this.cursor.row?.cells.toArray()
      });
    }
  }
  get isColumnResizable() {
    const allColumns = Array.from(this.ctx.grid.columnsContainer.allColumns);
    const column = allColumns.find((col) => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);
    if (!column.parent) {
      if (column.isColumnGroup) {
        return this.activeCell.colIndex + this.activeCell.colSpan !== this.ctx.grid.columnsContainer.leafColumnsToRender.length;
      } else {
        return this.activeCell.colIndex !== this.ctx.grid.columnsContainer.leafColumnsToRender.length - 1;
      }
    } else {
      const columnGroup = column.parent;
      const columnGroupChildren = Array.from(columnGroup.children).sort((a, b) => a.orderIndex - b.orderIndex);
      const columnIndexInsideGroup = columnGroupChildren.indexOf(column);
      if (column.isReordered || column.orderIndex > 0 || column.isReordered && column.orderIndex === 0) {
        return column.orderIndex - columnGroupChildren[0]["orderIndex"] !== columnGroupChildren.length - 1;
      }
      return columnIndexInsideGroup !== columnGroupChildren.length - 1;
    }
  }
  viewport;
  columnViewport;
  activeRowIndex = 0;
  alive = false;
  active = true;
  mode = 0;
  model = new NavigationModel();
  cursor = new NavigationCursor(this.model);
  meta;
  subs;
  pendingRowIndex;
  virtualCell;
  pagerIsNavigable = false;
  tableIsNavigable = false;
  toolbarIsNavigable = false;
  lastCellRowIndex;
  isShiftPressed = false;
  currentSelection = [];
  get activeDataRow() {
    return Math.max(0, this.activeRowIndex - this.meta.headerRows);
  }
  constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, ctx, resizeService, focusableParent) {
    this.zone = zone;
    this.domEvents = domEvents;
    this.pagerContextService = pagerContextService;
    this.scrollRequestService = scrollRequestService;
    this.groupsService = groupsService;
    this.detailsService = detailsService;
    this.focusRoot = focusRoot;
    this.editService = editService;
    this.cd = cd;
    this.ctx = ctx;
    this.resizeService = resizeService;
    this.focusableParent = focusableParent;
    this.changes = this.cursor.changes;
  }
  init(meta, navigableOptions) {
    this.setActiveSections(navigableOptions);
    this.alive = true;
    this.focusRoot.active = true;
    this.metadata = meta;
    const onStableSubscriber = (...operators) => (args) => this.zone.isStable ? from([true]).pipe(map(() => args)) : this.zone.onStable.pipe(take(1), map(() => args), ...operators);
    const onStable = onStableSubscriber();
    this.subs = new Subscription();
    this.subs.add(this.cursor.changes.subscribe((args) => this.onCursorChanges(args)));
    this.subs.add(this.domEvents.focus.pipe(switchMap(onStable)).subscribe((args) => this.navigateTo(args.target)));
    this.subs.add(this.domEvents.focusOut.pipe(filter(
      () => this.mode !== 0
      /* NavigationMode.Standby */
    ), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus)))).subscribe((args) => this.onFocusOut(args)));
    this.subs.add(this.domEvents.windowBlur.pipe(filter(
      () => this.mode !== 0
      /* NavigationMode.Standby */
    )).subscribe(() => this.onWindowBlur()));
    this.subs.add(
      // Closing the editor will not always trigger focusout in Firefox.
      // To get around this, we ensure that the cell is closed after editing.
      this.editService.changes.pipe(filter(
        (e) => e.action !== "edit" && this.mode === 2
        /* NavigationMode.Content */
      ), filter((e) => e.action === "cellClose" && !e.prevented), switchMap(onStable)).subscribe(() => this.leaveCell())
    );
    this.subs.add(this.pagerContextService.pageChange.subscribe(() => this.cursor.reset(0, 0)));
    this.subs.add(this.domEvents.keydown.subscribe((args) => this.onKeydown(args)));
    this.subs.add(this.domEvents.shiftKeyup.subscribe(() => {
      this.isShiftPressed = false;
    }));
    this.subs.add(this.domEvents.keydown.pipe(filter(
      (args) => args.keyCode === Keys.Tab && this.mode === 2
      /* NavigationMode.Content */
    ), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
      // Timeout if focusOut doesn't fire very soon
      interval(0).pipe(take(1))
    )))).subscribe(() => this.onTabout()));
    if (this.focusableParent) {
      const element = new GridFocusableElement(this);
      this.focusableParent.registerElement(element);
    }
    this.deactivateElements();
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
    this.alive = false;
  }
  registerCell(cell2) {
    if (cell2.logicalRowIndex !== this.pendingRowIndex) {
      const modelCell = this.model.registerCell(cell2);
      if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {
        this.virtualCell = false;
      }
    }
  }
  registerCellOnCurrentRow(cell2) {
    if (cell2.logicalRowIndex === this.pendingRowIndex) {
      this.model.registerCell(cell2);
    }
  }
  unregisterCell(index, rowIndex, cell2) {
    this.model.unregisterCell(index, rowIndex, cell2);
  }
  registerRow(row2) {
    this.model.registerRow(row2);
    this.pendingRowIndex = row2.logicalRowIndex;
  }
  updateRow(row2) {
    this.model.updateRow(row2);
  }
  unregisterRow(index, row2) {
    this.model.unregisterRow(index, row2);
    const lastRow = this.model.lastRow;
    if (lastRow && this.mode === 0) {
      const maxIndex = this.needsViewport() && this.viewport ? this.viewport.lastItemIndex : lastRow.index;
      if (this.activeRowIndex > maxIndex) {
        this.cursor.reset(0, 0);
      }
    }
  }
  isCellFocusable(cell2) {
    return this.alive && this.active && this.mode !== 2 && this.cursor.isActive(cell2.logicalRowIndex, cell2.logicalColIndex);
  }
  isCellFocused(cell2) {
    return this.mode === 1 && this.isCellFocusable(cell2);
  }
  navigateTo(el) {
    if (!this.alive || !isDocumentAvailable()) {
      return;
    }
    const cell2 = targetCell(el, this.meta.gridElement.nativeElement);
    if (!cell2) {
      return;
    }
    const oldMode = this.mode;
    const focusInCell = contains$1(cell2.element, document.activeElement);
    const focusInActiveRowContent = this.mode === 2 && this.activeRowIndex === cell2.rowIndex && el !== cell2.element;
    if (focusInCell) {
      this.mode = 2;
      this.cursor.reset(cell2.rowIndex, cell2.colIndex);
      this.activateRow();
    } else if (!focusInActiveRowContent) {
      this.mode = 1;
      this.deactivateElements();
      const alreadyActive = this.cursor.isActive(cell2.rowIndex, cell2.colIndex);
      const isCursor = oldMode === 1 && alreadyActive;
      if (!isCursor) {
        this.cursor.reset(cell2.rowIndex, cell2.colIndex);
      }
    }
  }
  tryFocus(el) {
    this.activateElements();
    const focusable = findFocusableChild(el);
    if (focusable) {
      const cell2 = targetCell(focusable, this.meta.gridElement.nativeElement);
      if (cell2) {
        this.cursor.reset(cell2.rowIndex, cell2.colIndex);
        this.deactivateElements();
        this.enterCell();
      }
      focusable.focus();
    } else {
      this.deactivateElements();
    }
    return !!focusable;
  }
  needsViewport() {
    return this.meta && this.meta.isVirtual;
  }
  setViewport(firstItemIndex, lastItemIndex) {
    this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
      const dataRowIndex = this.activeDataRow;
      const ahead = firstItemIndex - dataRowIndex;
      const behind = dataRowIndex - lastItemIndex;
      if (ahead > 0) {
        this.cursor.reset(firstItemIndex + this.meta.headerRows);
      } else if (behind > 0) {
        this.cursor.reset(lastItemIndex - this.meta.headerRows);
      }
    }
  }
  setColumnViewport(firstItemIndex, lastItemIndex) {
    this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
      const activeColumnIndex = this.cursor.cell ? this.cursor.cell.colIndex : 0;
      const ahead = firstItemIndex - activeColumnIndex;
      const behind = activeColumnIndex - lastItemIndex;
      if (ahead > 0) {
        this.cursor.reset(void 0, firstItemIndex, false);
      } else if (behind > 0) {
        this.cursor.reset(void 0, lastItemIndex, false);
      }
    }
  }
  focusCell(rowIndex = void 0, colIndex = void 0) {
    this.mode = 1;
    this.cursor.reset(rowIndex, colIndex);
    return this.activeCell;
  }
  focusCellByElement(el) {
    const cell2 = targetCell(el, this.meta.gridElement.nativeElement);
    if (cell2) {
      return this.focusCell(cell2.rowIndex, cell2.colIndex);
    }
  }
  focusNextCell(wrap = true) {
    return this.focusAdjacentCell(true, wrap);
  }
  focusPrevCell(wrap = true) {
    return this.focusAdjacentCell(false, wrap);
  }
  toggle(active) {
    this.active = active;
    this.cursor.announce();
  }
  hasFocus() {
    return this.mode === 1 || this.mode === 2;
  }
  autoFocusCell(start, end2) {
    return !this.meta.virtualColumns || end2 < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end2);
  }
  setActiveSections(navigableOptions) {
    this.pagerIsNavigable = navigableOptions.includes("pager");
    this.tableIsNavigable = navigableOptions.includes("table");
    this.toolbarIsNavigable = navigableOptions.includes("toolbar");
  }
  focusAdjacentCell(fwd, wrap) {
    this.focusCell();
    let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
    if (wrap && !success) {
      success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
      if (success) {
        const row2 = this.cursor.row;
        const colIdx = fwd ? 0 : this.cursor.lastCellIndex(row2);
        this.cursor.reset(row2.index, colIdx);
      }
    }
    if (success) {
      return this.activeCell;
    } else {
      this.mode = 0;
      this.cursor.announce();
    }
    return null;
  }
  enterCell() {
    const cell2 = this.cursor.cell;
    if (!cell2) {
      return;
    }
    const group = cell2.focusGroup;
    const focusable = group && group.canFocus();
    this.mode = focusable ? 2 : 1;
    this.cursor.announce();
    if (focusable) {
      this.activateRow();
      group.focus();
    }
  }
  leaveCell() {
    const cell2 = this.cursor.cell;
    if (!cell2) {
      return;
    }
    const group = cell2.focusGroup;
    const focusable = group && group.canFocus();
    if (!focusable) {
      this.deactivateElements();
    }
    this.mode = 1;
    this.cursor.announce();
  }
  activateElements() {
    this.focusRoot.activate();
  }
  deactivateElements() {
    this.focusRoot.deactivate();
  }
  activateRow() {
    this.cursor.row.cells.forEach((cell2) => cell2.focusGroup && cell2.focusGroup.activate());
  }
  moveCursorFwd() {
    this.lastCellRowIndex = this.activeCell.rowIndex;
    return this.ctx.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
  }
  moveCursorBwd() {
    this.lastCellRowIndex = this.activeCell.rowIndex;
    return this.ctx.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
  }
  onCursorKeydown(args) {
    let preventDefault2 = false;
    const modifier = args.ctrlKey || args.metaKey;
    let step = modifier ? 5 : 1;
    const rowspan = +args.target?.getAttribute("rowspan");
    let rowspanOffset = 0;
    let startNewSelection = false;
    const allowMultipleRanges = this.ctx.grid.selectionService.active && this.ctx.grid.selectableSettings?.multipleRanges || this.ctx.grid.cellSelectionService.active && this.ctx.grid.cellSelectionService?.options?.multipleRanges;
    if (!allowMultipleRanges) {
      this.currentSelection = [];
    }
    if (!this.onCellKeydown(args)) {
      return;
    }
    const row2 = this.cursor.row;
    const dir2 = args.keyCode === Keys.ArrowDown ? "Down" : "Up";
    const right2 = args.keyCode === Keys.ArrowRight;
    const isArrowKey2 = args.code === "ArrowDown" || args.code === "ArrowUp" || args.code === "ArrowLeft" || args.code === "ArrowRight";
    if (!this.isShiftPressed && args.shiftKey && isArrowKey2) {
      startNewSelection = true;
      this.isShiftPressed = true;
    }
    switch (args.keyCode) {
      case Keys.ArrowDown:
      case Keys.ArrowUp:
        if (rowspan > 1) {
          rowspanOffset = this.calculateRowspanOffset(dir2, rowspan);
          step += rowspanOffset;
        }
        if (args.shiftKey) {
          if (this.ctx.grid.blockArrowSelection) {
            return;
          }
          preventDefault2 = this.cursor[`move${dir2}`](step);
          const preserveCurrentSelection = startNewSelection && allowMultipleRanges;
          if (this.activeRow?.dataItem) {
            const sign = dir2 === "Down" ? 1 : -1;
            this.handleVerticalArrowSelection(sign * step, preserveCurrentSelection);
          }
        } else {
          preventDefault2 = this.cursor[`move${dir2}`](step);
        }
        this.lastCellRowIndex = this.activeRowIndex;
        break;
      case Keys.ArrowRight:
      case Keys.ArrowLeft:
        if (args.altKey && this.ctx.grid.resizable && this.isColumnResizable) {
          this.columnResize(right2);
          break;
        }
        if (args.shiftKey) {
          if (this.ctx.grid.blockArrowSelection) {
            return;
          }
          preventDefault2 = this[`moveCursor${right2 ? "Fwd" : "Bwd"}`]();
          const preserveCurrentSelection = startNewSelection && allowMultipleRanges;
          this.handleHorizontalArrowSelection(args, preserveCurrentSelection);
        } else {
          preventDefault2 = this[`moveCursor${right2 ? "Fwd" : "Bwd"}`]();
        }
        break;
      case Keys.PageDown:
        if (this.metadata.isVirtual && this.viewport) {
          let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;
          if (this.metadata.hasDetailTemplate) {
            nextItemIndex++;
          }
          nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);
          this.cursor.reset(nextItemIndex);
          preventDefault2 = true;
        } else if (this.metadata.hasPager) {
          this.zone.run(() => this.pagerContextService.nextPage());
          preventDefault2 = true;
        }
        break;
      case Keys.PageUp:
        if (this.metadata.isVirtual && this.viewport) {
          const viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
          const firstItemIndex = this.viewport.firstItemIndex;
          const nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);
          this.cursor.reset(nextItemIndex);
          preventDefault2 = true;
        } else if (this.metadata.hasPager) {
          this.zone.run(() => this.pagerContextService.prevPage());
          preventDefault2 = true;
        }
        break;
      case Keys.Home:
        if (modifier) {
          if (this.meta.isVirtual) {
            this.cursor.reset(this.meta.headerRows, 0, false);
          } else {
            this.cursor.reset(this.model.firstRow.index, 0, false);
          }
        } else {
          let firstColumnIndex = 0;
          if (this.meta.hasDetailTemplate && row2.index < this.meta.headerRows) {
            firstColumnIndex = 1;
          }
          this.cursor.reset(row2.index, firstColumnIndex, false);
        }
        preventDefault2 = true;
        break;
      case Keys.End:
        if (modifier) {
          if (this.meta.isVirtual) {
            let lastRowIndex = this.meta.maxLogicalRowIndex;
            if (this.meta.hasDetailTemplate) {
              lastRowIndex--;
            }
            this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);
          } else {
            this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);
          }
        } else {
          const lastIndex = this.cursor.lastCellIndex(row2);
          const cell2 = this.model.findCell(lastIndex, row2);
          if (cell2) {
            this.cursor.reset(cell2.rowIndex, cell2.colIndex);
          } else {
            this.cursor.reset(row2.index, lastIndex);
          }
        }
        preventDefault2 = true;
        break;
      case Keys.Enter:
      case Keys.F2: {
        const groupItem = row2.groupItem;
        if (groupItem) {
          this.zone.run(() => this.groupsService.toggleRow(groupItem));
        } else if (this.cursor.cell.detailExpandCell) {
          this.zone.run(() => this.detailsService.toggleRow(row2.dataRowIndex, row2.dataItem));
        } else {
          this.enterCell();
          if (!this.cursor.cell.focusGroup.isNavigable()) {
            preventDefault2 = true;
          }
        }
        break;
      }
      default:
        if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
          this.enterCell();
        }
    }
    if (preventDefault2) {
      args.preventDefault();
    }
  }
  columnResize(onRightArrow) {
    const column = this.ctx.grid.columnsContainer.allColumns.find((col) => col.level === this.activeCell.rowIndex && col.leafIndex === this.activeCell.colIndex);
    this.resizeService.start(column);
    this.resizeService.resizeColumns(onRightArrow ? resizeStep : -1 * resizeStep);
    if (this.resizeService.resizeColumns.length > 0) {
      this.resizeService.end();
    }
  }
  onContentKeydown(args) {
    if (!this.onCellKeydown(args)) {
      return;
    }
    const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.target);
    if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {
      this.leaveCell();
      this.cursor.reset();
      args.stopPropagation();
    } else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {
      this.onCursorKeydown(args);
      if (args.defaultPrevented) {
        this.leaveCell();
      }
    }
  }
  onCellKeydown(args) {
    if (this.editService.isEditingCell()) {
      const confirm = args.keyCode === Keys.Enter;
      const cancel = args.keyCode === Keys.Escape;
      const navigate = isNavigationKey(args.keyCode);
      if (confirm) {
        this.editService.closeCell(args);
      } else if (cancel) {
        this.editService.closeCell(args);
        this.cd.detectChanges();
      } else if (navigate) {
        return false;
      }
    }
    this.cellKeydown.emit(args);
    return true;
  }
  onCursorChanges(args) {
    this.activeRowIndex = args.rowIndex;
    const dataRowIndex = this.activeDataRow;
    if (this.meta && this.meta.isVirtual && args.rowIndex >= this.meta.headerRows && this.viewport && !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1) {
      this.scrollRequestService.scrollTo({
        row: dataRowIndex
      });
    }
    if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {
      const cell2 = this.activeCell;
      const {
        start,
        end: end2
      } = this.model.cellRange(cell2);
      if (!cell2) {
        this.virtualCell = true;
      }
      if (!cell2 && this.mode !== 0 || cell2 && !this.columnViewport.intersects(start, end2)) {
        this.scrollRequestService.scrollTo({
          column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0)
        });
      }
    }
  }
  onFocusOut(args) {
    if (isVisible(args.target)) {
      this.mode = 0;
    } else {
      this.mode = 1;
    }
    this.deactivateElements();
    this.cursor.announce();
  }
  onWindowBlur() {
    this.mode = 0;
    this.deactivateElements();
    this.cursor.announce();
  }
  onKeydown(args) {
    if (this.mode === 1) {
      this.onCursorKeydown(args);
    } else if (this.mode === 2) {
      this.onContentKeydown(args);
    }
  }
  onTabout() {
    if (this.cursor.cell.focusGroup.isNavigable()) {
      return;
    }
    this.leaveCell();
    this.cursor.reset();
  }
  handleVerticalArrowSelection(args, preserveSelection) {
    const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
    const rowSelectionEnabled = this.ctx.grid.selectionService.active && !this.ctx.grid.selectableSettings.checkboxOnly;
    if (cellSelectionEnabled || rowSelectionEnabled) {
      const selectionService = this.ctx.grid[cellSelectionEnabled ? "cellSelectionService" : "selectionService"];
      const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
      const rowIdx = this.activeRow.dataRowIndex - this.ctx.grid.skip;
      const dataItem = selectionService.settings.view.at(rowIdx);
      const item = {
        index: this.activeRow.dataRowIndex,
        data: dataItem,
        column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx]
      };
      if (selectionService.options.mode === "multiple") {
        const startRowIndex = this.activeRow.dataRowIndex - args;
        cellSelectionEnabled ? this.handleMultipleArrowCellSelection(item, preserveSelection, startRowIndex, colIdx) : this.handleMultipleArrowRowSelection(item, preserveSelection, startRowIndex);
      } else {
        selectionService.handleClick(item, args);
      }
    }
  }
  handleHorizontalArrowSelection(args, preserveSelection) {
    const cellSelectionEnabled = this.ctx.grid.cellSelectionService.active;
    if (cellSelectionEnabled) {
      const selectionService = this.ctx.grid[cellSelectionEnabled ? "cellSelectionService" : "selectionService"];
      const row2 = this.activeRow;
      const colIdx = this.cursor.cell ? this.cursor.cell.colIndex : 0;
      const dataItem = selectionService.settings.view.at(row2.dataRowIndex - this.ctx.grid.skip);
      const item = {
        index: row2.dataRowIndex,
        data: dataItem,
        column: this.ctx.grid.columnsContainer.leafColumnsToRender[colIdx]
      };
      if (!isPresent(dataItem) || !isPresent(item.column)) {
        return;
      }
      if (selectionService.options.mode === "multiple") {
        const startColumnIndex = args.key === "ArrowRight" ? colIdx - 1 : colIdx + 1;
        this.handleMultipleArrowCellSelection(item, preserveSelection, row2.dataRowIndex, startColumnIndex);
      } else {
        selectionService.handleClick(item, args);
      }
    }
  }
  handleMultipleArrowCellSelection(item, preserveSelection, startRow, startColumn) {
    const cellSelectionService = this.ctx.grid.cellSelectionService;
    const startRowIndex = preserveSelection ? startRow : Math.min(cellSelectionService.lastSelectionItemRowIndex, item.index);
    const startColIndex = preserveSelection ? startColumn : Math.min(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
    const endRowIndex = preserveSelection ? item.index : Math.max(cellSelectionService.lastSelectionItemRowIndex, item.index);
    const endColIndex = preserveSelection ? item.column.leafIndex : Math.max(cellSelectionService.lastSelectionItemColIndex, item.column.leafIndex);
    if (preserveSelection) {
      cellSelectionService.lastSelectionItemRowIndex = startRow;
      cellSelectionService.lastSelectionItemColIndex = startColumn;
      this.currentSelection = cellSelectionService.currentSelection;
    }
    const ev = cellSelectionService.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveSelection, this.currentSelection);
    cellSelectionService.changes.emit(ev);
  }
  handleMultipleArrowRowSelection(item, preserveSelection, startRow) {
    const rowSelectionService = this.ctx.grid.selectionService;
    const startRowIndex = preserveSelection ? startRow : Math.min(rowSelectionService.lastSelectionStartIndex, item.index);
    const endRowIndex = preserveSelection ? item.index : Math.max(rowSelectionService.lastSelectionStartIndex, item.index);
    if (preserveSelection) {
      rowSelectionService.lastSelectionStartIndex = startRow;
      this.currentSelection = rowSelectionService.currentSelection;
    }
    const ev = rowSelectionService.selectRange(startRowIndex, endRowIndex, preserveSelection, this.currentSelection);
    rowSelectionService.changes.emit(ev);
  }
  calculateRowspanOffset(direction, cellRowspan) {
    if (!isPresent(this.lastCellRowIndex)) {
      return 0;
    }
    const offset3 = direction === "Up" ? Math.abs(this.lastCellRowIndex - this.activeRowIndex) : this.activeRowIndex + cellRowspan - this.lastCellRowIndex - 1;
    return offset3;
  }
  static ɵfac = function NavigationService_Factory(t) {
    return new (t || _NavigationService)(ɵɵinject(NgZone), ɵɵinject(DomEventsService), ɵɵinject(PagerContextService), ɵɵinject(ScrollRequestService), ɵɵinject(GroupsService), ɵɵinject(DetailsService), ɵɵinject(FocusRoot), ɵɵinject(EditService), ɵɵinject(ChangeDetectorRef), ɵɵinject(ContextService), ɵɵinject(ColumnResizingService), ɵɵinject(FocusableDirective, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService2, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }, {
      type: DomEventsService
    }, {
      type: PagerContextService
    }, {
      type: ScrollRequestService
    }, {
      type: GroupsService
    }, {
      type: DetailsService
    }, {
      type: FocusRoot
    }, {
      type: EditService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }, {
      type: ColumnResizingService
    }, {
      type: FocusableDirective,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var preventOnDblClick$1 = (release) => (mouseDown) => of(mouseDown).pipe(delay(150), takeUntil(release));
var hasClass = (className) => (el) => new RegExp(`(^| )${className}( |$)`).test(el.className);
var isDeleteButton = or(hasClass("k-i-x"), hasClass("k-svg-i-x"), hasClass("k-icon-button"));
var isSortIcon = or(hasClass("k-i-sort-asc-small"), hasClass("k-i-sort-desc-small"), hasClass("k-svg-i-sort-asc-small"), hasClass("k-svg-i-sort-desc-small"));
var skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName("label")));
var elementUnderCursor = ({
  clientX,
  clientY
}) => isDocumentAvailable() && document.elementFromPoint(clientX, clientY);
var hideThenShow = (element, cont) => {
  element.style.display = "none";
  const result = cont();
  element.style.display = "block";
  return result;
};
var DraggableColumnDirective = class _DraggableColumnDirective {
  draggable;
  element;
  zone;
  service;
  hint;
  cue;
  nav;
  renderer;
  context = {};
  set enableDrag(enabled) {
    this.enabled = enabled;
    this.updateTouchAction();
  }
  drag = new EventEmitter();
  subscriptions = new Subscription();
  enabled;
  constructor(draggable, element, zone, service, hint, cue, nav, renderer) {
    this.draggable = draggable;
    this.element = element;
    this.zone = zone;
    this.service = service;
    this.hint = hint;
    this.cue = cue;
    this.nav = nav;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter(() => this.enabled), filter(({
      originalEvent: {
        target
      }
    }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {
      const originalEvent = e.originalEvent;
      if (!e.isTouch) {
        originalEvent.preventDefault();
      }
      this.nav.navigateTo(originalEvent.target);
    }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap(() => {
      this.hint.create(this.context.hint);
      this.cue.create();
    }), switchMap((down) => this.draggable.kendoDrag.pipe(tap((e) => {
      if (e.isTouch) {
        e.originalEvent.preventDefault();
      }
    }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map((move) => ({
      move,
      down
    })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  drop(upEvent) {
    this.hint.remove();
    this.cue.remove();
    this.service.notifyDrop(this, upEvent);
  }
  performDrag({
    move
  }) {
    this.hint.move(move);
    const cursorElement = this.elementUnderCursor(move);
    if (cursorElement) {
      this.service.notifyDrag(this, cursorElement, move);
    }
    this.drag.emit({
      draggable: this,
      mouseEvent: move
    });
  }
  elementUnderCursor(mouseEvent) {
    this.hint.hide();
    let target = elementUnderCursor(mouseEvent);
    if (target && /k-grouping-dropclue/.test(target.className)) {
      target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));
    }
    this.hint.show();
    return target;
  }
  updateTouchAction() {
    if (!this.element) {
      return;
    }
    this.enabled ? this.renderer.addClass(this.element.nativeElement, "k-touch-action-none") : this.renderer.removeClass(this.element.nativeElement, "k-touch-action-none");
  }
  static ɵfac = function DraggableColumnDirective_Factory(t) {
    return new (t || _DraggableColumnDirective)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DragAndDropService), ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DraggableColumnDirective,
    selectors: [["", "kendoDraggableColumn", ""]],
    inputs: {
      context: "context",
      enableDrag: "enableDrag"
    },
    outputs: {
      drag: "drag"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableColumnDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDraggableColumn]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DraggableDirective,
      decorators: [{
        type: Host
      }]
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: DragAndDropService
    }, {
      type: DragHintService
    }, {
      type: DropCueService
    }, {
      type: NavigationService2
    }, {
      type: Renderer2
    }];
  }, {
    context: [{
      type: Input
    }],
    enableDrag: [{
      type: Input
    }],
    drag: [{
      type: Output
    }]
  });
})();
var DropTargetDirective = class _DropTargetDirective {
  element;
  service;
  context = {};
  enter = new EventEmitter();
  leave = new EventEmitter();
  drop = new EventEmitter();
  subscriptions = new Subscription();
  constructor(element, service) {
    this.element = element;
    this.service = service;
  }
  ngOnInit() {
    this.service.add(this);
    const changes = this.service.changes.pipe(filter(({
      target
    }) => target === this));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "leave")).subscribe((e) => {
      this.leave.next(this.eventArgs(e));
    }));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "enter")).subscribe((e) => {
      this.enter.next(this.eventArgs(e));
    }));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "drop")).subscribe((e) => {
      this.drop.next(this.eventArgs(e));
    }));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  eventArgs(e) {
    return {
      target: this,
      mouseEvent: e.mouseEvent,
      draggable: e.draggable
    };
  }
  static ɵfac = function DropTargetDirective_Factory(t) {
    return new (t || _DropTargetDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DragAndDropService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropTargetDirective,
    selectors: [["", "kendoDropTarget", ""]],
    inputs: {
      context: "context"
    },
    outputs: {
      enter: "enter",
      leave: "leave",
      drop: "drop"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTarget]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DragAndDropService
    }];
  }, {
    context: [{
      type: Input
    }],
    enter: [{
      type: Output
    }],
    leave: [{
      type: Output
    }],
    drop: [{
      type: Output
    }]
  });
})();
function isColumnGroupComponent(column) {
  return column.isColumnGroup;
}
var ColumnGroupComponent2 = class _ColumnGroupComponent extends ColumnBase2 {
  parent;
  /**
   * @hidden
   */
  includeInChooser = false;
  /**
   * @hidden
   */
  isColumnGroup = true;
  /**
   * @hidden
   */
  minResizableWidth = 10;
  /**
   * @hidden
   */
  maxResizableWidth;
  /**
   * @hidden
   */
  children;
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
    if (parent && parent.isSpanColumn) {
      throw new Error(ColumnConfigurationErrorMessages.nestedInside("ColumnGroupComponent", "SpanColumnComponent"));
    }
  }
  /**
   * @hidden
   */
  rowspan() {
    return 1;
  }
  /**
   * @hidden
   *
   * Used to hide the cellRowspan property from the public API.
   */
  set cellRowspan(cellRowSpan) {
    super.cellRowspan = cellRowSpan;
  }
  /**
   * @hidden
   */
  get colspan() {
    if (!this.children) {
      return 1;
    }
    return columnsSpan(this.children.filter((child) => child !== this && child.isVisible));
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this.children ? (this.firstChild || {}).leafIndex : -1;
  }
  get childrenArray() {
    return this.children.filter((c) => c !== this);
  }
  get hasChildren() {
    return Boolean(this.firstChild);
  }
  get firstChild() {
    return this.children.find((column) => column !== this);
  }
  static ɵfac = function ColumnGroupComponent_Factory(t) {
    return new (t || _ColumnGroupComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnGroupComponent,
    selectors: [["kendo-grid-column-group"]],
    contentQueries: function ColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnBase2, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
      }
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _ColumnGroupComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ColumnGroupComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnGroupComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => ColumnGroupComponent2)
      }],
      selector: "kendo-grid-column-group",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }]
  });
})();
var DetailTemplateDirective = class _DetailTemplateDirective {
  templateRef;
  /**
   * Defines the function that indicates if a given detail row and the associated **Expand** or **Collapse** button will be displayed.
   */
  set showIf(fn) {
    if (typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("showIf", fn));
    }
    this._condition = fn;
  }
  get showIf() {
    return this._condition;
  }
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  _condition = () => true;
  static ɵfac = function DetailTemplateDirective_Factory(t) {
    return new (t || _DetailTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DetailTemplateDirective,
    selectors: [["", "kendoGridDetailTemplate", ""]],
    inputs: {
      showIf: [InputFlags.None, "kendoGridDetailTemplateShowIf", "showIf"]
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridDetailTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showIf: [{
      type: Input,
      args: ["kendoGridDetailTemplateShowIf"]
    }]
  });
})();
var ColGroupComponent = class _ColGroupComponent {
  columns = [];
  groups = [];
  detailTemplate;
  sort = new Array();
  get columnsToRender() {
    return columnsToRender(this.columns);
  }
  trackBy(index) {
    return index;
  }
  isSorted(column) {
    const state2 = this.sortDescriptor(column.field);
    return this.isSortable(column) && (state2.dir === "asc" || state2.dir === "desc");
  }
  getColumnComponent(column) {
    return column;
  }
  isSortable(column) {
    return !isNullOrEmptyString(column.field) && isTruthy(column.sortable);
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
  static ɵfac = function ColGroupComponent_Factory(t) {
    return new (t || _ColGroupComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColGroupComponent,
    selectors: [["", "kendoGridColGroup", ""]],
    inputs: {
      columns: "columns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      sort: "sort"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c04,
    decls: 4,
    vars: 4,
    consts: [[3, "k-group-col", 4, "ngFor", "ngForOf"], [3, "k-hierarchy-col", 4, "ngIf"], [3, "width", "k-sorted", 4, "ngFor", "ngForOf", "ngForTrackBy"]],
    template: function ColGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0);
        ɵɵtemplate(1, ColGroupComponent_col_1_Template, 1, 2, "col", 0)(2, ColGroupComponent_col_2_Template, 1, 2, "col", 1)(3, ColGroupComponent_col_3_Template, 1, 4, "col", 2);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.groups);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.columnsToRender)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, NgIf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColGroupComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridColGroup]",
      template: `
    <ng-container>
        <col [class.k-group-col]="true" *ngFor="let g of groups" />
        <col [class.k-hierarchy-col]="true" *ngIf="detailTemplate?.templateRef"/>
        <col *ngFor="let column of columnsToRender; trackBy: trackBy;"
            [style.width.px]="column.width"
            [class.k-sorted]="isSorted(getColumnComponent(column))"/>
    </ng-container>
    `,
      standalone: true,
      imports: [NgForOf, NgIf]
    }]
  }], null, {
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    sort: [{
      type: Input
    }]
  });
})();
var LoadingTemplateDirective = class _LoadingTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function LoadingTemplateDirective_Factory(t) {
    return new (t || _LoadingTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadingTemplateDirective,
    selectors: [["", "kendoGridLoadingTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridLoadingTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var LoadingComponent = class _LoadingComponent {
  ctx;
  hostClass = true;
  loadingTemplate;
  get loadingText() {
    return this.ctx.localization.get("loading");
  }
  constructor(ctx) {
    this.ctx = ctx;
  }
  static ɵfac = function LoadingComponent_Factory(t) {
    return new (t || _LoadingComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LoadingComponent,
    selectors: [["", "kendoGridLoading", ""]],
    hostVars: 2,
    hostBindings: function LoadingComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-loading-mask", ctx.hostClass);
      }
    },
    inputs: {
      loadingTemplate: "loadingTemplate"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c110,
    decls: 2,
    vars: 2,
    consts: [[4, "ngIf"], [1, "k-loading-text"], [1, "k-loading-image"], [1, "k-loading-color"], [3, "ngTemplateOutlet"]],
    template: function LoadingComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, LoadingComponent_ng_container_0_Template, 5, 1, "ng-container", 0)(1, LoadingComponent_1_Template, 1, 1, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.loadingTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loadingTemplate);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridLoading]",
      template: `
        <ng-container *ngIf="!loadingTemplate">
            <span class="k-loading-text">{{ loadingText }}</span>
            <div class="k-loading-image"></div>
            <div class="k-loading-color"></div>
        </ng-container>
        <ng-template *ngIf="loadingTemplate" [ngTemplateOutlet]="loadingTemplate?.templateRef">
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-loading-mask"]
    }],
    loadingTemplate: [{
      type: Input
    }]
  });
})();
var ResizeService = class _ResizeService {
  resizeSubscription = new Subscription(() => {
  });
  dispatcher = new Subject();
  changes = this.dispatcher.asObservable().pipe(throttleTime(100));
  connect(resizes) {
    this.resizeSubscription.add(resizes.subscribe(this.dispatcher));
  }
  destroy() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  static ɵfac = function ResizeService_Factory(t) {
    return new (t || _ResizeService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ResizeService,
    factory: _ResizeService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeService, [{
    type: Injectable
  }], null, null);
})();
var ResizableContainerDirective = class _ResizableContainerDirective {
  el;
  renderer;
  resizeService;
  ctx;
  _lockedWidth;
  set lockedWidth(value) {
    this._lockedWidth = value;
    if (this.enabled) {
      this.attachResize();
      this.resize();
    }
  }
  set kendoGridResizableContainer(enabled) {
    const refresh = enabled !== this.enabled;
    this.enabled = enabled;
    if (refresh) {
      this.attachResize();
      this.resize();
    }
  }
  enabled = false;
  resizeSubscription;
  constructor(el, renderer, resizeService, ctx) {
    this.el = el;
    this.renderer = renderer;
    this.resizeService = resizeService;
    this.ctx = ctx;
  }
  ngOnDestroy() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  attachResize() {
    if (this.resizeSubscription && !this.enabled) {
      this.resizeSubscription.unsubscribe();
      this.resizeSubscription = null;
    }
    if (!this.resizeSubscription && this.enabled) {
      this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));
    }
  }
  resize() {
    if (this.ctx.grid && this.ctx.grid.wrapper) {
      const containerElement = this.ctx.grid.wrapper.nativeElement;
      const width2 = Math.max(containerElement.clientWidth - this._lockedWidth, 0);
      if (this.enabled && width2 > 0) {
        this.renderer.setStyle(this.el.nativeElement, "width", width2 + "px");
      } else {
        this.renderer.setStyle(this.el.nativeElement, "width", "");
      }
    }
  }
  static ɵfac = function ResizableContainerDirective_Factory(t) {
    return new (t || _ResizableContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ResizeService), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ResizableContainerDirective,
    selectors: [["", "kendoGridResizableContainer", ""]],
    inputs: {
      lockedWidth: "lockedWidth",
      kendoGridResizableContainer: "kendoGridResizableContainer"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizableContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridResizableContainer]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ResizeService
    }, {
      type: ContextService
    }];
  }, {
    lockedWidth: [{
      type: Input,
      args: ["lockedWidth"]
    }],
    kendoGridResizableContainer: [{
      type: Input
    }]
  });
})();
var FocusGroup = class _FocusGroup {
  root;
  active = true;
  children = [];
  get focusableChildren() {
    return this.children.filter((el) => el.canFocus());
  }
  get isActive() {
    return this.active;
  }
  constructor(root) {
    this.root = root;
    this.root.registerGroup(this);
  }
  ngOnDestroy() {
    this.root.unregisterGroup(this);
    this.active = true;
  }
  registerElement(element) {
    this.unregisterElement(element);
    this.children.push(element);
  }
  unregisterElement(element) {
    this.children = this.children.filter((f) => f !== element);
  }
  /**
   * Returns a Boolean value which indicates if the group will receive focus when the cell is focused.
   * Requires a single "simple" focusable element such as a button or a checkbox.
   */
  isNavigable() {
    const focusable = this.focusableChildren;
    return focusable.length === 1 && focusable[0].isNavigable();
  }
  canFocus() {
    return this.focusableChildren.length > 0;
  }
  focus() {
    if (this.canFocus() && !this.hasFocus()) {
      this.focusableChildren[0].focus();
    }
  }
  activate() {
    this.toggleState(true);
  }
  deactivate() {
    this.toggleState(false);
  }
  hasFocus() {
    return this.children.reduce((focused, element) => focused || element.hasFocus(), false);
  }
  toggleState(active) {
    if (this.active !== active) {
      this.active = active;
      this.children.forEach((f) => f.toggle(active));
    }
  }
  static ɵfac = function FocusGroup_Factory(t) {
    return new (t || _FocusGroup)(ɵɵinject(FocusRoot));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusGroup,
    factory: _FocusGroup.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusGroup, [{
    type: Injectable
  }], function() {
    return [{
      type: FocusRoot
    }];
  }, null);
})();
var reset = (...lists) => {
  let diff = false;
  for (let idx2 = 0; idx2 < lists.length; idx2++) {
    const [list2, columns] = lists[idx2];
    diff = diff || list2.length !== columns.length;
    list2.reset(columns);
  }
  return diff;
};
var ColumnsContainer = class {
  columns;
  allColumns = new QueryList();
  leafColumns = new QueryList();
  lockedColumns = new QueryList();
  nonLockedColumns = new QueryList();
  lockedLeafColumns = new QueryList();
  nonLockedLeafColumns = new QueryList();
  totalLevels = 0;
  changes = new EventEmitter();
  leafColumnsToRender = [];
  lockedColumnsToRender = [];
  nonLockedColumnsToRender = [];
  hasGroupHeaderColumn = false;
  hasGroupFooter = false;
  hasFooter = false;
  unlockedWidth = 0;
  constructor(columns) {
    this.columns = columns;
  }
  refresh() {
    const currentLevels = this.totalLevels;
    const leafColumns2 = new Array();
    const lockedLeafColumns = new Array();
    const nonLockedLeafColumns = new Array();
    const lockedColumns = new Array();
    const nonLockedColumns = new Array();
    const allColumns = new Array();
    const leafColumnsToRender = new Array();
    const lockedColumnsToRender = new Array();
    const nonLockedColumnsToRender = new Array();
    let hasGroupHeaderColumn = false;
    let hasGroupFooter = false;
    let hasFooter = false;
    let unlockedWidth = 0;
    let leafIndex = 0;
    this.totalLevels = 0;
    this.columns().forEach((column) => {
      const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;
      const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;
      const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;
      if (!isColumnGroupComponent(column)) {
        containerLeafColumns.push(column);
        leafColumns2.push(column);
        leafColumnsToRender.push(...columnsToRender([column]));
        toRenderContainer.push(...columnsToRender([column]));
        hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn((leaf) => Boolean(leaf.groupHeaderColumnTemplateRef), column);
        hasGroupFooter = hasGroupFooter || someLeafColumn((leaf) => Boolean(leaf.groupFooterTemplateRef), column);
        hasFooter = hasFooter || someLeafColumn((leaf) => Boolean(leaf.footerTemplateRef), column);
        if (!column.isLocked) {
          unlockedWidth += column.width || 0;
        }
        if (column.isSpanColumn) {
          column.children.forEach((c) => {
            c.leafIndex = leafIndex++;
          });
        } else {
          column.leafIndex = leafIndex++;
        }
      }
      containerColumns.push(column);
      allColumns.push(column);
      this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;
    });
    this.hasGroupHeaderColumn = hasGroupHeaderColumn;
    this.hasGroupFooter = hasGroupFooter;
    this.hasFooter = hasFooter;
    this.leafColumnsToRender = leafColumnsToRender;
    this.lockedColumnsToRender = lockedColumnsToRender;
    this.nonLockedColumnsToRender = nonLockedColumnsToRender;
    this.unlockedWidth = unlockedWidth;
    const changes = reset([this.leafColumns, leafColumns2], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;
    if (changes) {
      this.changes.emit();
    }
    return changes;
  }
};
var NO_STICKY = {
  left: "0px",
  right: "0px"
};
var ColumnInfoService = class _ColumnInfoService {
  visibilityChange = new EventEmitter();
  lockedChange = new EventEmitter();
  stickyChange = new EventEmitter();
  columnRangeChange = new EventEmitter();
  columnsContainer = new ColumnsContainer(() => []);
  list;
  stickyColumns;
  get lockedLeafColumns() {
    return this.columnsContainer.lockedLeafColumns;
  }
  get nonLockedLeafColumns() {
    return this.columnsContainer.nonLockedLeafColumns;
  }
  get isLocked() {
    return this.lockedLeafColumns.length > 0;
  }
  get totalLevels() {
    return this.columnsContainer.totalLevels;
  }
  get hiddenColumns() {
    if (!this.list) {
      return [];
    }
    return this.list().filter((column) => !column.isVisible);
  }
  get leafNamedColumns() {
    const columns = expandColumns(this.list().filterSort((column) => !column.isColumnGroup)).filter((column) => column.matchesMedia && column.displayTitle);
    return orderBy(columns, [{
      field: "locked",
      dir: "desc"
    }]);
  }
  get unlockedRootCount() {
    return this.list().rootColumns().filter((column) => !column.locked && column.isVisible).length;
  }
  stickyColumnsStyles(column) {
    this.stickyColumns = this.list().rootColumns().filter((column2) => column2.sticky && !column2.locked && column2.isVisible);
    if (this.stickyColumns.length === 0) {
      return NO_STICKY;
    }
    const result = this.stickyColumns.reduce((acc, curr) => {
      if (curr.leafIndex < column.leafIndex) {
        acc.left += curr.width;
      } else if (curr.leafIndex > column.leafIndex) {
        acc.right += curr.width;
      }
      return acc;
    }, {
      left: 0,
      right: 0
    });
    return {
      left: `${result.left}px`,
      right: `${result.right}px`
    };
  }
  init(columns, list2) {
    this.columnsContainer = columns;
    this.list = list2;
    this.stickyColumns = null;
  }
  changeVisibility(columns) {
    this.stickyColumns = null;
    this.visibilityChange.emit(columns);
  }
  changeLocked(columns) {
    this.stickyColumns = null;
    this.lockedChange.emit(columns);
  }
  changeStuck(columns) {
    this.stickyColumns = null;
    this.stickyChange.emit(columns);
  }
  static ɵfac = function ColumnInfoService_Factory(t) {
    return new (t || _ColumnInfoService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnInfoService,
    factory: _ColumnInfoService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnInfoService, [{
    type: Injectable
  }], null, null);
})();
var id$3 = 0;
function nextId$1() {
  return id$3++;
}
var LogicalCellDirective = class _LogicalCellDirective {
  focusGroup;
  element;
  columnInfoService;
  idService;
  navigationService;
  renderer;
  zone;
  cellContext;
  logicalColIndex;
  logicalRowIndex;
  logicalSlaveCell = false;
  colIndex;
  colSpan = 1;
  rowSpan = 1;
  groupItem;
  dataRowIndex = -1;
  dataItem;
  detailExpandCell = false;
  headerLabelText;
  uid = nextId$1();
  get id() {
    if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {
      return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);
    }
  }
  get cellRowspan() {
    return String(this.rowSpan);
  }
  get rowspanClass() {
    return this.dataRowIndex > -1 && this.rowSpan > 1;
  }
  get ariaColIndex() {
    if (this.logicalSlaveCell || this.logicalColIndex === -1) {
      return void 0;
    }
    return this.logicalColIndex + 1;
  }
  navigationChange;
  constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {
    this.focusGroup = focusGroup;
    this.element = element;
    this.columnInfoService = columnInfoService;
    this.idService = idService;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this.zone = zone;
    this.cellContext = cellContext;
  }
  ngOnInit() {
    if (!this.navigationService.tableEnabled) {
      return;
    }
    this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));
  }
  ngDoCheck() {
    if (!this.navigationService.tableEnabled || this.logicalColIndex === -1) {
      return;
    }
    if (this.cellContext) {
      this.cellContext.focusGroup = this.focusGroup;
    }
    this.registerNoChanges();
  }
  ngOnChanges(changes) {
    if (!this.navigationService.tableEnabled) {
      return;
    }
    const keys = Object.keys(changes);
    if (keys.length === 1 && keys[0] === "groupItem" || this.logicalColIndex === -1) {
      return;
    }
    const indexChange = changes["logicalColIndex"];
    const rowIndexChange = changes["logicalRowIndex"];
    const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;
    const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;
    this.navigationService.unregisterCell(index, rowIndex, this);
    this.registerChanges();
    this.updateElement();
  }
  ngOnDestroy() {
    if (this.navigationChange) {
      this.navigationChange.unsubscribe();
    }
    this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);
  }
  onNavigationChange(e) {
    const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;
    const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;
    if (active || wasActive) {
      this.updateElement();
    }
  }
  updateElement() {
    const el = this.element.nativeElement;
    this.renderer.setAttribute(el, "tabIndex", this.isFocusable() && !this.logicalSlaveCell ? "0" : "-1");
    if (this.isFocused()) {
      if (this.focusGroup.isNavigable()) {
        this.focusGroup.focus();
      } else {
        if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {
          this.microtask(() => this.isFocused() && el.focus());
        }
        this.renderer.addClass(el, "k-focus");
      }
      if (this.headerLabelText) {
        el.removeAttribute("aria-label");
      }
    } else {
      this.renderer.removeClass(el, "k-focus");
      if (this.headerLabelText) {
        el.setAttribute("aria-label", this.headerLabelText);
      }
    }
  }
  microtask(callback) {
    this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));
  }
  registerChanges() {
    if (!this.logicalSlaveCell) {
      this.navigationService.registerCell(this);
    }
  }
  registerNoChanges() {
    if (!this.logicalSlaveCell) {
      this.navigationService.registerCellOnCurrentRow(this);
    }
  }
  isFocusable() {
    return this.navigationService.isCellFocusable(this);
  }
  isFocused() {
    return this.navigationService.isCellFocused(this);
  }
  static ɵfac = function LogicalCellDirective_Factory(t) {
    return new (t || _LogicalCellDirective)(ɵɵdirectiveInject(FocusGroup), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(CELL_CONTEXT, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LogicalCellDirective,
    selectors: [["", "kendoGridLogicalCell", ""]],
    hostVars: 5,
    hostBindings: function LogicalCellDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.id)("rowspan", ctx.cellRowspan)("aria-colindex", ctx.ariaColIndex);
        ɵɵclassProp("k-table-td-row-span", ctx.rowspanClass);
      }
    },
    inputs: {
      logicalColIndex: "logicalColIndex",
      logicalRowIndex: "logicalRowIndex",
      logicalSlaveCell: "logicalSlaveCell",
      colIndex: "colIndex",
      colSpan: "colSpan",
      rowSpan: "rowSpan",
      groupItem: "groupItem",
      dataRowIndex: "dataRowIndex",
      dataItem: "dataItem",
      detailExpandCell: "detailExpandCell",
      headerLabelText: "headerLabelText"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FocusGroup,
      deps: [FocusRoot],
      useClass: FocusGroup
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogicalCellDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: FocusGroup,
        deps: [FocusRoot],
        useClass: FocusGroup
      }],
      selector: "[kendoGridLogicalCell]",
      standalone: true
    }]
  }], function() {
    return [{
      type: FocusGroup
    }, {
      type: ElementRef
    }, {
      type: ColumnInfoService
    }, {
      type: IdService
    }, {
      type: NavigationService2
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }];
  }, {
    logicalColIndex: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    logicalSlaveCell: [{
      type: Input
    }],
    colIndex: [{
      type: Input
    }],
    colSpan: [{
      type: Input
    }],
    rowSpan: [{
      type: Input
    }],
    groupItem: [{
      type: Input
    }],
    dataRowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    detailExpandCell: [{
      type: Input
    }],
    headerLabelText: [{
      type: Input
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    cellRowspan: [{
      type: HostBinding,
      args: ["attr.rowspan"]
    }],
    rowspanClass: [{
      type: HostBinding,
      args: ["class.k-table-td-row-span"]
    }],
    ariaColIndex: [{
      type: HostBinding,
      args: ["attr.aria-colindex"]
    }]
  });
})();
var id$2 = 0;
function nextId2() {
  return id$2++;
}
var LogicalRowDirective = class _LogicalRowDirective {
  idService;
  navigation;
  logicalRowIndex;
  logicalSlaveRow = false;
  logicalCellsCount;
  logicalSlaveCellsCount = 0;
  dataRowIndex = -1;
  dataItem;
  totalColumns;
  uid = nextId2();
  get hostRole() {
    return this.logicalSlaveRow ? "presentation" : "row";
  }
  get ariaRowIndex() {
    return this.logicalSlaveRow ? null : this.logicalRowIndex + 1;
  }
  get rowIndex() {
    return this.logicalSlaveRow ? this.logicalRowIndex + 1 : null;
  }
  tableRowClass = true;
  get ariaOwns() {
    if (this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {
      return void 0;
    }
    const ids = [];
    if (this.dataRowIndex < 0) {
      let total = this.logicalCellsCount + this.logicalSlaveCellsCount;
      this.columnsArray.forEach((column) => {
        if (column.isSpanColumn) {
          total += column.colspan - 1;
        }
      });
      for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {
        ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));
      }
    } else {
      let columnIndex = 0;
      this.columnsArray.forEach((column) => {
        if (!column.isLocked) {
          ids.push(this.idService.cellId(this.logicalRowIndex, columnIndex));
        }
        columnIndex += column.isSpanColumn ? column.colspan : 1;
      });
    }
    return ids.join(" ");
  }
  constructor(idService, navigation) {
    this.idService = idService;
    this.navigation = navigation;
  }
  ngOnChanges(changes) {
    if (!this.navigation.enabled || this.logicalSlaveRow) {
      return;
    }
    const indexChange = changes.logicalRowIndex;
    const logicalSlaveRowChange = changes.logicalSlaveRow;
    if (indexChange || logicalSlaveRowChange) {
      const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;
      this.navigation.unregisterRow(index, this);
      this.navigation.registerRow(this);
    } else if (anyChanged(["dataRowIndex", "dataItem"], changes)) {
      this.navigation.updateRow(this);
    }
  }
  ngOnDestroy() {
    this.navigation.unregisterRow(this.logicalRowIndex, this);
  }
  get columnsArray() {
    return this.totalColumns?.allColumns.toArray() || [];
  }
  static ɵfac = function LogicalRowDirective_Factory(t) {
    return new (t || _LogicalRowDirective)(ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(NavigationService2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LogicalRowDirective,
    selectors: [["", "kendoGridLogicalRow", ""]],
    hostVars: 6,
    hostBindings: function LogicalRowDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole)("aria-rowindex", ctx.ariaRowIndex)("data-kendo-grid-row-index", ctx.rowIndex)("aria-owns", ctx.ariaOwns);
        ɵɵclassProp("k-table-row", ctx.tableRowClass);
      }
    },
    inputs: {
      logicalRowIndex: "logicalRowIndex",
      logicalSlaveRow: "logicalSlaveRow",
      logicalCellsCount: "logicalCellsCount",
      logicalSlaveCellsCount: "logicalSlaveCellsCount",
      dataRowIndex: "dataRowIndex",
      dataItem: "dataItem",
      totalColumns: "totalColumns"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogicalRowDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridLogicalRow]",
      standalone: true
    }]
  }], function() {
    return [{
      type: IdService
    }, {
      type: NavigationService2
    }];
  }, {
    logicalRowIndex: [{
      type: Input
    }],
    logicalSlaveRow: [{
      type: Input
    }],
    logicalCellsCount: [{
      type: Input
    }],
    logicalSlaveCellsCount: [{
      type: Input
    }],
    dataRowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaRowIndex: [{
      type: HostBinding,
      args: ["attr.aria-rowindex"]
    }],
    rowIndex: [{
      type: HostBinding,
      args: ["attr.data-kendo-grid-row-index"]
    }],
    tableRowClass: [{
      type: HostBinding,
      args: ["class.k-table-row"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }]
  });
})();
var FORMAT_REGEX = /\{\d+:?/;
var FieldAccessorPipe = class _FieldAccessorPipe {
  intlService;
  constructor(intlService) {
    this.intlService = intlService;
  }
  transform(dataItem, fieldName, format) {
    if (!isNullOrEmptyString(fieldName)) {
      const value = getter(fieldName)(dataItem);
      if (!isNullOrEmptyString(format)) {
        return this.formatValue(format, value);
      }
      return value;
    }
    return dataItem;
  }
  formatValue(format, value) {
    const intl = this.intlService;
    if (isString(format) && format.match(FORMAT_REGEX)) {
      return intl.format(format, value);
    }
    return intl.toString(value, format);
  }
  static ɵfac = function FieldAccessorPipe_Factory(t) {
    return new (t || _FieldAccessorPipe)(ɵɵdirectiveInject(IntlService, 16));
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "valueOf",
    type: _FieldAccessorPipe,
    pure: false,
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FieldAccessorPipe, [{
    type: Pipe,
    args: [{
      // eslint-disable-next-line @angular-eslint/pipe-prefix
      name: "valueOf",
      pure: false,
      standalone: true
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var GridTableDirective = class _GridTableDirective {
  wrapper;
  hostClass = true;
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-table-sm", "k-table-md");
    }
  }
  get size() {
    return this._size;
  }
  _size = "medium";
  constructor(wrapper) {
    this.wrapper = wrapper;
  }
  static ɵfac = function GridTableDirective_Factory(t) {
    return new (t || _GridTableDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridTableDirective,
    selectors: [["", "kendoGridTable", ""]],
    hostVars: 6,
    hostBindings: function GridTableDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-table", ctx.hostClass)("k-table-sm", ctx.sizeSmallClass)("k-table-md", ctx.sizeMediumClass);
      }
    },
    inputs: {
      size: "size"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridTableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridTable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-table-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-table-md"]
    }],
    size: [{
      type: Input
    }]
  });
})();
var forEachColumn = (list2, callback) => {
  list2.forEach((column) => {
    callback(column);
    if (column.isColumnGroup && column.hasChildren) {
      forEachColumn(column.childrenArray, callback);
    }
  });
};
var forEachLevel = (list2, callback) => {
  sortColumns(list2).forEach((column) => {
    callback(column);
    if (column.isColumnGroup && column.hasChildren) {
      forEachLevel(column.childrenArray, callback);
    }
  });
};
var filterHierarchy = (list2, predicate) => {
  const result = [];
  sortColumns(list2).forEach((column) => {
    if (predicate(column)) {
      if (column.isColumnGroup) {
        const children2 = filterHierarchy(column.childrenArray, predicate);
        if (children2.length) {
          result.push(column, ...children2);
        }
      } else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {
        result.push(column);
      }
    }
  });
  return result.sort((a, b) => Number(b.locked) - Number(a.locked));
};
var ColumnList = class _ColumnList {
  columns;
  static empty() {
    return new _ColumnList(new QueryList());
  }
  constructor(columns) {
    this.columns = columns;
  }
  forEach(callback) {
    forEachColumn(this.columns, callback);
  }
  filter(callback) {
    const result = [];
    forEachColumn(this.columns, (column) => {
      if (callback(column)) {
        result.push(column);
      }
    });
    return result;
  }
  filterHierarchy(predicate) {
    return filterHierarchy(this.columns.toArray(), predicate);
  }
  filterSort(callback) {
    const result = [];
    forEachLevel(this.columns.toArray(), (column) => {
      if (callback(column)) {
        result.push(column);
      }
    });
    return result;
  }
  toArray() {
    const result = [];
    forEachColumn(this.columns, (column) => {
      result.push(column);
    });
    return result;
  }
  rootColumns() {
    return this.columns.toArray();
  }
  totalColumnLevels() {
    let totalLevels = 0;
    this.forEach((column) => {
      totalLevels = Math.max(column.level, totalLevels);
    });
    return totalLevels;
  }
};
var GroupInfoService = class {
  _columnList = ColumnList.empty;
  get columns() {
    return expandColumns(this._columnList().toArray()).filter(isColumnComponent);
  }
  registerColumnsContainer(columns) {
    this._columnList = columns;
  }
  formatForGroup(item) {
    const column = this.columnForGroup(item);
    return column ? column.format : "";
  }
  isGroupable(groupField) {
    const [column] = this.columns.filter((x) => x.field === groupField);
    return column ? column.groupable : true;
  }
  groupTitle(item) {
    const column = this.columnForGroup(item);
    return column ? column.title || column.field : this.groupField(item);
  }
  groupHeaderTemplate(item) {
    const column = this.columnForGroup(item);
    return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : void 0;
  }
  groupField(group) {
    return group.data ? group.data.field : group.field;
  }
  columnForGroup(group) {
    const field = this.groupField(group);
    const [column] = this.columns.filter((x) => x.field === field);
    return column;
  }
};
var GroupHeaderComponent = class _GroupHeaderComponent {
  groupsService;
  groupInfoService;
  ctx;
  rowIndex;
  logicalRowIndex;
  item;
  skipGroupDecoration = false;
  hasDetails = false;
  totalColumnsCount = 0;
  hasGroupHeaderColumn;
  groupHeaderColumns;
  columns;
  groups = [];
  groupItemClass = true;
  tableGroupRowClass = true;
  isExpanded = false;
  caretAltDownIcon = caretAltDownIcon;
  caretAltRightIcon = caretAltRightIcon;
  caretAltLeftIcon = caretAltLeftIcon;
  constructor(groupsService, groupInfoService, ctx) {
    this.groupsService = groupsService;
    this.groupInfoService = groupInfoService;
    this.ctx = ctx;
  }
  ngDoCheck() {
    const groupArgs = {
      group: this.item.data,
      groupIndex: this.item.index,
      parentGroup: getGroupRowArgs(this.item.parentGroup)
    };
    this.isExpanded = this.groupsService.isExpanded(groupArgs);
  }
  prefixGroupCell(item) {
    return new Array(item.level);
  }
  toggleGroup(item) {
    this.groupsService.toggleRow(item);
    return false;
  }
  groupSpan(item) {
    const groupCount = (this.groups || []).length;
    const detailOffset = this.hasDetails ? 1 : 0;
    if (this.hasGroupHeaderColumn) {
      return groupCount + 1 + detailOffset - item.level;
    }
    const columnCount = columnsSpan(this.columns);
    if (this.skipGroupDecoration) {
      return columnCount;
    }
    return groupCount + columnCount + detailOffset - item.level;
  }
  logicalColSpan() {
    return this.skipGroupDecoration ? 1 : this.totalColumnsCount;
  }
  ariaRole() {
    if (this.skipGroupDecoration) {
      return "presentation";
    }
    return "gridcell";
  }
  formatForGroup(item) {
    return this.groupInfoService.formatForGroup(item);
  }
  groupTitle(item) {
    return this.groupInfoService.groupTitle(item);
  }
  groupHeaderTemplate(item) {
    return this.groupInfoService.groupHeaderTemplate(item);
  }
  get groupButtonTitle() {
    const messageKey = this.isExpanded ? "groupCollapse" : "groupExpand";
    return this.ctx.localization.get(messageKey);
  }
  get arrowIcon() {
    const icon = !this.isExpanded ? !this.ctx.localization.rtl ? "caret-alt-right" : "caret-alt-left" : "caret-alt-down";
    return icon;
  }
  get arrowSVGIcon() {
    const icon = !this.isExpanded ? !this.ctx.localization.rtl ? this.caretAltRightIcon : this.caretAltLeftIcon : this.caretAltDownIcon;
    return icon;
  }
  static ɵfac = function GroupHeaderComponent_Factory(t) {
    return new (t || _GroupHeaderComponent)(ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GroupHeaderComponent,
    selectors: [["", "kendoGridGroupHeader", ""]],
    hostVars: 4,
    hostBindings: function GroupHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-grouping-row", ctx.groupItemClass)("k-table-group-row", ctx.tableGroupRowClass);
      }
    },
    inputs: {
      rowIndex: "rowIndex",
      logicalRowIndex: "logicalRowIndex",
      item: "item",
      skipGroupDecoration: "skipGroupDecoration",
      hasDetails: "hasDetails",
      totalColumnsCount: "totalColumnsCount",
      hasGroupHeaderColumn: "hasGroupHeaderColumn",
      groupHeaderColumns: "groupHeaderColumns",
      columns: "columns",
      groups: "groups"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c210,
    decls: 3,
    vars: 3,
    consts: [[4, "ngIf"], ["aria-selected", "false", "class", "k-table-td", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan", 4, "ngIf"], ["class", "k-group-cell k-table-td k-table-group-td", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-group-cell", "k-table-td", "k-table-group-td"], ["aria-selected", "false", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"], [1, "k-reset"], ["href", "#", "tabindex", "-1", "role", "presentation", 3, "click"], [3, "name", "svgIcon"], [3, "templateContext"], ["role", "gridcell", "class", "k-table-td", "aria-selected", "false", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan", 4, "ngFor", "ngForOf"], ["role", "gridcell", "aria-selected", "false", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function GroupHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, GroupHeaderComponent_ng_container_0_Template, 2, 1, "ng-container", 0)(1, GroupHeaderComponent_td_1_Template, 3, 9, "td", 1)(2, GroupHeaderComponent_ng_container_2_Template, 2, 1, "ng-container", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.skipGroupDecoration);
        ɵɵadvance();
        ɵɵproperty("ngIf", !(ctx.skipGroupDecoration && ctx.hasGroupHeaderColumn));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasGroupHeaderColumn);
      }
    },
    dependencies: [NgIf, NgForOf, LogicalCellDirective, IconWrapperComponent, TemplateContextDirective, NgTemplateOutlet, FieldAccessorPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridGroupHeader]",
      template: `
        <ng-container *ngIf="!skipGroupDecoration">
            <td class="k-group-cell k-table-td k-table-group-td"
                role="presentation"
                *ngFor="let g of prefixGroupCell(item)"></td>
        </ng-container>
        <td [attr.colspan]="groupSpan(item)" *ngIf="!(skipGroupDecoration && hasGroupHeaderColumn)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            class="k-table-td"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
                <ng-container *ngIf="!skipGroupDecoration">
                    <a href="#" tabindex="-1" (click)="toggleGroup(item)"
                        role="presentation"
                        [attr.title]="groupButtonTitle"
                        [attr.aria-label]="groupButtonTitle">
                        <kendo-icon-wrapper
                            [name]="arrowIcon"
                            [svgIcon]="arrowSVGIcon"></kendo-icon-wrapper>
                    </a>
                    <ng-container *ngIf="!groupHeaderTemplate(item)">
                    {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                    </ng-container>
                    <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                    </ng-template>
                </ng-container>
            </p>
        </td>
        <ng-container *ngIf="hasGroupHeaderColumn">
            <td *ngFor="let column of groupHeaderColumns; let index = index"
                role="gridcell"
                class="k-table-td"
                aria-selected="false"
                kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="index + 1"
                [logicalSlaveCell]="false"
                [groupItem]="item"
                [colSpan]="1"
            >
                <ng-template *ngIf="column.groupHeaderColumnTemplateRef" [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-template>
            </td>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, NgForOf, LogicalCellDirective, IconWrapperComponent, TemplateContextDirective, NgTemplateOutlet, FieldAccessorPipe]
    }]
  }], function() {
    return [{
      type: GroupsService
    }, {
      type: GroupInfoService
    }, {
      type: ContextService
    }];
  }, {
    rowIndex: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    skipGroupDecoration: [{
      type: Input
    }],
    hasDetails: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    hasGroupHeaderColumn: [{
      type: Input
    }],
    groupHeaderColumns: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    groupItemClass: [{
      type: HostBinding,
      args: ["class.k-grouping-row"]
    }],
    tableGroupRowClass: [{
      type: HostBinding,
      args: ["class.k-table-group-row"]
    }]
  });
})();
var withoutField = ({
  field
}) => isNullOrEmptyString(field);
var alreadyGrouped = ({
  groups,
  field
}) => groups.some((group) => group.field === field);
var overSameTarget = ({
  target,
  field
}) => target.field === field;
var overLastTarget = ({
  target
}) => target.lastTarget;
var isLastGroup = ({
  groups,
  field
}) => groups.map((group) => group.field).indexOf(field) === groups.length - 1;
var isNotGroupable = (groupsService) => ({
  field
}) => !groupsService.isGroupable(field);
var columnRules = (groupService) => or(withoutField, alreadyGrouped, isNotGroupable(groupService));
var indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));
var GroupPanelComponent = class _GroupPanelComponent {
  hint;
  cue;
  groupInfoService;
  ctx;
  cd;
  popupService;
  ngZone;
  renderer;
  change = new EventEmitter();
  get groupHeaderClass() {
    return true;
  }
  set text(value) {
    this.emptyText = value;
  }
  get text() {
    return this.emptyText ? this.emptyText : this.ctx.localization.get("groupPanelEmpty");
  }
  navigable;
  groups = [];
  dropTargets = new QueryList();
  defaultTemplate;
  groupTitles = [];
  isChipMenuOpen = false;
  get gridId() {
    return this.ctx.grid?.ariaRootId;
  }
  rtl = false;
  first;
  last;
  arrowLeftIcon = arrowLeftIcon;
  arrowRightIcon = arrowRightIcon;
  emptyText;
  subscription;
  targetSubscription;
  popupSubs;
  popupRef;
  activeItem;
  constructor(hint, cue, groupInfoService, ctx, cd, popupService, ngZone, renderer) {
    this.hint = hint;
    this.cue = cue;
    this.groupInfoService = groupInfoService;
    this.ctx = ctx;
    this.cd = cd;
    this.popupService = popupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.subscription = this.ctx.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.cd.markForCheck();
    });
    this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));
  }
  ngDoCheck() {
    const currentTitles = this.groups.map((group) => this.groupInfoService.groupTitle(group));
    if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current3, idx2) => current3 !== this.groupTitles[idx2])) {
      this.groupTitles = currentTitles;
      this.cd.markForCheck();
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.destroyMenu();
  }
  messageFor(token) {
    return this.ctx.localization.get(token);
  }
  getTitle(group) {
    return this.messageFor(group.dir === "desc" ? "sortedDescending" : "sortedAscending");
  }
  getDirectionIcon(group) {
    return group.dir === "desc" ? "sort-desc-sm" : "sort-asc-sm";
  }
  getDirectionSvgIcon(group) {
    return group.dir === "desc" ? sortDescSmallIcon : sortAscSmallIcon;
  }
  directionChange(group) {
    group.dir = group.dir ? group.dir : "asc";
    group.dir = group.dir === "asc" ? "desc" : "asc";
    const index = this.groups.findIndex((x) => x.field === group.field);
    const groups = [...this.groups.slice(0, index), group, ...this.groups.slice(index + 1)];
    this.change.emit(groups);
  }
  insert(field, index) {
    const groups = this.groups.filter((x) => x.field !== field);
    if (groups.length || this.groups.length === 0) {
      this.change.emit([...groups.slice(0, index), {
        field
      }, ...groups.slice(index)]);
    }
  }
  remove(group) {
    this.destroyMenu();
    this.change.emit(this.groups.filter((x) => x.field !== group.field));
  }
  toggleMenu(chip, first, last2, field) {
    const anchor2 = chip.element.nativeElement.querySelector(".k-chip-action");
    if (this.popupRef) {
      const popupAnchor = this.popupRef.popup.instance.anchor;
      this.destroyMenu();
      if (anchor2 === popupAnchor) {
        return;
      }
    }
    this.first = first;
    this.last = last2;
    const direction = this.ctx.localization.rtl ? "right" : "left";
    this.popupRef = this.popupService.open({
      anchor: anchor2,
      content: this.defaultTemplate,
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      },
      positionMode: "absolute"
    });
    this.activeItem = this.dropTargets.find((dt) => dt.context.field === field);
    this.renderer.setAttribute(this.popupRef.popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    const menuItems = Array.from(this.popupRef.popupElement.querySelectorAll(".k-menu-item"));
    this.activateMenuItem(menuItems[1], "previous");
    this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {
      this.destroyMenu(true);
    });
    if (isUniversal()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.popupSubs.add(fromEvent(document, "click").pipe(filter((event2) => !closest3(event2.target, (node) => node === this.popupRef.popupElement || node.matches && node.matches(".k-chip-action")))).subscribe(() => {
        this.destroyMenu();
      }));
    });
  }
  handleKeyDown = (e) => {
    if (e.keyCode === Keys.ArrowDown || e.keyCode === Keys.ArrowUp) {
      e.preventDefault();
      const relatedItemType = e.target.matches(":first-child") ? "next" : "previous";
      this.activateMenuItem(e.target, relatedItemType);
    } else if (e.keyCode === Keys.Escape) {
      this.destroyMenu(true);
    } else if (e.keyCode === Keys.Tab) {
      this.destroyMenu(true);
    } else if (e.keyCode === Keys.Space || e.keyCode === Keys.Enter) {
      this.handleMenuClick(e);
    }
  };
  handleClick = (e) => {
    e.preventDefault();
    const menuItemEl = e.target.closest(".k-menu-item");
    if (!menuItemEl.matches('[aria-disabled="true"]')) {
      this.handleMenuClick(e);
      return;
    }
    if (menuItemEl.getAttribute("tabindex") === "0") {
      return;
    }
    const activeMenuItem = menuItemEl.closest(".k-menu-group").querySelector('[tabindex="0"]');
    const relatedItemType = activeMenuItem.matches(":first-child") ? "next" : "previous";
    this.activateMenuItem(activeMenuItem, relatedItemType);
  };
  canDrop(draggable, target) {
    const isIndicator = draggable.type === "groupIndicator";
    const rules2 = isIndicator ? indicatorRules : columnRules(this.groupInfoService);
    return !rules2({
      field: draggable.field,
      groups: this.groups,
      target
    });
  }
  attachTargets() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.targetSubscription = new Subscription();
    const enterStream = this.dropTargets.reduce((acc, target) => merge(acc, target.enter), from([]));
    const leaveStream = this.dropTargets.reduce((acc, target) => merge(acc, target.leave), from([]));
    const dropStream = this.dropTargets.reduce((acc, target) => merge(acc, target.drop), from([]));
    this.targetSubscription.add(enterStream.pipe(tap(() => {
      this.hint.removeLock();
      this.destroyMenu();
    }), filter(({
      draggable,
      target
    }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
  }
  enter({
    draggable,
    target
  }) {
    this.hint.enable();
    let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);
    if (this.ctx.localization.rtl) {
      before = !before;
    }
    this.cue.position(position(target.element.nativeElement, before));
  }
  leave() {
    this.hint.disable();
    this.cue.hide();
  }
  drop({
    target,
    draggable
  }) {
    const field = draggable.context.field;
    const index = this.dropTargets.toArray().indexOf(target);
    this.insert(field, index);
  }
  destroyMenu(focusAnchor) {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.popupSubs && this.popupSubs.unsubscribe();
      focusAnchor && this.activeItem.context.target.focus();
    }
  }
  activateMenuItem(item, relatedItemType) {
    this.renderer.setAttribute(item, "tabindex", "-1");
    this.renderer.removeClass(item, "k-focus");
    const relatedItem = item[`${relatedItemType}ElementSibling`];
    this.renderer.setAttribute(relatedItem, "tabindex", "0");
    this.renderer.addClass(relatedItem, "k-focus");
    this.ngZone.runOutsideAngular(() => setTimeout(() => relatedItem.focus()));
  }
  handleMenuClick(e) {
    e.preventDefault();
    if (e.target.getAttribute("aria-disabled") !== "true") {
      const chips = this.dropTargets.toArray().slice(0, this.dropTargets.length - 1);
      let groupChip, groupChipIndex;
      for (let i = 0; i < chips.length; i++) {
        if (chips[i].element.nativeElement === this.popupRef.popup.instance.anchor.closest(".k-chip")) {
          groupChip = chips[i];
          groupChipIndex = i;
          break;
        }
      }
      const isPrev = e.target.closest(".k-menu-item").matches(":first-child");
      if (isPrev && groupChipIndex > 0) {
        this.insert(groupChip.context.field, groupChipIndex - 1);
      } else if (!isPrev && groupChipIndex < chips.length - 1) {
        this.insert(groupChip.context.field, groupChipIndex + 1);
      }
      this.destroyMenu(true);
    }
  }
  static ɵfac = function GroupPanelComponent_Factory(t) {
    return new (t || _GroupPanelComponent)(ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GroupPanelComponent,
    selectors: [["kendo-grid-group-panel"]],
    viewQuery: function GroupPanelComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c53, 7, TemplateRef);
        ɵɵviewQuery(DropTargetDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargets = _t);
      }
    },
    hostVars: 2,
    hostBindings: function GroupPanelComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-grouping-header", ctx.groupHeaderClass);
      }
    },
    inputs: {
      text: "text",
      navigable: "navigable",
      groups: "groups"
    },
    outputs: {
      change: "change"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 5,
    vars: 3,
    consts: [["defaultTemplate", ""], ["chip", ""], ["class", "k-grouping-drop-container", "kendoDropTarget", "", 3, "context", 4, "ngIf"], ["role", "none", 3, "navigable", 4, "ngIf"], ["kendoDropTarget", "", 1, "k-grouping-drop-container", 3, "context"], ["role", "none", 3, "navigable"], ["kendoDropTarget", "", "kendoDraggableColumn", "", "kendoDraggable", "", 3, "title", "enableDrag", "context", "label", "removable", "hasMenu", "icon", "svgIcon", "contentClick", "remove", "menuToggle", "keydown.alt.arrowdown", 4, "ngFor", "ngForOf"], ["kendoDropTarget", "", "kendoDraggableColumn", "", "kendoDraggable", "", 3, "contentClick", "remove", "menuToggle", "keydown.alt.arrowdown", "title", "enableDrag", "context", "label", "removable", "hasMenu", "icon", "svgIcon"], ["unselectable", "on", "role", "menu", 1, "k-group", "k-menu-group", "k-reset", "k-menu-group-md", 3, "kendoEventsOutsideAngular"], ["role", "menuitem", "unselectable", "on", 1, "k-item", "k-menu-item"], [1, "k-link", "k-menu-link"], [3, "name", "svgIcon"], [1, "k-menu-link-text"]],
    template: function GroupPanelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, GroupPanelComponent_div_0_Template, 2, 3, "div", 2)(1, GroupPanelComponent_kendo_chiplist_1_Template, 2, 2, "kendo-chiplist", 3)(2, GroupPanelComponent_div_2_Template, 2, 2, "div", 2)(3, GroupPanelComponent_ng_template_3_Template, 11, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.groups.length === 0);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.groups.length !== 0);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.groups.length !== 0);
      }
    },
    dependencies: [NgIf, DropTargetDirective, ChipListComponent, NgForOf, ChipComponent, DraggableColumnDirective, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupPanelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-grid-group-panel",
      template: `
        <div
            *ngIf="groups.length === 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >
            {{ text }}
        </div>

        <kendo-chiplist
            *ngIf="groups.length !== 0"
            [navigable]="navigable"
            role="none">
            <kendo-chip
                *ngFor="let group of groups; let index = index; let first = first; let last = last;"
                #chip
                kendoDropTarget
                kendoDraggableColumn
                kendoDraggable
                [title]="getTitle(group)"
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index],
                    target: chip
                }"
                [label]="groupTitles[index]"
                [removable]="true"
                [hasMenu]="true"
                [icon]="getDirectionIcon(group)"
                [svgIcon]="getDirectionSvgIcon(group)"
                [attr.aria-haspopup]="'menu'"
                [attr.aria-expanded]="isChipMenuOpen"
                [attr.aria-controls]="gridId"
                (contentClick)="directionChange(group)"
                (remove)="remove(group)"
                (menuToggle)="toggleMenu(chip, first, last, group.field)"
                (keydown.alt.arrowdown)="$event.preventDefault(); toggleMenu(chip, first, last, group.field)"
            >
            </kendo-chip>
        </kendo-chiplist>

        <div
            *ngIf="groups.length !== 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >&nbsp;</div>

        <ng-template #defaultTemplate>
            <ul unselectable="on" role="menu" class="k-group k-menu-group k-reset k-menu-group-md" [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                click: handleClick
            }">
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="first">
                    <span class="k-link k-menu-link" [class.k-disabled]="first">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-right' : 'arrow-left'"
                            [svgIcon]="rtl ? arrowRightIcon : arrowLeftIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuPrevious')}}</span>
                    </span>
                </li>
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="last">
                    <span class="k-link k-menu-link" [class.k-disabled]="last">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-left' : 'arrow-right'"
                            [svgIcon]="rtl ? arrowLeftIcon : arrowRightIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuNext')}}</span>
                    </span>
                </li>
            </ul>
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, DropTargetDirective, ChipListComponent, NgForOf, ChipComponent, DraggableColumnDirective, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: DragHintService
    }, {
      type: DropCueService
    }, {
      type: GroupInfoService
    }, {
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PopupService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }];
  }, {
    change: [{
      type: Output
    }],
    groupHeaderClass: [{
      type: HostBinding,
      args: ["class.k-grouping-header"]
    }],
    text: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    dropTargets: [{
      type: ViewChildren,
      args: [DropTargetDirective]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: true,
        read: TemplateRef
      }]
    }]
  });
})();
var localizeOperators$1 = (operators) => (localization) => Object.keys(operators).reduce((acc, key) => {
  acc[operators[key]] = localization.get(key);
  return acc;
}, {});
var operatorTexts = localizeOperators$1({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterGteOperator": "gte",
  "filterGtOperator": "gt",
  "filterLteOperator": "lte",
  "filterLtOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty",
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterAfterOrEqualOperator": "after-eq",
  "filterAfterOperator": "after",
  "filterBeforeOrEqualOperator": "before-eq",
  "filterBeforeOperator": "before"
});
var toJSON = (xs) => xs.map((x) => x.toJSON());
var FilterOperatorBase = class _FilterOperatorBase {
  operator;
  ctx;
  /**
   * The text that will be displayed in the drop-down list.
   * @readonly
   * @type {string}
   * @memberOf FilterOperatorBase
   */
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = isNullOrEmptyString(value) ? this.messages[this.operator] : value;
  }
  subscription;
  messages;
  _text;
  constructor(operator, ctx) {
    this.operator = operator;
    this.ctx = ctx;
    this.messages = operatorTexts(this.ctx.localization);
    this._text = this.messages[this.operator];
    this.subscription = this.ctx.localization.changes.subscribe(this.refreshText.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: this.operator
    };
  }
  refreshText() {
    const update3 = this._text === this.messages[this.operator];
    this.messages = operatorTexts(this.ctx.localization);
    if (update3) {
      this._text = this.messages[this.operator];
    }
  }
  static ɵfac = function FilterOperatorBase_Factory(t) {
    return new (t || _FilterOperatorBase)(ɵɵdirectiveInject("filterOperator"), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterOperatorBase,
    selectors: [["kendo-grid-filter-operator-base"]],
    inputs: {
      text: "text"
    },
    decls: 0,
    vars: 0,
    template: function FilterOperatorBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterOperatorBase, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-operator-base",
      template: ``
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: ["filterOperator"]
      }]
    }, {
      type: ContextService
    }];
  }, {
    text: [{
      type: Input
    }]
  });
})();
var ContainsFilterOperatorComponent = class _ContainsFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("contains", ctx);
  }
  static ɵfac = function ContainsFilterOperatorComponent_Factory(t) {
    return new (t || _ContainsFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ContainsFilterOperatorComponent,
    selectors: [["kendo-filter-contains-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _ContainsFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ContainsFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainsFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => ContainsFilterOperatorComponent)
      }],
      selector: "kendo-filter-contains-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var DoesNotContainFilterOperatorComponent = class _DoesNotContainFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("doesnotcontain", ctx);
  }
  static ɵfac = function DoesNotContainFilterOperatorComponent_Factory(t) {
    return new (t || _DoesNotContainFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DoesNotContainFilterOperatorComponent,
    selectors: [["kendo-filter-not-contains-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _DoesNotContainFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function DoesNotContainFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DoesNotContainFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
      }],
      selector: "kendo-filter-not-contains-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var EndsWithFilterOperatorComponent = class _EndsWithFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("endswith", ctx);
  }
  static ɵfac = function EndsWithFilterOperatorComponent_Factory(t) {
    return new (t || _EndsWithFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _EndsWithFilterOperatorComponent,
    selectors: [["kendo-filter-endswith-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _EndsWithFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function EndsWithFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EndsWithFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
      }],
      selector: "kendo-filter-endswith-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var EqualFilterOperatorComponent = class _EqualFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("eq", ctx);
  }
  static ɵfac = function EqualFilterOperatorComponent_Factory(t) {
    return new (t || _EqualFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _EqualFilterOperatorComponent,
    selectors: [["kendo-filter-eq-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _EqualFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function EqualFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EqualFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => EqualFilterOperatorComponent)
      }],
      selector: "kendo-filter-eq-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsEmptyFilterOperatorComponent = class _IsEmptyFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isempty", ctx);
  }
  static ɵfac = function IsEmptyFilterOperatorComponent_Factory(t) {
    return new (t || _IsEmptyFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsEmptyFilterOperatorComponent,
    selectors: [["kendo-filter-isempty-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsEmptyFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function IsEmptyFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsEmptyFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
      }],
      selector: "kendo-filter-isempty-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsNotEmptyFilterOperatorComponent = class _IsNotEmptyFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isnotempty", ctx);
  }
  static ɵfac = function IsNotEmptyFilterOperatorComponent_Factory(t) {
    return new (t || _IsNotEmptyFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsNotEmptyFilterOperatorComponent,
    selectors: [["kendo-filter-isnotempty-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsNotEmptyFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function IsNotEmptyFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNotEmptyFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnotempty-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsNotNullFilterOperatorComponent = class _IsNotNullFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isnotnull", ctx);
  }
  static ɵfac = function IsNotNullFilterOperatorComponent_Factory(t) {
    return new (t || _IsNotNullFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsNotNullFilterOperatorComponent,
    selectors: [["kendo-filter-isnotnull-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsNotNullFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function IsNotNullFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNotNullFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnotnull-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsNullFilterOperatorComponent = class _IsNullFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("isnull", ctx);
  }
  static ɵfac = function IsNullFilterOperatorComponent_Factory(t) {
    return new (t || _IsNullFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _IsNullFilterOperatorComponent,
    selectors: [["kendo-filter-isnull-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _IsNullFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function IsNullFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNullFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNullFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnull-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var NotEqualFilterOperatorComponent = class _NotEqualFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("neq", ctx);
  }
  static ɵfac = function NotEqualFilterOperatorComponent_Factory(t) {
    return new (t || _NotEqualFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NotEqualFilterOperatorComponent,
    selectors: [["kendo-filter-neq-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _NotEqualFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function NotEqualFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotEqualFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
      }],
      selector: "kendo-filter-neq-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var StartsWithFilterOperatorComponent = class _StartsWithFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("startswith", ctx);
  }
  static ɵfac = function StartsWithFilterOperatorComponent_Factory(t) {
    return new (t || _StartsWithFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StartsWithFilterOperatorComponent,
    selectors: [["kendo-filter-startswith-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _StartsWithFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function StartsWithFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StartsWithFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
      }],
      selector: "kendo-filter-startswith-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var GreaterFilterOperatorComponent = class _GreaterFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("gt", ctx);
  }
  static ɵfac = function GreaterFilterOperatorComponent_Factory(t) {
    return new (t || _GreaterFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GreaterFilterOperatorComponent,
    selectors: [["kendo-filter-gt-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _GreaterFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function GreaterFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GreaterFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => GreaterFilterOperatorComponent)
      }],
      selector: "kendo-filter-gt-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var GreaterOrEqualToFilterOperatorComponent = class _GreaterOrEqualToFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("gte", ctx);
  }
  static ɵfac = function GreaterOrEqualToFilterOperatorComponent_Factory(t) {
    return new (t || _GreaterOrEqualToFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GreaterOrEqualToFilterOperatorComponent,
    selectors: [["kendo-filter-gte-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _GreaterOrEqualToFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function GreaterOrEqualToFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GreaterOrEqualToFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
      }],
      selector: "kendo-filter-gte-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var LessFilterOperatorComponent = class _LessFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("lt", ctx);
  }
  static ɵfac = function LessFilterOperatorComponent_Factory(t) {
    return new (t || _LessFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LessFilterOperatorComponent,
    selectors: [["kendo-filter-lt-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _LessFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function LessFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LessFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => LessFilterOperatorComponent)
      }],
      selector: "kendo-filter-lt-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var LessOrEqualToFilterOperatorComponent = class _LessOrEqualToFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("lte", ctx);
  }
  static ɵfac = function LessOrEqualToFilterOperatorComponent_Factory(t) {
    return new (t || _LessOrEqualToFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _LessOrEqualToFilterOperatorComponent,
    selectors: [["kendo-filter-lte-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _LessOrEqualToFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function LessOrEqualToFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LessOrEqualToFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
      }],
      selector: "kendo-filter-lte-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var AfterFilterOperatorComponent = class _AfterFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("after", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "gt"
    };
  }
  static ɵfac = function AfterFilterOperatorComponent_Factory(t) {
    return new (t || _AfterFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AfterFilterOperatorComponent,
    selectors: [["kendo-filter-after-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _AfterFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function AfterFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AfterFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => AfterFilterOperatorComponent)
      }],
      selector: "kendo-filter-after-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var AfterEqFilterOperatorComponent = class _AfterEqFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("after-eq", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "gte"
    };
  }
  static ɵfac = function AfterEqFilterOperatorComponent_Factory(t) {
    return new (t || _AfterEqFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AfterEqFilterOperatorComponent,
    selectors: [["kendo-filter-after-eq-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _AfterEqFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function AfterEqFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AfterEqFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
      }],
      selector: "kendo-filter-after-eq-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var BeforeEqFilterOperatorComponent = class _BeforeEqFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("before-eq", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "lte"
    };
  }
  static ɵfac = function BeforeEqFilterOperatorComponent_Factory(t) {
    return new (t || _BeforeEqFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BeforeEqFilterOperatorComponent,
    selectors: [["kendo-filter-before-eq-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _BeforeEqFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function BeforeEqFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BeforeEqFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
      }],
      selector: "kendo-filter-before-eq-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var BeforeFilterOperatorComponent = class _BeforeFilterOperatorComponent extends FilterOperatorBase {
  constructor(ctx) {
    super("before", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "lt"
    };
  }
  static ɵfac = function BeforeFilterOperatorComponent_Factory(t) {
    return new (t || _BeforeFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BeforeFilterOperatorComponent,
    selectors: [["kendo-filter-before-operator"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: FilterOperatorBase,
      useExisting: forwardRef(() => _BeforeFilterOperatorComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function BeforeFilterOperatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BeforeFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => BeforeFilterOperatorComponent)
      }],
      selector: "kendo-filter-before-operator",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var SizingOptionsService = class _SizingOptionsService {
  changes = new Subject();
  static ɵfac = function SizingOptionsService_Factory(t) {
    return new (t || _SizingOptionsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SizingOptionsService,
    factory: _SizingOptionsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SizingOptionsService, [{
    type: Injectable
  }], null, null);
})();
var FilterCellOperatorsComponent = class _FilterCellOperatorsComponent {
  ctx;
  sizing;
  clearText = "Clear";
  filterClearIcon = filterClearIcon;
  /**
   * @hidden
   */
  filterSVGIcon = filterIcon;
  /**
   * @hidden
   */
  size = "medium";
  /**
   * @hidden
   */
  get hostClasses() {
    return true;
  }
  /**
   * @hidden
   */
  dropdown;
  /**
   * The filter operators that will be displayed.
   */
  operators = [];
  /**
   * Determines if the **Clear** button will be displayed.
   * @type {boolean}
   */
  showButton;
  /**
   * Determines if the list of operators will be displayed.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  /**
   * The selected operator.
   * @type {string}
   */
  value;
  /**
   * The Grid column which the filter operators are associated with.
   */
  column;
  /**
   * Fires when the operator is selected.
   * @type {EventEmitter<string>}
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the **Clear** button is clicked.
   * @type {EventEmitter<undefined>}
   */
  clear = new EventEmitter();
  subs;
  constructor(ctx, sizing) {
    this.ctx = ctx;
    this.sizing = sizing;
  }
  /**
   * @hidden
   */
  onChange(dataItem) {
    this.valueChange.emit(dataItem);
  }
  /**
   * @hidden
   */
  clearClick() {
    this.clear.emit();
    return false;
  }
  /**
   * @hidden
   */
  clearKeydown(args) {
    if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {
      this.clear.emit();
    }
  }
  /**
   * @hidden
   */
  dropdownKeydown(args) {
    if (args.defaultPrevented) {
      return;
    }
    if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {
      this.dropdown.toggle(true);
      args.preventDefault();
    }
  }
  ngOnInit() {
    this.subs = this.ctx.localization.changes.subscribe(() => this.clearText = this.ctx.localization.get("filterClearButton"));
    this.subs.add(this.sizing.changes.subscribe((size) => this.size = size));
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterCellOperatorLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function FilterCellOperatorsComponent_Factory(t) {
    return new (t || _FilterCellOperatorsComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterCellOperatorsComponent,
    selectors: [["kendo-grid-filter-cell-operators"]],
    viewQuery: function FilterCellOperatorsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c92, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdown = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function FilterCellOperatorsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell-operator", ctx.hostClasses);
      }
    },
    inputs: {
      operators: "operators",
      showButton: "showButton",
      showOperators: "showOperators",
      value: "value",
      column: "column"
    },
    outputs: {
      valueChange: "valueChange",
      clear: "clear"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 2,
    vars: 2,
    consts: [["dropdown", ""], ["kendoGridFocusable", "", "class", "k-dropdown-operator", "icon", "filter", "textField", "text", "valueField", "value", 3, "data", "value", "svgIcon", "valuePrimitive", "popupSettings", "size", "valueChange", "keydown", 4, "ngIf"], ["type", "button", "kendoButton", "", "kendoGridFocusable", "", "icon", "filter-clear", 3, "svgIcon", "title", "size", "click", "keydown", 4, "ngIf"], ["kendoGridFocusable", "", "icon", "filter", "textField", "text", "valueField", "value", 1, "k-dropdown-operator", 3, "valueChange", "keydown", "data", "value", "svgIcon", "valuePrimitive", "popupSettings", "size"], ["type", "button", "kendoButton", "", "kendoGridFocusable", "", "icon", "filter-clear", 3, "click", "keydown", "svgIcon", "title", "size"]],
    template: function FilterCellOperatorsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, FilterCellOperatorsComponent_kendo_dropdownlist_0_Template, 2, 8, "kendo-dropdownlist", 1)(1, FilterCellOperatorsComponent_button_1_Template, 1, 3, "button", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showButton);
      }
    },
    dependencies: [NgIf, DropDownListComponent, FocusableDirective, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellOperatorsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-cell-operators",
      template: `
        <kendo-dropdownlist
            #dropdown
            *ngIf="showOperators"
            kendoGridFocusable
            [attr.aria-label]="column && columnLabel"
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            icon="filter"
            [svgIcon]="filterSVGIcon"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            [size]="size"
            (keydown)="dropdownKeydown($event)">
        </kendo-dropdownlist>
        <button type="button"
            kendoButton
            kendoGridFocusable
            *ngIf="showButton"
            icon="filter-clear"
            [svgIcon]="filterClearIcon"
            [title]="clearText"
            [size]="size"
            (click)="clearClick()"
            (keydown)="clearKeydown($event)"></button>
    `,
      standalone: true,
      imports: [NgIf, DropDownListComponent, FocusableDirective, ButtonComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell-operator"]
    }],
    dropdown: [{
      type: ViewChild,
      args: ["dropdown", {
        static: false
      }]
    }],
    operators: [{
      type: Input
    }],
    showButton: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    clear: [{
      type: Output
    }]
  });
})();
var FilterInputDirective = class _FilterInputDirective {
  ngZone;
  element;
  renderer;
  change = new EventEmitter();
  composing = false;
  kendoInput;
  filterDelay = 500;
  columnLabel;
  set value(value) {
    this.accessor.writeValue(value);
  }
  set disabled(value) {
    this.accessor.setDisabledState(value);
  }
  accessor;
  changeRequests = new Subject();
  changeRequestsSubscription;
  unsubscribeEvents;
  constructor(valueAccessors, ngZone, element, renderer) {
    this.ngZone = ngZone;
    this.element = element;
    this.renderer = renderer;
    this.accessor = valueAccessors[0];
    ngZone.runOutsideAngular(() => {
      const unsubscribeStart = renderer.listen(element.nativeElement, "compositionstart", () => this.composing = true);
      const unsubscribeEnd = renderer.listen(element.nativeElement, "compositionend", (event2) => {
        this.composing = false;
        const value = event2.target?.value;
        this.filterDelay > 0 ? this.changeRequests.next(value) : this.change.emit(value);
      });
      this.unsubscribeEvents = () => {
        unsubscribeStart();
        unsubscribeEnd();
      };
    });
  }
  ngAfterViewInit() {
    this.addAriaAttributes();
    this.accessor.registerOnChange((x) => this.filterDelay > 0 ? this.changeRequests.next(x) : this.change.emit(x));
    this.subscribeChanges();
  }
  ngOnChanges(changes) {
    if (isChanged("filterDelay", changes)) {
      this.unsubscribeChanges();
      this.subscribeChanges();
    }
  }
  ngOnDestroy() {
    this.unsubscribeChanges();
    this.unsubscribeEvents();
  }
  subscribeChanges() {
    this.changeRequestsSubscription = this.changeRequests.pipe(debounceTime(this.filterDelay), filter(() => !this.composing)).subscribe((x) => {
      this.ngZone.run(() => {
        this.change.emit(x);
      });
    });
  }
  unsubscribeChanges() {
    if (this.changeRequestsSubscription) {
      this.changeRequestsSubscription.unsubscribe();
    }
  }
  addAriaAttributes() {
    const ariaValue = this.columnLabel;
    if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
      const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) || this.element.nativeElement;
      this.renderer.setAttribute(focusableElement, "aria-label", ariaValue);
    } else {
      const inputElement = this.element.nativeElement.querySelector(".k-input-inner");
      const elementToSetLabel = inputElement ? inputElement : this.element.nativeElement;
      if (ariaValue) {
        this.renderer.setAttribute(elementToSetLabel, "aria-label", ariaValue);
      }
    }
  }
  static ɵfac = function FilterInputDirective_Factory(t) {
    return new (t || _FilterInputDirective)(ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterInputDirective,
    selectors: [["", "kendoFilterInput", ""]],
    contentQueries: function FilterInputDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, KendoInput, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
      }
    },
    inputs: {
      filterDelay: "filterDelay",
      columnLabel: "columnLabel",
      value: "value"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterInput]",
      standalone: true
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Self
      }, {
        type: Inject,
        args: [NG_VALUE_ACCESSOR]
      }]
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    kendoInput: [{
      type: ContentChild,
      args: [KendoInput, {
        static: true
      }]
    }],
    filterDelay: [{
      type: Input
    }],
    columnLabel: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var MenuTabbingService = class _MenuTabbingService {
  firstFocusable;
  lastFocusable;
  isColumnMenu = false;
  isPopupOpen = false;
  lastMenuItem;
  isTabbedInterface = false;
  static ɵfac = function MenuTabbingService_Factory(t) {
    return new (t || _MenuTabbingService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MenuTabbingService,
    factory: _MenuTabbingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuTabbingService, [{
    type: Injectable
  }], null, null);
})();
var FilterService = class _FilterService {
  /**
   * @hidden
   */
  menuTabbingService;
  /**
   * Fires when the filter descriptors is set.
   */
  changes = new Subject();
  /**
   * Sets the filter descriptor.
   *
   * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.
   */
  filter(value) {
    this.changes.next(value);
  }
  /**
   * @hidden
   */
  constructor(menuTabbingService) {
    this.menuTabbingService = menuTabbingService;
  }
  static ɵfac = function FilterService_Factory(t) {
    return new (t || _FilterService)(ɵɵinject(MenuTabbingService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FilterService,
    factory: _FilterService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterService, [{
    type: Injectable
  }], function() {
    return [{
      type: MenuTabbingService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ScrollSyncService2 = class _ScrollSyncService {
  ngZone;
  changes = new Subject();
  elements = [];
  source;
  subscriptions = new Subscription();
  headerSubscription = new Subscription();
  bodySubscription = new Subscription();
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.subscriptions.add(this.changes.subscribe((args) => this.scrollLeft(args)));
  }
  registerEmitter(el, sourceType) {
    this.unregister(sourceType);
    this.elements.push({
      element: el,
      sourceType
    });
    if (sourceType === "body" || sourceType === "header") {
      this.ngZone.runOutsideAngular(() => {
        const obs = fromEvent(el, "scroll").pipe(map(({
          target: {
            scrollLeft
          }
        }) => ({
          scrollLeft,
          sourceType
        })));
        const subscription = obs.pipe(distinctUntilChanged((x, y) => x.scrollLeft === y.scrollLeft), filter((x) => !this.source || this.source === x.sourceType), tap((x) => this.source = x.sourceType)).subscribe((x) => this.changes.next(x));
        subscription.add(obs.pipe(filter((x) => this.source && this.source !== x.sourceType)).subscribe(() => this.source = void 0));
        if (sourceType === "body") {
          this.bodySubscription.add(subscription);
        } else {
          this.headerSubscription.add(subscription);
        }
      });
    }
  }
  /**
   * destroy
   */
  destroy() {
    this.subscriptions.unsubscribe();
    this.headerSubscription.unsubscribe();
    this.bodySubscription.unsubscribe();
  }
  scrollLeft({
    scrollLeft,
    sourceType
  }) {
    this.ngZone.runOutsideAngular(() => {
      this.elements.filter((x) => sourceType !== x.sourceType).forEach(({
        element
      }) => element.scrollLeft = scrollLeft);
    });
  }
  unregister(sourceType) {
    const index = this.elements.findIndex((x) => x.sourceType === sourceType);
    if (index > -1) {
      if (sourceType === "header") {
        this.headerSubscription.unsubscribe();
        this.headerSubscription = new Subscription();
      } else if (sourceType === "body") {
        this.bodySubscription.unsubscribe();
        this.bodySubscription = new Subscription();
      }
      this.elements.splice(index, 1);
    }
  }
  static ɵfac = function ScrollSyncService_Factory(t) {
    return new (t || _ScrollSyncService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollSyncService,
    factory: _ScrollSyncService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollSyncService2, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var AdaptiveGridService = class _AdaptiveGridService {
  ctx;
  adaptiveService;
  /**
   * Observable that emits when the ActionSheet's views change animation ends.
   */
  get animationEnd() {
    return this.animationEndSubject.asObservable();
  }
  columnMenuService;
  columns = [];
  secondaryView;
  viewType;
  popupRef;
  column;
  filterMenuContainer;
  filterMenuContainerComponentRef;
  animationEndSubject = new Subject();
  constructor(ctx, adaptiveService) {
    this.ctx = ctx;
    this.adaptiveService = adaptiveService;
  }
  submitFilter() {
    this.filterMenuContainer.submit();
    this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
    this.reset();
  }
  resetFilter() {
    this.filterMenuContainer.reset();
    this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
    this.reset();
  }
  reset() {
    this.ctx.grid.adaptiveRenderer.actionSheet.currentView = 1;
    this.filterMenuContainerComponentRef?.destroy();
    this.column = null;
    this.popupRef = null;
    this.filterMenuContainer = null;
    this.viewType = null;
    this.secondaryView = null;
  }
  /**
   * Emits an event to notify that the animation has ended.
   */
  notifyAnimationEnd() {
    this.animationEndSubject.next();
  }
  get windowSize() {
    return this.adaptiveService.size;
  }
  static ɵfac = function AdaptiveGridService_Factory(t) {
    return new (t || _AdaptiveGridService)(ɵɵinject(ContextService), ɵɵinject(AdaptiveService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AdaptiveGridService,
    factory: _AdaptiveGridService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveGridService, [{
    type: Injectable
  }], function() {
    return [{
      type: ContextService
    }, {
      type: AdaptiveService
    }];
  }, null);
})();
var contains = (node, predicate) => {
  while (node) {
    if (predicate(node)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};
var PopupCloseEvent = class extends PreventableEvent4 {
  /**
   * The original DOM event that causes the popup to close.
   */
  originalEvent;
  constructor(e) {
    super();
    this.originalEvent = e;
  }
};
var DEFAULT_POPUP_CLASS = "k-grid-filter-popup";
var SinglePopupService = class _SinglePopupService {
  popupService;
  renderer;
  ngZone;
  ctx;
  adaptiveGridService;
  /**
   * Fires when the filter or column menus are about to close because the user clicked outside their popups.
   * Used to prevent the popup from closing.
   */
  onClose = new Subject();
  removeClick;
  pointerEventsSub = new Subscription();
  popupRef;
  scrollSubscription;
  canClosePopup = true;
  /**
   * @hidden
   */
  constructor(popupService, renderer, ngZone, scrollSyncService, ctx, adaptiveGridService) {
    this.popupService = popupService;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.adaptiveGridService = adaptiveGridService;
    this.scrollSubscription = scrollSyncService.changes.pipe(skip(1)).subscribe(() => this.destroy());
  }
  /**
   * @hidden
   */
  open(anchor2, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {
    const toggle = isPresent4(popupRef) && this.popupRef === popupRef;
    this.destroy();
    if (!toggle) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        anchor: anchor2,
        popupClass,
        content: template,
        positionMode: "absolute"
      });
      this.adaptiveGridService.popupRef = this.popupRef;
      this.renderer.setAttribute(this.popupRef.popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
      this.attachClose(anchor2);
    }
    const popupEl = this.popupRef?.popupElement;
    if (popupEl) {
      this.attachMouseListeners(popupEl);
    }
    return this.popupRef;
  }
  /**
   * @hidden
   */
  destroy() {
    if (this.popupRef) {
      this.detachClose();
      this.pointerEventsSub.unsubscribe();
      this.pointerEventsSub = null;
      this.popupRef.close();
      this.popupRef = null;
      this.adaptiveGridService.popupRef = null;
    }
  }
  ngOnDestroy() {
    this.destroy();
    this.scrollSubscription.unsubscribe();
  }
  detachClose() {
    if (this.removeClick) {
      this.removeClick();
    }
  }
  attachClose(skipElement) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.detachClose();
    this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen("document", "click", (e) => {
      if (!contains(e.target, (x) => this.popupRef.popupElement === x || x === skipElement)) {
        const args = new PopupCloseEvent(e);
        this.onClose.next(args);
        if (!args.isDefaultPrevented() && this.canClosePopup) {
          this.destroy();
        }
        this.canClosePopup = true;
      }
    }));
  }
  attachMouseListeners(el) {
    this.pointerEventsSub = new Subscription();
    this.ngZone.runOutsideAngular(() => {
      this.pointerEventsSub.add(this.renderer.listen(el, "pointerdown", (e) => {
        e.stopImmediatePropagation();
        this.canClosePopup = false;
      }));
      this.pointerEventsSub.add(this.renderer.listen(el, "pointerup", () => {
        this.canClosePopup = true;
      }));
    });
  }
  static ɵfac = function SinglePopupService_Factory(t) {
    return new (t || _SinglePopupService)(ɵɵinject(PopupService), ɵɵinject(Renderer2), ɵɵinject(NgZone), ɵɵinject(ScrollSyncService2), ɵɵinject(ContextService), ɵɵinject(AdaptiveGridService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SinglePopupService,
    factory: _SinglePopupService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SinglePopupService, [{
    type: Injectable
  }], function() {
    return [{
      type: PopupService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ScrollSyncService2
    }, {
      type: ContextService
    }, {
      type: AdaptiveGridService
    }];
  }, null);
})();
var insertDefaultFilter = (index, rootFilter, filter3) => {
  rootFilter = rootFilter || {
    filters: [],
    logic: "and"
  };
  rootFilter.filters[index] = filter3;
  return filter3;
};
var setFilter = (index, filter3, field, defaultOperator) => {
  if (isPresent4(filter3) && isPresent4(filter3.filters) && filter3.filters.length > index) {
    return filter3.filters[index];
  } else {
    return insertDefaultFilter(index, filter3, {
      field,
      operator: defaultOperator
    });
  }
};
var logicOperators = (localization) => [{
  text: localization.get("filterAndLogic"),
  value: "and"
}, {
  text: localization.get("filterOrLogic"),
  value: "or"
}];
var flatten2 = (filter3) => {
  if (isPresent4(filter3.filters)) {
    return filter3.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten2(curr) : [curr]), []);
  }
  return [];
};
var trimFilterByField = (filter3, field) => {
  if (isPresent4(filter3) && isPresent4(filter3.filters)) {
    filter3.filters = filter3.filters.filter((x) => {
      if (isCompositeFilterDescriptor(x)) {
        trimFilterByField(x, field);
        return x.filters.length;
      } else {
        return x.field !== field;
      }
    });
  }
};
var filtersByField = (filter3, field) => flatten2(filter3 || {}).filter((x) => x.field === field);
var filterByField = (filter3, field) => {
  const [currentFilter] = filtersByField(filter3, field);
  return currentFilter;
};
var removeFilter = (filter3, field) => {
  trimFilterByField(filter3, field);
  return filter3;
};
var localizeOperators = (operators) => (localization) => Object.keys(operators).map((key) => ({
  text: localization.get(key),
  value: operators[key]
}));
var BaseFilterCellComponent = class _BaseFilterCellComponent {
  filterService;
  get hostClasses() {
    return true;
  }
  operatorList = new QueryList();
  get operators() {
    return this._operators?.length ? this._operators : this.defaultOperators;
  }
  set operators(values) {
    this._operators = values;
  }
  /**
   * @hidden
   */
  size = "medium";
  /**
   * The current root filter.
   * @type {CompositeFilterDescriptor}
   */
  filter;
  defaultOperators;
  _operators;
  operationListSubscription;
  constructor(filterService) {
    this.filterService = filterService;
  }
  /**
   * @hidden
   */
  ngAfterContentInit() {
    this.operationListSubscription = observe(this.operatorList).pipe(map((q) => q.toArray()), map(toJSON)).subscribe((x) => {
      this.operators = x;
    });
  }
  ngOnDestroy() {
    if (this.operationListSubscription) {
      this.operationListSubscription.unsubscribe();
    }
  }
  filterByField(field) {
    return filterByField(this.filter, field);
  }
  filtersByField(field) {
    return filtersByField(this.filter, field);
  }
  removeFilter(field) {
    return removeFilter(this.filter, field);
  }
  updateFilter(filter3) {
    const root = this.filter || {
      filters: [],
      logic: "and"
    };
    const [currentFilter] = flatten2(root).filter((x) => x.field === filter3.field);
    if (!isPresent4(currentFilter)) {
      root.filters.push(filter3);
    } else {
      Object.assign(currentFilter, filter3);
    }
    return root;
  }
  applyFilter(filter3) {
    this.filterService.filter(filter3);
  }
  static ɵfac = function BaseFilterCellComponent_Factory(t) {
    return new (t || _BaseFilterCellComponent)(ɵɵdirectiveInject(FilterService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseFilterCellComponent,
    contentQueries: function BaseFilterCellComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, FilterOperatorBase, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.operatorList = _t);
      }
    },
    hostVars: 2,
    hostBindings: function BaseFilterCellComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      operators: "operators",
      filter: "filter"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseFilterCellComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    operatorList: [{
      type: ContentChildren,
      args: [FilterOperatorBase]
    }],
    operators: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;
var isChanged2 = (a, b) => {
  if (a.length !== b.length) {
    return true;
  }
  for (let idx2 = 0, len = a.length; idx2 < len; idx2++) {
    const prev = a[idx2];
    const curr = b[idx2];
    if (isCompositeFilterDescriptor(prev)) {
      if (diffFilters(prev, curr[idx2])) {
        return true;
      }
    } else if (areDifferent(prev, curr)) {
      return true;
    }
  }
  return false;
};
var copyObject = (obj) => {
  const result = {};
  Object.assign(result, obj);
  if (obj.constructor !== Object) {
    const proto = obj.constructor.prototype;
    Object.getOwnPropertyNames(proto).forEach((property) => {
      if (property !== "constructor" && property !== "__proto__" && property !== "prototype" && proto.hasOwnProperty(property)) {
        result[property] = obj[property];
      }
    });
  }
  return result;
};
var cloneFilter = (filter3) => copyObject(filter3);
var cloneFilters = (filter3) => {
  if (!filter3) {
    return;
  }
  if (isCompositeFilterDescriptor(filter3)) {
    return {
      filters: cloneFilters(filter3.filters),
      logic: filter3.logic
    };
  } else if (Array.isArray(filter3)) {
    return filter3.map(cloneFilters);
  }
  return cloneFilter(filter3);
};
var diffFilters = (a, b) => {
  if (isPresent4(a) && !isPresent4(b)) {
    return true;
  }
  if (!isPresent4(a) && isPresent4(b)) {
    return true;
  }
  return isPresent4(a) && isPresent4(b) && isChanged2(a.filters, b.filters);
};
var FilterHostDirective = class _FilterHostDirective {
  host;
  column;
  filter;
  component;
  constructor(host) {
    this.host = host;
  }
  ngOnInit() {
    this.component = this.host.createComponent(this.componentType());
    this.initComponent({
      column: this.column,
      filter: this.filter
    });
  }
  ngOnDestroy() {
    if (this.component) {
      this.component.destroy();
      this.component = null;
    }
  }
  ngOnChanges(changes) {
    if (anyChanged(["column", "filter"], changes)) {
      this.initComponent({
        column: this.column,
        filter: this.filter
      });
    }
  }
  initComponent({
    column,
    filter: filter3
  }) {
    const instance = this.component.instance;
    instance.column = column;
    instance.filter = filter3;
  }
  static ɵfac = function FilterHostDirective_Factory(t) {
    return new (t || _FilterHostDirective)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterHostDirective,
    selectors: [["", "kendoGridFilterHostBase", ""]],
    inputs: {
      column: "column",
      filter: "filter"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterHostBase]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var stringOperators$1 = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty"
});
var StringFilterComponent = class _StringFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * The default filter operator.
   * @type {string}
   * @default 'contains'
   */
  operator = "contains";
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField((this.column || {}).field);
  }
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = stringOperators$1(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
  static ɵfac = function StringFilterComponent_Factory(t) {
    return new (t || _StringFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _StringFilterComponent,
    inputs: {
      column: "column",
      operator: "operator"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }],
    operator: [{
      type: Input
    }]
  });
})();
var FilterMenuDropDownListDirective = class _FilterMenuDropDownListDirective {
  host;
  filterMenuDropDownLabel;
  constructor(host) {
    this.host = host;
  }
  ngAfterViewInit() {
    const wrapperElement = this.host.wrapper.nativeElement;
    wrapperElement.setAttribute("aria-label", this.filterMenuDropDownLabel);
    wrapperElement.addEventListener("keydown", this.keydownHandler, true);
  }
  ngOnDestroy() {
    this.host.wrapper.nativeElement.removeEventListener("keydown", this.keydownHandler);
  }
  keydownHandler = (e) => {
    if (e.keyCode === Keys.Escape && this.host.isOpen) {
      e.stopPropagation();
      this.host.toggle(false);
    }
  };
  static ɵfac = function FilterMenuDropDownListDirective_Factory(t) {
    return new (t || _FilterMenuDropDownListDirective)(ɵɵdirectiveInject(DropDownListComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterMenuDropDownListDirective,
    selectors: [["", "kendoFilterMenuDropDown", ""]],
    inputs: {
      filterMenuDropDownLabel: "filterMenuDropDownLabel"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuDropDownListDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuDropDown]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DropDownListComponent
    }];
  }, {
    filterMenuDropDownLabel: [{
      type: Input
    }]
  });
})();
var EMPTY_VALUE_OPERATORS = /* @__PURE__ */ new Set(["isnull", "isnotnull", "isempty", "isnotempty"]);
var isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);
var FilterInputWrapperComponent = class _FilterInputWrapperComponent extends BaseFilterCellComponent {
  column;
  input;
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  get currentOperator() {
    const filter3 = this.currentFilter;
    if (!this._operator) {
      this._operator = filter3 ? filter3.operator : this.defaultOperator;
    }
    return this._operator;
  }
  set currentOperator(value) {
    this._operator = value;
    const emptyValueOperator = isEmptyValueOperator(value);
    this.filterInputDisabled = emptyValueOperator;
    if (emptyValueOperator) {
      this.applyNoValueFilter(value);
    } else if (!isBlank(value) && isPresent4(this.currentFilter)) {
      this.onChange(this.currentFilter.value);
    }
  }
  get defaultOperator() {
    if (!isNullOrEmptyString(this._defaultOperator)) {
      return this._defaultOperator;
    } else if (this.operators && this.operators.length) {
      return this.operators[0].value;
    }
    return "eq";
  }
  set defaultOperator(value) {
    this._defaultOperator = value;
  }
  set filterInputDisabled(disabled) {
    if (!this.input) {
      return;
    }
    this.input.disabled = disabled;
  }
  _defaultOperator;
  _operator;
  changeSubscription;
  constructor(filterService) {
    super(filterService);
  }
  ngAfterContentInit() {
    if (isPresent4(this.input)) {
      this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));
      this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this.changeSubscription) {
      this.changeSubscription.unsubscribe();
    }
  }
  onChange(value) {
    if (!isNullOrEmptyString(value) || this.filterByField(this.column.field)) {
      this.filterChange(isNullOrEmptyString(value) ? this.removeFilter(this.column.field) : this.updateFilter({
        field: this.column.field,
        operator: this.currentOperator,
        value
      }));
    }
  }
  onClear() {
    this.onChange(null);
    this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);
  }
  applyNoValueFilter(operator) {
    this.filterChange(this.updateFilter({
      field: this.column.field,
      operator,
      value: null
    }));
  }
  ngOnChanges(changes) {
    if (isChanged("filter", changes, false)) {
      this._operator = null;
      this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
    }
  }
  static ɵfac = function FilterInputWrapperComponent_Factory(t) {
    return new (t || _FilterInputWrapperComponent)(ɵɵdirectiveInject(FilterService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterInputWrapperComponent,
    contentQueries: function FilterInputWrapperComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, FilterInputDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    inputs: {
      column: "column",
      defaultOperator: "defaultOperator"
    },
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputWrapperComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }];
  }, {
    column: [{
      type: Input
    }],
    input: [{
      type: ContentChild,
      args: [FilterInputDirective, {
        static: false
      }]
    }],
    defaultOperator: [{
      type: Input
    }]
  });
})();
var FilterMenuInputWrapperComponent = class _FilterMenuInputWrapperComponent extends FilterInputWrapperComponent {
  ctx;
  adaptiveGridService;
  filterService;
  isFirstDropDown;
  menuTabbingService;
  firstOperatorDropDown;
  _currentFilter;
  subs = new Subscription();
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  constructor(ctx, adaptiveGridService) {
    super(null);
    this.ctx = ctx;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngAfterViewInit() {
    const shouldFocusFirstFocusable = this.isFirstDropDown && this.filterService?.menuTabbingService;
    const isTabbedInterface = this.menuTabbingService?.isTabbedInterface;
    if (shouldFocusFirstFocusable && !isTabbedInterface) {
      this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;
      if (this.ctx.grid?.isActionSheetExpanded) {
        this.subs.add(this.adaptiveGridService.animationEnd.subscribe(() => {
          this.firstOperatorDropDown.focus();
        }));
      } else {
        this.firstOperatorDropDown.focus();
      }
    }
  }
  ngOnDestroy() {
    this.subs?.unsubscribe();
  }
  operatorChange(dataItem) {
    this.currentOperator = dataItem;
  }
  filterChange(filter3) {
    this.applyFilter(filter3);
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this._currentFilter;
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  set currentFilter(value) {
    this._currentFilter = value;
  }
  updateFilter(filter3) {
    Object.assign(this.currentFilter, filter3);
    return this.filter;
  }
  onChange(value) {
    this.filterChange(this.updateFilter({
      field: this.column.field,
      operator: this.currentOperator,
      value
    }));
  }
  onShiftTab(e) {
    e.stopImmediatePropagation();
    if (!this.menuTabbingService?.isColumnMenu && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {
      e.preventDefault();
      this.filterService.menuTabbingService.lastFocusable.focus();
    }
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuOperatorsDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function FilterMenuInputWrapperComponent_Factory(t) {
    return new (t || _FilterMenuInputWrapperComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterMenuInputWrapperComponent,
    selectors: [["kendo-grid-filter-menu-input-wrapper"]],
    viewQuery: function FilterMenuInputWrapperComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(DropDownListComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.firstOperatorDropDown = _t.first);
      }
    },
    inputs: {
      filterService: "filterService",
      isFirstDropDown: "isFirstDropDown",
      menuTabbingService: "menuTabbingService",
      currentFilter: "currentFilter"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    ngContentSelectors: _c112,
    decls: 2,
    vars: 7,
    consts: [["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 3, "valueChange", "keydown.shift.tab", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "value", "valuePrimitive"]],
    template: function FilterMenuInputWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "kendo-dropdownlist", 0);
        ɵɵlistener("valueChange", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {
          return ctx.operatorChange($event);
        })("keydown.shift.tab", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_keydown_shift_tab_0_listener($event) {
          return ctx.onShiftTab($event);
        });
        ɵɵelementEnd();
        ɵɵprojection(1);
      }
      if (rf & 2) {
        ɵɵproperty("adaptiveTitle", ctx.ctx.localization.get("adaptiveFilterOperatorsTitle"))("adaptiveMode", ctx.ctx.grid == null ? null : ctx.ctx.grid.adaptiveMode)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterMenuDropDownLabel", ctx.filterMenuDropDownLabel)("data", ctx.operators)("value", ctx.currentOperator)("valuePrimitive", true);
      }
    },
    dependencies: [DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuInputWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-menu-input-wrapper",
      template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `,
      standalone: true,
      imports: [DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: AdaptiveGridService
    }];
  }, {
    filterService: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    firstOperatorDropDown: [{
      type: ViewChild,
      args: [DropDownListComponent, {
        static: false
      }]
    }],
    currentFilter: [{
      type: Input
    }]
  });
})();
var StringFilterMenuInputComponent = class _StringFilterMenuInputComponent {
  ctx;
  operators = [];
  column;
  filter;
  operator;
  currentFilter;
  filterService;
  isFirstDropDown;
  menuTabbingService;
  placeholder;
  constructor(ctx) {
    this.ctx = ctx;
  }
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function StringFilterMenuInputComponent_Factory(t) {
    return new (t || _StringFilterMenuInputComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StringFilterMenuInputComponent,
    selectors: [["kendo-grid-string-filter-menu-input"]],
    inputs: {
      operators: "operators",
      column: "column",
      filter: "filter",
      operator: "operator",
      currentFilter: "currentFilter",
      filterService: "filterService",
      isFirstDropDown: "isFirstDropDown",
      menuTabbingService: "menuTabbingService",
      placeholder: "placeholder"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 2,
    vars: 13,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "columnLabel", "size", "filterDelay", "placeholder", "ngModel"]],
    template: function StringFilterMenuInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0);
        ɵɵelement(1, "kendo-textbox", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        let tmp_12_0;
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("filterDelay", 0)("placeholder", ctx.placeholder)("ngModel", (tmp_12_0 = ctx.currentFilter == null ? null : ctx.currentFilter.value) !== null && tmp_12_0 !== void 0 ? tmp_12_0 : null);
      }
    },
    dependencies: [FilterMenuInputWrapperComponent, TextBoxComponent, FilterInputDirective, FormsModule, NgControlStatus, NgModel],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-textbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [filterDelay]="0"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null">
            </kendo-textbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
      standalone: true,
      imports: [FilterMenuInputWrapperComponent, TextBoxComponent, FilterInputDirective, FormsModule]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var StringFilterMenuComponent = class _StringFilterMenuComponent extends StringFilterComponent {
  ctx;
  logicOperators = [];
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * The current menu filter.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * Determines if the inputs of second criteria will displayed.
   * @default true
   */
  extra = true;
  /**
   * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
   */
  filterService;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder;
  /**
   * The placeholder text for the second filter input. Applies when `extra` is set to `true`.
   * @type {string}
   */
  extraPlaceholder;
  /**
   * @hidden
   */
  menuTabbingService;
  constructor(ctx) {
    super(null, ctx);
    this.ctx = ctx;
    this.logicOperators = logicOperators(this.ctx.localization);
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value) {
    this.filter.logic = value;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
  static ɵfac = function StringFilterMenuComponent_Factory(t) {
    return new (t || _StringFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StringFilterMenuComponent,
    selectors: [["kendo-grid-string-filter-menu"]],
    hostVars: 2,
    hostBindings: function StringFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      extra: "extra",
      filterService: "filterService",
      placeholder: "placeholder",
      extraPlaceholder: "extraPlaceholder",
      menuTabbingService: "menuTabbingService"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 10,
    consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "isFirstDropDown", "placeholder", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "placeholder", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "placeholder", "menuTabbingService"]],
    template: function StringFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-string-filter-menu-input", 0);
        ɵɵtemplate(1, StringFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 7, "kendo-dropdownlist", 1)(2, StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template, 1, 7, "kendo-grid-string-filter-menu-input", 2);
      }
      if (rf & 2) {
        ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("isFirstDropDown", true)("placeholder", ctx.placeholder)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.extra);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.extra);
      }
    },
    dependencies: [StringFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-menu",
      template: `
        <kendo-grid-string-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [isFirstDropDown]="true"
            [placeholder]="placeholder"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-string-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [placeholder]="extraPlaceholder"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
    `,
      standalone: true,
      imports: [StringFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    extraPlaceholder: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var numericOperators = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterGteOperator": "gte",
  "filterGtOperator": "gt",
  "filterLteOperator": "lte",
  "filterLtOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull"
});
var NumericFilterComponent = class _NumericFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * The default filter operator.
   * @type {string}
   * @default 'eq'
   */
  operator = "eq";
  /**
   * Specifies the value that is used to increment or decrement the component value.
   * @type {numeric}
   * @default 1
   */
  step = 1;
  /**
   * Specifies the smallest value that is valid.
   * @type {number}
   */
  min;
  /**
   * Specifies the greatest value that is valid.
   * @type {number}
   */
  max;
  /**
   * Specifies whether the **Up** and **Down** spin buttons will be rendered.
   * @type {boolean}
   * @default true
   */
  spinners = true;
  /**
   * Specifies the number precision applied to the component value when it is focused.
   * If the user enters a number with a greater precision than is currently configured, the component value is rounded.
   *
   * @type {number}
   */
  decimals;
  /**
   * Specifies the number format used when the component is not focused.
   * By default, the `column.format` value is used (if set).
   */
  get format() {
    return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
  }
  set format(value) {
    this._format = value;
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  get columnFormat() {
    return this.column && !isNullOrEmptyString(this.column.format) ? extractFormat(this.column.format) : "n2";
  }
  _format;
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.defaultOperators = numericOperators(this.ctx.localization);
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = numericOperators(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
  static ɵfac = function NumericFilterComponent_Factory(t) {
    return new (t || _NumericFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NumericFilterComponent,
    inputs: {
      column: "column",
      operator: "operator",
      step: "step",
      min: "min",
      max: "max",
      spinners: "spinners",
      decimals: "decimals",
      format: "format"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    format: [{
      type: Input
    }]
  });
})();
var NumericFilterMenuInputComponent = class _NumericFilterMenuInputComponent {
  ctx;
  operators = [];
  column;
  filter;
  operator;
  currentFilter;
  filterService;
  filterDelay;
  isFirstDropDown;
  menuTabbingService;
  /**
   * Specifies the value which is used to increment or decrement the component value.
   * @type {numeric}
   */
  step = 1;
  /**
   * Specifies the smallest value that is valid.
   * @type {number}
   */
  min;
  /**
   * Specifies the greatest value that is valid.
   * @type {number}
   */
  max;
  /**
   * Specifies whether the **Up** and **Down** spin buttons will be rendered.
   * @type {boolean}
   */
  spinners = true;
  /**
   * Specifies the number precision tat is applied to the component value when it is focused.
   * If the user enters a number with a greater precision than is currently configured, the component value is rounded.
   *
   * @type {number}
   */
  decimals;
  /**
   * Specifies the number format that is used when the component is not focused.
   * By default, the `column.format` value is used (if set).
   */
  format;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder;
  constructor(ctx) {
    this.ctx = ctx;
  }
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function NumericFilterMenuInputComponent_Factory(t) {
    return new (t || _NumericFilterMenuInputComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericFilterMenuInputComponent,
    selectors: [["kendo-grid-numeric-filter-menu-input"]],
    inputs: {
      operators: "operators",
      column: "column",
      filter: "filter",
      operator: "operator",
      currentFilter: "currentFilter",
      filterService: "filterService",
      filterDelay: "filterDelay",
      isFirstDropDown: "isFirstDropDown",
      menuTabbingService: "menuTabbingService",
      step: "step",
      min: "min",
      max: "max",
      spinners: "spinners",
      decimals: "decimals",
      format: "format",
      placeholder: "placeholder"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 3,
    vars: 22,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "size", "value", "format", "decimals", "spinners", "min", "max", "step", "placeholder"], [3, "increment", "decrement"]],
    template: function NumericFilterMenuInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0)(1, "kendo-numerictextbox", 1);
        ɵɵelement(2, "kendo-numerictextbox-messages", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("autoCorrect", true)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step)("placeholder", ctx.placeholder);
        ɵɵadvance();
        ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
      }
    },
    dependencies: [FilterMenuInputWrapperComponent, NumericTextBoxComponent, FilterInputDirective, NumericTextBoxCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `,
      standalone: true,
      imports: [FilterMenuInputWrapperComponent, NumericTextBoxComponent, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    filterDelay: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var NumericFilterMenuComponent = class _NumericFilterMenuComponent extends NumericFilterComponent {
  logicOperators = logicOperators(this.ctx.localization);
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * The current menu filter.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * Determines if the inputs of second criteria will displayed.
   * @default true
   */
  extra = true;
  /**
   * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
   */
  filterService;
  /**
   * Determines the delay (in milliseconds) before creating a filter descriptor based on the value. A value of 0 indicates no delay. The default value is 500.
   *
   * @default 500
   */
  filterDelay = 500;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder = "";
  /**
   * The placeholder text for the extra filter input. Applies when `extra` is set to `true`.
   * @type {string}
   */
  extraPlaceholder = "";
  /**
   * @hidden
   */
  menuTabbingService;
  constructor(ctx) {
    super(null, ctx);
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value) {
    this.filter.logic = value;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
  static ɵfac = function NumericFilterMenuComponent_Factory(t) {
    return new (t || _NumericFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericFilterMenuComponent,
    selectors: [["kendo-grid-numeric-filter-menu"]],
    hostVars: 2,
    hostBindings: function NumericFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      extra: "extra",
      filterService: "filterService",
      filterDelay: "filterDelay",
      placeholder: "placeholder",
      extraPlaceholder: "extraPlaceholder",
      menuTabbingService: "menuTabbingService"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 17,
    consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "filterDelay", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", "isFirstDropDown", "placeholder"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", "placeholder", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", "placeholder"]],
    template: function NumericFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 0);
        ɵɵtemplate(1, NumericFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 7, "kendo-dropdownlist", 1)(2, NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template, 1, 13, "kendo-grid-numeric-filter-menu-input", 2);
      }
      if (rf & 2) {
        ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("filterDelay", ctx.filterDelay)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step)("menuTabbingService", ctx.menuTabbingService)("isFirstDropDown", true)("placeholder", ctx.placeholder);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.extra);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.extra);
      }
    },
    dependencies: [NumericFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-menu",
      template: `
        <kendo-grid-numeric-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [filterDelay]="filterDelay"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [isFirstDropDown]="true"
            [placeholder]="placeholder">
        </kendo-grid-numeric-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-numeric-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [placeholder]="extraPlaceholder">
        </kendo-grid-numeric-filter-menu-input>
    `,
      standalone: true,
      imports: [NumericFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    filterDelay: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    extraPlaceholder: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var dateOperators = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterAfterOrEqualOperator": "gte",
  "filterAfterOperator": "gt",
  "filterBeforeOrEqualOperator": "lte",
  "filterBeforeOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull"
});
var DateFilterComponent = class _DateFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * The default filter operator. Defaults to `contains`.
   * @type {string}
   * @default 'gte'
   */
  operator = "gte";
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * Specifies the date format that is used when the component is not focused.
   * By default, the `column.format` value is used (if set).
   */
  set format(value) {
    this._format = value;
  }
  /**
   * Specifies the date format that is used when the component is not focused.
   * By default, the `column.format` value is used (if set).
   *
   * @readonly
   * @type {string}
   */
  get format() {
    return !isNullOrEmptyString(this._format) ? this._format : this.columnFormat;
  }
  /**
   * Specifies the smallest value that is valid.
   * @type {Date}
   */
  min;
  /**
   * Specifies the greatest value that is valid.
   * @type {Date}
   */
  max;
  /**
   * Defines the descriptions of the format sections in the input field.
   * [See example](slug:placeholders_datepicker#toc-format-sections-description).
   */
  formatPlaceholder;
  /**
   * Specifies the hint that the component displays when its value is `null`.
   * [See example](slug:placeholders_datepicker#toc-text-hints).
   */
  placeholder;
  /**
   * Defines the active view that the calendar initially renders.
   * By default, the active view is `month`.
   * You have to set `activeView` within the `topView`-`bottomView` range.
   * @default 'month'
   */
  activeView = "month";
  /**
   * Defines the bottommost calendar view, to which the user can navigate.
   * @default 'month'
   */
  bottomView = "month";
  /**
   * Defines the topmost calendar view, to which the user can navigate.
   * @default 'century'
   */
  topView = "century";
  /**
   * Determines whether to display a week number column in the `month` view of the Calendar.
   * @default false
   */
  weekNumber = false;
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  get columnFormat() {
    return this.column && !isNullOrEmptyString(this.column.format) ? extractFormat(this.column.format) : "d";
  }
  _format;
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.defaultOperators = dateOperators(this.ctx.localization);
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = dateOperators(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
  static ɵfac = function DateFilterComponent_Factory(t) {
    return new (t || _DateFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterComponent,
    selectors: [["kendo-grid-date-filter-base"]],
    inputs: {
      column: "column",
      operator: "operator",
      format: "format",
      min: "min",
      max: "max",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      weekNumber: "weekNumber"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function DateFilterComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-base",
      template: ``
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }]
  });
})();
var DateFilterMenuInputComponent = class _DateFilterMenuInputComponent {
  popupService;
  ctx;
  operators = [];
  column;
  filter;
  operator;
  currentFilter;
  filterService;
  menuTabbingService;
  format;
  formatPlaceholder;
  placeholder;
  min;
  max;
  activeView;
  bottomView;
  topView;
  weekNumber;
  isFirstDropDown;
  subscription;
  constructor(popupService, ctx) {
    this.popupService = popupService;
    this.ctx = ctx;
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  open(picker) {
    this.subscription = this.popupService.onClose.pipe(filter(() => picker.isActive)).subscribe((e) => e.preventDefault());
  }
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function DateFilterMenuInputComponent_Factory(t) {
    return new (t || _DateFilterMenuInputComponent)(ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterMenuInputComponent,
    selectors: [["kendo-grid-date-filter-menu-input"]],
    inputs: {
      operators: "operators",
      column: "column",
      filter: "filter",
      operator: "operator",
      currentFilter: "currentFilter",
      filterService: "filterService",
      menuTabbingService: "menuTabbingService",
      format: "format",
      formatPlaceholder: "formatPlaceholder",
      placeholder: "placeholder",
      min: "min",
      max: "max",
      activeView: "activeView",
      bottomView: "bottomView",
      topView: "topView",
      weekNumber: "weekNumber",
      isFirstDropDown: "isFirstDropDown"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 4,
    vars: 24,
    consts: [["picker", ""], [3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "open", "adaptiveMode", "size", "columnLabel", "filterDelay", "value", "placeholder", "formatPlaceholder", "format", "min", "max", "activeView", "bottomView", "topView", "weekNumber"], [3, "toggle", "today"]],
    template: function DateFilterMenuInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 1)(1, "kendo-datepicker", 2, 0);
        ɵɵlistener("open", function DateFilterMenuInputComponent_Template_kendo_datepicker_open_1_listener() {
          ɵɵrestoreView(_r1);
          const picker_r2 = ɵɵreference(2);
          return ɵɵresetView(ctx.open(picker_r2));
        });
        ɵɵelement(3, "kendo-datepicker-messages", 3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("adaptiveMode", ctx.ctx.grid == null ? null : ctx.ctx.grid.adaptiveMode)("size", (ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded) ? "large" : null)("columnLabel", ctx.columnLabel)("filterDelay", 0)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("placeholder", ctx.placeholder)("formatPlaceholder", ctx.formatPlaceholder)("format", ctx.format)("min", ctx.min)("max", ctx.max)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("weekNumber", ctx.weekNumber);
        ɵɵadvance(2);
        ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
      }
    },
    dependencies: [FilterMenuInputWrapperComponent, DatePickerComponent, FilterInputDirective, DatePickerCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService">
            <kendo-datepicker
                #picker
                kendoFilterInput
                [adaptiveMode]="ctx.grid?.adaptiveMode"
                [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `,
      standalone: true,
      imports: [FilterMenuInputWrapperComponent, DatePickerComponent, FilterInputDirective, DatePickerCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: SinglePopupService
    }, {
      type: ContextService
    }];
  }, {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }]
  });
})();
var DateFilterMenuComponent = class _DateFilterMenuComponent extends DateFilterComponent {
  logicOperators = logicOperators(this.ctx.localization);
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * The current menu filter.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * Determines if the inputs of second criteria will be displayed.
   * @default true
   */
  extra = true;
  /**
   * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
   */
  filterService;
  /**
   * @hidden
   */
  menuTabbingService;
  constructor(ctx) {
    super(null, ctx);
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value) {
    this.filter.logic = value;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
  static ɵfac = function DateFilterMenuComponent_Factory(t) {
    return new (t || _DateFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterMenuComponent,
    selectors: [["kendo-grid-date-filter-menu"]],
    hostVars: 2,
    hostBindings: function DateFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      extra: "extra",
      filterService: "filterService",
      menuTabbingService: "menuTabbingService"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 18,
    consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "isFirstDropDown", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "adaptiveTitle", "adaptiveMode", "size", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "menuTabbingService"]],
    template: function DateFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-date-filter-menu-input", 0);
        ɵɵtemplate(1, DateFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 7, "kendo-dropdownlist", 1)(2, DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template, 1, 15, "kendo-grid-date-filter-menu-input", 2);
      }
      if (rf & 2) {
        ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber)("isFirstDropDown", true)("menuTabbingService", ctx.menuTabbingService);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.extra);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.extra);
      }
    },
    dependencies: [DateFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-menu",
      template: `
        <kendo-grid-date-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [isFirstDropDown]="true"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-date-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [adaptiveTitle]="ctx.localization.get('adaptiveFilterOperatorsTitle')"
            [adaptiveMode]="ctx.grid?.adaptiveMode"
            [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-date-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-date-filter-menu-input>
    `,
      standalone: true,
      imports: [DateFilterMenuInputComponent, NgIf, DropDownListComponent, FilterMenuDropDownListDirective]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var BooleanFilterComponent = class _BooleanFilterComponent extends BaseFilterCellComponent {
  ctx;
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * @hidden
   */
  operator = "eq";
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  items;
  defaultItem;
  subscription;
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.items = [{
      text: this.ctx.localization.get("filterIsTrue"),
      value: true
    }, {
      text: this.ctx.localization.get("filterIsFalse"),
      value: false
    }];
    this.defaultItem = {
      text: this.ctx.localization.get("filterBooleanAll"),
      value: null
    };
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.items = [{
      text: this.ctx.localization.get("filterIsTrue"),
      value: true
    }, {
      text: this.ctx.localization.get("filterIsFalse"),
      value: false
    }];
    this.defaultItem = {
      text: this.ctx.localization.get("filterBooleanAll"),
      value: null
    };
  }
  static ɵfac = function BooleanFilterComponent_Factory(t) {
    return new (t || _BooleanFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BooleanFilterComponent,
    selectors: [["kendo-grid-boolean-filter-base"]],
    inputs: {
      column: "column"
    },
    features: [ɵɵInheritDefinitionFeature],
    decls: 0,
    vars: 0,
    template: function BooleanFilterComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-base",
      template: ``
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }]
  });
})();
var BooleanFilterRadioButtonDirective = class _BooleanFilterRadioButtonDirective {
  hostElement;
  renderer;
  columnLabel;
  radioButtonEl;
  constructor(hostElement, renderer) {
    this.hostElement = hostElement;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.radioButtonEl = this.hostElement.nativeElement;
    this.renderer.setAttribute(this.hostElement.nativeElement, "aria-label", this.columnLabel);
  }
  static ɵfac = function BooleanFilterRadioButtonDirective_Factory(t) {
    return new (t || _BooleanFilterRadioButtonDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BooleanFilterRadioButtonDirective,
    selectors: [["", "kendoFilterMenuRadioButton", ""]],
    inputs: {
      columnLabel: "columnLabel"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterRadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuRadioButton]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    columnLabel: [{
      type: Input
    }]
  });
})();
var BooleanFilterMenuComponent = class _BooleanFilterMenuComponent extends BooleanFilterComponent {
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  /**
   * The current menu filter.
   * @type {CompositeFilterDescriptor}
   */
  filter = {
    filters: [],
    logic: "and"
  };
  /**
   * The `FilterService` instance which is responsible for handling the changes in the filter descriptor.
   */
  filterService;
  /**
   * @hidden
   */
  menuTabbingService;
  idPrefix = guid();
  /**
   * @hidden
   */
  radioButtons;
  constructor(ctx) {
    super(null, ctx);
  }
  ngAfterViewInit() {
    this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;
    if (!this.menuTabbingService?.isTabbedInterface) {
      this.radioButtons.first.radioButtonEl.focus();
    }
  }
  /**
   * @hidden
   */
  radioId(value) {
    return `${this.idPrefix}_${value}`;
  }
  /**
   * @hidden
   */
  onChange(value, input) {
    this.applyFilter(this.updateFilter({
      field: this.column.field,
      operator: "eq",
      value
    }));
    this.filterService.menuTabbingService.firstFocusable = input.hostElement.nativeElement;
  }
  /**
   * @hidden
   */
  isSelected(radioValue) {
    return this.filtersByField(this.column.field).some(({
      value
    }) => value === radioValue);
  }
  /**
   * @hidden
   */
  onShiftTab(e) {
    if (!this.menuTabbingService?.isColumnMenu && this.filterService.menuTabbingService.lastFocusable) {
      e.preventDefault();
      this.filterService.menuTabbingService.lastFocusable.focus();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function BooleanFilterMenuComponent_Factory(t) {
    return new (t || _BooleanFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BooleanFilterMenuComponent,
    selectors: [["kendo-grid-boolean-filter-menu"]],
    viewQuery: function BooleanFilterMenuComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(BooleanFilterRadioButtonDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radioButtons = _t);
      }
    },
    hostVars: 2,
    hostBindings: function BooleanFilterMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell", ctx.hostClasses);
      }
    },
    inputs: {
      filter: "filter",
      filterService: "filterService",
      menuTabbingService: "menuTabbingService"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 1,
    consts: [["input", ""], [1, "k-radio-list", "k-reset"], [4, "ngFor", "ngForOf"], ["kendoFilterMenuRadioButton", "", 3, "change", "keydown.shift.tab", "columnLabel", "size", "name", "checked"], [1, "k-radio-label"]],
    template: function BooleanFilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "ul", 1);
        ɵɵtemplate(1, BooleanFilterMenuComponent_li_1_Template, 5, 7, "li", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.items);
      }
    },
    dependencies: [NgForOf, RadioButtonComponent, BooleanFilterRadioButtonDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-menu",
      template: `
        <ul class="k-radio-list k-reset">
            <li *ngFor="let item of items">
                <kendo-radiobutton
                    kendoFilterMenuRadioButton
                    [columnLabel]="columnLabel"
                    #input
                    [size]="ctx.grid?.isActionSheetExpanded ? 'large' : null"
                    [name]="idPrefix"
                    [checked]="isSelected(item.value)"
                    [attr.id]="radioId(item.value)"
                    (change)="onChange(item.value, input)"
                    (keydown.shift.tab)="onShiftTab($event)"
                ></kendo-radiobutton>
                <label class="k-radio-label" [attr.for]="input.focusableId">{{item.text}}</label>
            </li>
        </ul>
    `,
      standalone: true,
      imports: [NgForOf, RadioButtonComponent, BooleanFilterRadioButtonDirective]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    radioButtons: [{
      type: ViewChildren,
      args: [BooleanFilterRadioButtonDirective]
    }]
  });
})();
var filterMenuComponentFactory = (type) => ({
  "boolean": BooleanFilterMenuComponent,
  "date": DateFilterMenuComponent,
  "numeric": NumericFilterMenuComponent,
  "text": StringFilterMenuComponent
})[type];
var FilterMenuHostDirective = class _FilterMenuHostDirective extends FilterHostDirective {
  filterService;
  menuTabbingService;
  constructor(host) {
    super(host);
  }
  componentType() {
    if (isPresent4(this.column) && !isNullOrEmptyString(this.column.filter)) {
      return filterMenuComponentFactory(this.column.filter);
    }
    return StringFilterMenuComponent;
  }
  initComponent(ctx) {
    super.initComponent(ctx);
    this.component.instance.filterService = this.filterService;
    this.component.instance.menuTabbingService = this.menuTabbingService;
  }
  static ɵfac = function FilterMenuHostDirective_Factory(t) {
    return new (t || _FilterMenuHostDirective)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterMenuHostDirective,
    selectors: [["", "kendoFilterMenuHost", ""]],
    inputs: {
      filterService: "filterService",
      menuTabbingService: "menuTabbingService"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuHost]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var isNoValueOperator = (operator) => operator === "isnull" || operator === "isnotnull" || operator === "isempty" || operator === "isnotempty";
var validFilters = ({
  value,
  operator
}) => !isNullOrEmptyString(value) || isNoValueOperator(operator);
var trimFilters = (filter3) => {
  filter3.filters = filter3.filters.filter(validFilters);
  return filter3;
};
var findParent = (filters, field, parent) => {
  return filters.reduce((acc, filter3) => {
    if (acc) {
      return acc;
    }
    if (filter3.filters) {
      return findParent(filter3.filters, field, filter3);
    } else if (filter3.field === field) {
      return parent;
    }
    return acc;
  }, void 0);
};
var parentLogicOfDefault = (filter3, field, def = "and") => {
  const parent = findParent((filter3 || {}).filters || [], field);
  return isPresent4(parent) ? parent.logic : def;
};
var FilterMenuContainerComponent = class _FilterMenuContainerComponent {
  parentService;
  childService;
  ctx;
  cd;
  adaptiveGridService;
  close = new EventEmitter();
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * @hidden
   */
  isLast;
  /**
   * @hidden
   */
  isExpanded;
  /**
   * @hidden
   */
  menuTabbingService;
  /**
   * The current root filter.
   * @type {CompositeFilterDescriptor}
   */
  set filter(value) {
    this._filter = cloneFilters(value);
  }
  get filter() {
    return this._filter;
  }
  /**
   * @hidden
   */
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  get childFilter() {
    if (!isPresent4(this._childFilter)) {
      this._childFilter = {
        filters: filtersByField(this.filter, (this.column || {}).field),
        logic: parentLogicOfDefault(this.filter, (this.column || {}).field)
      };
    }
    return this._childFilter;
  }
  resetButton;
  filterButton;
  _childFilter;
  subscription;
  _templateContext = {};
  _filter;
  constructor(parentService, childService, ctx, cd, menuTabbingService, adaptiveGridService) {
    this.parentService = parentService;
    this.childService = childService;
    this.ctx = ctx;
    this.cd = cd;
    this.adaptiveGridService = adaptiveGridService;
    this.menuTabbingService = menuTabbingService;
    this.adaptiveGridService.filterMenuContainer = this;
  }
  ngOnInit() {
    this.subscription = this.childService.changes.subscribe((filter3) => this._childFilter = filter3);
    this.subscription.add(this.ctx.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngAfterViewChecked() {
    if (!this.menuTabbingService.isColumnMenu || this.isLast && this.isExpanded) {
      this.menuTabbingService.lastFocusable = this.resetButton?.nativeElement;
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.menuTabbingService.lastFocusable = void 0;
  }
  get disabled() {
    return !this.childFilter.filters.some(validFilters);
  }
  get templateContext() {
    this._templateContext.column = this.column;
    this._templateContext.filter = this.childFilter;
    this._templateContext.filterService = this.childService;
    this._templateContext["$implicit"] = this.childFilter;
    return this._templateContext;
  }
  get hasTemplate() {
    return isPresent4(this.column) && isPresent4(this.column.filterMenuTemplateRef);
  }
  submit() {
    const filter3 = trimFilters(this.childFilter);
    if (filter3.filters.length) {
      const root = this.filter || {
        filters: [],
        logic: "and"
      };
      removeFilter(root, this.column.field);
      root.filters.push(filter3);
      this.parentService.filter(root);
    }
    this.close.emit();
    return false;
  }
  reset() {
    const root = this.filter || {
      filters: [],
      logic: "and"
    };
    removeFilter(root, this.column.field);
    this.parentService.filter(root);
    this.close.emit();
  }
  resetChildFilters() {
    this._childFilter = null;
  }
  onTab(e, buttonType) {
    if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {
      e.preventDefault();
      if (buttonType === "reset") {
        this.menuTabbingService.firstFocusable.focus();
      } else {
        this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.resetButton.nativeElement.focus();
      }
    }
  }
  get clearText() {
    return this.ctx.localization.get("filterClearButton");
  }
  get filterText() {
    return this.ctx.localization.get("filterFilterButton");
  }
  static ɵfac = function FilterMenuContainerComponent_Factory(t) {
    return new (t || _FilterMenuContainerComponent)(ɵɵdirectiveInject(FilterService, 4), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MenuTabbingService), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterMenuContainerComponent,
    selectors: [["kendo-grid-filter-menu-container"]],
    viewQuery: function FilterMenuContainerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c123, 5);
        ɵɵviewQuery(_c132, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resetButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterButton = _t.first);
      }
    },
    inputs: {
      column: "column",
      isLast: "isLast",
      isExpanded: "isExpanded",
      menuTabbingService: "menuTabbingService",
      filter: "filter",
      actionsClass: "actionsClass"
    },
    outputs: {
      close: "close"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([FilterService, MenuTabbingService]), ɵɵStandaloneFeature],
    decls: 6,
    vars: 4,
    consts: [["filterButton", ""], ["resetButton", ""], [1, "k-filter-menu", 3, "submit", "reset"], [1, "k-filter-menu-container"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "ngClass", 4, "ngIf"], ["kendoFilterMenuHost", "", 3, "filterService", "column", "filter", "menuTabbingService"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngClass"], ["type", "submit", 1, "k-button", "k-button-solid-primary", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "keydown.tab", "disabled"], ["type", "reset", 1, "k-button", "k-button-solid-base", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "keydown.tab"]],
    template: function FilterMenuContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "form", 2);
        ɵɵlistener("submit", function FilterMenuContainerComponent_Template_form_submit_0_listener() {
          return ctx.submit();
        })("reset", function FilterMenuContainerComponent_Template_form_reset_0_listener() {
          return ctx.reset();
        });
        ɵɵelementStart(1, "div", 3);
        ɵɵelementContainerStart(2, 4);
        ɵɵtemplate(3, FilterMenuContainerComponent_ng_container_3_Template, 2, 4, "ng-container", 5)(4, FilterMenuContainerComponent_ng_container_4_Template, 2, 1, "ng-container", 5);
        ɵɵelementContainerEnd();
        ɵɵtemplate(5, FilterMenuContainerComponent_div_5_Template, 7, 4, "div", 6);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngSwitch", ctx.hasTemplate);
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", false);
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", true);
        ɵɵadvance();
        ɵɵproperty("ngIf", !(ctx.ctx.grid == null ? null : ctx.ctx.grid.isActionSheetExpanded));
      }
    },
    dependencies: [FormsModule, ɵNgNoValidate, NgControlStatusGroup, NgForm, NgSwitch, NgSwitchCase, FilterMenuHostDirective, NgIf, NgTemplateOutlet, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuContainerComponent, [{
    type: Component,
    args: [{
      providers: [FilterService, MenuTabbingService],
      selector: "kendo-grid-filter-menu-container",
      template: `
        <form (submit)="submit()" (reset)="reset()"
            class="k-filter-menu">
            <div class="k-filter-menu-container">
                <ng-container [ngSwitch]="hasTemplate">
                    <ng-container *ngSwitchCase="false">
                        <ng-container
                            kendoFilterMenuHost
                            [filterService]="childService"
                            [column]="column"
                            [filter]="childFilter"
                            [menuTabbingService]="menuTabbingService">
                        </ng-container>
                    </ng-container>
                    <ng-container *ngSwitchCase="true">
                        <ng-template
                            *ngIf="column.filterMenuTemplateRef"
                            [ngTemplateOutlet]="column.filterMenuTemplateRef"
                            [ngTemplateOutletContext]="templateContext"
                            >
                        </ng-template>
                    </ng-container>
                </ng-container>
                <div *ngIf="!ctx.grid?.isActionSheetExpanded" [ngClass]="actionsClass">
                    <button #filterButton
                        type="submit"
                        class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        [disabled]="disabled"
                        (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                    <button
                        #resetButton
                        type="reset"
                        class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
                </div>
            </div>
        </form>
    `,
      standalone: true,
      imports: [FormsModule, NgSwitch, NgSwitchCase, FilterMenuHostDirective, NgIf, NgTemplateOutlet, NgClass]
    }]
  }], function() {
    return [{
      type: FilterService,
      decorators: [{
        type: SkipSelf
      }]
    }, {
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: MenuTabbingService
    }, {
      type: AdaptiveGridService
    }];
  }, {
    close: [{
      type: Output
    }],
    column: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    actionsClass: [{
      type: Input
    }],
    resetButton: [{
      type: ViewChild,
      args: ["resetButton", {
        static: false
      }]
    }],
    filterButton: [{
      type: ViewChild,
      args: ["filterButton", {
        static: false
      }]
    }]
  });
})();
var id$1 = 0;
var getId$1 = (gridId) => `${gridId}-filter-menu-${id$1++}`;
var FilterMenuComponent = class _FilterMenuComponent {
  filterService;
  popupService;
  ctx;
  navigationService;
  renderer;
  cdr;
  adaptiveGridService;
  zone;
  idService;
  filterIcon = filterIcon;
  /**
   * The column with which the filter is associated.
   * @type {ColumnComponent}
   */
  column;
  /**
   * The current root filter.
   * @type {CompositeFilterDescriptor}
   */
  filter;
  anchor;
  template;
  tabIndex = "-1";
  popupRef;
  popupSubs;
  constructor(filterService, popupService, ctx, navigationService, renderer, cdr, adaptiveGridService, zone, idService) {
    this.filterService = filterService;
    this.popupService = popupService;
    this.ctx = ctx;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this.cdr = cdr;
    this.adaptiveGridService = adaptiveGridService;
    this.zone = zone;
    this.idService = idService;
  }
  ngOnDestroy() {
    this.cleanUp();
  }
  get hasFilters() {
    return filtersByField(this.filter, (this.column || {}).field).length > 0;
  }
  /**
   * @hidden
   */
  get filterLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuTitle") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  /**
   * @hidden
   */
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  toggle(anchor2, template) {
    if (this.ctx.grid?.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "filterMenu";
        this.adaptiveGridService.column = this.column;
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
      }
    } else {
      this.popupRef = this.popupService.open(anchor2, template, this.popupRef);
      const ariaRoot = this.isNavigable ? anchor2.closest(".k-table-th") : anchor2;
      if (this.popupRef) {
        this.popupSubs?.unsubscribe();
        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
          this.close();
          this.updateAria(ariaRoot);
        });
        this.popupSubs.add(() => this.popupRef.popup.instance.close.subscribe(() => {
          this.popupRef = null;
          this.updateAria(ariaRoot);
        }));
        const popupAriaElement = this.popupRef.popupElement.querySelector(".k-grid-filter-popup");
        if (popupAriaElement) {
          const popupId = getId$1(this.idService?.gridId());
          this.renderer.setAttribute(popupAriaElement, "id", popupId);
          this.renderer.setAttribute(popupAriaElement, "role", "dialog");
          this.renderer.setAttribute(popupAriaElement, "aria-label", this.filterLabel);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-controls", popupId);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "true");
        }
      } else {
        this.focusRoot();
      }
    }
    return false;
  }
  close() {
    this.cleanUp();
    this.focusRoot();
  }
  updateAria(ariaRoot) {
    ariaRoot && this.renderer.removeAttribute(ariaRoot, "aria-controls");
    ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "false");
  }
  cleanUp() {
    this.popupService.destroy();
    this.popupRef = null;
    this.popupSubs?.unsubscribe();
    this.popupSubs = null;
    this.cdr.markForCheck();
  }
  focusRoot() {
    this.isNavigable ? this.navigationService.focusCell(0, this.column.leafIndex) : this.anchor.nativeElement.focus();
  }
  static ɵfac = function FilterMenuComponent_Factory(t) {
    return new (t || _FilterMenuComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterMenuComponent,
    selectors: [["kendo-grid-filter-menu"]],
    viewQuery: function FilterMenuComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c142, 7);
        ɵɵviewQuery(_c152, 7, TemplateRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    inputs: {
      column: "column",
      filter: "filter",
      tabIndex: "tabIndex"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 5,
    vars: 7,
    consts: [["anchor", ""], ["template", ""], ["href", "#", 1, "k-grid-filter-menu", "k-grid-header-menu", 3, "click", "keydown.enter", "tabindex"], ["name", "filter", 3, "svgIcon"], [3, "close", "keydown.escape", "keydown.enter", "column", "filter"]],
    template: function FilterMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "a", 2, 0);
        ɵɵlistener("click", function FilterMenuComponent_Template_a_click_0_listener() {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(1);
          const template_r3 = ɵɵreference(4);
          return ɵɵresetView(ctx.toggle(anchor_r2, template_r3));
        })("keydown.enter", function FilterMenuComponent_Template_a_keydown_enter_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.stopImmediatePropagation());
        });
        ɵɵelement(2, "kendo-icon-wrapper", 3);
        ɵɵelementEnd();
        ɵɵtemplate(3, FilterMenuComponent_ng_template_3_Template, 1, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵclassProp("k-active", ctx.hasFilters);
        ɵɵproperty("tabindex", ctx.tabIndex);
        ɵɵattribute("title", ctx.filterLabel)("aria-haspopup", ctx.isNavigable ? void 0 : "dialog")("aria-expanded", ctx.isNavigable ? void 0 : false);
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.filterIcon);
      }
    },
    dependencies: [IconWrapperComponent, FilterMenuContainerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-menu",
      template: `
        <a #anchor
            class="k-grid-filter-menu k-grid-header-menu"
            [class.k-active]="hasFilters"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'"
            [attr.aria-expanded]="isNavigable ? undefined : false">
            <kendo-icon-wrapper
                name="filter"
                [svgIcon]="filterIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()">
            </kendo-grid-filter-menu-container>
        </ng-template>
    `,
      standalone: true,
      imports: [IconWrapperComponent, FilterMenuContainerComponent]
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: SinglePopupService
    }, {
      type: ContextService
    }, {
      type: NavigationService2
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: AdaptiveGridService
    }, {
      type: NgZone
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        static: true
      }]
    }],
    template: [{
      type: ViewChild,
      args: ["template", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabIndex: [{
      type: Input
    }]
  });
})();
var EMPTY_FILTER_OPERATORS = ["isnull", "isnotnull", "isempty", "isnotempty"];
var FilterCellWrapperComponent = class _FilterCellWrapperComponent extends FilterInputWrapperComponent {
  get hostClasses() {
    return true;
  }
  get overrideBaseClasses() {
    return false;
  }
  showOperators = true;
  get showButton() {
    const filter3 = this.currentFilter;
    return isPresent4(filter3) && (!isNullOrEmptyString(filter3.value) || EMPTY_FILTER_OPERATORS.indexOf(String(filter3.operator)) >= 0);
  }
  constructor(filterService) {
    super(filterService);
  }
  filterChange(filter3) {
    this.applyFilter(filter3);
  }
  static ɵfac = function FilterCellWrapperComponent_Factory(t) {
    return new (t || _FilterCellWrapperComponent)(ɵɵdirectiveInject(FilterService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterCellWrapperComponent,
    selectors: [["kendo-grid-filter-wrapper-cell"]],
    hostVars: 4,
    hostBindings: function FilterCellWrapperComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filtercell-wrapper", ctx.hostClasses)("k-filtercell", ctx.overrideBaseClasses);
      }
    },
    inputs: {
      showOperators: "showOperators"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    ngContentSelectors: _c112,
    decls: 2,
    vars: 5,
    consts: [[3, "clear", "valueChange", "showOperators", "column", "operators", "showButton", "value"]],
    template: function FilterCellWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
        ɵɵelementStart(1, "kendo-grid-filter-cell-operators", 0);
        ɵɵlistener("clear", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_clear_1_listener() {
          return ctx.onClear();
        });
        ɵɵtwoWayListener("valueChange", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_valueChange_1_listener($event) {
          ɵɵtwoWayBindingSet(ctx.currentOperator, $event) || (ctx.currentOperator = $event);
          return $event;
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("showOperators", ctx.showOperators)("column", ctx.column)("operators", ctx.operators)("showButton", ctx.showButton);
        ɵɵtwoWayProperty("value", ctx.currentOperator);
      }
    },
    dependencies: [FilterCellOperatorsComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-wrapper-cell",
      template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [column]="column"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `,
      standalone: true,
      imports: [FilterCellOperatorsComponent]
    }]
  }], function() {
    return [{
      type: FilterService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell-wrapper"]
    }],
    overrideBaseClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    showOperators: [{
      type: Input
    }]
  });
})();
var stringOperators = localizeOperators({
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty"
});
var AutoCompleteFilterCellComponent = class _AutoCompleteFilterCellComponent extends BaseFilterCellComponent {
  ctx;
  showOperators = true;
  column;
  data;
  set valueField(value) {
    this._valueField = value;
  }
  get valueField() {
    return this._valueField ? this._valueField : this.column.field;
  }
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : "contains";
  }
  size = "medium";
  _valueField;
  subs;
  constructor(filterService, column, ctx, sizingOptionsService) {
    super(filterService);
    this.ctx = ctx;
    this.defaultOperators = stringOperators(this.ctx.localization);
    this.column = column;
    this.subs = sizingOptionsService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  static ɵfac = function AutoCompleteFilterCellComponent_Factory(t) {
    return new (t || _AutoCompleteFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ColumnComponent2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AutoCompleteFilterCellComponent,
    selectors: [["kendo-grid-autocomplete-filter-cell"]],
    inputs: {
      showOperators: "showOperators",
      column: "column",
      data: "data",
      valueField: "valueField"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 8,
    consts: [[3, "column", "filter", "operators", "showOperators"], ["kendoFilterInput", "", 3, "data", "size", "valueField", "value"]],
    template: function AutoCompleteFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵɵelement(1, "kendo-autocomplete", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("data", ctx.data)("size", ctx.size)("valueField", ctx.valueField)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
      }
    },
    dependencies: [FilterCellWrapperComponent, AutoCompleteComponent, FilterInputDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoCompleteFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-autocomplete-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [size]="size"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, AutoCompleteComponent, FilterInputDirective]
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ColumnComponent2
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    showOperators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }]
  });
})();
var BooleanFilterCellComponent = class _BooleanFilterCellComponent extends BooleanFilterComponent {
  cd;
  /**
   * @hidden
   */
  size = "medium";
  subs;
  constructor(filterService, ctx, cd, sizingService) {
    super(filterService, ctx);
    this.cd = cd;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  localizationChange() {
    super.localizationChange();
    this.cd.markForCheck();
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("booleanFilterCellLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function BooleanFilterCellComponent_Factory(t) {
    return new (t || _BooleanFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _BooleanFilterCellComponent,
    selectors: [["kendo-grid-boolean-filter-cell"]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 12,
    consts: [[3, "column", "filter", "showOperators", "defaultOperator"], ["kendoFilterInput", "", "kendoGridFocusable", "", "textField", "text", "valueField", "value", 3, "size", "columnLabel", "defaultItem", "data", "popupSettings", "valuePrimitive", "value"]],
    template: function BooleanFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵɵelement(1, "kendo-dropdownlist", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("showOperators", false)("defaultOperator", ctx.operator);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("columnLabel", ctx.columnLabel)("defaultItem", ctx.defaultItem)("data", ctx.items)("popupSettings", ɵɵpureFunction0(11, _c102))("valuePrimitive", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
      }
    },
    dependencies: [FilterCellWrapperComponent, DropDownListComponent, FilterInputDirective, FocusableDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [size]="size"
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, DropDownListComponent, FilterInputDirective, FocusableDirective]
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: SizingOptionsService
    }];
  }, null);
})();
var DateFilterCellComponent = class _DateFilterCellComponent extends DateFilterComponent {
  ctx;
  /**
   * Determines if the drop-down filter operators will be displayed. The default value is `true`.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  subs;
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.ctx = ctx;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function DateFilterCellComponent_Factory(t) {
    return new (t || _DateFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DateFilterCellComponent,
    selectors: [["kendo-grid-date-filter-cell"]],
    inputs: {
      showOperators: "showOperators"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 19,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoFilterInput", "", "kendoGridFocusable", "", 3, "columnLabel", "value", "format", "size", "formatPlaceholder", "placeholder", "activeView", "bottomView", "topView", "min", "max", "weekNumber"], [3, "toggle", "today"]],
    template: function DateFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-datepicker", 1);
        ɵɵelement(2, "kendo-datepicker-messages", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("size", ctx.size)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber);
        ɵɵadvance();
        ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
      }
    },
    dependencies: [FilterCellWrapperComponent, DatePickerComponent, FilterInputDirective, FocusableDirective, DatePickerCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [size]="size"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber">
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                ></kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, DatePickerComponent, FilterInputDirective, FocusableDirective, DatePickerCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    showOperators: [{
      type: Input
    }]
  });
})();
var StringFilterCellComponent = class _StringFilterCellComponent extends StringFilterComponent {
  /**
   * Determines the delay time (in milliseconds) before the filter value is submitted.
   * A value of `0` indicates no delay.
   * @type {boolean}
   * @default 500
   */
  filterDelay = 500;
  /**
   * Determines if the drop-down filter operators will be displayed.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  /**
   * The placeholder text for the filter input.
   * @type {string}
   */
  placeholder;
  subs;
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function StringFilterCellComponent_Factory(t) {
    return new (t || _StringFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StringFilterCellComponent,
    selectors: [["kendo-grid-string-filter-cell"]],
    inputs: {
      filterDelay: "filterDelay",
      showOperators: "showOperators",
      placeholder: "placeholder"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 10,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoGridFocusable", "", "kendoFilterInput", "", 3, "size", "columnLabel", "filterDelay", "placeholder", "ngModel"]],
    template: function StringFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
        ɵɵelement(1, "kendo-textbox", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        let tmp_9_0;
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("placeholder", ctx.placeholder)("ngModel", (tmp_9_0 = ctx.currentFilter == null ? null : ctx.currentFilter.value) !== null && tmp_9_0 !== void 0 ? tmp_9_0 : null);
      }
    },
    dependencies: [FilterCellWrapperComponent, TextBoxComponent, FocusableDirective, FilterInputDirective, FormsModule, NgControlStatus, NgModel],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-textbox
                [size]="size"
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [placeholder]="placeholder"
                [ngModel]="currentFilter?.value ?? null"
            ></kendo-textbox>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, TextBoxComponent, FocusableDirective, FilterInputDirective, FormsModule]
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    filterDelay: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var NumericFilterCellComponent = class _NumericFilterCellComponent extends NumericFilterComponent {
  ctx;
  /**
   * Determines the delay time (in milliseconds) before the filter value is submitted.
   * A value of `0` indicates no delay. The default value is `500`.
   * @type {boolean}\
   * @default 500
   */
  filterDelay = 500;
  /**
   * Determines if the drop-down filter operators will be displayed.
   * The default value is `true`.
   * @type {boolean}
   * @default true
   */
  showOperators = true;
  /**
  * The placeholder text for the filter input.
  * @type {string}
  */
  placeholder;
  subs;
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.ctx = ctx;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  static ɵfac = function NumericFilterCellComponent_Factory(t) {
    return new (t || _NumericFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericFilterCellComponent,
    selectors: [["kendo-grid-numeric-filter-cell"]],
    inputs: {
      filterDelay: "filterDelay",
      showOperators: "showOperators",
      placeholder: "placeholder"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 19,
    consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoGridFocusable", "", "kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "size", "step", "placeholder"], [3, "increment", "decrement"]],
    template: function NumericFilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-numerictextbox", 1);
        ɵɵelement(2, "kendo-numerictextbox-messages", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
        ɵɵadvance();
        ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("size", ctx.size)("step", ctx.step)("placeholder", ctx.placeholder);
        ɵɵadvance();
        ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
      }
    },
    dependencies: [FilterCellWrapperComponent, NumericTextBoxComponent, FocusableDirective, FilterInputDirective, NumericTextBoxCustomMessagesComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [size]="size"
                [step]="step"
                [placeholder]="placeholder">
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                ></kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `,
      standalone: true,
      imports: [FilterCellWrapperComponent, NumericTextBoxComponent, FocusableDirective, FilterInputDirective, NumericTextBoxCustomMessagesComponent]
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    filterDelay: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }]
  });
})();
var filterComponentFactory = (type) => ({
  "boolean": BooleanFilterCellComponent,
  "date": DateFilterCellComponent,
  "numeric": NumericFilterCellComponent,
  "text": StringFilterCellComponent
})[type];
var FilterCellHostDirective = class _FilterCellHostDirective extends FilterHostDirective {
  constructor(host) {
    super(host);
  }
  componentType() {
    if (!isNullOrEmptyString(this.column.filter)) {
      return filterComponentFactory(this.column.filter);
    }
    return StringFilterCellComponent;
  }
  static ɵfac = function FilterCellHostDirective_Factory(t) {
    return new (t || _FilterCellHostDirective)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterCellHostDirective,
    selectors: [["", "kendoFilterCellHost", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterCellHost]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, null);
})();
var FilterCellComponent = class _FilterCellComponent {
  hostRole = "gridcell";
  column;
  get filter() {
    return this._filter;
  }
  set filter(value) {
    this._filter = cloneFilters(value);
  }
  size = "medium";
  _templateContext = {};
  _filter;
  get templateContext() {
    this._templateContext.column = this.column;
    this._templateContext.filter = this.filter;
    this._templateContext["$implicit"] = this.filter;
    return this._templateContext;
  }
  get hasTemplate() {
    return isPresent4(this.column.filterCellTemplateRef);
  }
  get isFilterable() {
    return isPresent4(this.column) && !isNullOrEmptyString(this.column.field) && this.column.filterable;
  }
  static ɵfac = function FilterCellComponent_Factory(t) {
    return new (t || _FilterCellComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterCellComponent,
    selectors: [["", "kendoGridFilterCell", ""]],
    hostVars: 1,
    hostBindings: function FilterCellComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole);
      }
    },
    inputs: {
      column: "column",
      filter: "filter",
      size: "size"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c162,
    decls: 1,
    vars: 1,
    consts: [[4, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], ["kendoFilterCellHost", "", 3, "column", "filter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function FilterCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, FilterCellComponent_ng_container_0_Template, 4, 3, "ng-container", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.isFilterable);
      }
    },
    dependencies: [NgIf, NgSwitch, NgSwitchCase, FilterCellHostDirective, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridFilterCell]",
      template: `
        <ng-container *ngIf="isFilterable">
            <ng-container [ngSwitch]="hasTemplate">
                <ng-container *ngSwitchCase="false">
                    <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
                </ng-container>
                <ng-container *ngSwitchCase="true">
                    <ng-template
                        *ngIf="column.filterCellTemplateRef"
                        [ngTemplateOutlet]="column.filterCellTemplateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                </ng-container>
            </ng-container>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, NgSwitch, NgSwitchCase, FilterCellHostDirective, NgTemplateOutlet]
    }]
  }], null, {
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var FilterRowComponent = class _FilterRowComponent {
  ctx;
  columnInfoService;
  columns = [];
  filter;
  groups = [];
  detailTemplate;
  logicalRowIndex;
  lockedColumnsCount;
  filterRowClass = true;
  constructor(ctx, columnInfoService) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
  }
  addStickyStyles(column) {
    const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;
    return __spreadValues(__spreadValues({}, sticky), column.filterStyle);
  }
  filterLabel(column) {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = column.title || column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  getLogicalColIndex(columnIndex) {
    const colIndex = this.lockedColumnsCount + columnIndex;
    return this.detailTemplate?.templateRef ? colIndex + 1 : colIndex;
  }
  static ɵfac = function FilterRowComponent_Factory(t) {
    return new (t || _FilterRowComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterRowComponent,
    selectors: [["", "kendoGridFilterRow", ""]],
    hostVars: 2,
    hostBindings: function FilterRowComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-filter-row", ctx.filterRowClass);
      }
    },
    inputs: {
      columns: "columns",
      filter: "filter",
      groups: "groups",
      detailTemplate: "detailTemplate",
      logicalRowIndex: "logicalRowIndex",
      lockedColumnsCount: "lockedColumnsCount"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c172,
    decls: 3,
    vars: 3,
    consts: [["class", "k-table-td k-group-cell k-table-group-td", "role", "presentation", 4, "ngFor", "ngForOf"], ["class", "k-table-td k-hierarchy-cell", "role", "presentation", 4, "ngIf"], ["class", "k-table-td", "kendoGridFilterCell", "", "kendoGridLogicalCell", "", 3, "k-grid-header-sticky", "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-table-td", "k-group-cell", "k-table-group-td"], ["role", "presentation", 1, "k-table-td", "k-hierarchy-cell"], ["kendoGridFilterCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex"]],
    template: function FilterRowComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, FilterRowComponent_td_0_Template, 1, 0, "td", 0)(1, FilterRowComponent_td_1_Template, 1, 0, "td", 1)(2, FilterRowComponent_td_2_Template, 1, 9, "td", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.groups);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.columns);
      }
    },
    dependencies: [NgForOf, NgIf, FilterCellComponent, LogicalCellDirective, NgStyle, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterRowComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridFilterRow]",
      template: `
        <td
            class="k-table-td k-group-cell k-table-group-td"
            *ngFor="let g of groups"
            role="presentation">
        </td>
        <td
            class="k-table-td k-hierarchy-cell"
            *ngIf="detailTemplate?.templateRef"
            role="presentation">
        </td>
        <td *ngFor="let column of columns; let columnIndex = index"
            class="k-table-td"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel($any(column))"
            kendoGridFilterCell
                [column]="$any(column)"
                [filter]="filter"
            kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="getLogicalColIndex(columnIndex)"
      ></td>
    `,
      standalone: true,
      imports: [NgForOf, NgIf, FilterCellComponent, LogicalCellDirective, NgStyle, NgClass]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }];
  }, {
    columns: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    filterRowClass: [{
      type: HostBinding,
      args: ["class.k-filter-row"]
    }]
  });
})();
var ColumnMenuChooserItemCheckedDirective = class _ColumnMenuChooserItemCheckedDirective {
  host;
  kendoColumnMenuChooserItemChecked;
  checkbox;
  checkedChangeSub = new Subscription();
  constructor(host) {
    this.host = host;
  }
  ngAfterViewInit() {
    this.checkedChangeSub.add(this.checkbox.checkedStateChange.subscribe(() => {
      this.kendoColumnMenuChooserItemChecked = this.checkbox.checkedState === true;
    }));
  }
  ngOnDestroy() {
    this.checkedChangeSub.unsubscribe();
  }
  static ɵfac = function ColumnMenuChooserItemCheckedDirective_Factory(t) {
    return new (t || _ColumnMenuChooserItemCheckedDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnMenuChooserItemCheckedDirective,
    selectors: [["", "kendoColumnMenuChooserItemChecked", ""]],
    contentQueries: function ColumnMenuChooserItemCheckedDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CheckBoxComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkbox = _t.first);
      }
    },
    hostVars: 1,
    hostBindings: function ColumnMenuChooserItemCheckedDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-checked", ctx.kendoColumnMenuChooserItemChecked);
      }
    },
    inputs: {
      kendoColumnMenuChooserItemChecked: "kendoColumnMenuChooserItemChecked"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuChooserItemCheckedDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoColumnMenuChooserItemChecked]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    kendoColumnMenuChooserItemChecked: [{
      type: HostBinding,
      args: ["attr.aria-checked"]
    }, {
      type: Input
    }],
    checkbox: [{
      type: ContentChild,
      args: [CheckBoxComponent]
    }]
  });
})();
var ColumnMenuService = class _ColumnMenuService {
  /**
   * @hidden
   */
  menuTabbingService;
  /**
   * @hidden
   */
  closeMenu = new EventEmitter();
  /**
   * @hidden
   */
  column;
  /**
   * @hidden
   */
  sort;
  /**
   * @hidden
   */
  filter;
  /**
   * @hidden
   */
  sortable;
  /**
   * @hidden
   */
  columnMenuContainer;
  /**
   * @hidden
   */
  constructor(menuTabbingService) {
    this.menuTabbingService = menuTabbingService;
  }
  /**
   * Closes the column menu.
   */
  close() {
    this.closeMenu.emit();
  }
  static ɵfac = function ColumnMenuService_Factory(t) {
    return new (t || _ColumnMenuService)(ɵɵinject(MenuTabbingService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnMenuService,
    factory: _ColumnMenuService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuService, [{
    type: Injectable
  }], function() {
    return [{
      type: MenuTabbingService
    }];
  }, null);
})();
var ColumnListKeyboardNavigation = class _ColumnListKeyboardNavigation {
  renderer;
  items;
  activeIndex = 0;
  constructor(renderer) {
    this.renderer = renderer;
  }
  next() {
    this.toggle(this.activeIndex, false);
    this.activeIndex = Math.min(this.activeIndex + 1, this.items.length - 1);
    this.toggle(this.activeIndex, true);
  }
  prev() {
    this.toggle(this.activeIndex, false);
    this.activeIndex = Math.max(this.activeIndex - 1, 0);
    this.toggle(this.activeIndex, true);
  }
  toggle(index, active) {
    const element = this.items[index]?.host.nativeElement;
    element && this.renderer.setAttribute(this.items[index].host.nativeElement, "tabindex", active ? "0" : "-1");
    active && element?.focus();
  }
  toggleCheckedState() {
    this.items[this.activeIndex].host.nativeElement.firstElementChild.click();
  }
  static ɵfac = function ColumnListKeyboardNavigation_Factory(t) {
    return new (t || _ColumnListKeyboardNavigation)(ɵɵinject(Renderer2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnListKeyboardNavigation,
    factory: _ColumnListKeyboardNavigation.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnListKeyboardNavigation, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, null);
})();
var ColumnListComponent = class _ColumnListComponent {
  element;
  ngZone;
  renderer;
  listNavigationService;
  adaptiveGridService;
  ctx;
  checkIcon = checkIcon;
  arrowRotateCcwIcon = arrowRotateCcwIcon;
  className = true;
  get listSizeMd() {
    return !this.ctx?.grid?.isActionSheetExpanded;
  }
  get listSizeLg() {
    return this.ctx?.grid?.isActionSheetExpanded;
  }
  reset = new EventEmitter();
  apply = new EventEmitter();
  columnChange = new EventEmitter();
  set columns(value) {
    this._columns = value.filter((column) => column.includeInChooser !== false);
    this.allColumns = value;
    this.updateColumnState();
  }
  get columns() {
    return this._columns;
  }
  showActions = true;
  autoSync = true;
  ariaLabel;
  allowHideAll = false;
  applyText;
  resetText;
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  isLast;
  isExpanded;
  service;
  resetButton;
  applyButton;
  options;
  checkboxes;
  hasLocked;
  hasVisibleLocked;
  unlockedCount = 0;
  hasUnlockedFiltered;
  hasFiltered;
  _columns;
  allColumns;
  domSubscriptions = new Subscription();
  constructor(element, ngZone, renderer, listNavigationService, adaptiveGridService, ctx) {
    this.element = element;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.listNavigationService = listNavigationService;
    this.adaptiveGridService = adaptiveGridService;
    this.ctx = ctx;
  }
  ngOnInit() {
    if (!this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, "click", (e) => {
        e.stopImmediatePropagation();
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
          this.handleCheckBoxClick(e);
        });
      }));
      this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, "keydown", this.onKeydown));
    });
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.listNavigationService.items = this.options.toArray();
      if (!this.ctx) {
        this.listNavigationService.toggle(0, true);
      }
      this.updateDisabled();
    });
    if (this.ctx?.grid?.isActionSheetExpanded) {
      this.domSubscriptions.add(this.adaptiveGridService.animationEnd.subscribe(() => {
        this.listNavigationService.toggle(0, true);
      }));
    }
  }
  ngOnChanges(changes) {
    if (!this.service) {
      return;
    }
    if (changes["isLast"] && this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
    }
    if (changes["isExpanded"] && this.isExpanded && this.isLast && this.applyButton) {
      this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
    }
  }
  ngOnDestroy() {
    this.domSubscriptions.unsubscribe();
  }
  isDisabled(column) {
    return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find((current3) => current3 !== column && !current3.hidden)) || this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden;
  }
  cancelChanges() {
    this.checkboxes.forEach((element, index) => {
      element.checkedState = !this.columns[index].hidden;
    });
    this.updateDisabled();
    this.reset.emit();
  }
  applyChanges() {
    const changed = [];
    this.checkboxes.forEach((item, index) => {
      const column = this.columns[index];
      const hidden = !item.checkedState;
      if (Boolean(column.hidden) !== hidden) {
        column.hidden = hidden;
        changed.push(column);
      }
    });
    this.updateDisabled();
    this.apply.emit(changed);
  }
  onTab(e) {
    if (this.isLast) {
      e.preventDefault();
      if (this.service) {
        this.service.menuTabbingService.firstFocusable.focus();
      } else {
        this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
      }
    }
  }
  onKeydown = (e) => {
    if (e.keyCode !== Keys.Tab) {
      e.preventDefault();
    }
    if (e.key === "Tab" && !e.shiftKey && this.autoSync) {
      e.preventDefault();
    }
    if (e.key === "Tab" && e.shiftKey) {
      this.ngZone.run(() => {
        if (e.target.matches(".k-column-list-item")) {
          e.preventDefault();
          this.resetButton?.nativeElement.focus();
        }
      });
    }
    if (e.keyCode === Keys.ArrowDown) {
      this.listNavigationService.next();
    } else if (e.keyCode === Keys.ArrowUp) {
      this.listNavigationService.prev();
    } else if (e.keyCode === Keys.Space && e.target.classList.contains("k-column-list-item")) {
      this.listNavigationService.toggleCheckedState();
    }
  };
  updateDisabled() {
    if (this.allowHideAll && !this.hasLocked) {
      return;
    }
    const visibleColumns = [];
    const columnMap = /* @__PURE__ */ new Map();
    this.checkboxes.forEach((checkbox, index) => {
      this.setDisabledState(checkbox, false);
      if (checkbox.checkedState) {
        visibleColumns.push({
          checkbox,
          index
        });
        columnMap.set(index, this.columns[index]);
      }
    });
    if (!this.allowHideAll && visibleColumns.length === 1 && !this.hasFiltered) {
      this.setDisabledState(visibleColumns[0].checkbox, true);
    } else if (this.hasLocked && !this.hasUnlockedFiltered) {
      const checkedUnlocked = visibleColumns.filter((item) => !columnMap.get(item.index).locked);
      if (checkedUnlocked.length === 1) {
        this.setDisabledState(checkedUnlocked[0].checkbox, true);
      }
    }
  }
  updateColumnState() {
    this.hasLocked = this.allColumns.filter((column) => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;
    this.hasVisibleLocked = this.allColumns.filter((column) => column.locked && !column.hidden).length > 0;
    this.unlockedCount = this.columns.filter((column) => !column.locked && !column.hidden).length;
    const filteredColumns = this.allColumns.filter((column) => column.includeInChooser === false && !column.hidden);
    if (filteredColumns.length) {
      this.hasFiltered = filteredColumns.length > 0;
      this.hasUnlockedFiltered = filteredColumns.filter((column) => !column.locked).length > 0;
    } else {
      this.hasFiltered = false;
      this.hasUnlockedFiltered = false;
    }
  }
  setDisabledState(checkbox, disabled) {
    if (checkbox.disabled !== disabled) {
      this.ngZone.runOutsideAngular(() => {
        checkbox.disabled = disabled;
        const checkboxElement = checkbox.hostElement.nativeElement;
        const parentElement = checkboxElement.parentElement;
        if (disabled) {
          this.renderer.addClass(parentElement, "k-disabled");
          this.renderer.setAttribute(parentElement, "aria-disabled", "true");
        } else {
          this.renderer.removeClass(parentElement, "k-disabled");
          this.renderer.removeAttribute(parentElement, "aria-disabled");
        }
      });
    }
  }
  handleCheckBoxClick = (e) => {
    const closestItem = e.target.closest(".k-column-list-item");
    if (closestItem) {
      const checkboxElement = closestItem.querySelector(".k-checkbox-wrap");
      const index = parseInt(checkboxElement.firstElementChild.getAttribute("data-index"), 10);
      const checkbox = this.checkboxes.toArray()[index];
      if (e.target === checkbox.input.nativeElement) {
        closestItem.focus();
        e.target.classList.remove("k-focus");
      }
      if (this.autoSync) {
        if (!this.columns[index]) {
          return;
        }
        const column = this.columns[index];
        const hidden = !checkbox.checkedState;
        if (Boolean(column.hidden) !== hidden) {
          this.ngZone.runOutsideAngular(() => {
            column.hidden = hidden;
            this.ngZone.run(() => {
              this.columnChange.emit([column]);
            });
          });
        }
      } else {
        this.ngZone.run(() => this.updateDisabled());
      }
      if (index !== this.listNavigationService.activeIndex) {
        this.listNavigationService.toggle(this.listNavigationService.activeIndex, false);
        this.listNavigationService.activeIndex = index;
        this.listNavigationService.toggle(index, true);
      }
    }
  };
  static ɵfac = function ColumnListComponent_Factory(t) {
    return new (t || _ColumnListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ColumnListKeyboardNavigation), ɵɵdirectiveInject(AdaptiveGridService, 8), ɵɵdirectiveInject(ContextService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnListComponent,
    selectors: [["kendo-grid-columnlist"]],
    viewQuery: function ColumnListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c123, 5);
        ɵɵviewQuery(_c182, 5);
        ɵɵviewQuery(ColumnMenuChooserItemCheckedDirective, 5);
        ɵɵviewQuery(CheckBoxComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resetButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.applyButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxes = _t);
      }
    },
    hostVars: 6,
    hostBindings: function ColumnListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-column-list-wrapper", ctx.className)("k-column-list-md", ctx.listSizeMd)("k-column-list-lg", ctx.listSizeLg);
      }
    },
    inputs: {
      columns: "columns",
      showActions: "showActions",
      autoSync: "autoSync",
      ariaLabel: "ariaLabel",
      allowHideAll: "allowHideAll",
      applyText: "applyText",
      resetText: "resetText",
      actionsClass: "actionsClass",
      isLast: "isLast",
      isExpanded: "isExpanded",
      service: "service"
    },
    outputs: {
      reset: "reset",
      apply: "apply",
      columnChange: "columnChange"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([ColumnListKeyboardNavigation]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 3,
    consts: [["applyButton", ""], ["resetButton", ""], ["role", "listbox", "aria-multiselectable", "true", 1, "k-column-list"], ["class", "k-column-list-item", "role", "option", 3, "kendoColumnMenuChooserItemChecked", 4, "ngFor", "ngForOf"], [3, "ngClass", 4, "ngIf"], ["role", "option", 1, "k-column-list-item", 3, "kendoColumnMenuChooserItemChecked"], [3, "inputAttributes", "tabindex", "checkedState", "disabled"], [1, "k-checkbox-label"], [3, "ngClass"], ["kendoButton", "", "type", "button", "icon", "check", "themeColor", "primary", 3, "click", "keydown.enter", "keydown.space", "svgIcon"], ["kendoButton", "", "type", "button", "icon", "reset", 3, "keydown.tab", "click", "keydown.enter", "keydown.space", "svgIcon"]],
    template: function ColumnListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 2);
        ɵɵtemplate(1, ColumnListComponent_label_1_Template, 4, 8, "label", 3);
        ɵɵelementEnd();
        ɵɵtemplate(2, ColumnListComponent_div_2_Template, 7, 5, "div", 4);
      }
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx.ariaLabel);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.columns);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.autoSync && ctx.showActions);
      }
    },
    dependencies: [NgForOf, ColumnMenuChooserItemCheckedDirective, NgIf, NgClass, CheckBoxComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnlist",
      providers: [ColumnListKeyboardNavigation],
      template: `
        <div 
            class="k-column-list"
            role="listbox"
            aria-multiselectable="true"
            [attr.aria-label]="ariaLabel">
            <label 
                *ngFor="let column of columns; let index = index;" 
                class='k-column-list-item'
                [kendoColumnMenuChooserItemChecked]="!column.hidden"
                role="option">
                <kendo-checkbox
                    [inputAttributes]="{'data-index': index.toString()}"
                    [tabindex]="-1"
                    [checkedState]="!column.hidden"
                    [disabled]="isDisabled(column)"
                ></kendo-checkbox>
                <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync && showActions">            
            <button
                #applyButton
                kendoButton
                type="button"
                icon="check"
                [svgIcon]="checkIcon"
                themeColor="primary"
                (click)="applyChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation(); applyChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation(); applyChanges();">{{ applyText }}</button>
            <button
                #resetButton
                kendoButton
                type="button"
                icon="reset"
                [svgIcon]="arrowRotateCcwIcon"
                (keydown.tab)="onTab($event)"
                (click)="cancelChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation(); cancelChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation(); cancelChanges();">{{ resetText }}</button>
        </div>
    `,
      standalone: true,
      imports: [NgForOf, ColumnMenuChooserItemCheckedDirective, NgIf, NgClass, CheckBoxComponent, ButtonComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ColumnListKeyboardNavigation
    }, {
      type: AdaptiveGridService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContextService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    className: [{
      type: HostBinding,
      args: ["class.k-column-list-wrapper"]
    }],
    listSizeMd: [{
      type: HostBinding,
      args: ["class.k-column-list-md"]
    }],
    listSizeLg: [{
      type: HostBinding,
      args: ["class.k-column-list-lg"]
    }],
    reset: [{
      type: Output
    }],
    apply: [{
      type: Output
    }],
    columnChange: [{
      type: Output
    }],
    columns: [{
      type: Input
    }],
    showActions: [{
      type: Input
    }],
    autoSync: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    applyText: [{
      type: Input
    }],
    resetText: [{
      type: Input
    }],
    actionsClass: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    service: [{
      type: Input
    }],
    resetButton: [{
      type: ViewChild,
      args: ["resetButton", {
        static: false
      }]
    }],
    applyButton: [{
      type: ViewChild,
      args: ["applyButton", {
        static: false
      }]
    }],
    options: [{
      type: ViewChildren,
      args: [ColumnMenuChooserItemCheckedDirective]
    }],
    checkboxes: [{
      type: ViewChildren,
      args: [CheckBoxComponent]
    }]
  });
})();
var ColumnChooserComponent = class _ColumnChooserComponent {
  ctx;
  columnInfoService;
  popupService;
  ngZone;
  renderer;
  changeDetector;
  /**
   * Specifies if the changes in the visibility of the column will be immediately applied.
   *
   * @default false
   */
  autoSync = false;
  /**
   * Specifies if all columns can be hidden.
   *
   * @default true
   */
  allowHideAll = true;
  anchor;
  columnList;
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  columnsIcon = columnsIcon;
  popupRef;
  popupId;
  closeClick;
  escapeListener;
  constructor(ctx, columnInfoService, popupService, ngZone, renderer, changeDetector) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.popupService = popupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.changeDetector = changeDetector;
  }
  ngOnDestroy() {
    this.close();
  }
  /**
   * @hidden
   */
  messageFor = (token) => this.ctx.localization.get(token);
  /**
   * @hidden
   */
  toggle(anchor2, template) {
    if (!this.popupRef) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchor: anchor2.element,
        content: template,
        positionMode: "absolute",
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        }
      });
      const popupElement = this.popupRef?.popupElement;
      if (popupElement) {
        const popupId = `k-${guid()}`;
        const popupAriaElement = popupElement.querySelector(".k-popup");
        this.ngZone.runOutsideAngular(() => {
          this.escapeListener = this.renderer.listen(popupAriaElement, "keydown", (e) => {
            if (e.keyCode === Keys.Escape) {
              this.close(true);
            }
          });
        });
        this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
        this.renderer.setAttribute(popupAriaElement, "id", popupId);
        this.renderer.setAttribute(popupAriaElement, "role", "dialog");
        this.popupId = popupId;
      }
      if (!isDocumentAvailable()) {
        return;
      }
      this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen("document", "click", ({
        target
      }) => {
        if (!closest3(target, (node) => node === this.popupRef.popupElement || node === anchor2.element)) {
          this.ngZone.run(() => {
            this.close();
          });
        }
      }));
    } else {
      this.close();
    }
  }
  /**
   * @hidden
   */
  onApply(changed) {
    this.close(true);
    if (changed.length) {
      this.changeDetector.markForCheck();
      this.columnInfoService.changeVisibility(changed);
    }
  }
  /**
   * @hidden
   */
  onChange(changed) {
    this.changeDetector.markForCheck();
    this.columnInfoService.changeVisibility(changed);
  }
  close(focusAnchor = false) {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.changeDetector.markForCheck();
      this.escapeListener?.();
    }
    this.detachClose();
    focusAnchor && this.anchor.element.focus();
  }
  detachClose() {
    if (this.closeClick) {
      this.closeClick();
      this.closeClick = null;
    }
  }
  static ɵfac = function ColumnChooserComponent_Factory(t) {
    return new (t || _ColumnChooserComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnChooserComponent,
    selectors: [["kendo-grid-column-chooser"]],
    viewQuery: function ColumnChooserComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c142, 5);
        ɵɵviewQuery(_c202, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnList = _t.first);
      }
    },
    inputs: {
      autoSync: "autoSync",
      allowHideAll: "allowHideAll"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 4,
    vars: 5,
    consts: [["anchor", ""], ["template", ""], ["columnList", ""], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "columns", 3, "click", "svgIcon"], [3, "apply", "columnChange", "columns", "ariaLabel", "isLast", "applyText", "resetText", "autoSync", "allowHideAll"]],
    template: function ColumnChooserComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "button", 3, 0);
        ɵɵlistener("click", function ColumnChooserComponent_Template_button_click_0_listener() {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(1);
          const template_r3 = ɵɵreference(3);
          return ɵɵresetView(ctx.toggle(anchor_r2, template_r3));
        });
        ɵɵelementEnd();
        ɵɵtemplate(2, ColumnChooserComponent_ng_template_2_Template, 2, 7, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("svgIcon", ctx.columnsIcon);
        ɵɵattribute("title", ctx.messageFor("columns"))("aria-haspopup", "dialog")("aria-expanded", !!ctx.popupRef)("aria-controls", !!ctx.popupRef ? ctx.popupId : void 0);
      }
    },
    dependencies: [ButtonComponent, ColumnListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnChooserComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-chooser",
      template: `
        <button #anchor
            kendoButton
            type="button"
            (click)="toggle(anchor, template)"
            fillMode="flat"
            [attr.title]="messageFor('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [attr.aria-haspopup]="'dialog'"
            [attr.aria-expanded]="!!(popupRef)"
            [attr.aria-controls]="!!(popupRef) ? popupId : undefined"></button>
        <ng-template #template>
            <kendo-grid-columnlist
                #columnList
                [columns]="columns"
                [ariaLabel]="messageFor('columns')"
                [isLast]="true"
                [applyText]="messageFor('columnsApply')"
                [resetText]="messageFor('columnsReset')"
                [autoSync]="autoSync"
                [allowHideAll]="allowHideAll"
                (apply)="onApply($event)"
                (columnChange)="onChange($event)">
            </kendo-grid-columnlist>
        </ng-template>
    `,
      standalone: true,
      imports: [ButtonComponent, ColumnListComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: PopupService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    autoSync: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor"]
    }],
    columnList: [{
      type: ViewChild,
      args: ["columnList"]
    }]
  });
})();
var ToolbarToolName = {
  edit: "edit",
  save: "save",
  remove: "remove",
  cancel: "cancel",
  add: "add",
  columns: "columns",
  excelExport: "excelExport",
  pdfExport: "pdfExport"
};
var ICONS_MAP = {
  edit: {
    svgIcon: pencilIcon,
    icon: "pencil"
  },
  save: {
    svgIcon: saveIcon,
    icon: "save"
  },
  cancel: {
    svgIcon: cancelIcon,
    icon: "cancel"
  },
  remove: {
    svgIcon: trashIcon,
    icon: "trash"
  },
  add: {
    svgIcon: plusIcon,
    icon: "plus"
  },
  excelExport: {
    svgIcon: fileExcelIcon,
    icon: "file-excel"
  },
  pdfExport: {
    svgIcon: filePdfIcon,
    icon: "file-pdf"
  },
  columns: {
    svgIcon: columnsIcon,
    icon: "columns"
  }
};
var ToolbarToolBase = class _ToolbarToolBase {
  host;
  commandName;
  ctx;
  zone;
  cdr;
  clickSub = new Subscription();
  constructor(host, commandName, ctx, zone, cdr) {
    this.host = host;
    this.commandName = commandName;
    this.ctx = ctx;
    this.zone = zone;
    this.cdr = cdr;
  }
  ngOnInit() {
    this.clickSub = this.host.click.subscribe((e) => this.onClick(e));
    const hasIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "" && isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = ICONS_MAP[this.commandName].icon;
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = ICONS_MAP[this.commandName].svgIcon;
    }
  }
  ngAfterViewInit() {
    const hasText = isPresent(this.host.text);
    if (!hasText) {
      this.zone.runOutsideAngular(() => {
        setTimeout(() => {
          const messageKey = this.commandName === ToolbarToolName.columns ? "columns" : `${this.commandName}ToolbarToolText`;
          this.host.text = this.ctx.localization.get(messageKey);
          this.zone.run(() => {
            this.cdr.markForCheck();
          });
        });
      });
    }
  }
  ngOnDestroy() {
    this.clickSub.unsubscribe();
  }
  onClick(_e) {
  }
  static ɵfac = function ToolbarToolBase_Factory(t) {
    return new (t || _ToolbarToolBase)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject("command"), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ToolbarToolBase
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarToolBase, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: ToolBarButtonComponent
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: ["command"]
      }]
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var incrementingId$3 = 0;
var ColumnChooserToolbarDirective = class _ColumnChooserToolbarDirective extends ToolbarToolBase {
  renderer;
  popupSerivce;
  host;
  ctx;
  zone;
  refresh;
  adaptiveGridService;
  columnInfoService;
  /**
   * Specifies if the changes in the visibility of the column will be immediately applied.
   *
   * @default false
   */
  autoSync = false;
  /**
   * Specifies if all columns can be hidden.
   *
   * @default true
   */
  allowHideAll = true;
  /**
   * @hidden
   */
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  popupRef;
  subs = new Subscription();
  actionSheetCloseSub;
  nextId = incrementingId$3++;
  constructor(renderer, popupSerivce, host, ctx, zone, refresh, adaptiveGridService, columnInfoService, cdr) {
    super(host, ToolbarToolName.columns, ctx, zone, cdr);
    this.renderer = renderer;
    this.popupSerivce = popupSerivce;
    this.host = host;
    this.ctx = ctx;
    this.zone = zone;
    this.refresh = refresh;
    this.adaptiveGridService = adaptiveGridService;
    this.columnInfoService = columnInfoService;
  }
  ngOnInit() {
    this.subs.add(this.host.click.subscribe((e) => this.onClick(e)));
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "columns";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = columnsIcon;
    }
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.buttonElement?.setAttribute("aria-haspopup", "dialog");
      this.buttonElement?.setAttribute("aria-expanded", "false");
      this.buttonElement?.setAttribute("title", this.ctx.localization.get("columns"));
    });
    this.subs.add(this.refresh.onRefresh.pipe(filter((tool) => tool === this.host)).subscribe((tool) => {
      if (tool.overflows && this.popupRef) {
        this.popupRef.close();
      }
    }));
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subs.unsubscribe();
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "columnChooserToolbarTool";
        this.adaptiveGridService.columns = this.columns;
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      this.togglePopup();
    }
  }
  togglePopup() {
    if (!this.popupRef) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupSerivce.open({
        anchor: this.buttonElement,
        content: ColumnListComponent,
        positionMode: "absolute",
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        }
      });
      this.adaptiveGridService.popupRef = this.popupRef;
      const popupElement = this.popupRef.popupElement;
      const popupId = `k-column-chooser-tool-${this.nextId}-popup`;
      const popupAriaElement = popupElement.querySelector(".k-popup");
      this.zone.runOutsideAngular(() => {
        this.renderer.listen(popupAriaElement, "keydown", (e) => {
          if (e.key === "Escape") {
            this.closePopup(true);
          }
        });
      });
      this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
      this.renderer.setAttribute(popupAriaElement, "id", popupId);
      this.renderer.setAttribute(popupAriaElement, "role", "dialog");
      this.buttonElement?.setAttribute("aria-expanded", "true");
      this.buttonElement?.setAttribute("aria-controls", popupId);
      this.host.selected = true;
      const columnList = this.popupRef.content.instance;
      columnList.isLast = true;
      columnList.autoSync = this.autoSync;
      columnList.allowHideAll = this.allowHideAll;
      columnList.applyText = this.ctx.localization.get("columnsApply");
      columnList.resetText = this.ctx.localization.get("columnsReset");
      columnList.columns = this.ctx.grid.columns;
      columnList.ariaLabel = this.ctx.localization.get("columns");
      this.subs.add(this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
        this.closePopup(true);
      }));
      this.subs.add(columnList.apply.subscribe(() => {
        this.closePopup();
      }));
      this.zone.runOutsideAngular(() => this.renderer.listen("document", "click", ({
        target
      }) => {
        if (this.popupRef && !closest(target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
          this.zone.run(() => {
            this.closePopup();
          });
        }
      }));
    } else {
      this.closePopup();
    }
  }
  closePopup(focusAnchor = false) {
    this.popupRef.close();
    this.popupRef = null;
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    focusAnchor && this.buttonElement?.focus();
  }
  get buttonElement() {
    return this.host.getButton();
  }
  static ɵfac = function ColumnChooserToolbarDirective_Factory(t) {
    return new (t || _ColumnChooserToolbarDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(RefreshService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnChooserToolbarDirective,
    selectors: [["", "kendoGridColumnChooserTool", ""]],
    inputs: {
      autoSync: "autoSync",
      allowHideAll: "allowHideAll"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnChooserToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnChooserTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: PopupService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: RefreshService
    }, {
      type: AdaptiveGridService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    autoSync: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }]
  });
})();
var ColumnMenuItemBase = class _ColumnMenuItemBase {
  /**
   * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.
   * Requires a mandatory input.
   */
  service;
  hostClass = true;
  ngOnInit() {
    if (isDevMode() && !this.service) {
      throw new Error(ColumnMenuErrorMessages.serviceInput);
    }
  }
  /**
   * @hidden
   */
  close() {
    this.service.close();
  }
  static ɵfac = function ColumnMenuItemBase_Factory(t) {
    return new (t || _ColumnMenuItemBase)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuItemBase,
    selectors: [["kendo-grid-column-menu-item-base"]],
    hostVars: 2,
    hostBindings: function ColumnMenuItemBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-columnmenu-item-wrapper", ctx.hostClass);
      }
    },
    inputs: {
      service: "service"
    },
    decls: 0,
    vars: 0,
    template: function ColumnMenuItemBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemBase, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-menu-item-base",
      template: ``
    }]
  }], null, {
    service: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-columnmenu-item-wrapper"]
    }]
  });
})();
var hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;
var hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;
var hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);
var hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);
var hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);
var hasColumnChooser = (settings) => settings.columnChooser !== false;
var hasAutoSizeColumn = (settings) => settings.autoSizeColumn;
var hasAutoSizeAllColumns = (settings) => settings.autoSizeAllColumns;
var autoSizeColumn = (grid, service, column) => {
  column ? grid.autoFitColumn(column) : grid.autoFitColumns();
  service.close();
};
var hasItems = (settings, column) => hasAutoSizeAllColumns(settings) || hasColumnChooser(settings) || hasFilter(settings, column) || hasAutoSizeColumn(settings) || hasLock(settings, column) || hasSort(settings, column);
var ColumnMenuItemContentTemplateDirective = class _ColumnMenuItemContentTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnMenuItemContentTemplateDirective_Factory(t) {
    return new (t || _ColumnMenuItemContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnMenuItemContentTemplateDirective,
    selectors: [["", "kendoGridColumnMenuItemContentTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuItemContentTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DEFAULTS = {
  allowUnsort: true,
  mode: "single",
  showIndexes: true,
  initialDirection: "asc",
  multiSortKey: "none"
};
var normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);
var ColumnMenuItemComponent = class _ColumnMenuItemComponent {
  ngZone;
  ctx;
  adaptiveGridService;
  element;
  /**
   * @hidden
   */
  sortAscSmallIcon = sortAscSmallIcon;
  /**
   * @hidden
   */
  sortDescSmallIcon = sortDescSmallIcon;
  /**
   * Fires when the item is clicked.
   */
  itemClick = new EventEmitter();
  /**
   * Fires when the content is expanded.
   */
  expand = new EventEmitter();
  /**
   * Fires when the content is collapsed.
   */
  collapse = new EventEmitter();
  /**
   * Specifies the name of the [font icon](slug:icon_list)
   * that will be rendered within the item.
   */
  icon;
  /**
   * Defines the [SVG icon](slug:svgicon_list) to be rendered within the item.
   */
  svgIcon;
  /**
   * @hidden
   */
  indicatorIcon;
  /**
   * Specifies the item text.
   */
  text;
  /**
   * Specifies if the item is selected.
   */
  selected;
  /**
   * Specifies if the item is disabled.
   */
  disabled;
  /**
   * Specifies if the item is expanded.
   */
  expanded;
  /**
   * @hidden
   */
  focused;
  /**
   * Represents the [ColumnMenuService]({% slug api_grid_columnmenuservice %}) class.
   * Required to include the item in the column menu keyboard navigation sequence.
   */
  service;
  /**
   * @hidden
   */
  column;
  contentTemplate;
  contentState = "collapsed";
  contentId;
  chevronUpIcon = chevronUpIcon;
  chevronDownIcon = chevronDownIcon;
  chevronRightIcon = chevronRightIcon;
  filterIcon = filterIcon;
  /**
   * @hidden
   */
  get hasFilters() {
    return filtersByField(this.ctx.grid.filter, this.column.field).length > 0;
  }
  get expandedIcon() {
    if (this.ctx.grid.isActionSheetExpanded) {
      return "arrow-chevron-right";
    }
    return this.expanded ? "arrow-chevron-up" : "arrow-chevron-down";
  }
  get expandedSvgIcon() {
    if (this.ctx.grid.isActionSheetExpanded) {
      return this.chevronRightIcon;
    }
    return this.expanded ? this.chevronUpIcon : this.chevronDownIcon;
  }
  constructor(ngZone, ctx, adaptiveGridService, element) {
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.adaptiveGridService = adaptiveGridService;
    this.element = element;
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.contentTemplate && (this.contentId = `k-${guid()}`);
    });
  }
  ngOnChanges(changes) {
    if (changes.expanded) {
      this.updateContentState();
    }
  }
  /**
   * @hidden
   */
  sortDescriptor(field) {
    return this.ctx.grid.sort.find((item) => item.field === field) || {
      field
    };
  }
  /**
   * @hidden
   */
  showSortNumbering(column) {
    const {
      showIndexes
    } = normalize$1(this.ctx.grid.sortable);
    return showIndexes && this.ctx.grid.sort && this.ctx.grid.sort.filter(({
      dir: dir2
    }) => isPresent4(dir2)).length > 1 && this.sortOrder(column.field) > 0;
  }
  /**
   * @hidden
   */
  sortOrder(field) {
    return this.ctx.grid.sort.filter(({
      dir: dir2
    }) => isPresent4(dir2)).findIndex((x) => x.field === field) + 1;
  }
  /**
   * @hidden
   */
  onClick(e) {
    this.itemClick.emit(e);
    if (this.contentTemplate) {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.expanded = !this.expanded;
        this.updateContentState();
      }
      if (this.expanded) {
        this.expand.emit();
      } else {
        this.collapse.emit();
      }
    }
  }
  updateContentState() {
    this.contentState = this.expanded ? "expanded" : "collapsed";
  }
  static ɵfac = function ColumnMenuItemComponent_Factory(t) {
    return new (t || _ColumnMenuItemComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuItemComponent,
    selectors: [["kendo-grid-columnmenu-item"]],
    contentQueries: function ColumnMenuItemComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnMenuItemContentTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
      }
    },
    inputs: {
      icon: "icon",
      svgIcon: "svgIcon",
      indicatorIcon: "indicatorIcon",
      text: "text",
      selected: "selected",
      disabled: "disabled",
      expanded: "expanded",
      focused: "focused",
      service: "service",
      column: "column"
    },
    outputs: {
      itemClick: "itemClick",
      expand: "expand",
      collapse: "collapse"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 2,
    consts: [["content", ""], ["class", "k-expander", 4, "ngIf", "ngIfElse"], [1, "k-expander"], [3, "ngTemplateOutlet"], ["role", "button", 1, "k-columnmenu-item", 3, "click", "keydown.enter"], [3, "name", "svgIcon", 4, "ngIf"], ["class", "k-columnmenu-indicators", 4, "ngIf"], ["class", "k-columnmenu-indicators", "name", "filter", 3, "svgIcon", 4, "ngIf"], ["class", "k-spacer", 4, "ngIf"], ["class", "k-expander-indicator", 4, "ngIf"], ["class", "k-columnmenu-item-content", 3, "overflow", 4, "ngIf"], [3, "name", "svgIcon"], [1, "k-columnmenu-indicators"], ["class", "k-sort-index", 4, "ngIf"], [1, "k-sort-index"], ["name", "filter", 1, "k-columnmenu-indicators", 3, "svgIcon"], [1, "k-spacer"], [1, "k-expander-indicator"], [1, "k-columnmenu-item-content"]],
    template: function ColumnMenuItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ColumnMenuItemComponent_div_0_Template, 2, 1, "div", 1)(1, ColumnMenuItemComponent_ng_template_1_Template, 8, 15, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const content_r1 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.contentTemplate)("ngIfElse", content_r1);
      }
    },
    dependencies: [IconWrapperComponent, NgIf, NgTemplateOutlet],
    encapsulation: 2,
    data: {
      animation: [trigger("state", [state("collapsed", style({
        display: "none"
      })), state("expanded", style({
        display: "block"
      })), transition("collapsed => expanded", [style({
        height: "0px",
        display: "block"
      }), animate("100ms ease-in", style({
        height: "*"
      }))]), transition("expanded => collapsed", [style({
        height: "*"
      }), animate("100ms ease-in", style({
        height: "0px"
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemComponent, [{
    type: Component,
    args: [{
      animations: [trigger("state", [state("collapsed", style({
        display: "none"
      })), state("expanded", style({
        display: "block"
      })), transition("collapsed => expanded", [style({
        height: "0px",
        display: "block"
      }), animate("100ms ease-in", style({
        height: "*"
      }))]), transition("expanded => collapsed", [style({
        height: "*"
      }), animate("100ms ease-in", style({
        height: "0px"
      }))])])],
      selector: "kendo-grid-columnmenu-item",
      template: `
        <div *ngIf="contentTemplate; else content" class="k-expander">
            <ng-container [ngTemplateOutlet]="content"></ng-container>
        </div>

        <ng-template #content>
            <div
                class="k-columnmenu-item"
                (click)="onClick($event)"
                (keydown.enter)="onClick($event)"
                [class.k-selected]="selected"
                [class.k-disabled]="disabled"
                [class.k-focus]="focused"
                role="button"
                [attr.aria-expanded]="expanded"
                [attr.aria-controls]="expanded ? contentId : undefined">
                <kendo-icon-wrapper
                    *ngIf="icon || svgIcon"
                    [name]="icon"
                    [svgIcon]="svgIcon"></kendo-icon-wrapper>
                {{ text }}
                <span *ngIf="(ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'sortToolbarTool' && sortDescriptor(column.field).dir)"
                        class="k-columnmenu-indicators">
                    <kendo-icon-wrapper
                        [name]="sortDescriptor(column.field).dir === 'asc' ? 'sort-asc-small' : 'sort-desc-small'"
                        [svgIcon]="sortDescriptor(column.field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon">
                    </kendo-icon-wrapper>
                    <span *ngIf="showSortNumbering(column)" class="k-sort-index">{{sortOrder(column.field)}}</span>
                </span>
                <kendo-icon-wrapper
                    *ngIf="(ctx.grid.isActionSheetExpanded && adaptiveGridService.viewType === 'filterToolbarTool' && hasFilters) || indicatorIcon"
                    class="k-columnmenu-indicators"
                    name="filter"
                    [svgIcon]="filterIcon">
                </kendo-icon-wrapper>
                <span *ngIf="contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool'" class="k-spacer"></span>
                <span *ngIf="contentTemplate && adaptiveGridService.viewType !== 'sortToolbarTool'" class="k-expander-indicator">
                    <kendo-icon-wrapper
                        [name]="expandedIcon"
                        [svgIcon]="expandedSvgIcon">
                    </kendo-icon-wrapper>
                </span>
            </div>
            <div *ngIf="contentTemplate" [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
                <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
                </ng-container>
            </div>
        </ng-template>
    `,
      standalone: true,
      imports: [IconWrapperComponent, NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: ContextService
    }, {
      type: AdaptiveGridService
    }, {
      type: ElementRef
    }];
  }, {
    itemClick: [{
      type: Output
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    indicatorIcon: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    focused: [{
      type: Input
    }],
    service: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [ColumnMenuItemContentTemplateDirective]
    }]
  });
})();
var ColumnMenuAutoSizeAllColumnsComponent = class _ColumnMenuAutoSizeAllColumnsComponent extends ColumnMenuItemBase {
  ctx;
  displayInlineFlexIcon = displayInlineFlexIcon;
  constructor(ctx) {
    super();
    this.ctx = ctx;
  }
  ngOnInit() {
    const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
    if (isVirtualColumns && isDevMode()) {
      console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
    }
  }
  /**
   * Resizes all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.
   */
  autoSizeAllColumns() {
    autoSizeColumn(this.ctx.grid, this.service);
  }
  static ɵfac = function ColumnMenuAutoSizeAllColumnsComponent_Factory(t) {
    return new (t || _ColumnMenuAutoSizeAllColumnsComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuAutoSizeAllColumnsComponent,
    selectors: [["kendo-grid-columnmenu-autosize-all-columns"]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 1,
    vars: 1,
    consts: [["icon", "display-inline-flex", 3, "text", "svgIcon", "itemClick", 4, "ngIf"], ["icon", "display-inline-flex", 3, "itemClick", "text", "svgIcon"]],
    template: function ColumnMenuAutoSizeAllColumnsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ColumnMenuAutoSizeAllColumnsComponent_kendo_grid_columnmenu_item_0_Template, 1, 2, "kendo-grid-columnmenu-item", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.ctx.grid.virtualColumns);
      }
    },
    dependencies: [NgIf, ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuAutoSizeAllColumnsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-autosize-all-columns",
      template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            [text]="ctx.localization.get('autosizeAllColumns')"
            icon="display-inline-flex"
            [svgIcon]="displayInlineFlexIcon"
            (itemClick)="autoSizeAllColumns()"
        ></kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [NgIf, ColumnMenuItemComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var ColumnMenuAutoSizeColumnComponent = class _ColumnMenuAutoSizeColumnComponent extends ColumnMenuItemBase {
  ctx;
  /**
   * The Grid column instance which will be resized through the auto size column option.
   */
  column;
  maxWidthIcon = maxWidthIcon;
  constructor(ctx) {
    super();
    this.ctx = ctx;
  }
  ngOnInit() {
    const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
    if (isVirtualColumns && isDevMode()) {
      console.warn(ColumnMenuErrorMessages.autoSizeColumn);
    }
  }
  /**
   * Resizes a specified column to the minimum possible width so that it fits the widest header or cell content without wrapping.
   */
  autoSizeColumn() {
    autoSizeColumn(this.ctx.grid, this.service, this.column);
  }
  static ɵfac = function ColumnMenuAutoSizeColumnComponent_Factory(t) {
    return new (t || _ColumnMenuAutoSizeColumnComponent)(ɵɵdirectiveInject(ContextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuAutoSizeColumnComponent,
    selectors: [["kendo-grid-columnmenu-autosize-column"]],
    inputs: {
      column: "column"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 1,
    vars: 1,
    consts: [["class", "k-grid-columnmenu-autosize-column", "icon", "max-width", 3, "text", "svgIcon", "itemClick", 4, "ngIf"], ["icon", "max-width", 1, "k-grid-columnmenu-autosize-column", 3, "itemClick", "text", "svgIcon"]],
    template: function ColumnMenuAutoSizeColumnComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ColumnMenuAutoSizeColumnComponent_kendo_grid_columnmenu_item_0_Template, 1, 2, "kendo-grid-columnmenu-item", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.ctx.grid.virtualColumns);
      }
    },
    dependencies: [NgIf, ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuAutoSizeColumnComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-autosize-column",
      template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            class="k-grid-columnmenu-autosize-column"
            [text]="ctx.localization.get('autosizeThisColumn')"
            icon="max-width"
            [svgIcon]="maxWidthIcon"
            (itemClick)="autoSizeColumn()"
        ></kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [NgIf, ColumnMenuItemComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }]
  });
})();
var ColumnMenuChooserComponent = class _ColumnMenuChooserComponent extends ColumnMenuItemBase {
  ctx;
  columnInfoService;
  changeDetector;
  hostElement;
  /**
   * Fires when the content is expanded.
   */
  expand = new EventEmitter();
  /**
   * Fires when the content is collapsed.
   */
  collapse = new EventEmitter();
  /**
   * Specifies if the content is expanded.
   * @default false
   */
  expanded = false;
  /**
   * @hidden
   */
  isLast = false;
  /**
   * @hidden
   */
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  columnsIcon = columnsIcon;
  constructor(ctx, columnInfoService, changeDetector, hostElement) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
  }
  /**
   * @hidden
   */
  onApply(changed) {
    this.close();
    if (changed.length) {
      this.changeDetector.markForCheck();
      this.columnInfoService.changeVisibility(changed);
    }
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector(".k-columnmenu-item");
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    this.expand.emit();
  }
  static ɵfac = function ColumnMenuChooserComponent_Factory(t) {
    return new (t || _ColumnMenuChooserComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuChooserComponent,
    selectors: [["kendo-grid-columnmenu-chooser"]],
    inputs: {
      expanded: "expanded",
      isLast: "isLast"
    },
    outputs: {
      expand: "expand",
      collapse: "collapse"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 3,
    consts: [["icon", "columns", 3, "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "apply", "applyText", "resetText", "ariaLabel", "columns", "autoSync", "allowHideAll", "actionsClass", "isLast", "isExpanded", "service"]],
    template: function ColumnMenuChooserComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("collapse", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
          return ctx.onCollapse();
        })("expand", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
          return ctx.onExpand();
        });
        ɵɵtemplate(1, ColumnMenuChooserComponent_ng_template_1_Template, 1, 10, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("columns"))("svgIcon", ctx.columnsIcon)("expanded", ctx.expanded);
      }
    },
    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuChooserComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-chooser",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnlist
                    [applyText]="ctx.localization.get('columnsApply')"
                    [resetText]="ctx.localization.get('columnsReset')"
                    [ariaLabel]="ctx.localization.get('columns')"
                    [columns]="columns"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [service]="service"
                    (apply)="onApply($event)">
                </kendo-grid-columnlist>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnListComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuStickComponent = class _ColumnMenuStickComponent extends ColumnMenuItemBase {
  ctx;
  columnInfoService;
  changeDetector;
  stickIcon = stickIcon;
  unstickIcon = unstickIcon;
  constructor(ctx, columnInfoService, changeDetector) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
  }
  get text() {
    return this.ctx.localization.get(this.sticky ? "unstick" : "stick");
  }
  get icon() {
    return this.sticky ? "unstick" : "stick";
  }
  get svgIcon() {
    return this.sticky ? this.unstickIcon : this.stickIcon;
  }
  get disabled() {
    return !this.sticky && this.columnInfoService.unlockedRootCount < 2;
  }
  /**
   * @hidden
   */
  toggleColumn() {
    this.toggleHierarchy(!this.sticky);
    this.close();
    this.changeDetector.markForCheck();
  }
  toggleHierarchy(sticky) {
    let root = this.service.column;
    while (root.parent) {
      root = root.parent;
    }
    const columns = [root];
    const allChanged = [];
    while (columns.length) {
      const column = columns.shift();
      column.sticky = sticky;
      allChanged.push(column);
      if (column.hasChildren) {
        columns.push(...column.childrenArray);
      }
    }
    this.columnInfoService.changeStuck(allChanged);
  }
  get sticky() {
    return this.service.column.sticky;
  }
  static ɵfac = function ColumnMenuStickComponent_Factory(t) {
    return new (t || _ColumnMenuStickComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuStickComponent,
    selectors: [["kendo-grid-columnmenu-stick"]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 1,
    vars: 4,
    consts: [[3, "itemClick", "text", "icon", "svgIcon", "disabled"]],
    template: function ColumnMenuStickComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("itemClick", function ColumnMenuStickComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
          return ctx.toggleColumn();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.text)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("disabled", ctx.disabled);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuStickComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-stick",
      template: `
        <kendo-grid-columnmenu-item
           [text]="text"
           [icon]="icon"
           [svgIcon]="svgIcon"
           (itemClick)="toggleColumn()"
           [disabled]="disabled">
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var ColumnMenuLockComponent = class _ColumnMenuLockComponent extends ColumnMenuItemBase {
  ctx;
  columnInfoService;
  changeDetector;
  constructor(ctx, columnInfoService, changeDetector) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
  }
  get text() {
    return this.ctx.localization.get(this.locked ? "unlock" : "lock");
  }
  get icon() {
    return this.locked ? "unlock" : "lock";
  }
  unlockIcon = unlockIcon;
  lockIcon = lockIcon;
  get svgIcon() {
    return this.locked ? this.unlockIcon : this.lockIcon;
  }
  get disabled() {
    return !this.locked && this.columnInfoService.unlockedRootCount < 2;
  }
  /**
   * @hidden
   */
  toggleColumn() {
    this.toggleHierarchy(!this.locked);
    this.close();
    this.changeDetector.markForCheck();
  }
  toggleHierarchy(locked) {
    let root = this.service.column;
    while (root.parent) {
      root = root.parent;
    }
    const columns = [root];
    const allChanged = [];
    while (columns.length) {
      const column = columns.shift();
      column.locked = locked;
      allChanged.push(column);
      if (column.hasChildren) {
        columns.push(...column.childrenArray);
      }
    }
    this.columnInfoService.changeLocked(allChanged);
  }
  get locked() {
    return this.service.column.locked;
  }
  static ɵfac = function ColumnMenuLockComponent_Factory(t) {
    return new (t || _ColumnMenuLockComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuLockComponent,
    selectors: [["kendo-grid-columnmenu-lock"]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 1,
    vars: 4,
    consts: [[3, "itemClick", "text", "icon", "svgIcon", "disabled"]],
    template: function ColumnMenuLockComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("itemClick", function ColumnMenuLockComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
          return ctx.toggleColumn();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.text)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("disabled", ctx.disabled);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuLockComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-lock",
      template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            [svgIcon]="svgIcon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var ColumnMenuPositionComponent = class _ColumnMenuPositionComponent extends ColumnMenuItemBase {
  ctx;
  hostElement;
  /**
   * Fires when the content is expanded.
   */
  expand = new EventEmitter();
  /**
   * Fires when the content is collapsed.
   */
  collapse = new EventEmitter();
  /**
   * Specifies if the content is expanded.
   * @default false
   */
  expanded = false;
  /**
   * Specifies if the lock column item is displayed.
   */
  showLock;
  /**
   * Specifies if the stick column item is displayed.
   */
  showStick;
  /**
   * @hidden
   */
  actionsClass = "k-actions";
  /**
   * @hidden
   */
  set isLast(value) {
    this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    this._isLast = value;
  }
  /**
   * @hidden
   */
  get isLast() {
    return this._isLast;
  }
  setColumnPositionIcon = setColumnPositionIcon;
  _isLast = false;
  constructor(ctx, hostElement) {
    super();
    this.ctx = ctx;
    this.hostElement = hostElement;
  }
  /**
   * @hidden
   */
  onTab(e, isLastItem) {
    if (this.isLast && isLastItem) {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (this.service) {
        this.service.menuTabbingService.firstFocusable.focus();
      }
    }
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    }
    this.expand.emit();
  }
  getLastFocusableItem() {
    const menuItems = this.hostElement.nativeElement.querySelectorAll(".k-columnmenu-item");
    const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;
    return menuItems[lastFocusableIndex];
  }
  static ɵfac = function ColumnMenuPositionComponent_Factory(t) {
    return new (t || _ColumnMenuPositionComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuPositionComponent,
    selectors: [["kendo-grid-columnmenu-position"]],
    inputs: {
      expanded: "expanded",
      showLock: "showLock",
      showStick: "showStick",
      isLast: "isLast"
    },
    outputs: {
      expand: "expand",
      collapse: "collapse"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 3,
    consts: [["icon", "set-column-position", 3, "keydown.tab", "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "service", "keydown.tab", 4, "ngIf"], [3, "keydown.tab", "service"]],
    template: function ColumnMenuPositionComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_keydown_tab_0_listener($event) {
          return ctx.onTab($event, !ctx.expanded);
        })("collapse", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
          return ctx.onCollapse();
        })("expand", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
          return ctx.onExpand();
        });
        ɵɵtemplate(1, ColumnMenuPositionComponent_ng_template_1_Template, 2, 2, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("setColumnPosition"))("svgIcon", ctx.setColumnPositionIcon)("expanded", ctx.expanded);
      }
    },
    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, NgIf, ColumnMenuLockComponent, ColumnMenuStickComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuPositionComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-position",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('setColumnPosition')"
            icon="set-column-position"
            [svgIcon]="setColumnPositionIcon"
            [expanded]="expanded"
            (keydown.tab)="onTab($event, !expanded)"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnmenu-lock
                    *ngIf="showLock"
                    (keydown.tab)="onTab($event, !showStick)"
                    [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick
                    *ngIf="showStick"
                    (keydown.tab)="onTab($event, true)"
                    [service]="service">
                </kendo-grid-columnmenu-stick>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, NgIf, ColumnMenuLockComponent, ColumnMenuStickComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ElementRef
    }];
  }, {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    showLock: [{
      type: Input
    }],
    showStick: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuFilterComponent = class _ColumnMenuFilterComponent extends ColumnMenuItemBase {
  ctx;
  hostElement;
  /**
   * Fires when the content is expanded.
   */
  expand = new EventEmitter();
  /**
   * Fires when the content is collapsed.
   */
  collapse = new EventEmitter();
  /**
   * Specifies if the content is expanded.
   * @default false
   */
  expanded = false;
  /**
   * @hidden
   */
  isLast = false;
  /**
   * @hidden
   */
  actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
  filterIcon = filterIcon;
  constructor(ctx, hostElement) {
    super();
    this.ctx = ctx;
    this.hostElement = hostElement;
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector(".k-columnmenu-item");
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    this.expand.emit();
  }
  static ɵfac = function ColumnMenuFilterComponent_Factory(t) {
    return new (t || _ColumnMenuFilterComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuFilterComponent,
    selectors: [["kendo-grid-columnmenu-filter"]],
    inputs: {
      expanded: "expanded",
      isLast: "isLast"
    },
    outputs: {
      expand: "expand",
      collapse: "collapse"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 3,
    consts: [["icon", "filter", 3, "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "keydown.shift.tab", "close", "column", "menuTabbingService", "filter", "actionsClass", "isLast", "isExpanded"]],
    template: function ColumnMenuFilterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("collapse", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
          return ctx.onCollapse();
        })("expand", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
          return ctx.onExpand();
        });
        ɵɵtemplate(1, ColumnMenuFilterComponent_ng_template_1_Template, 1, 6, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("filter"))("svgIcon", ctx.filterIcon)("expanded", ctx.expanded);
      }
    },
    dependencies: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-filter",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('filter')"
            icon="filter"
            [svgIcon]="filterIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, FilterMenuContainerComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ElementRef
    }];
  }, {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuItemDirective = class _ColumnMenuItemDirective {
  hostElement;
  renderer;
  ngZone;
  cdr;
  ctx;
  /**
   * The reference to the Grid column menu item. Required to include the item in the built-in keyboard navigation.
   */
  menuItemComponent;
  firstFocusableElement;
  lastFocusableElement;
  /**
   * @hidden
   */
  set isFirst(value) {
    if (value) {
      const focusableElement = this.columnMenuItems[0];
      this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;
      this.ngZone.runOutsideAngular(() => {
        const firstItemKeydownSub = this.renderer.listen(focusableElement, "keydown", this.onTab);
        this.subs.add(firstItemKeydownSub);
      });
    }
    this._isFirst = value;
  }
  /**
   * @hidden
   */
  get isFirst() {
    return this._isFirst;
  }
  /**
   * @hidden
   */
  set isLast(value) {
    if (!this.columnMenuItems) {
      return;
    }
    if (value) {
      const lastFocusableElement = this.getLastColumnMenuItem();
      this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;
      this.ngZone.runOutsideAngular(() => {
        const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, "keydown", this.onTab);
        this.subs.add(lastItemKeydownSub);
      });
      if (this.isExpandableItem()) {
        this.menuItemComponent.isLast = true;
        if (this.ctx.grid.isActionSheetExpanded) {
          this.cdr.detectChanges();
        }
      }
    }
    this._isLast = value;
  }
  /**
   * @hidden
   */
  get isLast() {
    return this._isLast;
  }
  _isFirst = false;
  _isLast = false;
  columnMenuItems;
  subs = new Subscription();
  constructor(hostElement, renderer, ngZone, cdr, ctx) {
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.ctx = ctx;
  }
  ngAfterViewInit() {
    this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll(".k-columnmenu-item");
    [].slice.apply(this.columnMenuItems).forEach((el) => this.renderer.setAttribute(el, "tabindex", "0"));
    if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {
      this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;
    }
    this.menuItemComponent.service?.columnMenuContainer?.templateMenuItems.push(this);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  onTab = (e) => {
    if (e.keyCode !== Keys.Tab) {
      return;
    }
    if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {
      e.preventDefault();
      this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();
    }
    if (this.isLast && !e.shiftKey) {
      const lastColumnMenuItem = this.getLastColumnMenuItem();
      const isExpanded = this.menuItemComponent.expanded;
      if (lastColumnMenuItem === e.target && !isExpanded) {
        e.preventDefault();
        this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();
      }
    }
  };
  getLastColumnMenuItem() {
    return this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1];
  }
  isExpandableItem() {
    return this.menuItemComponent instanceof ColumnMenuFilterComponent || this.menuItemComponent instanceof ColumnMenuChooserComponent || this.menuItemComponent instanceof ColumnMenuPositionComponent;
  }
  static ɵfac = function ColumnMenuItemDirective_Factory(t) {
    return new (t || _ColumnMenuItemDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnMenuItemDirective,
    selectors: [["", "kendoGridColumnMenuItem", ""]],
    inputs: {
      menuItemComponent: [InputFlags.None, "kendoGridColumnMenuItem", "menuItemComponent"]
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuItem]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }];
  }, {
    menuItemComponent: [{
      type: Input,
      args: ["kendoGridColumnMenuItem"]
    }]
  });
})();
var ColumnMenuContainerComponent = class _ColumnMenuContainerComponent {
  service;
  ngZone;
  columnMenuItems;
  templateMenuItems = [];
  constructor(service, ngZone) {
    this.service = service;
    this.ngZone = ngZone;
    service.columnMenuContainer = this;
  }
  ngAfterViewInit() {
    if (this.columnMenuItems.length) {
      this.columnMenuItems.first.isFirst = true;
      this.columnMenuItems.last.isLast = true;
    } else if (this.templateMenuItems.length) {
      this.templateMenuItems[0].isFirst = true;
      this.templateMenuItems[this.templateMenuItems.length - 1].isLast = true;
    } else {
      return;
    }
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.service.menuTabbingService.firstFocusable?.focus());
  }
  static ɵfac = function ColumnMenuContainerComponent_Factory(t) {
    return new (t || _ColumnMenuContainerComponent)(ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuContainerComponent,
    selectors: [["kendo-grid-columnmenu-container"]],
    contentQueries: function ColumnMenuContainerComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnMenuItemDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuItems = _t);
      }
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    ngContentSelectors: _c112,
    decls: 1,
    vars: 0,
    template: function ColumnMenuContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuContainerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-container",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnMenuService
    }, {
      type: NgZone,
      decorators: [{
        type: Inject,
        args: [NgZone]
      }]
    }];
  }, {
    columnMenuItems: [{
      type: ContentChildren,
      args: [ColumnMenuItemDirective, {
        descendants: true
      }]
    }]
  });
})();
var SortService = class {
  changes = new Subject();
  sort(value) {
    this.changes.next(value);
  }
};
var ColumnMenuSortComponent = class _ColumnMenuSortComponent extends ColumnMenuItemBase {
  ctx;
  sortService;
  renderer;
  sortAscSmallIcon = sortAscSmallIcon;
  sortDescSmallIcon = sortDescSmallIcon;
  constructor(ctx, sortService, renderer) {
    super();
    this.ctx = ctx;
    this.sortService = sortService;
    this.renderer = renderer;
  }
  get sortedAsc() {
    const descriptor = this.descriptor;
    return descriptor && (!descriptor.dir || descriptor.dir === "asc");
  }
  get sortedDesc() {
    const descriptor = this.descriptor;
    return descriptor && descriptor.dir === "desc";
  }
  /**
   * @hidden
   */
  toggleSort(dir2) {
    const field = this.service.column.field;
    const {
      mode,
      allowUnsort
    } = normalize$1(this.service.sortable);
    const descriptor = this.descriptor;
    const sort = mode === "multiple" ? this.service.sort.filter((s) => s.field !== field) : [];
    if (descriptor && descriptor.dir === dir2) {
      if (!allowUnsort) {
        return;
      }
    } else {
      sort.push({
        field,
        dir: dir2
      });
    }
    this.sortService.sort(sort);
    this.close();
  }
  get descriptor() {
    return [].concat(this.service.sort || []).find((s) => s.field === this.service.column.field);
  }
  static ɵfac = function ColumnMenuSortComponent_Factory(t) {
    return new (t || _ColumnMenuSortComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuSortComponent,
    selectors: [["kendo-grid-columnmenu-sort"]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 2,
    vars: 6,
    consts: [["icon", "sort-asc-small", 3, "itemClick", "text", "svgIcon", "selected"], ["icon", "sort-desc-small", 3, "itemClick", "text", "svgIcon", "selected"]],
    template: function ColumnMenuSortComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
        ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
          return ctx.toggleSort("asc");
        });
        ɵɵelementEnd();
        ɵɵelementStart(1, "kendo-grid-columnmenu-item", 1);
        ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_1_listener() {
          return ctx.toggleSort("desc");
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("text", ctx.ctx.localization.get("sortAscending"))("svgIcon", ctx.sortAscSmallIcon)("selected", ctx.sortedAsc);
        ɵɵadvance();
        ɵɵproperty("text", ctx.ctx.localization.get("sortDescending"))("svgIcon", ctx.sortDescSmallIcon)("selected", ctx.sortedDesc);
      }
    },
    dependencies: [ColumnMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuSortComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-sort",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortAscending')"
            icon="sort-asc-small"
            [svgIcon]="sortAscSmallIcon"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortDescending')"
            icon="sort-desc-small"
            [svgIcon]="sortDescSmallIcon"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `,
      standalone: true,
      imports: [ColumnMenuItemComponent]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: SortService
    }, {
      type: Renderer2
    }];
  }, null);
})();
var POPUP_CLASSES = "k-grid-columnmenu-popup k-column-menu";
var id = 0;
var getId = (gridId) => `${gridId}-column-menu-${id++}`;
var ColumnMenuComponent = class _ColumnMenuComponent {
  navigationService;
  popupService;
  service;
  ctx;
  renderer;
  cdr;
  columnInfoService;
  idService;
  adaptiveGridService;
  /**
   * @hidden
   */
  standalone = true;
  /**
   * The Grid column instance to control with the menu.
   */
  column;
  /**
   * The settings for the Column Menu.
   */
  settings = {};
  /**
   * The descriptors by which the data will be sorted.
   * Typically bound to the same value as [GridComponent.sort]({% slug api_grid_gridcomponent %}#toc-sort).
   */
  sort;
  /**
   * The descriptor by which the data will be filtered.
   * Typically bound to the same value as [GridComponent.filter]({% slug api_grid_gridcomponent %}#toc-filter).
   */
  filter;
  /**
   * @hidden
   */
  sortable = true;
  /**
   * @hidden
   */
  columnMenuTemplate;
  /**
   * @hidden
   */
  tabIndex = "-1";
  anchor;
  template;
  defaultTemplate;
  tabbedInterfaceTemplate;
  tabStrip;
  /**
   * @hidden
   */
  columnsIcon = columnsIcon;
  /**
   * @hidden
   */
  actionsClass = "k-actions";
  /**
   * @hidden
   */
  slidersIcon = slidersIcon;
  /**
   * @hidden
   */
  filterIcon = filterIcon;
  /**
   * @hidden
   */
  expandedFilter = false;
  /**
   * @hidden
   */
  expandedColumns = false;
  /**
   * @hidden
   */
  expandedPosition = false;
  /**
   * @hidden
   */
  get showGeneralTab() {
    return this.hasSort || this.hasLock || this.hasStick || this.hasPosition || this.hasAutoSizeColumn || this.hasAutoSizeAllColumns;
  }
  moreVerticalIcon = moreVerticalIcon;
  popupRef;
  closeSubscription;
  popupSubs;
  constructor(navigationService, popupService, service, ctx, renderer, cdr, columnInfoService, idService, adaptiveGridService) {
    this.navigationService = navigationService;
    this.popupService = popupService;
    this.service = service;
    this.ctx = ctx;
    this.renderer = renderer;
    this.cdr = cdr;
    this.columnInfoService = columnInfoService;
    this.idService = idService;
    this.adaptiveGridService = adaptiveGridService;
    this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this, true));
  }
  /**
   * @hidden
   */
  get isActive() {
    return this.hasFilter && filtersByField(this.filter, this.column.field).length > 0 || !this.sortable && this.hasSort && this.sort.find((descriptor) => descriptor.field === this.column.field);
  }
  /**
   * @hidden
   */
  get hasFilter() {
    return hasFilter(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  /**
   * @hidden
   */
  get hasSort() {
    return hasSort(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasColumnChooser() {
    return hasColumnChooser(this.settings);
  }
  /**
   * @hidden
   */
  onApply(changed) {
    this.close(true);
    if (changed.length) {
      this.cdr.markForCheck();
      this.columnInfoService.changeVisibility(changed);
    }
  }
  /**
   * @hidden
   */
  get hasAutoSizeColumn() {
    return hasAutoSizeColumn(this.settings);
  }
  /**
   * @hidden
   */
  get hasAutoSizeAllColumns() {
    return hasAutoSizeAllColumns(this.settings);
  }
  /**
   * @hidden
   */
  get hasLock() {
    return hasLock(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasStick() {
    return hasStick(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasPosition() {
    return hasPosition(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  ngAfterViewInit() {
    if (this.ctx.grid.virtualColumns && isDevMode()) {
      if (this.settings.autoSizeAllColumns) {
        this.settings.autoSizeAllColumns = false;
        console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
      }
      if (this.settings.autoSizeColumn) {
        this.settings.autoSizeColumn = false;
        console.warn(ColumnMenuErrorMessages.autoSizeColumn);
      }
    }
    this.service.menuTabbingService.isTabbedInterface = this.settings.view === "tabbed" ? true : false;
  }
  ngOnChanges() {
    this.service.column = this.column;
    this.service.sort = this.sort;
    this.service.filter = this.filter;
    this.service.sortable = this.sortable;
  }
  ngOnDestroy() {
    this.close();
    this.closeSubscription.unsubscribe();
    this.popupSubs?.unsubscribe();
    this.closeSubscription = this.popupSubs = null;
  }
  /**
   * @hidden
   */
  toggle(e, anchor2, template) {
    if (e) {
      e.preventDefault();
      e instanceof KeyboardEvent && e.stopImmediatePropagation();
    }
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "columnMenu";
        this.adaptiveGridService.columns = this.columns;
        this.adaptiveGridService.columnMenuService = this.service;
        this.adaptiveGridService.column = this.column;
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
      }
    } else {
      this.expandedFilter = this.getExpandedState(this.settings.filter);
      this.expandedColumns = this.getExpandedState(this.settings.columnChooser);
      this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);
      this.popupRef = this.popupService.open(anchor2, template, this.popupRef, POPUP_CLASSES);
      const ariaRoot = this.isNavigable ? anchor2.closest(".k-table-th") : anchor2;
      if (this.popupRef) {
        this.popupSubs?.unsubscribe();
        this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
          this.popupSubs?.unsubscribe();
          this.popupSubs = null;
          this.close(true);
          this.updateAria(ariaRoot);
        });
        this.popupSubs.add(() => this.popupRef.popup.instance.close.subscribe(() => {
          this.popupSubs?.unsubscribe();
          this.popupSubs = this.popupRef = null;
          this.updateAria(ariaRoot);
        }));
        const popupAriaElement = this.popupRef.popupElement.querySelector(".k-grid-columnmenu-popup");
        if (popupAriaElement) {
          const popupId = getId(this.idService?.gridId());
          this.renderer.setAttribute(popupAriaElement, "id", popupId);
          this.renderer.setAttribute(popupAriaElement, "role", "dialog");
          this.renderer.setAttribute(popupAriaElement, "aria-label", this.columnMenuTitle);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-controls", popupId);
          ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "true");
        }
        if (this.settings.view === "tabbed") {
          this.renderer.addClass(popupAriaElement, "k-column-menu-tabbed");
          this.renderer.addClass(popupAriaElement, "k-column-menu");
          this.cdr.detectChanges();
          this.tabStrip?.selectTab(0);
        }
      } else {
        this.focusRoot();
      }
    }
  }
  /**
   * @hidden
   */
  close(triggerFocus = false) {
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      this.ctx.grid.adaptiveRenderer.actionSheet.toggle(false);
    } else {
      this.popupService.destroy();
      this.popupRef = null;
      this.cdr.markForCheck();
    }
    if (!triggerFocus) {
      return;
    }
    this.focusRoot();
  }
  /**
   * @hidden
   */
  get columnMenuTitle() {
    const localizationMsg = this.ctx.localization.get("columnMenu") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  getExpandedState(menuItemSettings) {
    return typeof menuItemSettings === "object" ? menuItemSettings.expanded : false;
  }
  updateAria(ariaRoot) {
    ariaRoot && this.renderer.removeAttribute(ariaRoot, "aria-controls");
    ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "false");
  }
  focusRoot() {
    this.isNavigable ? this.navigationService.focusCell(0, this.column.leafIndex) : this.anchor.nativeElement.focus();
  }
  static ɵfac = function ColumnMenuComponent_Factory(t) {
    return new (t || _ColumnMenuComponent)(ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(IdService, 8), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColumnMenuComponent,
    selectors: [["kendo-grid-column-menu"]],
    viewQuery: function ColumnMenuComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c142, 7);
        ɵɵviewQuery(_c152, 7, TemplateRef);
        ɵɵviewQuery(_c53, 7, TemplateRef);
        ɵɵviewQuery(_c212, 7, TemplateRef);
        ɵɵviewQuery(TabStripComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabbedInterfaceTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabStrip = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function ColumnMenuComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-grid-column-menu-standalone", ctx.standalone);
      }
    },
    inputs: {
      standalone: "standalone",
      column: "column",
      settings: "settings",
      sort: "sort",
      filter: "filter",
      sortable: "sortable",
      columnMenuTemplate: "columnMenuTemplate",
      tabIndex: "tabIndex"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([ColumnMenuService, MenuTabbingService]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 9,
    vars: 8,
    consts: [["anchor", ""], ["template", ""], ["defaultTemplate", ""], ["tabbedInterfaceTemplate", ""], ["sortItem", ""], ["lockItem", ""], ["stickItem", ""], ["positionItem", ""], ["chooserItem", ""], ["autoSizeColumnItem", ""], ["autoSizeAllColumnsItem", ""], ["filterItem", ""], ["tabstrip", ""], ["href", "#", 1, "k-grid-header-menu", "k-grid-column-menu", 3, "click", "keydown.enter", "ngClass", "tabindex"], ["name", "more-vertical", 3, "svgIcon"], [3, "keydown.escape", "keydown.enter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "kendoGridColumnMenuItem", "service", 4, "ngIf"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded", 4, "ngIf"], ["class", "k-separator", 3, "borderColor", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service", "expanded", 4, "ngIf"], [3, "service", "kendoGridColumnMenuItem", "column", 4, "ngIf"], [3, "service", "kendoGridColumnMenuItem", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded"], [1, "k-separator"], [3, "kendoGridColumnMenuItem", "service", "expanded"], [3, "service", "kendoGridColumnMenuItem", "column"], [3, "service", "kendoGridColumnMenuItem"], [3, "keydown.escape"], [4, "ngIf"], ["kendoTabTitle", ""], ["kendoTabContent", ""], ["name", "filter", 3, "svgIcon"], [3, "keydown.shift.tab", "close", "column", "menuTabbingService", "filter", "actionsClass"], ["name", "sliders", 3, "svgIcon"], ["name", "columns", 3, "svgIcon"], [3, "apply", "applyText", "resetText", "columns", "autoSync", "allowHideAll", "actionsClass", "service"]],
    template: function ColumnMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "a", 13, 0);
        ɵɵlistener("click", function ColumnMenuComponent_Template_a_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          const anchor_r2 = ɵɵreference(1);
          const template_r3 = ɵɵreference(4);
          return ɵɵresetView(ctx.toggle($event, anchor_r2, template_r3));
        })("keydown.enter", function ColumnMenuComponent_Template_a_keydown_enter_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.stopImmediatePropagation());
        });
        ɵɵelement(2, "kendo-icon-wrapper", 14);
        ɵɵelementEnd();
        ɵɵtemplate(3, ColumnMenuComponent_ng_template_3_Template, 2, 5, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, ColumnMenuComponent_ng_template_5_Template, 11, 10, "ng-template", null, 2, ɵɵtemplateRefExtractor)(7, ColumnMenuComponent_ng_template_7_Template, 5, 3, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c223, ctx.isActive))("tabindex", ctx.tabIndex);
        ɵɵattribute("title", ctx.columnMenuTitle)("aria-expanded", ctx.isNavigable ? void 0 : false)("aria-haspopup", ctx.isNavigable ? void 0 : "dialog");
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.moreVerticalIcon);
      }
    },
    dependencies: [NgClass, IconWrapperComponent, ColumnMenuContainerComponent, NgTemplateOutlet, NgIf, ColumnMenuSortComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuFilterComponent, TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective, FilterMenuContainerComponent, ColumnListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuComponent, [{
    type: Component,
    args: [{
      providers: [ColumnMenuService, MenuTabbingService],
      selector: "kendo-grid-column-menu",
      template: `
        <a #anchor
            class="k-grid-header-menu k-grid-column-menu"
            [ngClass]="{ 'k-active': isActive }"
            (click)="toggle($event, anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [tabindex]="tabIndex"
            [attr.title]="columnMenuTitle"
            [attr.aria-expanded]="isNavigable ? undefined : false"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'">
            <kendo-icon-wrapper
                name="more-vertical"
                [svgIcon]="moreVerticalIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <ng-container
                    [ngTemplateOutlet]="column.columnMenuTemplateRef || columnMenuTemplate || (settings.view === 'tabbed' ? tabbedInterfaceTemplate : defaultTemplate)"
                    [ngTemplateOutletContext]="{ service: service, column: column }">
                </ng-container>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #defaultTemplate>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                </kendo-grid-columnmenu-sort>
                <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                </kendo-grid-columnmenu-stick>
                <kendo-grid-columnmenu-position
                    #positionItem
                    *ngIf="hasPosition"
                    [showLock]="hasLock"
                    [showStick]="hasStick"
                    [kendoGridColumnMenuItem]="positionItem"
                    [service]="service"
                    [expanded]="expandedPosition"
                >
                </kendo-grid-columnmenu-position>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-chooser
                    #chooserItem
                    *ngIf="hasColumnChooser"
                    [kendoGridColumnMenuItem]="chooserItem"
                    [service]="service"
                    [expanded]="expandedColumns">
                </kendo-grid-columnmenu-chooser>
                <kendo-grid-columnmenu-autosize-column
                    #autoSizeColumnItem
                    *ngIf="hasAutoSizeColumn"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeColumnItem"
                    [column]="column"
                >
                </kendo-grid-columnmenu-autosize-column>

                <kendo-grid-columnmenu-autosize-all-columns
                    #autoSizeAllColumnsItem
                    *ngIf="hasAutoSizeAllColumns"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                >
                </kendo-grid-columnmenu-autosize-all-columns>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-filter
                    #filterItem
                    *ngIf="hasFilter"
                    [kendoGridColumnMenuItem]="filterItem"
                    [service]="service"
                    [expanded]="expandedFilter">
                </kendo-grid-columnmenu-filter>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #tabbedInterfaceTemplate>
            <kendo-tabstrip #tabstrip
                (keydown.escape)="close(true)">
                <kendo-tabstrip-tab *ngIf="hasFilter">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuFilterTabTitle')"
                            name="filter"
                            [svgIcon]="filterIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-filter-menu-container
                            [column]="service.column"
                            [menuTabbingService]="service.menuTabbingService"
                            [filter]="service.filter"
                            [actionsClass]="actionsClass"
                            (keydown.shift.tab)="$event.stopImmediatePropagation()"
                            (close)="close()">
                        </kendo-grid-filter-menu-container>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="showGeneralTab">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuGeneralTabTitle')"
                            name="sliders"
                            [svgIcon]="slidersIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                        </kendo-grid-columnmenu-sort>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasSort && (hasLock || hasStick || hasPosition || hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                        </kendo-grid-columnmenu-lock>
                        <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                        </kendo-grid-columnmenu-stick>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="(hasLock || hasStick) && !hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-position
                            #positionItem
                            *ngIf="hasPosition"
                            [showLock]="hasLock"
                            [showStick]="hasStick"
                            [kendoGridColumnMenuItem]="positionItem"
                            [service]="service"
                            [expanded]="expandedPosition">
                        </kendo-grid-columnmenu-position>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-autosize-column
                            #autoSizeColumnItem
                            *ngIf="hasAutoSizeColumn"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeColumnItem"
                            [column]="column"
                        >
                        </kendo-grid-columnmenu-autosize-column>
                        <kendo-grid-columnmenu-autosize-all-columns
                            #autoSizeAllColumnsItem
                            *ngIf="hasAutoSizeAllColumns"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                        >
                        </kendo-grid-columnmenu-autosize-all-columns>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="hasColumnChooser">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuColumnsTabTitle')"
                            name="columns"
                            [svgIcon]="columnsIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnlist
                            [applyText]="ctx.localization.get('columnsApply')"
                            [resetText]="ctx.localization.get('columnsReset')"
                            [columns]="columns"
                            [autoSync]="false"
                            [allowHideAll]="false"
                            [actionsClass]="actionsClass"
                            [service]="service"
                            (apply)="onApply($event)">
                        </kendo-grid-columnlist>
                    </ng-template>
                </kendo-tabstrip-tab>
            </kendo-tabstrip>
        </ng-template>

    `,
      standalone: true,
      imports: [NgClass, IconWrapperComponent, ColumnMenuContainerComponent, NgTemplateOutlet, NgIf, ColumnMenuSortComponent, ColumnMenuItemDirective, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuFilterComponent, TabStripComponent, TabStripTabComponent, TabTitleDirective, TabContentDirective, FilterMenuContainerComponent, ColumnListComponent]
    }]
  }], function() {
    return [{
      type: NavigationService2
    }, {
      type: SinglePopupService
    }, {
      type: ColumnMenuService
    }, {
      type: ContextService
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: ColumnInfoService
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: AdaptiveGridService
    }];
  }, {
    standalone: [{
      type: HostBinding,
      args: ["class.k-grid-column-menu-standalone"]
    }, {
      type: Input
    }],
    column: [{
      type: Input
    }],
    settings: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    columnMenuTemplate: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        static: true
      }]
    }],
    template: [{
      type: ViewChild,
      args: ["template", {
        static: true,
        read: TemplateRef
      }]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabbedInterfaceTemplate: [{
      type: ViewChild,
      args: ["tabbedInterfaceTemplate", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabStrip: [{
      type: ViewChild,
      args: [TabStripComponent]
    }]
  });
})();
var ExcelService = class _ExcelService {
  saveToExcel = new EventEmitter();
  exportClick = new EventEmitter();
  save(component) {
    if (this.saveToExcel.observers.length === 0) {
      if (isDevMode()) {
        throw new Error(GridConfigurationErrorMessages.requiredModule("excel", "ExcelModule", "<kendo-grid-excel>"));
      }
    } else {
      this.saveToExcel.emit(component);
    }
  }
  static ɵfac = function ExcelService_Factory(t) {
    return new (t || _ExcelService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ExcelService,
    factory: _ExcelService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelService, [{
    type: Injectable
  }], null, null);
})();
var ExcelExportEvent = class extends PreventableEvent4 {
  workbook;
  constructor(workbook) {
    super();
    this.workbook = workbook;
  }
};
var fetchComponentData = (component) => {
  return {
    data: component.view.map((item) => item),
    group: component.group
  };
};
var toExcelColumn = (column) => {
  return {
    title: column.title,
    field: column.field,
    locked: Boolean(column.locked),
    width: column.width,
    level: column.level,
    hidden: !column.isVisible,
    groupHeaderTemplate: column.groupHeaderTemplate,
    groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,
    groupFooterTemplate: column.groupFooterTemplate,
    footerTemplate: column.footerTemplate
  };
};
var toExcelColumns = (columns) => {
  const result = [];
  sortColumns(columns).forEach((column) => {
    if (column.isSpanColumn) {
      result.push(...toExcelColumns(column.childrenArray));
    } else {
      const excelColumn = toExcelColumn(column);
      if (column.isColumnGroup) {
        excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));
      }
      result.push(excelColumn);
    }
  });
  return result;
};
var componentColumns = (component) => {
  const columns = toExcelColumns(component.columns.toArray());
  return orderBy(columns, [{
    field: "locked",
    dir: "desc"
  }]);
};
var ExcelComponent = class _ExcelComponent {
  ctx;
  zone;
  /**
   * Specifies the file name of the exported Excel file.
   * @default "Export.xlsx"
   */
  fileName = "Export.xlsx";
  /**
   * Enables or disables column filtering in the Excel file. This behavior is different from the filtering feature of the Grid.
   */
  filterable;
  /**
   * The author of the workbook.
   */
  creator;
  /**
   * The date on which the workbook was created. Defaults to `new Date()`.
   */
  date;
  /**
   * If set to `true`, the content is forwarded to [proxyURL](#toc-proxyurl) even if the browser supports the saving of files locally.
   */
  forceProxy;
  /**
   * The URL of the server-side proxy which streams the file to the end user.
   *
   * Using a proxy is required if the browser is not capable of saving files locally.
   *
   * Optionally, set up a proxy to reduce memory usage. This avoids copying the file contents in memory,
   * but transmits it over the network instead. For this use case, set [forceProxy](#toc-forceproxy) to `true`
   * to skip client-side saving even in browser that support it.
   *
   * In the request body, the proxy receives a POST request with the specific parameters. [See example](slug:server_proxy#toc-implementations).
   * The proxy returns the decoded file with the `"Content-Disposition"` header set to `attachment; filename="<fileName.xslx>"`.
   *
   * For details on the server-side proxy usage and implementation, see the [File Saver]({% slug overview_filesaver %}) documentation.
   */
  proxyURL;
  /**
   * The function that is used to get the exported data options. By default, uses the current data and group of the Grid.
   * To export data that is different from the current Grid data, provide a custom function.
   */
  fetchData;
  /**
   * If the data is grouped, the options of the cells that are inserted before the data,
   * group, and footer cells to indicate the group hierarchy.
   */
  paddingCellOptions;
  /**
   * If the data is grouped, the options of the cells that are inserted before the
   * header cells to align the headers and the column values.
   */
  headerPaddingCellOptions;
  /**
   * Specifies if the groups in the Excel file are collapsible.
   */
  collapsible;
  /**
   * @hidden
   */
  columns = new QueryList();
  saveSubscription;
  dataSubscription;
  constructor(excelService, ctx, zone) {
    this.ctx = ctx;
    this.zone = zone;
    this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));
  }
  ngOnDestroy() {
    this.saveSubscription.unsubscribe();
    if (this.dataSubscription) {
      this.dataSubscription.unsubscribe();
    }
  }
  save(component) {
    const data = (this.fetchData || fetchComponentData)(component);
    const exportData = (result) => {
      delete this.dataSubscription;
      this.exportData(component, result);
    };
    if (data instanceof Promise) {
      data.then(exportData);
    } else if (data instanceof Observable) {
      this.dataSubscription = data.pipe(take(1)).subscribe(exportData);
    } else {
      exportData(data);
    }
  }
  exportData(component, result) {
    const options = workbookOptions({
      columns: this.columns.length ? this.columns : componentColumns(component),
      data: result.data,
      group: result.group,
      filterable: this.filterable,
      creator: this.creator,
      date: this.date,
      paddingCellOptions: this.paddingCellOptions,
      headerPaddingCellOptions: this.headerPaddingCellOptions,
      rtl: this.ctx.localization.rtl,
      collapsible: this.collapsible
    });
    const args = new ExcelExportEvent(options);
    component.excelExport.emit(args);
    if (!args.isDefaultPrevented()) {
      this.zone.runOutsideAngular(() => this.saveFile(options));
    }
  }
  saveFile(options) {
    toDataURL(options).then((dataURL) => {
      saveAs(dataURL, this.fileName, {
        forceProxy: this.forceProxy,
        proxyURL: this.proxyURL
      });
    });
  }
  static ɵfac = function ExcelComponent_Factory(t) {
    return new (t || _ExcelComponent)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ExcelComponent,
    selectors: [["kendo-grid-excel"]],
    contentQueries: function ExcelComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnBase, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      }
    },
    inputs: {
      fileName: "fileName",
      filterable: "filterable",
      creator: "creator",
      date: "date",
      forceProxy: "forceProxy",
      proxyURL: "proxyURL",
      fetchData: "fetchData",
      paddingCellOptions: "paddingCellOptions",
      headerPaddingCellOptions: "headerPaddingCellOptions",
      collapsible: "collapsible"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ExcelComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-excel",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ExcelService
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    fileName: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    fetchData: [{
      type: Input
    }],
    paddingCellOptions: [{
      type: Input
    }],
    headerPaddingCellOptions: [{
      type: Input
    }],
    collapsible: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase, {
        descendants: true
      }]
    }]
  });
})();
var ExcelCommandDirective = class _ExcelCommandDirective extends ButtonComponent {
  excelService;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.excelService.exportClick.emit();
  }
  /**
   * @hidden
   */
  get excelClass() {
    return true;
  }
  constructor(excelService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.excelService = excelService;
    this.ngZone = ngZone;
  }
  static ɵfac = function ExcelCommandDirective_Factory(t) {
    return new (t || _ExcelCommandDirective)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ExcelCommandDirective,
    selectors: [["", "kendoGridExcelCommand", ""]],
    hostVars: 2,
    hostBindings: function ExcelCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function ExcelCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-grid-excel", ctx.excelClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    attrs: _c242,
    ngContentSelectors: _c112,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function ExcelCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, ExcelCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, ExcelCommandDirective_span_1_Template, 2, 1, "span", 1)(2, ExcelCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridExcelCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ExcelService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    excelClass: [{
      type: HostBinding,
      args: ["class.k-grid-excel"]
    }]
  });
})();
var SuspendService = class _SuspendService {
  scroll = false;
  static ɵfac = function SuspendService_Factory(t) {
    return new (t || _SuspendService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SuspendService,
    factory: _SuspendService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SuspendService, [{
    type: Injectable
  }], null, null);
})();
var PDFService = class _PDFService {
  savePDF = new EventEmitter();
  drawPDF = new EventEmitter();
  exportClick = new EventEmitter();
  dataChanged = new EventEmitter();
  exporting;
  save(component) {
    this.emitEvent(this.savePDF, component);
  }
  draw(component, promise) {
    this.emitEvent(this.drawPDF, {
      component,
      promise
    });
  }
  /**
   * @hidden
   */
  emitEvent(emitter, args) {
    if (emitter.observers.length === 0) {
      if (isDevMode()) {
        throw new Error(GridConfigurationErrorMessages.requiredModule("PDF", "PDFModule", "<kendo-grid-pdf>"));
      }
    } else {
      emitter.emit(args);
    }
  }
  static ɵfac = function PDFService_Factory(t) {
    return new (t || _PDFService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PDFService,
    factory: _PDFService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFService, [{
    type: Injectable
  }], null, null);
})();
var PDFMarginComponent = class _PDFMarginComponent extends PDFExportMarginComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPDFMarginComponent_BaseFactory;
    return function PDFMarginComponent_Factory(t) {
      return (ɵPDFMarginComponent_BaseFactory || (ɵPDFMarginComponent_BaseFactory = ɵɵgetInheritedFactory(_PDFMarginComponent)))(t || _PDFMarginComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFMarginComponent,
    selectors: [["kendo-grid-pdf-margin"]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function PDFMarginComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFMarginComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-pdf-margin",
      template: "",
      standalone: true
    }]
  }], null, null);
})();
var PDFTemplateDirective = class _PDFTemplateDirective extends PDFExportTemplateDirective {
  constructor(templateRef) {
    super(templateRef);
  }
  static ɵfac = function PDFTemplateDirective_Factory(t) {
    return new (t || _PDFTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PDFTemplateDirective,
    selectors: [["", "kendoGridPDFTemplate", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridPDFTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var HEADER_CLASS = "k-grid-header";
var FOOTER_CLASS = "k-grid-footer";
var GRID_LIST = "KENDO-GRID-LIST";
var TABLE = "TABLE";
var matchesList = matchesNodeName(GRID_LIST);
var matchesTable = matchesNodeName(TABLE);
var suffix = (locked) => locked ? "locked" : "wrap";
var GridQuery = class {
  element;
  headerWrap;
  list;
  footerWrap;
  constructor(element) {
    this.element = element;
    this.list = findElement(element, matchesList);
  }
  content(locked) {
    return findElement(this.list, matchesClasses(`k-grid-content${locked ? "-locked" : ""}`));
  }
  header(locked) {
    this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));
    return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));
  }
  footer(locked) {
    this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));
    return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));
  }
  table() {
    return findElement(this.element, matchesTable);
  }
};
var FIRST_CLASS = "k-first";
var INPUTS = ["input", "select", "textarea", "option"];
var cloneNode = (node) => {
  const clone = node.cloneNode(false);
  if (node._kendoExportVisual) {
    clone._kendoExportVisual = node._kendoExportVisual;
  }
  if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {
    clone.removeAttribute("id");
    clone.removeAttribute("name");
    clone.value = node.value;
    clone.checked = node.checked;
    clone.selected = node.selected;
  }
  let child = node.firstChild;
  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }
  return clone;
};
var appendNodes = (element, nodes) => {
  const length2 = nodes.length;
  for (let idx2 = 0; idx2 < length2; idx2++) {
    element.appendChild(cloneNode(nodes[idx2]));
  }
};
var wrapTable = (table2, size) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const wrapper = document.createElement("div");
  const classes = ["k-grid"];
  if (size && size !== "none") {
    classes.push(`k-grid-${size === "medium" ? "md" : "sm"}`);
  }
  wrapper.classList.add(...classes);
  wrapper.appendChild(table2);
  return wrapper;
};
var createTableElement = (sources) => {
  const sourceCount = sources.length;
  const element = cloneNode(sources[0]);
  const rowsCount = element.rows.length;
  if (sourceCount > 1) {
    for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
      for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {
        appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);
      }
    }
  }
  return element;
};
var setFirstCellClass = (header, headers) => {
  if (headers.length > 1 && header.rows.length > 1) {
    for (let idx2 = 1; idx2 < header.rows.length; idx2++) {
      const firstCellIndex = headers[0].rows[idx2].cells.length;
      const cell2 = header.rows[idx2].cells[firstCellIndex];
      if (String(cell2.className).indexOf(FIRST_CLASS) === -1) {
        cell2.className += ` ${FIRST_CLASS}`;
      }
    }
  }
};
var createTable = (colGroups, headers, bodies, footers, size) => {
  const table2 = document.createElement("table");
  const classes = ["k-table"];
  if (size && size !== "none") {
    classes.push(`k-table-${size === "medium" ? "md" : "sm"}`);
  }
  table2.classList.add(...classes);
  const colGroup = colGroups[0].cloneNode(true);
  for (let idx2 = 1; idx2 < colGroups.length; idx2++) {
    appendNodes(colGroup, colGroups[idx2].querySelectorAll("col"));
  }
  const header = createTableElement(headers);
  const body = createTableElement(bodies);
  setFirstCellClass(header, headers);
  table2.appendChild(colGroup);
  table2.appendChild(header);
  table2.appendChild(body);
  if (footers.length) {
    const footer = createTableElement(footers);
    table2.appendChild(footer);
  }
  return wrapTable(table2, size);
};
var exportElement = (wrapper, size) => {
  const query = new GridQuery(wrapper);
  const content2 = query.content();
  let result;
  if (content2) {
    const colGroups = [content2.querySelector("colgroup")];
    const headers = [query.header().querySelector("thead")];
    const bodies = [content2.querySelector("tbody")];
    const footer = query.footer();
    const footers = [];
    if (footer) {
      footers.push(footer.querySelector("tfoot"));
    }
    const lockedContent = query.content(true);
    if (lockedContent) {
      colGroups.unshift(lockedContent.querySelector("colgroup"));
      headers.unshift(query.header(true).querySelector("thead"));
      bodies.unshift(lockedContent.querySelector("tbody"));
      if (footer) {
        footers.unshift(query.footer(true).querySelector("tfoot"));
      }
    }
    result = createTable(colGroups, headers, bodies, footers, size);
  } else {
    result = wrapTable(query.table().cloneNode(true), size);
  }
  return result;
};
var createElement$1 = (tagName, className) => {
  const element = document.createElement(tagName);
  if (className) {
    element.className = className;
  }
  return element;
};
var createDiv = (className) => {
  return createElement$1("div", className);
};
var PDFComponent = class _PDFComponent extends PDFExportComponent {
  pdfService;
  suspendService;
  ngZone;
  ctx;
  /**
   * Exports all Grid pages, starting from the first one.
   */
  allPages;
  /**
   * The delay in milliseconds before exporting the Grid content.
   * Useful for scenarios which involve exporting complex components used in the Grid
   * templates such as charts or data-bound components with asynchronous data retrieval ([see example]({% slug pdfexport_grid %}#toc-exporting-all-pages)).
   *
   * @default 0
   */
  delay = 0;
  columns = new QueryList();
  /**
   * @hidden
   */
  marginComponent;
  /**
   * @hidden
   */
  pageTemplateDirective;
  progress;
  component;
  container;
  skip;
  pageSize;
  originalHeight;
  originalOverflow;
  saveSubscription;
  drawSubscription;
  renderAllPages;
  originalColumns;
  constructor(pdfService, suspendService, ngZone, element, ctx) {
    super(element);
    this.pdfService = pdfService;
    this.suspendService = suspendService;
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));
    this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));
    this.reset = this.reset.bind(this);
    this.draw = this.draw.bind(this);
  }
  ngOnDestroy() {
    this.saveSubscription.unsubscribe();
    this.drawSubscription.unsubscribe();
    this.reset();
  }
  /**
   * @hidden
   */
  saveAs() {
    throw new Error(GridConfigurationErrorMessages.unsupportedMethod("saveAs", "GridComponent.saveAsPDF"));
  }
  /**
   * @hidden
   */
  export() {
    throw new Error(GridConfigurationErrorMessages.unsupportedMethod("export", "GridComponent.drawPDF"));
  }
  savePDF(component) {
    this.createPDF(component, this.draw);
  }
  drawPDF({
    component,
    promise
  }) {
    this.createPDF(component, () => {
      this.createExportGroup(promise);
    });
  }
  createPDF(component, callback) {
    const pageSize = component.pageSize;
    const total = component.view.total;
    const columns = this.columns.toArray();
    if (columns.length) {
      this.originalColumns = component.columns.toArray();
    }
    this.component = component;
    this.suspendService.scroll = true;
    this.pdfService.exporting = true;
    this.initProgress();
    this.renderAllPages = this.allPages && pageSize < total;
    if (this.renderAllPages) {
      this.skip = component.skip;
      this.pageSize = pageSize;
      this.changePage(0, total, callback, columns);
    } else if (columns.length || component.virtualColumns) {
      this.changeColumns(columns, callback);
    } else {
      callback();
    }
  }
  initProgress() {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapperElement = this.component.wrapper.nativeElement;
    const progress = this.progress = createDiv("k-loading-pdf-mask");
    const overlay = cloneNode(wrapperElement);
    progress.appendChild(overlay);
    progress.appendChild(createDiv("k-loading-color"));
    progress.appendChild(createElement$1("span", "k-i-loading k-icon"));
    this.originalHeight = wrapperElement.style.height;
    this.originalOverflow = wrapperElement.style.overflow;
    wrapperElement.style.height = wrapperElement.offsetHeight + "px";
    wrapperElement.style.overflow = "hidden";
    wrapperElement.appendChild(progress);
    this.applyScroll(overlay);
  }
  applyScroll(overlay) {
    const query = new GridQuery(this.component.wrapper.nativeElement);
    const content2 = query.content();
    if (content2) {
      const overlayQuery = new GridQuery(overlay);
      const overlayContent = overlayQuery.content();
      overlayContent.scrollTop = content2.scrollTop;
      overlayContent.scrollLeft = content2.scrollLeft;
      overlayQuery.header().scrollLeft = query.header().scrollLeft;
      const footer = query.footer();
      if (footer) {
        overlayQuery.footer().scrollLeft = footer.scrollLeft;
      }
      const lockedContent = query.content(true);
      if (lockedContent) {
        const overlayLockedContent = overlayQuery.content(true);
        overlayLockedContent.scrollTop = lockedContent.scrollTop;
        overlayLockedContent.scrollLeft = lockedContent.scrollLeft;
      }
    }
  }
  draw() {
    this.createExportElement((element) => {
      this.save(element, this.fileName);
    });
  }
  createExportGroup(promise) {
    this.createExportElement((element) => {
      this.exportElement(element).then((group) => promise.resolve(group));
    });
  }
  createExportElement(callback) {
    this.ngZone.runOutsideAngular(() => {
      const container = this.container = createDiv("k-grid-pdf-export-element");
      const element = exportElement(this.component.wrapper.nativeElement, this.ctx?.grid.size || "medium");
      container.appendChild(element);
      document.body.appendChild(container);
      callback(element);
    });
  }
  drawOptions() {
    const options = super.drawOptions();
    options._destructive = true;
    return options;
  }
  cleanup() {
    super.cleanup();
    this.pdfService.exporting = false;
    if (this.component) {
      const originalColumns = this.originalColumns;
      delete this.originalColumns;
      if (this.renderAllPages) {
        this.changePage(this.skip, this.pageSize, this.reset, originalColumns);
      } else if (originalColumns || this.component.virtualColumns) {
        this.changeColumns(originalColumns, this.reset);
      } else {
        this.reset();
      }
    } else {
      this.reset();
    }
    this.removeContainer();
  }
  removeContainer() {
    if (this.container) {
      document.body.removeChild(this.container);
      delete this.container;
    }
  }
  changePage(skip3, _take, callback, columns) {
    this.ngZone.run(() => {
      this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {
        if (columns && columns.length || this.component.virtualColumns) {
          this.changeColumns(columns, callback);
        } else {
          this.onStable(callback);
        }
      });
      this.component.notifyPageChange("pdf", {
        skip: skip3,
        take: _take
      });
    });
  }
  changeColumns(columns, callback) {
    this.ngZone.run(() => {
      this.onStable(callback);
      if (columns && columns.length) {
        this.component.columns.reset(columns);
      }
    });
  }
  reset() {
    this.suspendService.scroll = false;
    this.renderAllPages = false;
    if (!this.component) {
      return;
    }
    const wrapperElement = this.component.wrapper.nativeElement;
    wrapperElement.removeChild(this.progress);
    wrapperElement.style.height = this.originalHeight;
    wrapperElement.style.overflow = this.originalOverflow;
    delete this.progress;
    delete this.component;
  }
  onStable(callback) {
    setTimeout(() => {
      let onStable = this.ngZone.onStable.asObservable().pipe(take(1));
      if (this.delay > 0) {
        onStable = onStable.pipe(delay(this.delay));
      }
      onStable.subscribe(callback);
    }, 0);
  }
  static ɵfac = function PDFComponent_Factory(t) {
    return new (t || _PDFComponent)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(SuspendService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFComponent,
    selectors: [["kendo-grid-pdf"]],
    contentQueries: function PDFComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PDFMarginComponent, 5);
        ɵɵcontentQuery(dirIndex, PDFTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ColumnBase2, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      }
    },
    inputs: {
      allPages: "allPages",
      delay: "delay"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function PDFComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-pdf",
      template: "",
      standalone: true
    }]
  }], function() {
    return [{
      type: PDFService
    }, {
      type: SuspendService
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: ContextService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    allPages: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }],
    marginComponent: [{
      type: ContentChild,
      args: [PDFMarginComponent, {
        static: false
      }]
    }],
    pageTemplateDirective: [{
      type: ContentChild,
      args: [PDFTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var PDFCommandDirective = class _PDFCommandDirective extends ButtonComponent {
  pdfService;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.pdfService.exportClick.emit();
  }
  /**
   * @hidden
   */
  get pdfClass() {
    return true;
  }
  constructor(pdfService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.pdfService = pdfService;
    this.ngZone = ngZone;
  }
  static ɵfac = function PDFCommandDirective_Factory(t) {
    return new (t || _PDFCommandDirective)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PDFCommandDirective,
    selectors: [["", "kendoGridPDFCommand", ""]],
    hostVars: 2,
    hostBindings: function PDFCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function PDFCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-grid-pdf", ctx.pdfClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    attrs: _c252,
    ngContentSelectors: _c112,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function PDFCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, PDFCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, PDFCommandDirective_span_1_Template, 2, 1, "span", 1)(2, PDFCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridPDFCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: PDFService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    pdfClass: [{
      type: HostBinding,
      args: ["class.k-grid-pdf"]
    }]
  });
})();
var isFilterable = (settings) => settings !== false;
var hasFilterMenu = (settings) => typeof settings === "string" && settings.indexOf("menu") > -1;
var hasFilterRow = (settings) => settings === true || typeof settings === "string" && settings.indexOf("row") > -1;
var ColumnReorderService = class _ColumnReorderService {
  changes = new EventEmitter();
  reorder(e) {
    this.changes.emit(e);
  }
  static ɵfac = function ColumnReorderService_Factory(t) {
    return new (t || _ColumnReorderService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColumnReorderService,
    factory: _ColumnReorderService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnReorderService, [{
    type: Injectable
  }], null, null);
})();
var ColumnReorderEvent = class extends PreventableEvent4 {
  /**
   * The reordered column.
   */
  column;
  /**
   * The new index of the column.
   * Relative to the collection of columns.
   */
  newIndex;
  /**
   * The original index of the column before reordering.
   * Relative to the collection of columns.
   */
  oldIndex;
  /**
   * @hidden
   */
  constructor({
    column,
    newIndex,
    oldIndex
  }) {
    super();
    this.column = column;
    this.newIndex = newIndex;
    this.oldIndex = oldIndex;
  }
};
var fromPercentage = (value, percent) => {
  const sign = percent < 0 ? -1 : 1;
  return Math.ceil(Math.abs(percent) / 100 * value) * sign;
};
var toPercentage = (value, whole) => value / whole * 100;
var headerWidth = (handle) => handle.nativeElement.parentElement.getBoundingClientRect().width;
var adjacentColumnWidth = (handle) => handle.nativeElement.parentElement.nextElementSibling?.getBoundingClientRect().width;
var adjacentColumnInGroupWidth = (handle, rowIndex, colIndex) => {
  const tableElement = handle.nativeElement.closest(".k-grid-header-table");
  const selector = (rowAttribute) => `tr[${rowAttribute}="${rowIndex}"] th[aria-colindex="${colIndex}"]`;
  const thElement = tableElement.querySelector([selector("aria-rowindex"), selector("data-kendo-grid-row-index")]);
  return thElement.getBoundingClientRect().width;
};
var allLeafColumns = (columns) => expandColumns(columns).filter((c) => !c.isColumnGroup);
var createMoveStream = (service, draggable) => (mouseDown) => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({
  pageX
}) => ({
  originalX: mouseDown.pageX,
  pageX
})));
var preventOnDblClick = (release) => (mouseDown) => of(mouseDown).pipe(delay(150), takeUntil(release));
var isInSpanColumn = (column) => !!(column.parent && column.parent.isSpanColumn);
var indexOf2 = (target, list2) => {
  let index = 0;
  let ignore = 0;
  let skip3 = 0;
  while (index < list2.length) {
    const current3 = list2[index];
    const isParentSpanColumn = isInSpanColumn(current3);
    if (current3 === target) {
      break;
    }
    if (ignore-- <= 0 && isParentSpanColumn) {
      ignore = current3.parent.children.length - 1;
      skip3 += ignore;
    }
    index++;
  }
  return index - skip3;
};
var ColumnHandleDirective = class _ColumnHandleDirective {
  draggable;
  element;
  service;
  zone;
  cdr;
  ctx;
  columnInfoService;
  isLast;
  columns = [];
  column;
  get visible() {
    if (this.isConstrainedMode && (this.isLast || this.isLastInGroup(this.column))) {
      return "none";
    }
    return this.column.resizable ? "block" : "none";
  }
  get leftStyle() {
    return isTruthy(this.rtl) ? 0 : null;
  }
  get rightStyle() {
    return isTruthy(this.rtl) ? null : 0;
  }
  get isConstrainedMode() {
    const isConstrainedMode = this.ctx.grid?.resizable === "constrained";
    const isUnconstrainedMode = this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === "unconstrained";
    const constrainedNoShift = isConstrainedMode && !this.service.isShiftPressed;
    const unconstrainedWithShift = isUnconstrainedMode && this.service.isShiftPressed;
    return constrainedNoShift || unconstrainedWithShift;
  }
  subscriptions = new Subscription();
  rtl = false;
  totalChildrenSum = 0;
  childrenColumns = [];
  minWidthTotal = 0;
  foundColumn;
  autoFit() {
    this.service.autoFitResize = true;
    const allLeafs = allLeafColumns(this.columns);
    const currentLeafs = leafColumns([this.column]).filter((column) => isTruthy(column.resizable));
    const columnInfo = currentLeafs.map((column) => {
      const isParentSpan = isInSpanColumn(column);
      const isLastInSpan = isParentSpan ? column.parent.children.last === column : false;
      const index = indexOf2(column, allLeafs);
      return {
        column,
        headerIndex: this.columnsForLevel(column.level).indexOf(column),
        index,
        isLastInSpan,
        isParentSpan,
        level: column.level
      };
    });
    currentLeafs.forEach((column) => column.width = 0);
    this.service.measureColumns(columnInfo);
  }
  constructor(draggable, element, service, zone, cdr, ctx, columnInfoService) {
    this.draggable = draggable;
    this.element = element;
    this.service = service;
    this.zone = zone;
    this.cdr = cdr;
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
  }
  ngOnInit() {
    if (isBlank(this.column.width)) {
      this.column.implicitWidth = headerWidth(this.element);
    }
    const service = this.service.changes.pipe(filter(() => this.column.resizable), filter((e) => isPresent4(e.columns.find((column) => column === this.column))));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "start")).subscribe(this.initState.bind(this)));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "resizeColumn")).subscribe(this.resize.bind(this)));
    this.subscriptions.add(this.service.changes.pipe(
      filter((e) => e.type === "start"),
      filter(this.shouldUpdate.bind(this)),
      take(1)
      //on first resize only
    ).subscribe(this.initColumnWidth.bind(this)));
    this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(this.stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable))).subscribe(({
      pageX,
      originalX
    }) => {
      const delta = pageX - originalX;
      const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);
      this.service.resizeColumns(percent);
    })));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "autoFitComplete")).subscribe(this.sizeToFit.bind(this)));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "triggerAutoFit")).subscribe(this.autoFit.bind(this)));
    this.subscriptions.add(this.ctx.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  shouldUpdate() {
    return !allLeafColumns(this.columns).map((column) => column.width || this.isConstrainedMode && !column.width && column.implicitWidth).some(isBlank);
  }
  initColumnWidth() {
    this.column.width = headerWidth(this.element);
    if (this.isConstrainedMode) {
      this.column.resizeStartWidth = this.column.width;
    }
  }
  initState() {
    this.column.resizeStartWidth = headerWidth(this.element);
    if (this.isConstrainedMode && !this.service.adjacentColumn) {
      this.setAdjacentColumn();
    }
    this.service.resizedColumn({
      column: this.column,
      oldWidth: this.column.resizeStartWidth
    });
  }
  resize({
    deltaPercent
  }) {
    let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);
    if (isTruthy(this.rtl)) {
      delta *= -1;
    }
    let newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);
    if (isPresent4(this.column.maxResizableWidth)) {
      newWidth = Math.min(newWidth, this.column.maxResizableWidth);
    }
    if (this.isConstrainedMode) {
      newWidth = this.calcNewColumnWidth(newWidth);
    }
    const tableDelta = this.getTableDelta(newWidth, delta);
    this.updateWidth(this.column, newWidth);
    this.service.resizeTable(this.column, tableDelta);
  }
  sizeToFit({
    columns,
    widths
  }) {
    const index = columns.indexOf(this.column);
    const width2 = Math.max(...widths.map((w) => w[index])) + 1;
    const tableDelta = width2 - this.column.resizeStartWidth;
    this.updateWidth(this.column, width2);
    this.service.resizeTable(this.column, tableDelta);
  }
  updateWidth(column, width2) {
    if (this.isConstrainedMode && this.service.adjacentColumn && !this.service.autoFitResize) {
      this.updateWidthsOfResizedColumns(column, width2);
    }
    column.width = width2;
    this.columnInfoService.hiddenColumns.forEach((col) => {
      if (isBlank(col.width) && isPresent4(col.implicitWidth)) {
        col.width = col.implicitWidth;
      }
    });
    this.cdr.markForCheck();
  }
  updateWidthsOfResizedColumns(column, width2) {
    let adjacentColumnNewWidth = column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - width2;
    if (this.service.draggedGroupColumn && column.parent) {
      this.updateWidthOfDraggedColumn(column, width2);
      this.setGroupWidths(this.service.draggedGroupColumn);
    } else if (!this.service.draggedGroupColumn && !column.parent && this.service.adjacentColumn.parent) {
      this.service.adjacentColumn.parent.width = column.width + this.service.adjacentColumn.parent.width - width2;
      this.service.adjacentColumn.width = adjacentColumnNewWidth;
    } else if (!this.service.draggedGroupColumn && column.parent && this.service.adjacentColumn.parent) {
      adjacentColumnNewWidth = column.width + this.service.adjacentColumn.width - width2;
      this.service.adjacentColumn.width = adjacentColumnNewWidth;
      const filteredColumns = this.service.adjacentColumn.parent.children.filter((c) => c !== this.service.adjacentColumn);
      const filteredColumnsWidth = filteredColumns.reduce((acc, c) => acc + c.width, 0);
      this.service.adjacentColumn.parent.width = adjacentColumnNewWidth + filteredColumnsWidth;
      this.setGroupWidths(this.service.adjacentColumn.parent);
    } else if (adjacentColumnNewWidth > this.service.adjacentColumn.minResizableWidth) {
      this.service.adjacentColumn.width = adjacentColumnNewWidth;
    }
  }
  calcNewColumnWidth(newWidth) {
    let maxAllowedResizableWidth;
    if (!this.service.adjacentColumn.parent) {
      maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width - this.service.adjacentColumn.minResizableWidth;
      if (!this.column.parent) {
        maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;
        if (this.service.adjacentColumn.maxResizableWidth) {
          const minResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.maxResizableWidth;
          maxAllowedResizableWidth = this.column.resizeStartWidth + this.service.adjacentColumn.resizeStartWidth - this.service.adjacentColumn.minResizableWidth;
          this.column.minResizableWidth = minResizableWidth;
          this.column.maxResizableWidth = maxAllowedResizableWidth;
        }
      }
    } else {
      maxAllowedResizableWidth = this.column.width + this.service.adjacentColumn.width;
      newWidth = Math.min(newWidth, maxAllowedResizableWidth);
      this.minWidthTotal = 0;
      const minResizableWidth = this.minAdjacentColumnWidth(this.service.adjacentColumn);
      maxAllowedResizableWidth -= minResizableWidth;
    }
    return Math.min(newWidth, maxAllowedResizableWidth - 1);
  }
  setAdjacentColumn() {
    const columnsForLevel = this.columnsForLevel(this.column.level);
    if (this.column.parent) {
      if (this.column.isReordered) {
        this.service.adjacentColumn = columnsForLevel.find((c) => c.orderIndex === this.column.orderIndex + 1);
        this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;
      } else {
        const columnIndex = columnsForLevel.indexOf(this.column);
        this.service.adjacentColumn = columnsForLevel[columnIndex + 1];
        this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
        const parentColumnChildren = Array.from(this.column.parent.children);
        const indexOfCurrentColumn = parentColumnChildren.indexOf(this.column);
        let adjacentColumn;
        if (indexOfCurrentColumn + 1 <= parentColumnChildren.length - 1) {
          adjacentColumn = parentColumnChildren[indexOfCurrentColumn + 1];
          if (adjacentColumn?.isColumnGroup) {
            this.service.adjacentColumn = adjacentColumn;
          }
        }
      }
      if (this.service.adjacentColumn.isColumnGroup) {
        this.foundColumn = null;
        this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
      }
      if (this.column.isColumnGroup) {
        this.service.draggedGroupColumn = this.column;
      }
    } else if (this.column.isColumnGroup) {
      if (this.column.isReordered) {
        this.service.adjacentColumn = columnsForLevel.find((c) => c.orderIndex === this.column.orderIndex + 1);
      } else {
        this.service.adjacentColumn = columnsForLevel[columnsForLevel.indexOf(this.column) + 1];
      }
      this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
      if (this.service.adjacentColumn.isColumnGroup) {
        this.foundColumn = null;
        this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
      }
      this.service.adjacentColumn.resizeStartWidth = this.service.adjacentColumn.width;
      this.service.draggedGroupColumn = this.column;
    } else {
      if (this.column.isReordered) {
        this.service.adjacentColumn = columnsForLevel.find((col) => col.orderIndex === this.column.orderIndex + 1);
      } else {
        let adjacentColumn = columnsForLevel.find((c) => c.leafIndex === this.column.leafIndex + 1);
        if (!adjacentColumn) {
          const indexOfCurrentColumn = columnsForLevel.indexOf(this.column);
          adjacentColumn = columnsForLevel[indexOfCurrentColumn + 1];
        }
        this.service.adjacentColumn = adjacentColumn;
      }
      if (!this.service.adjacentColumn.parent) {
        this.service.adjacentColumn.resizeStartWidth = adjacentColumnWidth(this.element);
      }
      if (this.service.adjacentColumn.isColumnGroup) {
        this.foundColumn = null;
        this.service.adjacentColumn = this.firstGroupChild(this.service.adjacentColumn);
        const rowIndex = this.service.adjacentColumn.level + 1;
        const colIndex = this.service.adjacentColumn.leafIndex + 1;
        this.service.adjacentColumn.resizeStartWidth = adjacentColumnInGroupWidth(this.element, rowIndex, colIndex);
      }
    }
    this.service.resizedColumn({
      column: this.service.adjacentColumn,
      oldWidth: this.service.adjacentColumn.resizeStartWidth
    });
  }
  firstGroupChild(column) {
    Array.from(column.children).sort((a, b) => a.orderIndex - b.orderIndex).forEach((c, idx2) => {
      if (idx2 === 0 && !c.isColumnGroup) {
        if (!this.foundColumn) {
          this.foundColumn = c;
        }
      } else if (c.isColumnGroup) {
        this.firstGroupChild(c);
      }
    });
    return this.foundColumn;
  }
  setGroupWidths(column) {
    const childrenWidths = column.children.reduce((acc, c) => acc + c.width, 0);
    column.width = childrenWidths;
    column.children.forEach((c) => {
      if (c.isColumnGroup) {
        this.setGroupWidths(c);
      }
    });
  }
  updateWidthOfDraggedColumn(column, width2) {
    this.totalChildrenSum = 0;
    this.childrenColumns = [];
    this.calcChildrenWidth(this.service.draggedGroupColumn);
    const childrenWidthNotIncludingColumn = this.childrenColumns.reduce((acc, col) => {
      return col !== column ? acc + col.width : acc;
    }, 0);
    this.service.draggedGroupColumn.width = childrenWidthNotIncludingColumn + width2;
    if (this.service.adjacentColumn.minResizableWidth <= this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width2 - childrenWidthNotIncludingColumn) {
      this.service.adjacentColumn.width = this.totalChildrenSum + this.service.adjacentColumn.resizeStartWidth - width2 - childrenWidthNotIncludingColumn;
    }
  }
  calcChildrenWidth(column) {
    const columnChildren = Array.from(column.children);
    const childrenNoGroups = columnChildren.filter((c) => !c.isColumnGroup);
    const childrenGroups = columnChildren.filter((c) => c.isColumnGroup);
    childrenNoGroups.forEach((col) => {
      if (this.childrenColumns.indexOf(col) === -1) {
        this.childrenColumns.push(col);
      }
    });
    this.totalChildrenSum += childrenNoGroups.reduce((acc, col) => acc + col.resizeStartWidth, 0);
    childrenGroups.forEach((col) => {
      this.calcChildrenWidth(col);
    });
  }
  columnsForLevel(level) {
    return columnsToRender(this.columns ? this.columns.filter((column) => column.level === level) : []);
  }
  minAdjacentColumnWidth(column) {
    if (column.isColumnGroup) {
      Array.from(column.children).forEach((c) => {
        this.minAdjacentColumnWidth(c);
      });
    } else {
      this.minWidthTotal += column.minResizableWidth;
      if (column.width < column.minResizableWidth) {
        column.width = column.minResizableWidth;
      }
    }
    return this.minWidthTotal;
  }
  getTableDelta(newWidth, delta) {
    const minWidth = this.column.minResizableWidth;
    const maxWidth = this.column.maxResizableWidth;
    const startWidth = this.column.resizeStartWidth;
    const isAboveMin = newWidth > minWidth;
    const isBelowMax = newWidth < maxWidth;
    const isInBoundaries = isPresent4(maxWidth) ? isAboveMin && isBelowMax : isAboveMin;
    if (isInBoundaries) {
      return delta;
    } else if (newWidth <= minWidth) {
      return minWidth - startWidth;
    } else {
      return startWidth - maxWidth;
    }
  }
  stopPropagation = ({
    originalEvent: event2
  }) => {
    this.service.isShiftPressed = event2.shiftKey;
    event2.stopPropagation();
    event2.preventDefault();
  };
  isLastInGroup(column) {
    if (column.parent) {
      const groupChildren = Array.from(column.parent.children);
      const indexOfCurrentColumn = groupChildren.indexOf(column);
      if (column.isReordered || column.orderIndex > 0 || column.isReordered && column.orderIndex === 0) {
        return column.orderIndex - groupChildren[0].orderIndex === groupChildren.length - 1;
      } else {
        return indexOfCurrentColumn === groupChildren.length - 1;
      }
    }
  }
  static ɵfac = function ColumnHandleDirective_Factory(t) {
    return new (t || _ColumnHandleDirective)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnHandleDirective,
    selectors: [["", "kendoGridColumnHandle", ""]],
    hostVars: 6,
    hostBindings: function ColumnHandleDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("dblclick", function ColumnHandleDirective_dblclick_HostBindingHandler() {
          return ctx.autoFit();
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible)("left", ctx.leftStyle)("right", ctx.rightStyle);
      }
    },
    inputs: {
      isLast: "isLast",
      columns: "columns",
      column: "column"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnHandle]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DraggableDirective,
      decorators: [{
        type: Host
      }]
    }, {
      type: ElementRef
    }, {
      type: ColumnResizingService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }, {
      type: ColumnInfoService
    }];
  }, {
    isLast: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    leftStyle: [{
      type: HostBinding,
      args: ["style.left"]
    }],
    rightStyle: [{
      type: HostBinding,
      args: ["style.right"]
    }],
    autoFit: [{
      type: HostListener,
      args: ["dblclick"]
    }]
  });
})();
var LocalDataChangesService = class _LocalDataChangesService {
  changes = new EventEmitter();
  data;
  static ɵfac = function LocalDataChangesService_Factory(t) {
    return new (t || _LocalDataChangesService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LocalDataChangesService,
    factory: _LocalDataChangesService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalDataChangesService, [{
    type: Injectable
  }], null, null);
})();
var CellSelectionAggregateService = class _CellSelectionAggregateService {
  ctx;
  dataChanges;
  columnInfoService;
  selectedItems = [];
  groupedAggregates = {
    dates: [],
    numbers: [],
    booleans: []
  };
  aggregates = {
    sum: null,
    average: null,
    min: null,
    max: null,
    count: null,
    isTrue: null,
    isFalse: null,
    earliest: null,
    latest: null
  };
  sub = new Subscription();
  constructor(ctx, dataChanges, columnInfoService) {
    this.ctx = ctx;
    this.dataChanges = dataChanges;
    this.columnInfoService = columnInfoService;
  }
  ngOnDestroy() {
    this.sub.unsubscribe();
  }
  isAggregateIncluded(aggregate) {
    const {
      cellAggregates
    } = this.ctx.grid.selectable;
    if (typeof cellAggregates !== "boolean") {
      return cellAggregates?.includes(aggregate);
    }
    return true;
  }
  init() {
    this.sub.add(this.ctx.grid.dataStateChange.subscribe(() => {
      this.nullifyAggregates();
      if (this.isAggregateIncluded("count")) {
        this.aggregates["count"] = 0;
      }
    }));
    if (this.ctx.grid.selectable.cellAggregates) {
      if (this.isAggregateIncluded("count")) {
        this.aggregates["count"] = 0;
      }
      const selectionDirective = this.ctx.grid.selectionDirective;
      if (selectionDirective && !this.isRowSelection) {
        this.selectedItems = selectionDirective.selectedKeys;
      }
    }
  }
  onSelectionChange(selectionArgs) {
    this.handleSelectedItems(selectionArgs);
    this.nullifyAggregates();
    this.handleAggregateChanges();
    return this.aggregates;
  }
  get isRowSelection() {
    return typeof this.ctx.grid.selectable === "boolean" || !this.ctx.grid.selectable.cell;
  }
  handleAggregateChanges() {
    const lockedColumns = this.columnInfoService.lockedLeafColumns.toArray();
    const nonLockedColumns = this.columnInfoService.nonLockedLeafColumns.toArray();
    const selectedItemsLength = this.selectedItems.length;
    const columns = [...lockedColumns, ...nonLockedColumns];
    const fields = columns.map((col) => col.field);
    if (this.isAggregateIncluded("count")) {
      this.aggregates["count"] = this.isRowSelection ? selectedItemsLength * columns.length : selectedItemsLength;
    }
    this.selectedItems.forEach((item) => {
      if (this.isRowSelection) {
        fields.forEach((field) => {
          const cellValue = item.dataItem;
          if (cellValue && cellValue.hasOwnProperty(field)) {
            const cellValue2 = item.dataItem[field];
            this.groupAggregates(cellValue2);
          }
        });
      } else if (!this.isRowSelection) {
        const selectedItem = this.ctx.grid.flatData.flatMap(recursiveFlatMap)[item.itemKey];
        const field = fields[item.columnKey];
        if (selectedItem && selectedItem.hasOwnProperty(field)) {
          const cellValue = selectedItem[fields[item.columnKey]];
          this.groupAggregates(cellValue);
        }
      }
    });
    this.calculateAggregates();
  }
  groupAggregates(aggregate) {
    if (typeof aggregate === "number") {
      this.groupedAggregates.numbers.push(aggregate);
    } else if (typeof aggregate === "boolean") {
      this.groupedAggregates.booleans.push(aggregate);
    } else if (aggregate instanceof Date) {
      this.groupedAggregates.dates.push(aggregate);
    }
  }
  calculateAggregates() {
    if (this.groupedAggregates.numbers.length > 0) {
      if (this.isAggregateIncluded("min")) {
        this.aggregates["min"] = Math.min(...this.groupedAggregates.numbers);
      }
      if (this.isAggregateIncluded("max")) {
        this.aggregates["max"] = Math.max(...this.groupedAggregates.numbers);
      }
      if (this.isAggregateIncluded("sum")) {
        this.aggregates["sum"] = this.groupedAggregates.numbers.reduce((acc, curr) => acc += curr, 0);
      }
      if (this.isAggregateIncluded("average")) {
        this.aggregates["average"] = this.aggregates["sum"] / this.groupedAggregates.numbers.length;
      }
    }
    if (this.groupedAggregates.booleans.length > 0) {
      if (this.isAggregateIncluded("isTrue")) {
        const isTrueCount = this.groupedAggregates.booleans.filter((bool) => bool).length;
        this.aggregates["isTrue"] = isTrueCount > 0 ? isTrueCount : null;
      }
      if (this.isAggregateIncluded("isFalse")) {
        const isFalseCount = this.groupedAggregates.booleans.length - this.aggregates["isTrue"];
        this.aggregates["isFalse"] = isFalseCount > 0 ? isFalseCount : null;
      }
    }
    if (this.groupedAggregates.dates.length > 0) {
      if (this.isAggregateIncluded("earliest")) {
        this.aggregates["earliest"] = new Date(Math.min(...this.groupedAggregates.dates));
      }
      if (this.isAggregateIncluded("latest")) {
        this.aggregates["latest"] = new Date(Math.max(...this.groupedAggregates.dates));
      }
    }
  }
  handleSelectedItems(selectionArgs) {
    const rowOrCellSelect = `${this.isRowSelection ? "selectedRows" : "selectedCells"}`;
    const rowOrCellDeselect = `${this.isRowSelection ? "deselectedRows" : "deselectedCells"}`;
    const selectedItems = selectionArgs[rowOrCellSelect];
    const deselectedItems = selectionArgs[rowOrCellDeselect];
    if (!this.isRowSelection) {
      deselectedItems.forEach((item, index) => {
        if (index + 1 < deselectedItems.length) {
          if (item.itemKey === deselectedItems[index + 1].itemKey && item.columnKey === deselectedItems[index + 1].columnKey) {
            deselectedItems.splice(index, 1);
          }
        }
      });
    }
    if (selectedItems.length > 0) {
      selectedItems.forEach((item) => {
        this.selectedItems = [...this.selectedItems, item];
      });
    }
    if (deselectedItems.length > 0) {
      if (this.isRowSelection) {
        deselectedItems.forEach((row2) => {
          this.selectedItems = this.selectedItems.filter((elem) => elem.dataItem !== row2.dataItem);
        });
      } else {
        deselectedItems.forEach((cell2) => {
          const index = this.selectedItems.findIndex((elem) => elem.itemKey === cell2.itemKey && elem.columnKey === cell2.columnKey);
          this.selectedItems.splice(index, 1);
        });
      }
    }
  }
  nullifyAggregates() {
    this.groupedAggregates = {
      dates: [],
      numbers: [],
      booleans: []
    };
    this.aggregates["count"] = null;
    this.aggregates["sum"] = this.aggregates["average"] = null;
    this.aggregates["max"] = this.aggregates["min"] = null;
    this.aggregates["isFalse"] = this.aggregates["isTrue"] = null;
    this.aggregates["earliest"] = this.aggregates["latest"] = null;
  }
  static ɵfac = function CellSelectionAggregateService_Factory(t) {
    return new (t || _CellSelectionAggregateService)(ɵɵinject(ContextService), ɵɵinject(LocalDataChangesService), ɵɵinject(ColumnInfoService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CellSelectionAggregateService,
    factory: _CellSelectionAggregateService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellSelectionAggregateService, [{
    type: Injectable
  }], function() {
    return [{
      type: ContextService
    }, {
      type: LocalDataChangesService
    }, {
      type: ColumnInfoService
    }];
  }, null);
})();
var SelectionService2 = class _SelectionService {
  domEvents;
  aggregateService;
  localDataChangesService;
  navigationService;
  ctxService;
  changes = new EventEmitter();
  lastSelectionStartIndex;
  currentSelection = [];
  nonSelectableRows = /* @__PURE__ */ new Map();
  selectAllChecked = false;
  settings;
  active = false;
  aggregates;
  get enableMarquee() {
    const checkboxOnly = this.settings && typeof this.settings === "object" && this.settings.checkboxOnly;
    if (!this.settings || checkboxOnly) {
      return false;
    }
    const selectableSettings = this.settings.selectable;
    const dragAndMultiple = typeof selectableSettings === "object" && isPresent4(selectableSettings) && selectableSettings.mode === "multiple" && selectableSettings.enabled !== false && !selectableSettings.checkboxOnly && selectableSettings.drag;
    return this.active && dragAndMultiple;
  }
  mouseDownEventArgs;
  dragging = false;
  get hasNonSelectable() {
    return this.nonSelectableRows.size > 0;
  }
  cellClickSubscription;
  mousedownSubscription;
  dataChangedSubscription;
  lastSelectionData = {};
  _selectAllState;
  constructor(domEvents, aggregateService, localDataChangesService, navigationService, ctxService) {
    this.domEvents = domEvents;
    this.aggregateService = aggregateService;
    this.localDataChangesService = localDataChangesService;
    this.navigationService = navigationService;
    this.ctxService = ctxService;
    this.addSubscriptions();
  }
  init(settings) {
    this.settings = settings;
    if (!isPresent4(this.lastSelectionStartIndex)) {
      this.lastSelectionStartIndex = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.index || 0;
      this.lastSelectionData = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.dataItem || {};
    }
    this.currentSelection = [];
    this.nonSelectableRows = /* @__PURE__ */ new Map();
    if (settings.selectable && settings.selectable.enabled !== false) {
      const iterator2 = this.getIterator();
      this._selectAllState = true;
      let item = iterator2.next();
      while (!item.done) {
        if (item.value && item.value.type === "data") {
          const rowArgs = {
            dataItem: item.value.data,
            index: item.value.index
          };
          if (settings.rowSelected(rowArgs)) {
            this.currentSelection[item.value.index] = rowArgs;
          } else {
            this._selectAllState = void 0;
          }
          if (!settings.isRowSelectable(rowArgs)) {
            this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
            this._selectAllState = void 0;
          }
        }
        item = iterator2.next();
      }
      if (this.currentSelection.length === 0) {
        this._selectAllState = false;
      }
    }
  }
  isSelected(index) {
    if (this.settings && this.active) {
      return this.options.enabled && isPresent4(this.currentSelection[index]) && !this.nonSelectableRows.has(index);
    }
  }
  handleClick(item, event2) {
    if (this.dragging) {
      this.dragging = false;
      return;
    }
    let ev;
    const ctrlKey = event2.ctrlKey || event2.metaKey;
    if (this.options.mode === "single" && ctrlKey && this.isSelected(item.index)) {
      ev = this.toggle(item);
    } else if (this.options.mode === "multiple") {
      if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event2.shiftKey) {
        ev = this.toggle(item);
      } else if (event2.shiftKey) {
        const preserveCurrentSelection = isMultipleRangesEnabled(this.settings);
        ev = this.addAllTo(item, ctrlKey, preserveCurrentSelection);
      }
    }
    if (!isPresent4(ev)) {
      ev = this.select(item);
      this.currentSelection[item.index] = {
        dataItem: item.data,
        index: item.index
      };
    }
    if (!ev.selectedRows.length && !ev.deselectedRows.length) {
      return;
    }
    ev.ctrlKey = ctrlKey;
    ev.shiftKey = event2.shiftKey;
    if (this.options.cellAggregates) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    if (ev.shiftKey) {
      ev.rangeStartRow = {
        dataItem: this.lastSelectionData,
        index: this.lastSelectionStartIndex
      };
      ev.rangeEndRow = {
        dataItem: item.data,
        index: item.index
      };
    }
    this.syncCurrentSelection(ev);
    this.changes.emit(ev);
  }
  toggle(item) {
    const selectedRows = [];
    const deselectedRows = [];
    this.lastSelectionStartIndex = item.index;
    this.lastSelectionData = item.data;
    const rowArgs = {
      dataItem: item.data,
      index: item.index
    };
    if (this.isSelected(item.index)) {
      deselectedRows.push(rowArgs);
    } else if (!this.nonSelectableRows.has(item.index)) {
      selectedRows.push(rowArgs);
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    return {
      deselectedRows,
      selectedRows
    };
  }
  toggleByIndex(index) {
    const iterator2 = this.getIterator();
    if (this.selectAllChecked && this.isSelected(index)) {
      this.selectAllChecked = false;
    }
    let item = iterator2.next();
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.index === index) {
        const itemToToggle = {
          data: item.value.data,
          index: item.value.index
        };
        if (this.isSelected(index) || this.options.mode === "multiple") {
          return this.toggle(itemToToggle);
        } else {
          return this.select(itemToToggle);
        }
      }
      item = iterator2.next();
    }
  }
  select(item) {
    const deselectedRows = [];
    const selectedRows = [];
    this.lastSelectionStartIndex = item.index;
    this.lastSelectionData = item.data;
    if (!this.isSelected(item.index) && !this.nonSelectableRows.has(item.index)) {
      selectedRows.push({
        dataItem: item.data,
        index: item.index
      });
    }
    this.currentSelection.forEach((row2) => {
      if (row2.index !== item.index) {
        deselectedRows.push(row2);
      }
    });
    return {
      deselectedRows,
      selectedRows
    };
  }
  //Used to manually deselect removed items
  deselect(removedItem) {
    const iterator2 = this.getIterator();
    let item = iterator2.next();
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.data === removedItem) {
        const rowArgs = {
          dataItem: item.value.data,
          index: item.value.index
        };
        if (this.isSelected(rowArgs.index) || this.nonSelectableRows.has(rowArgs.index)) {
          const ev = {
            ctrlKey: false,
            deselectedRows: [rowArgs],
            selectedRows: []
          };
          this.syncCurrentSelection(ev);
          this.changes.emit(ev);
        }
      }
      item = iterator2.next();
    }
  }
  addAllTo(item, ctrlKey, preserveSelection = false) {
    const selectedRows = [];
    const deselectedRows = [];
    const start = Math.min(this.lastSelectionStartIndex, item.index);
    const end2 = Math.max(this.lastSelectionStartIndex, item.index);
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx2 = next.value.index;
        const rowArgs = {
          dataItem: next.value.data,
          index: idx2
        };
        if ((idx2 < start || idx2 > end2) && this.isSelected(idx2) && !ctrlKey && !preserveSelection) {
          deselectedRows.push(rowArgs);
        }
        if (idx2 >= start && idx2 <= end2 && !this.isSelected(idx2) && !this.nonSelectableRows.has(idx2)) {
          selectedRows.push(rowArgs);
        }
      }
      next = iterator2.next();
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    return {
      deselectedRows,
      selectedRows
    };
  }
  updateAll(selectAllChecked) {
    this.selectAllChecked = selectAllChecked;
    const selectedRows = [];
    const deselectedRows = [];
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx2 = next.value.index;
        const rowArgs = {
          dataItem: next.value.data,
          index: idx2
        };
        if (!this.nonSelectableRows.has(idx2)) {
          if (this.isSelected(idx2) && !selectAllChecked) {
            deselectedRows.push(rowArgs);
          }
          if (!this.isSelected(idx2) && selectAllChecked) {
            selectedRows.push(rowArgs);
          }
        }
      }
      next = iterator2.next();
    }
    if (!selectedRows.length && !deselectedRows.length) {
      return;
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    const ev = {
      ctrlKey: true,
      deselectedRows,
      selectedRows,
      shiftKey: true
    };
    if (this.options.cellAggregates) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    this.syncCurrentSelection(ev);
    this.changes.emit(ev);
  }
  selectRange(startIndex, endIndex, preserveSelection, existingSelections = []) {
    const selectedRows = [];
    const deselectedRows = [];
    const start = Math.min(startIndex, endIndex);
    const end2 = Math.max(startIndex, endIndex);
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx2 = next.value.index;
        const rowArgs = {
          dataItem: next.value.data,
          index: idx2
        };
        if ((idx2 < start || idx2 > end2) && this.isSelected(idx2)) {
          const deselectRow = !(preserveSelection || existingSelections.find((value) => value && value.dataItem === rowArgs.dataItem && value.index === rowArgs.index));
          if (deselectRow) {
            deselectedRows.push(rowArgs);
          }
        }
        if (idx2 >= start && idx2 <= end2 && !this.isSelected(idx2) && !this.nonSelectableRows.has(idx2)) {
          selectedRows.push(rowArgs);
        }
      }
      next = iterator2.next();
    }
    let cellAggregates;
    if (this.options.cellAggregates) {
      cellAggregates = this.aggregateService.onSelectionChange({
        selectedRows,
        deselectedRows
      });
    }
    if (this.hasNonSelectable) {
      const nonSelectableRows = this.currentSelection.filter((i) => this.nonSelectableRows.has(i.index));
      deselectedRows.push(...nonSelectableRows);
    }
    return {
      deselectedRows,
      selectedRows,
      cellAggregates
    };
  }
  get selectAllState() {
    return this._selectAllState;
  }
  get selected() {
    return this.currentSelection.map((item) => {
      return item.index;
    }).filter((n) => typeof n === "number");
  }
  get options() {
    const defaultOptions2 = {
      cellAggregates: false,
      checkboxOnly: false,
      enabled: true,
      mode: "multiple",
      metaKeyMultiSelect: true
    };
    if (!isPresent4(this.settings)) {
      return defaultOptions2;
    }
    if (typeof this.settings.selectable === "boolean") {
      return {
        cellAggregates: false,
        checkboxOnly: false,
        enabled: this.settings.selectable,
        mode: "multiple",
        metaKeyMultiSelect: true
      };
    } else {
      return Object.assign(defaultOptions2, this.settings.selectable);
    }
  }
  ngOnDestroy() {
    this.removeSubscriptions();
  }
  targetArgs() {
    return {
      index: this.mouseDownEventArgs.rowIndex,
      dataItem: this.mouseDownEventArgs.dataItem
    };
  }
  addSubscriptions() {
    if (!this.cellClickSubscription) {
      this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
        if (this.options.enabled && !this.options.checkboxOnly && args.type !== "contextmenu") {
          if (this.active) {
            this.handleClick({
              index: args.rowIndex,
              data: args.dataItem
            }, args.originalEvent);
          }
        }
      });
    }
    if (!this.mousedownSubscription) {
      this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
        this.mouseDownEventArgs = args;
        if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {
          if (this.active) {
            args.originalEvent.preventDefault();
            this.navigationService.focusCellByElement(args.originalEvent.target);
          }
        }
      });
    }
    if (this.localDataChangesService && !this.dataChangedSubscription) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
        if (this.active) {
          if (isPresent4(args.action) && args.action === "remove") {
            this.deselect(args.item);
          }
        }
      });
    }
  }
  getIterator() {
    const accessor = this.settings.view.accessor();
    if (!accessor) {
      return;
    }
    return accessor[iterator]();
  }
  removeSubscriptions() {
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
      this.cellClickSubscription = null;
    }
    if (this.mousedownSubscription) {
      this.mousedownSubscription.unsubscribe();
      this.mousedownSubscription = null;
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
      this.dataChangedSubscription = null;
    }
  }
  syncCurrentSelection(ev) {
    for (const row2 of ev.deselectedRows) {
      this.currentSelection.splice(row2.index, 1);
    }
    for (const row2 of ev.selectedRows) {
      this.currentSelection[row2.index] = row2;
    }
  }
  static ɵfac = function SelectionService_Factory(t) {
    return new (t || _SelectionService)(ɵɵinject(DomEventsService), ɵɵinject(CellSelectionAggregateService), ɵɵinject(LocalDataChangesService), ɵɵinject(NavigationService2), ɵɵinject(ContextService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService2, [{
    type: Injectable
  }], function() {
    return [{
      type: DomEventsService
    }, {
      type: CellSelectionAggregateService
    }, {
      type: LocalDataChangesService
    }, {
      type: NavigationService2
    }, {
      type: ContextService
    }];
  }, null);
})();
var CellSelectionService = class _CellSelectionService {
  domEvents;
  aggregateService;
  localDataChangesService;
  navigationService;
  changes = new EventEmitter();
  mouseUpEvent = new EventEmitter();
  currentSelection = [];
  settings;
  active = false;
  aggregates;
  nonSelectableRows = /* @__PURE__ */ new Map();
  get enableMarquee() {
    const checkboxOnly = this.settings && typeof this.settings === "object" && this.settings.checkboxOnly;
    if (!this.settings || checkboxOnly) {
      return false;
    }
    const selectableSettings = this.settings.selectable;
    const dragAndMultiple = typeof selectableSettings === "object" && isPresent4(selectableSettings) && selectableSettings.mode === "multiple" && selectableSettings.cell && selectableSettings.enabled !== false && selectableSettings.drag;
    return this.active && dragAndMultiple;
  }
  get hasNonSelectable() {
    return this.nonSelectableRows.size > 0;
  }
  mouseDownEventArgs;
  mouseUpEventArgs;
  dragging = false;
  dragSelectDeselect = false;
  lastSelectionItem = {
    itemKey: 0,
    columnKey: 0
  };
  lastSelectionItemRowIndex = 0;
  lastSelectionItemColIndex = 0;
  cellClickSubscription;
  dataChangedSubscription;
  mousedownSubscription;
  constructor(domEvents, aggregateService, localDataChangesService, navigationService) {
    this.domEvents = domEvents;
    this.aggregateService = aggregateService;
    this.localDataChangesService = localDataChangesService;
    this.navigationService = navigationService;
    this.addSubscriptions();
  }
  init(settings) {
    this.settings = settings;
    this.currentSelection = [];
    this.nonSelectableRows = /* @__PURE__ */ new Map();
    if (settings.selectable && settings.selectable.enabled !== false) {
      const iterator2 = this.getIterator();
      let item = iterator2.next();
      while (!item.done) {
        if (item.value && item.value.type === "data") {
          const rowArgs = {
            dataItem: item.value.data,
            index: item.value.index
          };
          settings.columns.forEach((col) => {
            const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);
            if (selectedCellArgs.selected) {
              this.currentSelection.push(selectedCellArgs.item);
            }
            if (!settings.isRowSelectable(rowArgs)) {
              this.nonSelectableRows.set(rowArgs.index, rowArgs.dataItem);
            }
          });
        }
        item = iterator2.next();
      }
    }
  }
  isCellSelected(item, col) {
    if (this.settings && this.active) {
      const selectedCellArgs = this.settings.cellSelected({
        dataItem: item.data,
        index: item.index
      }, col, col.leafIndex);
      return this.options.enabled && selectedCellArgs.selected && !this.nonSelectableRows.has(item.index);
    }
    return false;
  }
  handleClick(item, event2) {
    if (this.dragging) {
      this.dragging = false;
      return;
    }
    let ev;
    const ctrlKey = event2.ctrlKey || event2.metaKey;
    if (this.options.mode === "single" && ctrlKey && this.isCellSelected(item, item.column)) {
      ev = this.toggle(item);
    } else if (this.options.mode === "multiple") {
      if ((ctrlKey || !this.options.metaKeyMultiSelect) && !event2.shiftKey) {
        ev = this.toggle(item);
      } else if (event2.shiftKey) {
        const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);
        const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);
        const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);
        const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);
        const preserveCurrentSelection = isMultipleRangesEnabled(this.settings);
        ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveCurrentSelection);
        if (preserveCurrentSelection) {
          this.lastSelectionItemRowIndex = item.index;
          this.lastSelectionItemColIndex = item.column.leafIndex;
        }
      }
    }
    if (!isPresent4(ev)) {
      ev = this.select(item);
      this.currentSelection = [this.lastSelectionItem];
    }
    if (!ev.selectedCells.length && !ev.deselectedCells.length) {
      return;
    }
    ev.ctrlKey = ctrlKey;
    ev.shiftKey = event2.shiftKey;
    if (this.options.cellAggregates && !event2.shiftKey) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    if (ev.shiftKey) {
      ev.rangeStartCell = this.lastSelectionItem;
      ev.rangeEndCell = __spreadValues({}, this.settings.cellSelected({
        dataItem: item.data,
        index: item.index
      }, item.column, item.column.leafIndex).item);
    }
    this.changes.emit(ev);
  }
  toggle(item) {
    const selectedCells = [];
    const deselectedCells = [];
    this.lastSelectionItem = this.settings.cellSelected({
      dataItem: item.data,
      index: item.index
    }, item.column, item.column.leafIndex).item;
    this.lastSelectionItemRowIndex = item.index;
    this.lastSelectionItemColIndex = item.column.leafIndex;
    if (this.isCellSelected(item, item.column)) {
      deselectedCells.push(this.lastSelectionItem);
    } else if (!this.nonSelectableRows.has(item.index)) {
      selectedCells.push(this.lastSelectionItem);
    }
    return {
      deselectedCells,
      selectedCells
    };
  }
  select(item) {
    const selectedCells = [];
    const deselectedCells = [];
    this.lastSelectionItem = this.settings.cellSelected({
      dataItem: item.data,
      index: item.index
    }, item.column, item.column.leafIndex).item;
    this.lastSelectionItemRowIndex = item.index;
    this.lastSelectionItemColIndex = item.column.leafIndex;
    if (!this.isCellSelected(item, item.column) && !this.nonSelectableRows.has(item.index)) {
      selectedCells.push(this.lastSelectionItem);
    }
    this.currentSelection.forEach((selectedItem) => {
      if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {
        deselectedCells.push(selectedItem);
      }
    });
    return {
      deselectedCells,
      selectedCells
    };
  }
  //Used to manually deselect removed items
  deselect(removedItem) {
    const iterator2 = this.getIterator();
    let item = iterator2.next();
    let rowArgs;
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.data === removedItem) {
        rowArgs = {
          dataItem: item.value.data,
          index: item.value.index
        };
        break;
      }
      item = iterator2.next();
    }
    if (rowArgs) {
      const cellsToRemove = this.currentSelection.filter((selectedItem) => {
        const contender = this.settings.cellSelected(rowArgs, null, null).item;
        return selectedItem.itemKey === contender.itemKey || this.nonSelectableRows.has(rowArgs.index);
      });
      if (cellsToRemove.length) {
        const ev = {
          ctrlKey: false,
          deselectedCells: cellsToRemove,
          selectedCells: []
        };
        this.changes.emit(ev);
      }
    }
  }
  selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex, preserveSelection = false, existingSelections = []) {
    const selectedCells = [];
    const deselectedCells = [];
    const selectionStartRow = Math.min(startRowIndex, endRowIndex);
    const selectionStartCol = Math.min(startColIndex, endColIndex);
    const selectionEndRow = Math.max(startRowIndex, endRowIndex);
    const selectionEndCol = Math.max(startColIndex, endColIndex);
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx2 = next.value.index;
        const data = next.value.data;
        const rowArgs = {
          dataItem: data,
          index: idx2
        };
        this.settings.columns.forEach((col) => {
          const {
            item
          } = this.settings.cellSelected(rowArgs, col, col.leafIndex);
          const selected = this.isCellSelected(next.value, col);
          const isInRowRange = selectionStartRow <= idx2 && idx2 <= selectionEndRow;
          const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;
          const isInSelectionRect = isInRowRange && isInColRange;
          if (!isInSelectionRect && selected) {
            const deselectCell = !(preserveSelection || existingSelections.find((value) => value && value.itemKey === item.itemKey && value.columnKey === item.columnKey));
            if (deselectCell) {
              deselectedCells.push(item);
            }
          }
          if (isInSelectionRect && !selected && !this.nonSelectableRows.has(idx2)) {
            selectedCells.push(item);
          }
        });
      }
      next = iterator2.next();
    }
    let cellAggregates;
    if (this.options.cellAggregates) {
      cellAggregates = this.aggregateService.onSelectionChange({
        selectedCells,
        deselectedCells
      });
    }
    return {
      deselectedCells,
      selectedCells,
      cellAggregates
    };
  }
  get options() {
    const defaultOptions2 = {
      cellAggregates: false,
      checkboxOnly: false,
      enabled: true,
      mode: "multiple",
      metaKeyMultiSelect: true
    };
    if (!isPresent4(this.settings)) {
      return defaultOptions2;
    }
    if (typeof this.settings.selectable === "boolean") {
      return {
        cellAggregates: false,
        checkboxOnly: false,
        enabled: this.settings.selectable,
        mode: "multiple",
        metaKeyMultiSelect: true
      };
    } else {
      return Object.assign(defaultOptions2, this.settings.selectable);
    }
  }
  ngOnDestroy() {
    this.removeSubscriptions();
  }
  addSubscriptions() {
    if (!this.cellClickSubscription) {
      this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
        if (this.options.enabled && !this.options.checkboxOnly && args.type !== "contextmenu") {
          if (this.active) {
            this.handleClick({
              index: args.rowIndex,
              data: args.dataItem,
              column: args.column
            }, args.originalEvent);
          }
        }
      });
    }
    if (!this.mousedownSubscription) {
      this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
        this.mouseDownEventArgs = args;
        if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {
          if (this.active) {
            args.originalEvent.preventDefault();
            this.navigationService.focusCellByElement(args.originalEvent.target);
          }
        }
      });
    }
    if (this.localDataChangesService && !this.dataChangedSubscription) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
        if (this.active) {
          if (isPresent4(args.action) && args.action === "remove") {
            this.deselect(args.item);
          }
        }
      });
    }
  }
  getIterator() {
    const accessor = this.settings.view.accessor();
    if (!accessor) {
      return;
    }
    return accessor[iterator]();
  }
  removeSubscriptions() {
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
      this.cellClickSubscription = null;
    }
    if (this.mousedownSubscription) {
      this.mousedownSubscription.unsubscribe();
      this.mousedownSubscription = null;
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
      this.dataChangedSubscription = null;
    }
  }
  static ɵfac = function CellSelectionService_Factory(t) {
    return new (t || _CellSelectionService)(ɵɵinject(DomEventsService), ɵɵinject(CellSelectionAggregateService), ɵɵinject(LocalDataChangesService), ɵɵinject(NavigationService2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _CellSelectionService,
    factory: _CellSelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellSelectionService, [{
    type: Injectable
  }], function() {
    return [{
      type: DomEventsService
    }, {
      type: CellSelectionAggregateService
    }, {
      type: LocalDataChangesService
    }, {
      type: NavigationService2
    }];
  }, null);
})();
var SelectAllCheckboxDirective = class _SelectAllCheckboxDirective {
  selectionService;
  cellSelectionService;
  ngZone;
  element;
  renderer;
  checkbox;
  /**
   * Explicitly overrides the state of the select-all checkbox.
   */
  state;
  /**
   * Fires when the user clicks the `kendoGridSelectAllCheckbox` select-all checkbox
   * ([see example](slug:grid_row_selection#toc-select-all-checkbox)).
   */
  selectAllChange = new EventEmitter();
  destroyClick;
  checkboxChange;
  stateSet = false;
  ngAfterContentChecked() {
    this.setState();
  }
  ngOnChanges() {
    this.stateSet = true;
  }
  constructor(selectionService, cellSelectionService, ngZone, element, renderer, checkbox) {
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.ngZone = ngZone;
    this.element = element;
    this.renderer = renderer;
    this.checkbox = checkbox;
    this.ngZone.runOutsideAngular(() => {
      if (this.checkbox) {
        this.checkboxChange = this.checkbox.checkedStateChange.subscribe(this.onClick.bind(this));
      } else {
        this.destroyClick = this.renderer.listen(this.element.nativeElement, "click", this.onClick.bind(this));
      }
    });
  }
  ngOnDestroy() {
    if (this.checkboxChange) {
      this.checkboxChange.unsubscribe();
    }
    if (this.destroyClick) {
      this.destroyClick();
    }
  }
  /**
   * @hidden
   */
  onClick() {
    const isIndeterminateState = this.checkbox?.checkedState === "indeterminate" || this.element.nativeElement.indeterminate;
    const isCheckedState = this.checkbox?.checkedState === true || this.element.nativeElement.checked;
    const checkboxState = isCheckedState ? "checked" : isIndeterminateState ? "indeterminate" : "unchecked";
    const isChecked = this.selectionService.hasNonSelectable ? !this.selectionService.selectAllChecked : isCheckedState;
    const options = this.selectionService.options;
    const enabledAndMultiple = options.enabled && options.mode === "multiple" && !this.cellSelectionService.active;
    const shouldEmitSelectAll = hasObservers(this.selectAllChange);
    if (enabledAndMultiple || shouldEmitSelectAll) {
      this.ngZone.run(() => {
        if (enabledAndMultiple) {
          this.selectionService.updateAll(isChecked);
        }
        if (shouldEmitSelectAll) {
          this.selectAllChange.emit(checkboxState);
        }
      });
    }
  }
  /**
   * @hidden
   */
  setState() {
    const state2 = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;
    if (this.checkbox) {
      this.checkbox.checkedState = isPresent4(state2) ? state2 : "indeterminate";
    } else {
      const elem = this.element.nativeElement;
      this.renderer.setProperty(elem, "indeterminate", !isPresent4(state2));
      this.renderer.setProperty(elem, "checked", isPresent4(state2) ? state2 : false);
    }
  }
  /**
   * @hidden
   */
  stateToBool() {
    switch (this.state) {
      case "checked":
        return true;
      case "unchecked":
        return false;
      default:
        return void 0;
    }
  }
  static ɵfac = function SelectAllCheckboxDirective_Factory(t) {
    return new (t || _SelectAllCheckboxDirective)(ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(CheckBoxComponent, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectAllCheckboxDirective,
    selectors: [["", "kendoGridSelectAllCheckbox", ""]],
    inputs: {
      state: "state"
    },
    outputs: {
      selectAllChange: "selectAllChange"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectAllCheckboxDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectAllCheckbox]",
      standalone: true
    }]
  }], function() {
    return [{
      type: SelectionService2
    }, {
      type: CellSelectionService
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: CheckBoxComponent,
      decorators: [{
        type: Host
      }, {
        type: Optional
      }]
    }];
  }, {
    state: [{
      type: Input
    }],
    selectAllChange: [{
      type: Output
    }]
  });
})();
var mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));
var directions$1 = (initialDirection) => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
var isRootLevel = ({
  parent
}) => !isTruthy(parent);
var ofColumnType = ({
  draggable
}) => ["column", "columnGroup"].indexOf(draggable.context.type) >= 0;
var notSameElement = ({
  draggable,
  target
}) => draggable.element.nativeElement !== target.element.nativeElement;
var inSameParent = (x, y) => x.parent === y.parent || isInSpanColumn$1(y) && inSameParent(x, y.parent);
var sameParent = ({
  draggable,
  target
}) => inSameParent(draggable.context.column, target.context.column);
var lastNonLocked = ({
  draggable
}) => !isTruthy(draggable.context.column.locked) && isRootLevel(draggable.context.column) && draggable.context.lastColumn;
var notInSpanColumn = ({
  draggable
}) => !isInSpanColumn$1(draggable.context.column);
var reorderable = ({
  draggable
}) => draggable.context.column.reorderable;
var lockable = ({
  draggable,
  target
}) => draggable.context.column.lockable !== false || draggable.context.column.isLocked === target.context.column.isLocked;
var rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);
var modifierKeys = ["alt", "ctrl", "shift", "meta"];
var HeaderComponent2 = class _HeaderComponent {
  popupService;
  hint;
  cue;
  reorderService;
  idService;
  sortService;
  columnInfoService;
  cd;
  contextService;
  navigationService;
  zone;
  /**
   * @hidden
   */
  totalColumnLevels;
  columns = [];
  groups = [];
  detailTemplate;
  scrollable;
  filterable;
  sort = new Array();
  filter;
  sortable = false;
  groupable = false;
  lockedColumnsCount = 0;
  resizable = false;
  reorderable = false;
  columnMenu = false;
  columnMenuTemplate;
  totalColumnsCount = 0;
  totalColumns;
  tabIndex;
  size = "medium";
  sortedFields = {};
  hostClass = true;
  get sortableLabel() {
    return this.contextService.localization.get("sortable");
  }
  get columnMenuSettings() {
    return this.columnMenu;
  }
  dropTargets = new QueryList();
  filterMenus;
  columnMenus;
  // Number of unlocked columns in the next table, if any
  get unlockedColumnsCount() {
    return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
  }
  sortAscSmallIcon = sortAscSmallIcon;
  sortDescSmallIcon = sortDescSmallIcon;
  subscription = new Subscription();
  targetSubscription;
  stopSorting = false;
  _leafColumns;
  constructor(popupService, hint, cue, reorderService, idService, sortService, columnInfoService, cd, contextService, navigationService, zone) {
    this.popupService = popupService;
    this.hint = hint;
    this.cue = cue;
    this.reorderService = reorderService;
    this.idService = idService;
    this.sortService = sortService;
    this.columnInfoService = columnInfoService;
    this.cd = cd;
    this.contextService = contextService;
    this.navigationService = navigationService;
    this.zone = zone;
  }
  sortColumn(descriptor) {
    this.sortService.sort(descriptor);
  }
  getColumnComponent(column) {
    return column;
  }
  onSortClick(column, event2, link) {
    if (this.stopSorting) {
      this.stopSorting = false;
      return;
    }
    const target = event2.target;
    if (column.headerTemplateRef && target !== link) {
      const hasFocusableParent = Boolean(closestInScope2(target, isFocusable2, link));
      if (hasFocusableParent) {
        return;
      }
    }
    const modifier = this.matchModifier(event2);
    const toggledColumn = this.toggleSort(column, modifier);
    this.sortColumn(toggledColumn);
  }
  onHeaderKeydown(column, args) {
    if (args.keyCode === Keys.ArrowDown && args.altKey && this.showFilterMenu) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const filterMenu = this.filterMenus.find((fm) => fm.column === column);
      filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);
      return;
    }
    if (args.keyCode === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const columnMenu = this.columnMenus.find((cm) => cm.column === column);
      columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);
      return;
    }
    const isCtrlOrMeta = args.ctrlKey || args.metaKey;
    const isGroupingKeyShortcut = (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) && isCtrlOrMeta;
    if (isGroupingKeyShortcut && this.isGroupable(column)) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const isGroupedByField = this.groups.some((gr) => gr.field === column.field);
      if (isGroupedByField) {
        this.groups = this.groups.filter((gr) => gr.field !== column.field);
      } else {
        this.groups.push({
          field: column.field
        });
      }
      this.contextService.grid.groupChange.emit(this.groups);
      return;
    }
    const isLeftOrRightArrow = args.keyCode === Keys.ArrowLeft || args.keyCode === Keys.ArrowRight;
    const isReorderingKeyShortcut = isLeftOrRightArrow && isCtrlOrMeta;
    if (isReorderingKeyShortcut && this.isReorderable(column)) {
      args.preventDefault();
      const columnsCount = this.columnInfoService.leafNamedColumns.length;
      const reorderDirection = args.keyCode === Keys.ArrowLeft ? -1 : 1;
      const rtlMultiplier = this.contextService.localization.rtl ? -1 : 1;
      const reorderDirectionOffset = reorderDirection * rtlMultiplier;
      const newIndex = column.leafIndex + reorderDirectionOffset;
      const normalizedNewIndex = Math.min(Math.max(0, newIndex), columnsCount - 1);
      const gridInstance = this.contextService.grid;
      gridInstance.reorderColumn(column, normalizedNewIndex, {
        before: reorderDirectionOffset < 0
      });
      gridInstance.columnReorder.emit(new ColumnReorderEvent({
        column,
        newIndex: normalizedNewIndex,
        oldIndex: column.leafIndex
      }));
      return;
    }
    if (!this.sortable || args.defaultPrevented || column.sortable === false) {
      return;
    }
    if (args.keyCode === Keys.Enter && isPresent4(column.field)) {
      const modifier = this.matchModifier(args);
      this.sortService.sort(this.toggleSort(column, modifier));
    }
  }
  showSortNumbering(column) {
    const {
      showIndexes
    } = normalize$1(this.sortable);
    return showIndexes && this.sort && this.sort.filter(({
      dir: dir2
    }) => isPresent4(dir2)).length > 1 && this.sortOrder(column.field) > 0;
  }
  sortOrder(field) {
    return this.sort.filter(({
      dir: dir2
    }) => isPresent4(dir2)).findIndex((x) => x.field === field) + 1;
  }
  sortState(column) {
    if (!this.isInteractive(column, "sortable")) {
      return;
    }
    const state2 = this.sortDescriptor(column.field);
    if (state2.dir === "asc") {
      return "ascending";
    }
    if (state2.dir === "desc") {
      return "descending";
    }
  }
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  /**
   *
   * @param column
   * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.
   * @returns - SortDescriptor[]
   */
  toggleSort(column, modifier = true) {
    const {
      allowUnsort,
      mode,
      initialDirection
    } = normalize$1(this.sortable, column.sortable);
    const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);
    if (mode === "single" || !modifier) {
      return [descriptor];
    }
    return [...this.sort.filter((desc) => desc.field !== column.field), descriptor];
  }
  /**
   *
   * Determines whether the modifier key (if any) passed
   * with a click/keyboard event matches the user-defined multiSortKey.
   */
  matchModifier(event2) {
    const {
      multiSortKey
    } = normalize$1(this.sortable);
    if (multiSortKey === "none") {
      return modifierKeys.every((key) => !event2[`${key}Key`]);
    }
    return multiSortKey === "ctrl" ? event2.ctrlKey || event2.metaKey : event2[`${multiSortKey}Key`];
  }
  ngAfterViewInit() {
    this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));
  }
  ngDoCheck() {
    this._leafColumns = columnsToRender(this.columns || []).filter((x) => !isColumnGroupComponent(x));
  }
  ngOnChanges(changes) {
    const sortChange = changes.sort;
    if (sortChange && !sortChange.isFirstChange()) {
      sortChange.currentValue.forEach((change) => {
        this.sortedFields[change.field] = true;
      });
    }
  }
  ngOnInit() {
    this.subscription.add(this.contextService.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngOnDestroy() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    if (this.popupService) {
      this.popupService.destroy();
    }
    this.subscription.unsubscribe();
  }
  selectAllCheckboxId() {
    return this.idService.selectAllCheckboxId();
  }
  get selectAllCheckboxLabel() {
    return this.contextService.localization.get("selectAllCheckboxLabel");
  }
  isFirstOnRow(column, index) {
    const isTailing = (c) => c && (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));
    return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);
  }
  logicalColumnIndex(column) {
    const index = column.leafIndex;
    if (isPresent4(index)) {
      return index + (isPresent4(this.detailTemplate) ? 1 : 0);
    }
    return -1;
  }
  get showFilterMenu() {
    return !this.columnMenu && hasFilterMenu(this.filterable);
  }
  get showFilterRow() {
    return hasFilterRow(this.filterable);
  }
  showColumnMenu(column) {
    return this.columnMenu && column.columnMenu && (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));
  }
  isFilterable(column) {
    return !isNullOrEmptyString(column.field) && column.filterable === true;
  }
  canDrop(draggable, target) {
    isDocumentAvailable() && this.zone.runOutsideAngular(() => {
      document.addEventListener("pointerup", () => {
        this.stopSorting = true;
        setTimeout(() => this.stopSorting = false);
      }, {
        once: true,
        capture: true
      });
    });
    return this.reorderable && rules({
      draggable,
      target
    });
  }
  shouldActivate(column) {
    const canReorder = this.isReorderable(column);
    if (!canReorder && !isColumnComponent(column)) {
      return false;
    }
    const groupable = this.isGroupable(column);
    return groupable || canReorder;
  }
  isInteractive(column, prop) {
    return !isNullOrEmptyString(column.field) && isTruthy(this[prop]) && isTruthy(column[prop]);
  }
  isCheckboxColumn(column) {
    return isCheckboxColumn(column) && !column.templateRef;
  }
  addStickyStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.headerStyle), stickyStyles);
  }
  toggleDirection(field, allowUnsort, initialDirection) {
    const descriptor = this.sortDescriptor(field);
    const [first, second] = directions$1(initialDirection);
    let dir2 = first;
    if (descriptor.dir === first) {
      dir2 = second;
    } else if (descriptor.dir === second && allowUnsort) {
      dir2 = void 0;
    }
    return {
      dir: dir2,
      field
    };
  }
  columnsForLevel(level) {
    const columns = this.columns ? this.columns.filter((column) => column.level === level) : [];
    return sortColumns(columnsToRender(columns));
  }
  isColumnGroupComponent(column) {
    return isColumnGroupComponent(column);
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
  get columnLevels() {
    return new Array((this.totalColumnLevels || 0) + 1);
  }
  get leafColumns() {
    return this._leafColumns;
  }
  isReorderable(column) {
    return this.reorderable && column.reorderable;
  }
  isGroupable(column) {
    return this.groupable && isColumnComponent(column) && column.groupable !== false;
  }
  attachTargets() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.targetSubscription = new Subscription();
    const enterStream = merge(...this.dropTargets.map((target) => target.enter));
    const leaveStream = merge(...this.dropTargets.map((target) => target.leave));
    const dropStream = merge(...this.dropTargets.map((target) => target.drop));
    this.targetSubscription.add(enterStream.pipe(tap(({
      target,
      draggable
    }) => {
      if (draggable.context.type === "groupIndicator") {
        return;
      }
      const targetLocked = isTruthy(target.context.column.isLocked);
      const draggableLocked = isTruthy(draggable.context.column.isLocked);
      if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {
        this.hint.toggleLock(targetLocked);
      }
    }), filter(({
      draggable,
      target
    }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, {
      before: this.calculateBefore(e),
      changeContainer: e.changeContainer
    })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
  }
  normalizeTarget(e) {
    let target = e.target;
    const parent = target.context.column.parent;
    if (parent && parent.isSpanColumn) {
      const arr = this.dropTargets.toArray();
      const firstSpan = arr.find((t) => t.context.column.parent === parent);
      const index = arr.indexOf(firstSpan);
      const adjust = e.before ? 0 : parent.children.length - 1;
      target = arr[index + adjust];
    }
    return mergeObjects(e, {
      target
    });
  }
  trackMove(leaveStream, dropStream, e) {
    const column = e.target.context.column;
    const levelColumns = this.columnsForLevel(column.level);
    const index = levelColumns.indexOf(column);
    const isFirst = column.locked ? index === levelColumns.length - 1 : index === 0;
    const changed = e.draggable.context.column.isLocked !== column.isLocked;
    if (changed && isFirst) {
      return e.draggable.drag.pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({
        mouseEvent
      }) => mergeObjects({
        changeContainer: true
      }, e, {
        mouseEvent
      })));
    }
    return of(mergeObjects({
      changeContainer: changed
    }, e));
  }
  calculateBefore({
    draggable,
    target,
    mouseEvent,
    changeContainer = false
  }) {
    const targetElement = target.element.nativeElement;
    let before = false;
    if (changeContainer) {
      const {
        left: left2
      } = offset2(targetElement);
      const halfWidth = targetElement.offsetWidth / 2;
      const middle = left2 + halfWidth;
      before = middle > mouseEvent.pageX;
      if (this.contextService.localization.rtl) {
        before = !before;
      }
    } else {
      before = isTargetBefore(draggable.element.nativeElement, targetElement);
    }
    return before;
  }
  enter({
    target,
    before
  }) {
    this.hint.enable();
    if (this.contextService.localization.rtl) {
      before = !before;
    }
    this.cue.position(position(target.element.nativeElement, before));
  }
  leave() {
    this.hint.disable();
    this.cue.hide();
  }
  drop({
    draggable,
    target,
    before,
    changeContainer
  }) {
    this.reorderService.reorder({
      before,
      changeContainer,
      source: draggable.context.column,
      target: target.context.column
    });
  }
  static ɵfac = function HeaderComponent_Factory(t) {
    return new (t || _HeaderComponent)(ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(ColumnReorderService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HeaderComponent,
    selectors: [["", "kendoGridHeader", ""]],
    viewQuery: function HeaderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(DropTargetDirective, 5);
        ɵɵviewQuery(FilterMenuComponent, 5);
        ɵɵviewQuery(ColumnMenuComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargets = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenus = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenus = _t);
      }
    },
    hostVars: 2,
    hostBindings: function HeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-table-thead", ctx.hostClass);
      }
    },
    inputs: {
      totalColumnLevels: "totalColumnLevels",
      columns: "columns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      scrollable: "scrollable",
      filterable: "filterable",
      sort: "sort",
      filter: "filter",
      sortable: "sortable",
      groupable: "groupable",
      lockedColumnsCount: "lockedColumnsCount",
      resizable: "resizable",
      reorderable: "reorderable",
      columnMenu: "columnMenu",
      columnMenuTemplate: "columnMenuTemplate",
      totalColumnsCount: "totalColumnsCount",
      totalColumns: "totalColumns",
      tabIndex: "tabIndex",
      size: "size"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c262,
    decls: 2,
    vars: 2,
    consts: [["link", ""], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns", 4, "ngFor", "ngForOf"], ["kendoGridFilterRow", "", "kendoGridLogicalRow", "", 3, "columns", "filter", "groups", "detailTemplate", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns", 4, "ngIf"], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["class", "k-group-cell k-header k-table-th", "role", "presentation", 4, "ngFor", "ngForOf"], ["class", "k-hierarchy-cell k-header k-table-th", "role", "presentation", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-group-cell", "k-header", "k-table-th"], ["role", "presentation", 1, "k-hierarchy-cell", "k-header", "k-table-th"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header k-table-th", 3, "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "k-sorted", "enableDrag", "context", "k-filterable", "k-first", "k-grid-header-sticky", "ngClass", "ngStyle", "keydown", 4, "ngIf"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header k-table-th", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "k-first", "k-filterable", "k-grid-content-sticky", "ngClass", "ngStyle", 4, "ngIf"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "keydown", "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "enableDrag", "context", "ngClass", "ngStyle"], [4, "ngIf"], ["kendoGridColumnHandle", "", "kendoDraggable", "", "class", "k-column-resizer", 3, "isLast", "column", "columns", 4, "ngIf"], [1, "k-cell-inner"], [1, "k-link"], [3, "templateContext"], [3, "column", "filter", "tabIndex", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", "tabIndex", 4, "ngIf"], [1, "k-column-title"], [3, "column", "filter", "tabIndex"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", "tabIndex"], [1, "k-link", 3, "click"], ["role", "note", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-sort-order", 4, "ngIf"], ["role", "note", 3, "name", "svgIcon"], [1, "k-sort-order"], ["kendoGridSelectAllCheckbox", "", "kendoGridFocusable", "", 3, "inputAttributes"], ["kendoGridColumnHandle", "", "kendoDraggable", "", 1, "k-column-resizer", 3, "isLast", "column", "columns"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "ngClass", "ngStyle"], [3, "standalone", "settings", "column", "columnMenuTemplate", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate"], ["kendoGridFilterRow", "", "kendoGridLogicalRow", "", 3, "columns", "filter", "groups", "detailTemplate", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"]],
    template: function HeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, HeaderComponent_tr_0_Template, 4, 8, "tr", 1)(1, HeaderComponent_tr_1_Template, 1, 10, "tr", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.columnLevels);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showFilterRow);
      }
    },
    dependencies: [NgForOf, LogicalRowDirective, NgIf, LogicalCellDirective, DropTargetDirective, DraggableDirective, DraggableColumnDirective, NgClass, NgStyle, TemplateContextDirective, FilterMenuComponent, ColumnMenuComponent, IconWrapperComponent, SelectAllCheckboxDirective, FocusableDirective, ColumnHandleDirective, FilterRowComponent, CheckBoxComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderComponent2, [{
    type: Component,
    args: [{
      selector: "[kendoGridHeader]",
      template: `
        <tr *ngFor="let i of columnLevels; let levelIndex = index"
            kendoGridLogicalRow
                [logicalRowIndex]="levelIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns">
            <th
                class="k-group-cell k-header k-table-th"
                role="presentation"
                *ngFor="let g of groups">
            </th>
            <th class="k-hierarchy-cell k-header k-table-th"
                role="presentation"
                *ngIf="detailTemplate?.templateRef"
            >
            </th>
            <ng-container *ngFor="let column of columnsForLevel(levelIndex); let columnIndex = index; let last = last;">
                <th *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    [colSpan]="column.colspan"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    role="columnheader"
                    aria-selected="false"
                    [attr.aria-sort]="sortState(getColumnComponent(column))"
                    [class.k-sorted]="sortState(getColumnComponent(column))"
                    (keydown)="onHeaderKeydown(getColumnComponent(column), $event)"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: getColumnComponent(column).field,
                        type: 'column',
                        column: column,
                        hint: column.title || getColumnComponent(column).field,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-filterable]="(showFilterMenu && isFilterable(getColumnComponent(column))) || showColumnMenu(column)"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-grid-header-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan"
                    [attr.aria-haspopup]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'dialog' : undefined"
                    [attr.aria-expanded]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? false : undefined"
                    [attr.aria-keyshortcuts]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'Alt + ArrowDown' : undefined">
                    <ng-container *ngIf="!isInteractive(getColumnComponent(column), 'sortable')">
                        <span class="k-cell-inner">
                            <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'groupable') && !isInteractive(getColumnComponent(column), 'reorderable')">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>
                    <ng-container *ngIf="isInteractive(getColumnComponent(column), 'sortable')">
                        <span class="k-cell-inner">
                            <span #link class="k-link" (click)="onSortClick(getColumnComponent(column), $event, link)">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                                <span [class.k-sort-icon]="sortDescriptor(getColumnComponent(column).field).dir">
                                    <kendo-icon-wrapper
                                        *ngIf="sortDescriptor(getColumnComponent(column).field).dir"
                                        role="note" [attr.aria-label]="sortableLabel"
                                        name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                                        [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                                        ></kendo-icon-wrapper>
                                </span>
                                <span *ngIf="showSortNumbering(getColumnComponent(column))" class="k-sort-order">{{sortOrder(getColumnComponent(column).field)}}</span>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>
                    <ng-container *ngIf="isCheckboxColumn(column) && !column.headerTemplateRef && $any(column).showSelectAll">
                        <kendo-checkbox
                            [attr.id]="selectAllCheckboxId()"
                            [inputAttributes]="{'aria-label': selectAllCheckboxLabel}"
                            kendoGridSelectAllCheckbox
                            kendoGridFocusable
                        ></kendo-checkbox>
                    </ng-container>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [isLast]="last"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
                <th *ngIf="isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    [colSpan]="column.colspan"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-filterable]="showColumnMenu(column)"
                    [class.k-grid-content-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.headerStyle"
                    [attr.aria-haspopup]="(isNavigable && showColumnMenu(column)) ? 'dialog' : undefined"
                    [attr.aria-expanded]="(isNavigable && showColumnMenu(column)) ? false : undefined"
                    [attr.aria-keyshortcuts]="isNavigable && showColumnMenu(column) ? 'Alt + ArrowDown' : undefined"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">
                    <span class="k-cell-inner">
                        <span class="k-link" [class.!k-cursor-default]="!isInteractive(getColumnComponent(column), 'reorderable')">
                            <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: lockedColumnsCount + columnIndex,
                                    column: column,
                                    $implicit: column
                                }">
                            </ng-template>
                            <ng-container *ngIf="!column.headerTemplateRef">
                                <span class="k-column-title">{{column.displayTitle}}</span>
                            </ng-container>
                        </span>
                        <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                            [standalone]="false"
                            [settings]="columnMenuSettings"
                            [column]="column"
                            [columnMenuTemplate]="columnMenuTemplate">
                        </kendo-grid-column-menu>
                    </span>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [isLast]="last"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
            </ng-container>
        </tr>
        <tr *ngIf="showFilterRow"
            kendoGridFilterRow
                [columns]="leafColumns"
                [filter]="filter"
                [groups]="groups"
                [detailTemplate]="detailTemplate"
                [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="totalColumnLevels + 1"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns"></tr>
    `,
      standalone: true,
      imports: [NgForOf, LogicalRowDirective, NgIf, LogicalCellDirective, DropTargetDirective, DraggableDirective, DraggableColumnDirective, NgClass, NgStyle, TemplateContextDirective, FilterMenuComponent, ColumnMenuComponent, IconWrapperComponent, SelectAllCheckboxDirective, FocusableDirective, ColumnHandleDirective, FilterRowComponent, CheckBoxComponent]
    }]
  }], function() {
    return [{
      type: SinglePopupService
    }, {
      type: DragHintService
    }, {
      type: DropCueService
    }, {
      type: ColumnReorderService
    }, {
      type: IdService
    }, {
      type: SortService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }, {
      type: NavigationService2
    }, {
      type: NgZone
    }];
  }, {
    totalColumnLevels: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    columnMenuTemplate: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-thead"]
    }],
    dropTargets: [{
      type: ViewChildren,
      args: [DropTargetDirective]
    }],
    filterMenus: [{
      type: ViewChildren,
      args: [FilterMenuComponent]
    }],
    columnMenus: [{
      type: ViewChildren,
      args: [ColumnMenuComponent]
    }]
  });
})();
var FooterComponent2 = class _FooterComponent {
  columnInfoService;
  columns = [];
  groups = [];
  detailTemplate;
  scrollable;
  lockedColumnsCount = 0;
  logicalRowIndex = 0;
  totalColumns;
  totalColumnsCount = 0;
  get footerClass() {
    return !this.scrollable;
  }
  hostClass = true;
  hostRole = "rowgroup";
  constructor(columnInfoService) {
    this.columnInfoService = columnInfoService;
  }
  get columnsToRender() {
    return columnsToRender(this.columns || []);
  }
  // Number of unlocked columns in the next table, if any
  get unlockedColumnsCount() {
    return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
  }
  trackByIndex(index) {
    return index;
  }
  logicalColumnIndex(column) {
    const index = column.leafIndex;
    if (isPresent4(index)) {
      return index + (isPresent4(this.detailTemplate) ? 1 : 0);
    }
    return -1;
  }
  addStickyStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.footerStyle), stickyStyles);
  }
  isColumnGroupComponent(column) {
    return isColumnGroupComponent(column);
  }
  static ɵfac = function FooterComponent_Factory(t) {
    return new (t || _FooterComponent)(ɵɵdirectiveInject(ColumnInfoService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FooterComponent,
    selectors: [["", "kendoGridFooter", ""]],
    hostVars: 5,
    hostBindings: function FooterComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole);
        ɵɵclassProp("k-grid-footer", ctx.footerClass)("k-table-tfoot", ctx.hostClass);
      }
    },
    inputs: {
      columns: "columns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      scrollable: "scrollable",
      lockedColumnsCount: "lockedColumnsCount",
      logicalRowIndex: "logicalRowIndex",
      totalColumns: "totalColumns",
      totalColumnsCount: "totalColumnsCount"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c312,
    decls: 5,
    vars: 9,
    consts: [["kendoGridLogicalRow", "", 1, "k-footer-template", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["class", "k-table-td k-group-cell k-table-group-td", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", "class", "k-table-td k-hierarchy-cell", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "presentation", 1, "k-table-td", "k-group-cell", "k-table-group-td"], ["role", "presentation", 1, "k-table-td", "k-hierarchy-cell"], ["kendoGridLogicalCell", "", "class", "k-table-td", "role", "gridcell", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", "k-grid-footer-sticky", "ngClass", "ngStyle", 4, "ngIf"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "ngClass", "ngStyle"], [3, "templateContext"]],
    template: function FooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0);
        ɵɵelementStart(1, "tr", 0);
        ɵɵtemplate(2, FooterComponent_td_2_Template, 1, 0, "td", 1)(3, FooterComponent_td_3_Template, 1, 0, "td", 2)(4, FooterComponent_ng_container_4_Template, 2, 1, "ng-container", 3);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("logicalRowIndex", ctx.logicalRowIndex)("logicalSlaveRow", ctx.lockedColumnsCount > 0)("logicalCellsCount", ctx.columns.length)("logicalSlaveCellsCount", ctx.unlockedColumnsCount)("totalColumns", ctx.totalColumns);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.groups);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.columnsToRender)("ngForTrackBy", ctx.trackByIndex);
      }
    },
    dependencies: [LogicalRowDirective, NgForOf, NgIf, LogicalCellDirective, NgClass, NgStyle, TemplateContextDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterComponent2, [{
    type: Component,
    args: [{
      selector: "[kendoGridFooter]",
      template: `
    <ng-container>
        <tr
            class="k-footer-template"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns"
            >
            <td
                class="k-table-td k-group-cell k-table-group-td"
                role="presentation"
                *ngFor="let g of groups">
            </td>
            <td
                role="presentation"
                class="k-table-td k-hierarchy-cell"
                *ngIf="detailTemplate?.templateRef">
            </td>
            <ng-container *ngFor="let column of columnsToRender; let columnIndex = index; trackBy: trackByIndex;">
                <td *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    class="k-table-td"
                        [logicalRowIndex]="logicalRowIndex"
                        [logicalColIndex]="logicalColumnIndex(column)"
                        role="gridcell"
                        aria-selected="false"
                    [class.k-grid-footer-sticky]="column.sticky"
                    [ngClass]="column.footerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                    <ng-template
                        [templateContext]="{
                            templateRef: column.footerTemplateRef,
                            columnIndex: column.leafIndex,
                            column: column,
                            $implicit: column
                        }">
                    </ng-template>
                </td>
            </ng-container>
        </tr>
    </ng-container>
    `,
      standalone: true,
      imports: [LogicalRowDirective, NgForOf, NgIf, LogicalCellDirective, NgClass, NgStyle, TemplateContextDirective]
    }]
  }], function() {
    return [{
      type: ColumnInfoService
    }];
  }, {
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    footerClass: [{
      type: HostBinding,
      args: ["class.k-grid-footer"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-tfoot"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var CommandColumnComponent = class _CommandColumnComponent extends ColumnBase2 {
  parent;
  template;
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  /**
   * Defines a function that is used to determine the rowspan of each column cell.
   */
  set cellRowspan(cellRowspan) {
    super.cellRowspan = cellRowspan;
  }
  get cellRowspan() {
    return super.cellRowspan;
  }
  static ɵfac = function CommandColumnComponent_Factory(t) {
    return new (t || _CommandColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CommandColumnComponent,
    selectors: [["kendo-grid-command-column"]],
    contentQueries: function CommandColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _CommandColumnComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function CommandColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommandColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => CommandColumnComponent)
      }],
      selector: "kendo-grid-command-column",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective2, {
        static: false
      }]
    }]
  });
})();
var CheckboxColumnComponent = class _CheckboxColumnComponent extends ColumnBase2 {
  selectionService;
  cellSelectionService;
  parent;
  /**
   * Determines whether a select-all `kendoGridSelectAllCheckbox` checkbox will be displayed in the header.
   */
  showSelectAll;
  /**
   * Determines whether checkboxes will be rendered for rows which are marked as non-selectable. By default, such checkboxes are visible and disabled.
   */
  showDisabledCheckbox = true;
  /*
   * @hidden
   */
  isCheckboxColumn = true;
  template;
  constructor(selectionService, cellSelectionService, parent, idService) {
    super(parent, idService);
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.parent = parent;
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  rowSelectable(rowIdx) {
    return !this.selectionService.nonSelectableRows.has(rowIdx) && !this.cellSelectionService.nonSelectableRows.has(rowIdx);
  }
  /**
   * Defines a function that is used to determine the rowspan of each column cell.
   */
  set cellRowspan(cellRowspan) {
    super.cellRowspan = cellRowspan;
  }
  get cellRowspan() {
    return super.cellRowspan;
  }
  static ɵfac = function CheckboxColumnComponent_Factory(t) {
    return new (t || _CheckboxColumnComponent)(ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CheckboxColumnComponent,
    selectors: [["kendo-grid-checkbox-column"]],
    contentQueries: function CheckboxColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CellTemplateDirective2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      }
    },
    inputs: {
      showSelectAll: "showSelectAll",
      showDisabledCheckbox: "showDisabledCheckbox"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _CheckboxColumnComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function CheckboxColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => CheckboxColumnComponent)
      }],
      selector: "kendo-grid-checkbox-column",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: SelectionService2
    }, {
      type: CellSelectionService
    }, {
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showSelectAll: [{
      type: Input
    }],
    showDisabledCheckbox: [{
      type: Input
    }],
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective2, {
        static: false
      }]
    }]
  });
})();
var SelectionCheckboxDirective = class _SelectionCheckboxDirective {
  selectionService;
  cellSelectionService;
  aggregateService;
  el;
  renderer;
  ngZone;
  checkbox;
  /**
   * The current index of the `dataItem` that will be selected.
   */
  itemIndex;
  destroyClick;
  destroyKeyDown;
  ngAfterContentChecked() {
    this.setCheckedState();
  }
  constructor(selectionService, cellSelectionService, aggregateService, el, renderer, ngZone, checkbox) {
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.aggregateService = aggregateService;
    this.el = el;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.checkbox = checkbox;
    this.ngZone.runOutsideAngular(() => {
      this.destroyClick = this.renderer.listen(this.el.nativeElement, "click", this.onClick.bind(this));
      this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, "keydown", this.onKeyDown.bind(this));
    });
  }
  ngOnDestroy() {
    if (this.destroyClick) {
      this.destroyClick();
    }
    if (this.destroyKeyDown) {
      this.destroyKeyDown();
    }
  }
  onClick(event2) {
    const nonSelectableRow = this.selectionService.nonSelectableRows.has(this.itemIndex) || this.cellSelectionService.nonSelectableRows.has(this.itemIndex);
    if (nonSelectableRow || this.cellSelectionService.options.cell) {
      event2.preventDefault();
      return;
    }
    if (this.selectionService.options.enabled) {
      this.ngZone.run(() => {
        let ev;
        const ctrlKey = event2.ctrlKey || event2.metaKey;
        if (event2.shiftKey && this.selectionService.options.mode === "multiple") {
          const item = {
            index: this.itemIndex
          };
          ev = this.selectionService.addAllTo(item, ctrlKey);
        } else {
          ev = this.selectionService.toggleByIndex(this.itemIndex);
        }
        ev.ctrlKey = event2.ctrlKey;
        ev.shiftKey = event2.shiftKey;
        if (this.selectionService.options.cellAggregates) {
          ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        this.selectionService.changes.emit(ev);
      });
    }
  }
  onKeyDown(e) {
    if (e.keyCode === Keys.Enter) {
      this.onClick(e);
    }
  }
  /*
   * @hidden
   */
  setCheckedState() {
    const isSelected = this.selectionService.nonSelectableRows.has(this.itemIndex) ? false : this.selectionService.isSelected(this.itemIndex);
    if (this.checkbox) {
      this.checkbox.checkedState = isSelected;
    } else {
      this.renderer.setProperty(this.el.nativeElement, "checked", isSelected);
    }
  }
  static ɵfac = function SelectionCheckboxDirective_Factory(t) {
    return new (t || _SelectionCheckboxDirective)(ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(CellSelectionAggregateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(CheckBoxComponent, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectionCheckboxDirective,
    selectors: [["", "kendoGridSelectionCheckbox", ""]],
    inputs: {
      itemIndex: [InputFlags.None, "kendoGridSelectionCheckbox", "itemIndex"]
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionCheckboxDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectionCheckbox]",
      standalone: true
    }]
  }], function() {
    return [{
      type: SelectionService2
    }, {
      type: CellSelectionService
    }, {
      type: CellSelectionAggregateService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: CheckBoxComponent,
      decorators: [{
        type: Host
      }, {
        type: Optional
      }]
    }];
  }, {
    itemIndex: [{
      type: Input,
      args: ["kendoGridSelectionCheckbox"]
    }]
  });
})();
var ChangeNotificationService = class _ChangeNotificationService {
  ngZone;
  changes = new EventEmitter();
  subscription;
  constructor(ngZone) {
    this.ngZone = ngZone;
  }
  notify() {
    if (!this.subscription || this.subscription.closed) {
      this.subscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => this.changes.emit());
    }
  }
  static ɵfac = function ChangeNotificationService_Factory(t) {
    return new (t || _ChangeNotificationService)(ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ChangeNotificationService,
    factory: _ChangeNotificationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeNotificationService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var NoRecordsTemplateDirective = class _NoRecordsTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NoRecordsTemplateDirective_Factory(t) {
    return new (t || _NoRecordsTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NoRecordsTemplateDirective,
    selectors: [["", "kendoGridNoRecordsTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoRecordsTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridNoRecordsTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
function defaultTrackBy(index, item) {
  if (item.type === "data" && item.isEditing) {
    return item.data;
  }
  return index;
}
var NON_DATA_CELL_CLASSES = "k-hierarchy-cell k-detail-cell k-group-cell";
var NON_DATA_ROW_CLASSES = "k-grouping-row k-group-footer k-detail-row k-grid-norecords";
var IGNORE_TARGET_CLASSSES = "k-icon k-svg-icon";
var IGNORE_CONTAINER_CLASSES = "k-grid k-grid-ignore-click";
var CellComponent = class _CellComponent {
  editService;
  idService;
  ctx;
  cellContext;
  get commandCellClass() {
    return this.isCommand(this.column);
  }
  get dragHandleCellClass() {
    return isRowReorderColumn(this.column);
  }
  get dragRowHandleLabel() {
    return isRowReorderColumn(this.column) ? this.ctx.localization.get("dragRowHandleLabel") : void 0;
  }
  column;
  columnIndex;
  isNew = false;
  isLoading = false;
  isVirtual = false;
  loadingTemplate;
  set rowIndex(index) {
    this._rowIndex = index;
    this.updateCellContext();
  }
  get rowIndex() {
    return this._rowIndex;
  }
  dataItem;
  reorderIcon = reorderIcon;
  get isEdited() {
    if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable) {
      return false;
    }
    const editContext = this.editService.columnContext(this.rowIndex, this.column);
    return this.isFieldEditable(editContext, this.column);
  }
  get showLoading() {
    return this.isVirtual && this.isLoading;
  }
  get formGroup() {
    return this.editService.context(this.rowIndex).group;
  }
  get templateContext() {
    return this._templateContext;
  }
  get editTemplateContext() {
    this._editTemplateContext.$implicit = this.formGroup;
    this._editTemplateContext.isNew = this.isNew;
    this._editTemplateContext.column = this.column;
    this._editTemplateContext.dataItem = this.dataItem;
    this._editTemplateContext.formGroup = this.formGroup;
    this._editTemplateContext.rowIndex = this.rowIndex;
    return this._editTemplateContext;
  }
  get rowReorderTemplateContext() {
    this._rowReorderTemplateContext.$implicit = this.dataItem;
    this._rowReorderTemplateContext.columnIndex = this.columnIndex;
    this._rowReorderTemplateContext.rowIndex = this.rowIndex;
    return this._rowReorderTemplateContext;
  }
  get format() {
    if (isColumnComponent(this.column) && !isNullOrEmptyString(this.column.format)) {
      return extractFormat(this.column.format);
    }
    return void 0;
  }
  get isBoundColumn() {
    return this.column.field && !this.column.templateRef;
  }
  get isCheckboxColumn() {
    return isCheckboxColumn(this.column) && !this.column.templateRef;
  }
  get selectionCheckboxId() {
    return this.idService.selectionCheckboxId(this.rowIndex);
  }
  get selectionCheckboxLabel() {
    return this.ctx.localization.get("selectionCheckboxLabel");
  }
  get isSpanColumn() {
    return isSpanColumn(this.column) && !this.column.templateRef;
  }
  get children() {
    return columnsToRender([this.column]);
  }
  get isRowReorderColumn() {
    return isRowReorderColumn(this.column) && !this.column.templateRef;
  }
  get isRowSelectable() {
    return this.column.rowSelectable(this._rowIndex);
  }
  _rowIndex;
  get isColumnEditable() {
    if (!this.column || this.isCommand(this.column)) {
      return false;
    }
    return this.column.editable !== false;
  }
  _templateContext = {};
  _editTemplateContext = {};
  _rowReorderTemplateContext = {};
  constructor(editService, idService, ctx, cellContext) {
    this.editService = editService;
    this.idService = idService;
    this.ctx = ctx;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    this.updateCellContext();
  }
  ngOnChanges() {
    this.updateTemplateContext();
  }
  ngAfterContentChecked() {
    this.updateTemplateContext();
  }
  isCommand(column) {
    return column instanceof CommandColumnComponent;
  }
  isFieldEditable(editContext, column) {
    if (!isPresent4(editContext)) {
      return false;
    }
    if (isPresent4(column.editTemplate)) {
      return true;
    }
    return isPresent4(editContext.group) && isPresent4(editContext.group.get(column.field));
  }
  updateCellContext() {
    if (this.cellContext) {
      this.cellContext.rowIndex = this._rowIndex;
    }
  }
  updateTemplateContext() {
    if (!this.column.templateRef) {
      return;
    }
    const context = this._templateContext;
    context.isNew = this.isNew;
    context.column = this.column;
    context.dataItem = this.dataItem;
    context.rowIndex = this.rowIndex;
    context.columnIndex = this.columnIndex;
    context.$implicit = this.dataItem;
  }
  static ɵfac = function CellComponent_Factory(t) {
    return new (t || _CellComponent)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(CELL_CONTEXT, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CellComponent,
    selectors: [["", "kendoGridCell", ""]],
    hostVars: 7,
    hostBindings: function CellComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx.dragRowHandleLabel);
        ɵɵclassProp("k-command-cell", ctx.commandCellClass)("k-drag-cell", ctx.dragHandleCellClass)("k-touch-action-none", ctx.dragHandleCellClass);
      }
    },
    inputs: {
      column: "column",
      columnIndex: "columnIndex",
      isNew: "isNew",
      isLoading: "isLoading",
      isVirtual: "isVirtual",
      loadingTemplate: "loadingTemplate",
      rowIndex: "rowIndex",
      dataItem: "dataItem"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c323,
    decls: 3,
    vars: 3,
    consts: [["loading", ""], ["nonSelectableRow", ""], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngIf", "ngIfElse"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf"], [3, "kendoGridSelectionCheckbox", "inputAttributes"], [3, "kendoGridSelectionCheckbox", "inputAttributes", "disabled", 4, "ngIf"], [3, "kendoGridSelectionCheckbox", "inputAttributes", "disabled"], ["name", "reorder", 3, "svgIcon", 4, "ngIf"], ["name", "reorder", 3, "svgIcon"], ["class", "k-skeleton-text k-skeleton", 4, "ngIf"], [1, "k-skeleton-text", "k-skeleton"], [3, "ngSwitch", 4, "ngIf"], ["kendoGridFocusable", "", 3, "format", "formControl", 4, "ngSwitchCase"], ["kendoGridFocusable", "", 3, "formControl", 4, "ngSwitchCase"], ["kendoGridFocusable", "", 3, "formControl", 4, "ngSwitchDefault"], ["kendoGridFocusable", "", 3, "format", "formControl"], ["kendoGridFocusable", "", 3, "formControl"]],
    template: function CellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 2);
        ɵɵtemplate(1, CellComponent_ng_container_1_Template, 4, 2, "ng-container", 3)(2, CellComponent_ng_container_2_Template, 3, 2, "ng-container", 3);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngSwitch", ctx.isEdited);
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", false);
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", true);
      }
    },
    dependencies: [NgSwitch, NgSwitchCase, NgIf, NgTemplateOutlet, NgForOf, FocusableDirective, SelectionCheckboxDirective, IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, NgSwitchDefault, FieldAccessorPipe, ReactiveFormsModule, NgControlStatus, FormControlDirective, CheckBoxComponent, TextBoxComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridCell]",
      template: `
        <ng-container [ngSwitch]="isEdited">
            <ng-container *ngSwitchCase="false">
                <ng-container *ngIf="!showLoading; else loading">
                    <ng-template *ngIf="column.templateRef"
                        [ngTemplateOutlet]="column.templateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                    <ng-container *ngIf="isSpanColumn">
                        <ng-container *ngFor="let childColumn of children">
                            {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                        </ng-container>
                    </ng-container>
                    <ng-container *ngIf="isBoundColumn">{{ dataItem | valueOf: column.field: column.format}}</ng-container>
                    <ng-container *ngIf="isCheckboxColumn && !isNew">
                        <ng-container *ngIf="isRowSelectable; else nonSelectableRow">
                            <kendo-checkbox
                                [kendoGridSelectionCheckbox]="rowIndex"
                                [attr.id]="selectionCheckboxId"
                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}">
                            </kendo-checkbox>
                        </ng-container>
                        <ng-template #nonSelectableRow>
                            <kendo-checkbox *ngIf="column.showDisabledCheckbox"
                                [kendoGridSelectionCheckbox]="rowIndex"
                                [attr.id]="selectionCheckboxId"
                                [inputAttributes]="{'aria-label': selectionCheckboxLabel}"
                                [disabled]="true"
                            ></kendo-checkbox>
                        </ng-template>
                    </ng-container>
                    <ng-container *ngIf="isRowReorderColumn && !isNew">
                        <kendo-icon-wrapper *ngIf="!column.dragHandleTemplate?.first"
                            name="reorder"
                            [svgIcon]="reorderIcon">
                        </kendo-icon-wrapper>
                        <ng-template *ngIf="column.dragHandleTemplate?.first"
                            [ngTemplateOutlet]="column.rowDragHandleTemplateRef"
                            [ngTemplateOutletContext]="rowReorderTemplateContext">
                        </ng-template>
                    </ng-container>
                </ng-container>
                <ng-template #loading>
                    <ng-template
                        *ngIf="loadingTemplate"
                        [ngTemplateOutlet]="loadingTemplate"
                        [ngTemplateOutletContext]="{$implicit: column}">
                    </ng-template>
                    <div *ngIf="!loadingTemplate" class="k-skeleton-text k-skeleton"></div>
                </ng-template>
            </ng-container>
            <ng-container *ngSwitchCase="true">
                <ng-template
                    *ngIf="column.editTemplateRef"
                    [ngTemplateOutlet]="column.editTemplateRef"
                    [ngTemplateOutletContext]="editTemplateContext">
                </ng-template>
                <ng-container [ngSwitch]="column.editor" *ngIf="!column.editTemplateRef">
                    <kendo-numerictextbox
                        *ngSwitchCase="'numeric'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-numerictextbox>

                    <kendo-datepicker
                        *ngSwitchCase="'date'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-datepicker>

                    <kendo-checkbox
                        *ngSwitchCase="'boolean'"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-checkbox>

                    <kendo-textbox
                        *ngSwitchDefault
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-textbox>
                </ng-container>
            </ng-container>
        </ng-container>
    `,
      standalone: true,
      imports: [NgSwitch, NgSwitchCase, NgIf, NgTemplateOutlet, NgForOf, FocusableDirective, SelectionCheckboxDirective, IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, NgSwitchDefault, FieldAccessorPipe, ReactiveFormsModule, CheckBoxComponent, TextBoxComponent]
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: IdService
    }, {
      type: ContextService
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }];
  }, {
    commandCellClass: [{
      type: HostBinding,
      args: ["class.k-command-cell"]
    }],
    dragHandleCellClass: [{
      type: HostBinding,
      args: ["class.k-drag-cell"]
    }, {
      type: HostBinding,
      args: ["class.k-touch-action-none"]
    }],
    dragRowHandleLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    column: [{
      type: Input
    }],
    columnIndex: [{
      type: Input
    }],
    isNew: [{
      type: Input
    }],
    isLoading: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    loadingTemplate: [{
      type: Input
    }],
    rowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }]
  });
})();
var RowspanService = class {
  skipCells = [];
  addCells(rowIndex, colIndex, rowspan) {
    for (let i = 1; i < rowspan; i++) {
      if (!this.skipCells.some(this.cellExists(rowIndex + i, colIndex))) {
        this.skipCells.push({
          rowIndex: rowIndex + i,
          colIndex
        });
      }
    }
  }
  reset() {
    this.skipCells = [];
  }
  shouldSkip(rowIndex, colIndex) {
    return !!this.skipCells.find(this.cellExists(rowIndex, colIndex));
  }
  cellExists = (rowIndex, colIndex) => (cell2) => cell2.rowIndex === rowIndex && cell2.colIndex === colIndex;
};
var columnCellIndex = (cell2, cells) => {
  let cellIndex = 0;
  for (let idx2 = 0; idx2 < cells.length; idx2++) {
    if (cells[idx2] === cell2) {
      return cellIndex;
    }
    if (!hasClasses(cells[idx2], "k-hierarchy-cell k-group-cell")) {
      cellIndex++;
    }
  }
};
var TableBodyComponent = class _TableBodyComponent {
  detailsService;
  groupsService;
  changeNotification;
  editService;
  ctx;
  ngZone;
  renderer;
  element;
  domEvents;
  selectionService;
  cellSelectionService;
  columnInfoService;
  navigationService;
  rowspanService;
  columns = [];
  allColumns;
  groups = [];
  detailTemplate;
  noRecordsTemplate;
  data;
  skip = 0;
  selectable;
  filterable;
  noRecordsText;
  isLocked = false;
  isLoading;
  isVirtual;
  cellLoadingTemplate;
  skipGroupDecoration = false;
  showGroupFooters = false;
  lockedColumnsCount = 0;
  totalColumnsCount = 0;
  virtualColumns;
  trackBy = defaultTrackBy;
  rowSticky;
  totalColumns;
  rowClass = () => null;
  hostClass = true;
  groupHeaderSlaveCellsCount;
  groupHeaderColumns;
  clickSubscription;
  touchSubscription;
  l10nSubscription;
  cellKeydownSubscription;
  clickTimeout;
  minusIcon = minusIcon;
  plusIcon = plusIcon;
  dataArray;
  rerender = false;
  constructor(detailsService, groupsService, changeNotification, editService, ctx, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService, rowspanService) {
    this.detailsService = detailsService;
    this.groupsService = groupsService;
    this.changeNotification = changeNotification;
    this.editService = editService;
    this.ctx = ctx;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.element = element;
    this.domEvents = domEvents;
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.columnInfoService = columnInfoService;
    this.navigationService = navigationService;
    this.rowspanService = rowspanService;
    this.noRecordsText = this.ctx.localization.get("noRecords");
    this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));
    this.trackByWrapper = this.trackByWrapper.bind(this);
    this.trackByColumns = this.trackByColumns.bind(this);
  }
  get newDataItem() {
    return this.editService.newDataItem;
  }
  get cachedDataArray() {
    if (!this.dataArray) {
      this.dataArray = this.data.map((item) => item);
    }
    return this.dataArray;
  }
  // Number of unlocked columns in the next table, if any
  unlockedColumnsCount(item) {
    const allColumns = this.allColumns || this.columns;
    let allColumnsCount = allColumns.length;
    allColumns.forEach((column) => {
      if (column.isSpanColumn) {
        allColumnsCount += column.colspan - 1;
      }
    });
    const contentColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - allColumnsCount;
    const headerFooterColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - allColumns.length;
    return item && this.isDataItem(item) ? contentColumnsCount : headerFooterColumnsCount;
  }
  shouldSkipCell(rowIndex, colIndex) {
    return this.rowspanService.shouldSkip(rowIndex, colIndex);
  }
  getRowspan(row2, column, colIndex) {
    if (this.rerender) {
      this.dataArray = null;
      this.rerender = false;
    }
    const rowspan = column.cellRowspan(row2, column, this.cachedDataArray);
    if (rowspan > 1) {
      this.rowspanService.addCells(row2.index, colIndex, rowspan);
    }
    this.ngZone.runOutsideAngular(() => setTimeout(() => {
      this.rerender = true;
      this.rowspanService.reset();
    }));
    return rowspan;
  }
  isAriaSelected(item, column) {
    return this.cellSelectionService.isCellSelected(item, column) || this.isRowSelected(item) ? "true" : "false";
  }
  toggleRow(index, dataItem) {
    this.detailsService.toggleRow(index, dataItem);
    return false;
  }
  isExpanded(viewItem) {
    return this.detailsService.isExpanded(viewItem.index, viewItem.data);
  }
  detailButtonIconName(viewItem) {
    const expanded = this.isExpanded(viewItem);
    return expanded ? "minus" : "plus";
  }
  detailButtonSvgIcon(viewItem) {
    const expanded = this.isExpanded(viewItem);
    return expanded ? this.minusIcon : this.plusIcon;
  }
  detailButtonTitle(viewItem) {
    const messageKey = this.isExpanded(viewItem) ? "detailCollapse" : "detailExpand";
    return this.ctx.localization.get(messageKey);
  }
  isGroup(item) {
    return item.type === "group";
  }
  isDataItem(item) {
    return !this.isGroup(item) && !this.isFooter(item);
  }
  isFooter(item) {
    return item.type === "footer";
  }
  isFooterItemInExpandedGroup(item) {
    const footerItem = {
      data: item.data,
      index: item.groupIndex,
      parentGroup: item.group.parentGroup
    };
    return this.isInExpandedGroup(footerItem);
  }
  isDataItemInExpandedGroup(item) {
    const dataItem = {
      data: item.group.data,
      index: item.groupIndex,
      parentGroup: item.group.parentGroup
    };
    return this.isInExpandedGroup(dataItem);
  }
  isInExpandedGroup(item) {
    return this.groupsService.isInExpandedGroup(item);
  }
  isParentGroupExpanded(item) {
    return this.groupsService.isInExpandedGroup(item.parentGroup);
  }
  isOdd(item) {
    return item.index % 2 !== 0;
  }
  isSelectable(args) {
    const rowSelectable = this.isRowSelectable(args);
    const selectionEnabled = this.selectable && this.selectable.enabled !== false;
    return selectionEnabled && rowSelectable;
  }
  isRowSelected(item) {
    return this.selectionService.isSelected(item.index);
  }
  isRowSelectable(args) {
    return this.selectionService.settings?.isRowSelectable(args) || this.cellSelectionService.settings?.isRowSelectable(args);
  }
  trackByWrapper(index, item) {
    if (item.type === "data") {
      item.isEditing = this.editService.hasEdited(item.index);
    }
    return this.trackBy(index, item);
  }
  trackByColumns(index, item) {
    return this.virtualColumns ? index : item;
  }
  ngDoCheck() {
    if (this.hasGroupHeaderColumn) {
      this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));
    } else {
      this.groupHeaderColumns = [];
    }
    if (this.isLocked) {
      this.groupHeaderSlaveCellsCount = this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;
    } else {
      this.groupHeaderSlaveCellsCount = 0;
    }
  }
  ngAfterViewChecked() {
    if (this.rowSticky) {
      this.applyStickyRowsStyling();
    }
  }
  ngOnChanges(changes) {
    if (isChanged("columns", changes, false)) {
      this.changeNotification.notify();
    }
  }
  logicalRowIndex(rowIndex) {
    let pos = this.skip + rowIndex;
    if (this.hasDetailTemplate) {
      pos *= 2;
    }
    const absoluteRowIndex = 1 + pos;
    const addRowOffset = this.editService.hasNewItem ? 1 : 0;
    const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
    const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;
    return absoluteRowIndex + headerRowCount;
  }
  addRowLogicalIndex() {
    return this.columnInfoService.totalLevels + 1 + (hasFilterRow(this.filterable) ? 1 : 0);
  }
  logicalColIndex(column) {
    if (!isPresent4(column.leafIndex)) {
      return -1;
    }
    return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      const clickHandler = this.clickHandler.bind(this);
      const mousedownSubscription = this.renderer.listen(this.element.nativeElement, "mousedown", clickHandler);
      const mouseupSubscription = this.renderer.listen(this.element.nativeElement, "mouseup", clickHandler);
      const clickSubscription = this.renderer.listen(this.element.nativeElement, "click", clickHandler);
      const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, "contextmenu", clickHandler);
      const touchstartSubscription = this.renderer.listen(this.element.nativeElement, "touchstart", clickHandler);
      const touchendSubscription = this.renderer.listen(this.element.nativeElement, "touchend", clickHandler);
      this.clickSubscription = () => {
        mousedownSubscription();
        mouseupSubscription();
        clickSubscription();
        contextmenuSubscription();
      };
      this.touchSubscription = () => {
        touchstartSubscription();
        touchendSubscription();
      };
    });
    let originalNoRecordText = this.ctx.localization.get("noRecords");
    this.l10nSubscription = this.ctx.localization.changes.subscribe(() => {
      if (this.noRecordsText === originalNoRecordText) {
        this.noRecordsText = this.ctx.localization.get("noRecords");
        originalNoRecordText = this.noRecordsText;
      }
    });
  }
  ngOnDestroy() {
    if (this.clickSubscription) {
      this.clickSubscription();
    }
    if (this.touchSubscription) {
      this.touchSubscription();
    }
    if (this.l10nSubscription) {
      this.l10nSubscription.unsubscribe();
    }
    this.cellKeydownSubscription.unsubscribe();
    clearTimeout(this.clickTimeout);
  }
  isEditingCell(index, column) {
    return this.editService.isEditing() && this.editService.isEditedColumn(index, column);
  }
  isEditingRow(index) {
    return this.editService.isEditing() && this.editService.hasEdited(index);
  }
  get hasGroupHeaderColumn() {
    return this.columnsContainer.hasGroupHeaderColumn;
  }
  get columnsContainer() {
    return this.columnInfoService.columnsContainer;
  }
  get columnsSpan() {
    return columnsSpan(this.columns);
  }
  get allColumnsSpan() {
    return columnsSpan(this.allColumns || this.columns);
  }
  get colSpan() {
    return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);
  }
  get footerColumns() {
    const colsToRender = Array.from(this.columns).reduce((cols, col) => {
      const newCols = col instanceof SpanColumnComponent ? Array.from(col.children) : [col];
      return [...cols, ...newCols];
    }, []);
    return colsToRender;
  }
  showGroupHeader(item) {
    return !item.data.skipHeader;
  }
  addStickyColumnStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.style), stickyStyles);
  }
  resizeHandler() {
    this.applyStickyRowsStyling();
  }
  get hasDetailTemplate() {
    return isPresent4(this.detailTemplate);
  }
  clickHandler(eventArg) {
    const element = this.element.nativeElement;
    const target = this.eventTarget(eventArg);
    const selectionEnabled = this.selectable && this.selectable.enabled !== false;
    if (eventArg.keyCode === Keys.Space) {
      if (!selectionEnabled) {
        return;
      }
      if (!this.editService.isEditing()) {
        eventArg.preventDefault();
      }
    }
    let cell2, row2, body, gridElement;
    let currentTarget = target;
    do {
      cell2 = closest3(currentTarget, matchesNodeName("td"));
      row2 = closest3(cell2, matchesNodeName("tr"));
      body = closest3(row2, matchesNodeName("tbody"));
      currentTarget = body;
      gridElement = closestInScope2(currentTarget, matchesClasses("k-grid"), element);
    } while (body && body !== element && !gridElement);
    if (cell2 && !hasClasses(cell2, NON_DATA_CELL_CLASSES) && !hasClasses(row2, NON_DATA_ROW_CLASSES) && body === element && !gridElement) {
      this.editService.preventCellClose();
      const focusable = target !== cell2 && isFocusableWithTabKey(target, false);
      if (!focusable && !matchesNodeName("label")(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) && !closestInScope2(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell2)) {
        const args = this.cellClickArgs(cell2, row2, eventArg);
        if (selectionEnabled && !this.isRowSelectable({
          index: args.rowIndex,
          dataItem: args.dataItem
        })) {
          return;
        }
        if (eventArg.type === "mousedown" || eventArg.type === "touchstart") {
          this.domEvents.cellMousedown.emit(args);
        } else if (eventArg.type === "mouseup" || eventArg.type === "touchend") {
          this.domEvents.cellMouseup.emit(args);
        } else {
          if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {
            if (eventArg.type === "click") {
              this.clickTimeout = setTimeout(() => {
                this.emitCellClick(args);
              }, 0);
            } else {
              this.emitCellClick(args);
            }
          }
        }
      }
    }
  }
  emitCellClick(args) {
    this.domEvents.cellClick.emit(Object.assign(args, {
      isEdited: args.isEditedRow || args.isEditedColumn
    }));
  }
  cellKeydownHandler(args) {
    if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {
      this.clickHandler(args);
    }
  }
  cellClickArgs(cell2, row2, eventArg) {
    const index = columnCellIndex(cell2, row2.cells);
    const column = this.columns.toArray()[index];
    const columnIndex = this.lockedColumnsCount + index;
    let rowIndex = row2.getAttribute("data-kendo-grid-item-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
    const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.data.at(rowIndex - this.skip);
    const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);
    const isEditedRow = this.editService.isEdited(rowIndex);
    const type = eventArg.type === "keydown" ? "click" : eventArg.type;
    return {
      column,
      columnIndex,
      dataItem,
      isEditedColumn,
      isEditedRow,
      originalEvent: eventArg,
      rowIndex,
      type
    };
  }
  eventTarget(args) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (args.type === "touchend") {
      const touch = args.changedTouches[0];
      return document.elementFromPoint(touch.clientX, touch.clientY);
    }
    return args.target;
  }
  applyStickyRowsStyling() {
    if (!isDocumentAvailable()) {
      return;
    }
    const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll(".k-grid-row-sticky"));
    const length2 = stickyRows.length;
    if (length2) {
      let accumulatedHeight = 0;
      const stickyRowsOffsets = [];
      stickyRows.forEach((row2) => {
        const rowHeight = row2.getBoundingClientRect().height;
        stickyRowsOffsets.push({
          accumulatedHeight,
          rowHeight
        });
        accumulatedHeight += rowHeight;
      });
      stickyRows.forEach((row2, index) => {
        this.renderer.setStyle(row2, "top", `${stickyRowsOffsets[index].accumulatedHeight}px`);
        this.renderer.setStyle(row2, "bottom", `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);
      });
    }
  }
  static ɵfac = function TableBodyComponent_Factory(t) {
    return new (t || _TableBodyComponent)(ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(RowspanService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TableBodyComponent,
    selectors: [["", "kendoGridTableBody", ""]],
    hostVars: 2,
    hostBindings: function TableBodyComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-table-tbody", ctx.hostClass);
      }
    },
    inputs: {
      columns: "columns",
      allColumns: "allColumns",
      groups: "groups",
      detailTemplate: "detailTemplate",
      noRecordsTemplate: "noRecordsTemplate",
      data: "data",
      skip: "skip",
      selectable: "selectable",
      filterable: "filterable",
      noRecordsText: "noRecordsText",
      isLocked: "isLocked",
      isLoading: "isLoading",
      isVirtual: "isVirtual",
      cellLoadingTemplate: "cellLoadingTemplate",
      skipGroupDecoration: "skipGroupDecoration",
      showGroupFooters: "showGroupFooters",
      lockedColumnsCount: "lockedColumnsCount",
      totalColumnsCount: "totalColumnsCount",
      virtualColumns: "virtualColumns",
      trackBy: "trackBy",
      rowSticky: "rowSticky",
      totalColumns: "totalColumns",
      rowClass: "rowClass"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c342,
    decls: 4,
    vars: 5,
    consts: [[4, "ngIf"], ["class", "k-grid-norecords", "role", "row", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "resize", 4, "ngIf"], ["kendoGridLogicalRow", "", 1, "k-grid-add-row", "k-grid-edit-row", "k-master-row", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["class", "k-hierarchy-cell k-table-td", "kendoGridLogicalCell", "", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", 4, "ngIf"], ["class", "k-table-td", "kendoGridCell", "", "kendoGridLogicalCell", "", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "k-grid-content-sticky", "ngClass", "left", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "k-group-cell k-table-td k-table-group-td", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-group-cell", "k-table-td", "k-table-group-td"], ["kendoGridLogicalCell", "", "aria-selected", "false", 1, "k-hierarchy-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "ngClass", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan"], ["role", "row", 1, "k-grid-norecords"], [1, "k-table-td"], [3, "templateContext"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", "class", "k-grid-row-sticky", "ngClass", "k-master-row", "k-expanded", "k-grid-edit-row", "k-selected", 4, "ngIf"], ["class", "k-detail-row", "kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", 4, "ngIf"], ["class", "k-group-footer", "kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", "ngClass"], ["class", "k-hierarchy-cell k-table-td", "kendoGridLogicalCell", "", "aria-selected", "false", "role", "gridcell", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "detailExpandCell", 4, "ngIf"], ["kendoGridLogicalCell", "", "aria-selected", "false", "role", "gridcell", 1, "k-hierarchy-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "detailExpandCell"], ["href", "#", "tabindex", "-1", 3, "click", 4, "ngIf"], ["href", "#", "tabindex", "-1", 3, "click"], [3, "name", "svgIcon"], ["kendoGridCell", "", "kendoGridLogicalCell", "", "class", "k-table-td", 3, "rowIndex", "columnIndex", "column", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "rowSpan", "k-grid-content-sticky", "k-touch-action-none", "ngClass", "k-grid-edit-cell", "ngStyle", "k-selected", 4, "ngIf"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "column", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "rowSpan", "ngClass", "ngStyle"], ["kendoGridLogicalRow", "", 1, "k-detail-row", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount"], ["class", "k-group-cell k-table-td k-table-group-td", 4, "ngFor", "ngForOf"], [1, "k-hierarchy-cell", "k-table-td"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-detail-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "colIndex", "colSpan"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-group-cell", "k-table-td", "k-table-group-td"], ["kendoGridLogicalRow", "", 1, "k-group-footer", 3, "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalCell", "", "class", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex"], [3, "resize"]],
    template: function TableBodyComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, TableBodyComponent_ng_container_0_Template, 5, 9, "ng-container", 0)(1, TableBodyComponent_tr_1_Template, 4, 3, "tr", 1)(2, TableBodyComponent_ng_container_2_Template, 5, 4, "ng-container", 2)(3, TableBodyComponent_kendo_resize_sensor_3_Template, 1, 0, "kendo-resize-sensor", 3);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.editService.hasNewItem);
        ɵɵadvance();
        ɵɵproperty("ngIf", (ctx.data == null ? null : ctx.data.length) === 0 || ctx.data === null);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackByWrapper);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.rowSticky);
      }
    },
    dependencies: [NgIf, LogicalRowDirective, NgForOf, LogicalCellDirective, CellComponent, NgClass, NgStyle, TemplateContextDirective, GroupHeaderComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableBodyComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridTableBody]",
      template: `
    <ng-container *ngIf="editService.hasNewItem">
        <tr class="k-grid-add-row k-grid-edit-row k-master-row"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount()"
                [totalColumns]="totalColumns">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;"
                class="k-table-td"
                kendoGridCell
                    [rowIndex]="-1"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [isNew]="true"
                    [column]="column"
                    [dataItem]="newDataItem"
                [class.k-grid-content-sticky]="column.sticky"
                [ngClass]="column.cssClass"
                [style.left]="column.sticky ? '0' : undefined"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [attr.role]="column.tableCellsRole"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="logicalColIndex(column)"
                    [colSpan]="column.colspan">
            </td>
        </tr>
    </ng-container>
    <tr *ngIf="data?.length === 0 || data === null" class="k-grid-norecords" role="row">
        <td [attr.colspan]="colSpan" class="k-table-td">
            <ng-template
                *ngIf="noRecordsTemplate?.templateRef"
                [templateContext]="{
                    templateRef: noRecordsTemplate?.templateRef
                 }">
            </ng-template>
            <ng-container *ngIf="!noRecordsTemplate?.templateRef">
                {{noRecordsText}}
            </ng-container>
        </td>
    </tr>
    <ng-container *ngFor="let item of data; trackBy: trackByWrapper; let rowIndex = index;">
        <tr *ngIf="isGroup(item) && isParentGroupExpanded($any(item)) && showGroupHeader(item)"
            kendoGridGroupHeader
                [columns]="columns"
                [groups]="groups"
                [item]="$any(item)"
                [hasDetails]="!!detailTemplate?.templateRef"
                [skipGroupDecoration]="skipGroupDecoration"
                [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                [groupHeaderColumns]="groupHeaderColumns"
                [rowIndex]="rowIndex + 1"
                [totalColumnsCount]="totalColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
        </tr>
        <tr
            *ngIf="isDataItem(item) && (!$any(item).group || isDataItemInExpandedGroup($any(item)))"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)"
            class="{{ isOdd(item) ?  'k-table-alt-row' : ''}}"
            [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: $any(item).index }) : false"
            [ngClass]="rowClass({ dataItem: item.data, index: $any(item).index })"
            [class.k-master-row]="true"
            [class.k-expanded]="isDataItem(item) && isExpanded(item)"
            [class.k-grid-edit-row]="isEditingRow($any(item).index)"
            [attr.aria-selected]="lockedColumnsCount < 1 ? isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item) : undefined"
            [attr.data-kendo-grid-item-index]="$any(item).index"
            [class.k-selected]="isSelectable({ dataItem: item.data, index: $any(item).index }) && isRowSelected(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [detailExpandCell]="true"
                    aria-selected="false"
                    role="gridcell">
                <a
                    *ngIf="detailTemplate.showIf(item.data, $any(item).index)"
                    [attr.title]="detailButtonTitle(item)"
                    [attr.aria-label]="detailButtonTitle(item)"
                    href="#" tabindex="-1" (click)="toggleRow($any(item).index, item.data)">
                    <kendo-icon-wrapper
                        [name]="detailButtonIconName(item)"
                        [svgIcon]="detailButtonSvgIcon(item)"></kendo-icon-wrapper>
                </a>
            </td>
            <ng-container *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;">
                <td *ngIf="column.cellRowspan ? !shouldSkipCell(rowIndex, lockedColumnsCount + columnIndex) : true"
                    kendoGridCell
                        [rowIndex]="$any(item).index"
                        [columnIndex]="lockedColumnsCount + columnIndex"
                        [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                        [column]="column"
                        [dataItem]="item.data"
                        [isLoading]="isLoading"
                        [isVirtual]="isVirtual"
                        [loadingTemplate]="cellLoadingTemplate"
                    kendoGridLogicalCell
                        [logicalRowIndex]="logicalRowIndex(rowIndex)"
                        [logicalColIndex]="logicalColIndex(column)"
                        [dataRowIndex]="$any(item).index"
                        [dataItem]="item.data"
                        [colIndex]="columnIndex"
                        [colSpan]="column.colspan"
                        [rowSpan]="column.cellRowspan ? getRowspan({
                                index: rowIndex,
                                dataItem: item
                            }, column, lockedColumnsCount + columnIndex) : 1"
                        [attr.role]="column.tableCellsRole"
                        class="k-table-td"
                        [attr.aria-selected]="lockedColumnsCount < 1 && isSelectable({ dataItem: item.data, index: $any(item).index }) ? isAriaSelected(item, column) : undefined"
                        [class.k-grid-content-sticky]="column.sticky"
                        [class.k-touch-action-none]="isSelectable({ dataItem: item.data, index: $any(item).index }) && $any(selectable).drag"
                    [ngClass]="column.cssClass"
                    [class.k-grid-edit-cell]="isEditingCell($any(item).index, column)"
                    [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                    [attr.colspan]="column.colspan"
                    [class.k-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                    >
                </td>
            </ng-container>
        </tr>
        <tr *ngIf="isDataItem(item) &&
                (!$any(item).group || isDataItemInExpandedGroup($any(item))) &&
                detailTemplate?.templateRef &&
                detailTemplate.showIf(item.data, $any(item).index) &&
                isExpanded(item)"
            class="k-detail-row"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                [logicalSlaveRow]="false"
                [logicalCellsCount]="1"
            >
            <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups"></td>
            <td class="k-hierarchy-cell k-table-td"></td>
            <td class="k-detail-cell k-table-td"
                [attr.colspan]="columnsSpan"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [colIndex]="0"
                    [colSpan]="allColumnsSpan + 1"
                    role="gridcell" aria-selected="false"
                >
                <ng-template
                    [ngTemplateOutlet]="detailTemplate.templateRef"
                    [ngTemplateOutletContext]="{
                        dataItem: item.data,
                        rowIndex: $any(item).index,
                        $implicit: item.data
                    }">
                </ng-template>
            </td>
        </tr>
        <tr *ngIf="isFooter(item) &&
                $any(item).group &&
                (isFooterItemInExpandedGroup($any(item)) || (showGroupFooters && isParentGroupExpanded($any(item).group))) &&
                !$any(item.data).hideFooter"
            class="k-group-footer"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td k-table-group-td" *ngFor="let g of groups"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                [attr.data-skip]="skipGroupDecoration"
                class="k-table-td"
                *ngFor="let column of footerColumns; let columnIndex = index; trackBy: trackByColumns;">
                <ng-template
                    [templateContext]="{
                        templateRef: $any(column).groupFooterTemplateRef,
                        group: $any(item.data),
                        field: $any(column).field,
                        column: column,
                        aggregates: $any(item.data)?.aggregates,
                        $implicit: $any(item.data)?.aggregates
                    }">
                </ng-template>
           </td>
        </tr>
    </ng-container>
    <kendo-resize-sensor *ngIf="rowSticky" (resize)="resizeHandler()"></kendo-resize-sensor>
    `,
      standalone: true,
      imports: [NgIf, LogicalRowDirective, NgForOf, LogicalCellDirective, CellComponent, NgClass, NgStyle, TemplateContextDirective, GroupHeaderComponent, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: DetailsService
    }, {
      type: GroupsService
    }, {
      type: ChangeNotificationService
    }, {
      type: EditService
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: DomEventsService
    }, {
      type: SelectionService2
    }, {
      type: CellSelectionService
    }, {
      type: ColumnInfoService
    }, {
      type: NavigationService2
    }, {
      type: RowspanService
    }];
  }, {
    columns: [{
      type: Input
    }],
    allColumns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    noRecordsTemplate: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    noRecordsText: [{
      type: Input
    }],
    isLocked: [{
      type: Input
    }],
    isLoading: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    cellLoadingTemplate: [{
      type: Input
    }],
    skipGroupDecoration: [{
      type: Input
    }],
    showGroupFooters: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-tbody"]
    }]
  });
})();
var EditCommandDirective = class _EditCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginEdit(this.rowIndex);
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function EditCommandDirective_Factory(t) {
    return new (t || _EditCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _EditCommandDirective,
    selectors: [["", "kendoGridEditCommand", ""]],
    hostVars: 4,
    hostBindings: function EditCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function EditCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-edit-command", ctx.commandClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    attrs: _c40,
    ngContentSelectors: _c112,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function EditCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, EditCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, EditCommandDirective_span_1_Template, 2, 1, "span", 1)(2, EditCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridEditCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-edit-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var CancelCommandDirective = class _CancelCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return !this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isEdited) {
      this.editService.endEdit(this.rowIndex);
    }
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function CancelCommandDirective_Factory(t) {
    return new (t || _CancelCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CancelCommandDirective,
    selectors: [["", "kendoGridCancelCommand", ""]],
    hostVars: 4,
    hostBindings: function CancelCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function CancelCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-cancel-command", ctx.commandClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    attrs: _c41,
    ngContentSelectors: _c112,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function CancelCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, CancelCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, CancelCommandDirective_span_1_Template, 2, 1, "span", 1)(2, CancelCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CancelCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridCancelCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-cancel-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var SaveCommandDirective = class _SaveCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return !this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isEdited) {
      this.editService.save(this.rowIndex);
    }
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function SaveCommandDirective_Factory(t) {
    return new (t || _SaveCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SaveCommandDirective,
    selectors: [["", "kendoGridSaveCommand", ""]],
    hostVars: 4,
    hostBindings: function SaveCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function SaveCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-save-command", ctx.commandClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    attrs: _c422,
    ngContentSelectors: _c112,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function SaveCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, SaveCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, SaveCommandDirective_span_1_Template, 2, 1, "span", 1)(2, SaveCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SaveCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridSaveCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-save-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var RemoveCommandDirective = class _RemoveCommandDirective extends ButtonComponent {
  editService;
  cellContext;
  rowIndex;
  isEdited;
  /**
   * @hidden
   */
  get visible() {
    return this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  commandClass = true;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    e.stopImmediatePropagation();
    this.editService.remove(this.rowIndex);
  }
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
  static ɵfac = function RemoveCommandDirective_Factory(t) {
    return new (t || _RemoveCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RemoveCommandDirective,
    selectors: [["", "kendoGridRemoveCommand", ""]],
    hostVars: 4,
    hostBindings: function RemoveCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function RemoveCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.visible);
        ɵɵclassProp("k-grid-remove-command", ctx.commandClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    attrs: _c432,
    ngContentSelectors: _c112,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function RemoveCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, RemoveCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, RemoveCommandDirective_span_1_Template, 2, 1, "span", 1)(2, RemoveCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RemoveCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridRemoveCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-remove-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var AddCommandDirective = class _AddCommandDirective extends ButtonComponent {
  editService;
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginAdd();
  }
  /**
   * @hidden
   */
  get commandClass() {
    return true;
  }
  constructor(editService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
  }
  static ɵfac = function AddCommandDirective_Factory(t) {
    return new (t || _AddCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AddCommandDirective,
    selectors: [["", "kendoGridAddCommand", ""]],
    hostVars: 2,
    hostBindings: function AddCommandDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function AddCommandDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-grid-add-command", ctx.commandClass);
      }
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    attrs: _c44,
    ngContentSelectors: _c112,
    decls: 5,
    vars: 3,
    consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
    template: function AddCommandDirective_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, AddCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, AddCommandDirective_span_1_Template, 2, 1, "span", 1)(2, AddCommandDirective_span_2_Template, 1, 1, "span", 2);
        ɵɵelementStart(3, "span", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.imageUrl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridAddCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgClass]
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-add-command"]
    }]
  });
})();
var CellLoadingTemplateDirective = class _CellLoadingTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CellLoadingTemplateDirective_Factory(t) {
    return new (t || _CellLoadingTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CellLoadingTemplateDirective,
    selectors: [["", "kendoGridCellLoadingTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellLoadingTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCellLoadingTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var RowDragHandleTemplateDirective = class _RowDragHandleTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RowDragHandleTemplateDirective_Factory(t) {
    return new (t || _RowDragHandleTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RowDragHandleTemplateDirective,
    selectors: [["", "kendoGridRowDragHandleTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowDragHandleTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRowDragHandleTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var RowDragHintTemplateDirective = class _RowDragHintTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RowDragHintTemplateDirective_Factory(t) {
    return new (t || _RowDragHintTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RowDragHintTemplateDirective,
    selectors: [["", "kendoGridRowDragHintTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowDragHintTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRowDragHintTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var RowReorderColumnComponent = class _RowReorderColumnComponent extends ColumnBase2 {
  parent;
  /**
   * Defines the name for an existing font icon in the Kendo UI theme.
   * @hidden
   */
  dragHandleIcon;
  /**
   * Defines an SVGIcon to be rendered as a drag handle.
   * @hidden
   */
  dragHandleSVGIcon;
  /**
   * @hidden
   */
  dragHandleTemplate = new QueryList();
  /**
   * @hidden
   */
  dragHintTemplate = new QueryList();
  /**
   * @hidden
   */
  isRowReorderColumn = true;
  /**
   * @hidden
   */
  get rowDragHandleTemplateRef() {
    const rowTemplate = this.dragHandleTemplate.first;
    return rowTemplate ? rowTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get rowDragHintTemplateRef() {
    const rowTemplate = this.dragHintTemplate.first;
    return rowTemplate ? rowTemplate.templateRef : void 0;
  }
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
  }
  /**
   * Defines a function that is used to determine the rowspan of each column cell.
   */
  set cellRowspan(cellRowspan) {
    super.cellRowspan = cellRowspan;
  }
  get cellRowspan() {
    return super.cellRowspan;
  }
  static ɵfac = function RowReorderColumnComponent_Factory(t) {
    return new (t || _RowReorderColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RowReorderColumnComponent,
    selectors: [["kendo-grid-rowreorder-column"]],
    contentQueries: function RowReorderColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, RowDragHandleTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, RowDragHintTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragHandleTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragHintTemplate = _t);
      }
    },
    inputs: {
      dragHandleIcon: "dragHandleIcon",
      dragHandleSVGIcon: "dragHandleSVGIcon"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColumnBase2,
      useExisting: forwardRef(() => _RowReorderColumnComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function RowReorderColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowReorderColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => RowReorderColumnComponent)
      }],
      selector: "kendo-grid-rowreorder-column",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    dragHandleIcon: [{
      type: Input
    }],
    dragHandleSVGIcon: [{
      type: Input
    }],
    dragHandleTemplate: [{
      type: ContentChildren,
      args: [RowDragHandleTemplateDirective, {
        descendants: false
      }]
    }],
    dragHintTemplate: [{
      type: ContentChildren,
      args: [RowDragHintTemplateDirective, {
        descendants: false
      }]
    }]
  });
})();
var ZoneAwareEventEmitter = class extends EventEmitter {
  ngZone;
  constructor(ngZone, isAsync = false) {
    super(isAsync);
    this.ngZone = ngZone;
  }
  subscribe(generatorOrNext, error2, complete) {
    let schedulerFn;
    let errorFn = (_) => null;
    let completeFn = () => null;
    if (generatorOrNext && typeof generatorOrNext === "object") {
      schedulerFn = (value) => {
        this.ngZone.run(() => generatorOrNext.next(value));
      };
      if (generatorOrNext.error) {
        errorFn = (err) => {
          this.ngZone.run(() => generatorOrNext.error(err));
        };
      }
      if (generatorOrNext.complete) {
        completeFn = () => {
          this.ngZone.run(() => generatorOrNext.complete());
        };
      }
    } else {
      schedulerFn = (value) => {
        this.ngZone.run(() => generatorOrNext(value));
      };
      if (error2) {
        errorFn = (err) => {
          this.ngZone.run(() => error2(err));
        };
      }
      if (complete) {
        completeFn = () => {
          this.ngZone.run(() => complete());
        };
      }
    }
    return super.subscribe(schedulerFn, errorFn, completeFn);
  }
};
var packageMetadata5 = {
  name: "@progress/kendo-angular-grid",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1749540270,
  version: "19.1.1",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var normalizeSettings = ({
  buttonCount = 10,
  info = true,
  type = "numeric",
  pageSizes = false,
  previousNext = true,
  responsive = true,
  position: position2 = "bottom"
}) => ({
  buttonCount,
  info,
  pageSizes,
  previousNext,
  type,
  responsive,
  position: position2
});
var normalize3 = (settings) => normalizeSettings(settings === true ? {} : settings);
var canCreateElement = () => isDocumentAvailable() && document.createElement;
var cachedScrollbarWidth = null;
var cachedPixelRatio;
var cachedRtlScrollLeft = null;
function scrollbarWidth() {
  if (cachedScrollbarWidth === null && canCreateElement()) {
    cachedPixelRatio = window.devicePixelRatio || 1;
    const div2 = document.createElement("div");
    div2.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
    div2.innerHTML = "&nbsp;";
    document.body.appendChild(div2);
    cachedScrollbarWidth = div2.offsetWidth - div2.scrollWidth;
    document.body.removeChild(div2);
  }
  return cachedScrollbarWidth;
}
function rtlScrollLeft() {
  if (cachedRtlScrollLeft === null && canCreateElement()) {
    const outer = document.createElement("div");
    outer.style.direction = "rtl";
    outer.style.display = "block";
    outer.style.clear = "both";
    outer.style.width = "100px";
    outer.style.visibility = "hidden";
    outer.style.position = "absolute";
    outer.style.left = "-10000px";
    outer.style.overflow = "scroll";
    outer.style.zoom = "1";
    const inner = document.createElement("div");
    inner.style.width = "200px";
    inner.style.height = "1px";
    outer.append(inner);
    document.body.appendChild(outer);
    const initial = outer.scrollLeft;
    outer.scrollLeft = -1;
    cachedRtlScrollLeft = outer.scrollLeft < 0 ? outer.scrollLeft : initial;
    document.body.removeChild(outer);
  }
  return cachedRtlScrollLeft;
}
var BrowserSupportService = class _BrowserSupportService {
  zone;
  changeDetector;
  changes = new EventEmitter();
  subscriptions;
  constructor(zone, changeDetector) {
    this.zone = zone;
    this.changeDetector = changeDetector;
    if (typeof window === "undefined") {
      return;
    }
    this.zone.runOutsideAngular(() => {
      this.subscriptions = fromEvent(window, "resize").pipe(auditTime(100)).subscribe(() => {
        if (cachedPixelRatio !== window.devicePixelRatio) {
          zone.run(() => {
            cachedScrollbarWidth = null;
            this.changes.emit();
            this.changeDetector.markForCheck();
          });
        }
      });
    });
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
      this.subscriptions = null;
    }
  }
  get scrollbarWidth() {
    return scrollbarWidth();
  }
  get rtlScrollLeft() {
    return rtlScrollLeft();
  }
  static ɵfac = function BrowserSupportService_Factory(t) {
    return new (t || _BrowserSupportService)(ɵɵinject(NgZone), ɵɵinject(ChangeDetectorRef));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BrowserSupportService,
    factory: _BrowserSupportService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserSupportService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var isGroupItem = (source) => {
  return source.items !== void 0 && source.field !== void 0;
};
var isVirtualGroupItem = (source) => {
  return source.offset !== void 0 && source.skipHeader !== void 0;
};
var flattenGroups = (groups) => groups.reduce((acc, curr) => {
  if (isGroupItem(curr)) {
    return acc.concat(flattenGroups(curr.items));
  }
  return acc.concat([curr]);
}, []);
var itemAt = (data, index) => {
  const first = data[0];
  if (isPresent4(first) && isGroupItem(first)) {
    return flattenGroups(data)[index];
  }
  return data[index];
};
var getIterator = (data, {
  footers,
  level,
  dataIndex,
  parentGroupIndex,
  groupIndex,
  parentGroup
}) => {
  const first = data[0];
  if (isPresent4(first) && isGroupItem(first)) {
    if (isVirtualGroupItem(first)) {
      groupIndex = isPresent4(first.offset) ? first.offset : groupIndex;
    }
    return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);
  }
  return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);
};
var ArrayIterator = class {
  arr;
  idx;
  constructor(arr, idx2 = 0) {
    this.arr = arr;
    this.idx = idx2;
    this.arr = arr || [];
  }
  [iterator]() {
    return this;
  }
  next() {
    return this.idx < this.arr.length ? {
      done: false,
      value: this.arr[this.idx++]
    } : {
      done: true,
      value: void 0
    };
  }
};
var Iterator = class {
  dataIndex;
  resultMap;
  _innerIterator;
  constructor(arr, dataIndex = 0, resultMap = (x) => x) {
    this.dataIndex = dataIndex;
    this.resultMap = resultMap;
    const iter = arr[iterator];
    this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);
  }
  [iterator]() {
    return this;
  }
  next() {
    return this.resultMap(this._innerIterator.next(), this.dataIndex++);
  }
};
var ItemIterator = class extends Iterator {
  constructor(arr, dataIndex, groupIndex, group) {
    super(arr, dataIndex, (x, idx2) => ({
      done: x.done,
      value: {
        data: x.value,
        groupIndex,
        index: idx2,
        type: "data",
        group
      }
    }));
  }
  /**
   * The index of the next record.
   * @readonly
   * @type {number}
   */
  get index() {
    return this.dataIndex;
  }
};
var prefix = (s, n) => {
  const p = s ? s + "_" : s;
  return `${p}${n}`;
};
var GroupIterator = class {
  arr;
  outputFooters;
  level;
  dataIndex;
  parentIndex;
  groupIndex;
  parentGroup;
  current;
  _innerIterator;
  _iterator;
  currentGroupIndex = "";
  constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = "", groupIndex = 0, parentGroup = void 0) {
    this.arr = arr;
    this.outputFooters = outputFooters;
    this.level = level;
    this.dataIndex = dataIndex;
    this.parentIndex = parentIndex;
    this.groupIndex = groupIndex;
    this.parentGroup = parentGroup;
    this.arr = arr || [];
    this._iterator = new Iterator(this.arr, this.dataIndex);
  }
  [iterator]() {
    return this;
  }
  nextGroupItem() {
    this.current = this._iterator.next().value;
    this._innerIterator = null;
    if (this.current) {
      this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);
      return {
        done: false,
        value: {
          data: this.current,
          index: this.currentGroupIndex,
          level: this.level,
          type: "group",
          parentGroup: this.parentGroup
        }
      };
    } else {
      this.current = null;
      return {
        done: true,
        value: void 0
      };
    }
  }
  footerItem() {
    if (this.current) {
      const group = this.current;
      this.current = null;
      return {
        done: false,
        value: {
          data: group,
          groupIndex: this.currentGroupIndex,
          level: this.level,
          type: "footer",
          group: {
            data: group,
            index: this.currentGroupIndex,
            level: this.level,
            type: "group",
            parentGroup: this.parentGroup
          }
        }
      };
    } else {
      this.current = null;
      return {
        done: true,
        value: void 0
      };
    }
  }
  innerIterator(group) {
    if (!this._innerIterator) {
      this._innerIterator = getIterator(group.items, {
        dataIndex: this.dataIndex,
        footers: this.outputFooters,
        level: this.level + 1,
        parentGroupIndex: this.currentGroupIndex,
        parentGroup: {
          data: this.current,
          index: this.currentGroupIndex,
          level: this.level,
          type: "group",
          parentGroup: this.parentGroup
        }
      });
    }
    return this._innerIterator;
  }
  nextDataItem(group) {
    const iterator2 = this.innerIterator(group);
    const result = iterator2.next();
    if (isPresent4(result.value) && !result.done && result.value.type === "data") {
      this.dataIndex = result.value.index + 1;
    }
    return !result.done ? result : void 0;
  }
  next() {
    if (!isPresent4(this.current)) {
      return this.nextGroupItem();
    }
    const item = this.nextDataItem(this.current);
    return item ? item : this.outputFooters ? this.footerItem() : this.nextGroupItem();
  }
  /**
   * The index of the last iterated data record.
   * @readonly
   * @type {number}
   */
  get index() {
    return this.dataIndex + 1;
  }
};
var DataResultIterator = class {
  source;
  skip;
  groupFooters;
  isObject;
  constructor(source, skip3 = 0, groupFooters = false) {
    this.source = source;
    this.skip = skip3;
    this.groupFooters = groupFooters;
    this.source = this.source ? this.source : [];
    this.isObject = this.isGridDataResult(this.source);
  }
  isGridDataResult(source) {
    return source.total !== void 0 && source.data !== void 0;
  }
  get total() {
    return this.isObject ? this.source.total : this.source.length;
  }
  get data() {
    return this.isObject ? this.source.data : this.source;
  }
  map(fn) {
    return this.data.map(fn);
  }
  filter(fn) {
    return this.data.filter(fn);
  }
  reduce(fn, init) {
    return this.data.reduce(fn, init);
  }
  forEach(fn) {
    this.data.forEach(fn);
  }
  some(fn) {
    return this.data.some(fn);
  }
  [iterator]() {
    return getIterator(this.data, {
      dataIndex: this.skip,
      footers: this.groupFooters,
      groupIndex: this.skip
    });
  }
  toString() {
    return this.data.toString();
  }
};
var DataCollection = class {
  accessor;
  constructor(accessor) {
    this.accessor = accessor;
  }
  get total() {
    return this.accessor().total;
  }
  get length() {
    return this.accessor().data.length;
  }
  get first() {
    return this.accessor().data[0];
  }
  get last() {
    return this.accessor().data[this.length - 1];
  }
  at(index) {
    return itemAt(this.accessor().data, index);
  }
  map(fn) {
    return this.accessor().map(fn);
  }
  filter(fn) {
    return this.accessor().filter(fn);
  }
  reduce(fn, init) {
    return this.accessor().reduce(fn, init);
  }
  forEach(fn) {
    this.accessor().forEach(fn);
  }
  some(fn) {
    return this.accessor().some(fn);
  }
  [iterator]() {
    return this.accessor()[iterator]();
  }
  toString() {
    return this.accessor().toString();
  }
};
var PairSet = class {
  /**
   * Gets the total number of X/Y key pairs.
   */
  get size() {
    return this.totalKeysCount;
  }
  /**
   * Holds a set of Y keys for each defined X key.
   * Each X key creates a map which holds a set of Y keys.
   *
   * Map { 1 => Set { 1, 2, 3 } } // pairs: [1, 1], [1, 2], [1, 3]
   */
  keysX = /* @__PURE__ */ new Map();
  /**
   * Count the each added or deleted key manually to avoid iterating over all items when calling `this.size`.
   */
  totalKeysCount = 0;
  constructor(items, keyXField, keyYField) {
    if (items && keyXField && keyYField) {
      items.forEach((item) => this.add(item[keyXField], item[keyYField]));
    }
  }
  /**
   * Adds a couple of items identified as a combination.
   */
  add(keyX, keyY) {
    if (!this.keysX.has(keyX)) {
      this.keysX.set(keyX, /* @__PURE__ */ new Set());
    }
    if (!this.has(keyX, keyY)) {
      this.keysX.get(keyX).add(keyY);
      this.totalKeysCount += 1;
    }
  }
  /**
   * Adds a combination of a couple of items identified together.
   */
  delete(keyX, keyY) {
    if (this.has(keyX, keyY)) {
      this.keysX.get(keyX).delete(keyY);
      this.totalKeysCount -= 1;
    }
  }
  /**
   * Checks whether the defined combination is stored.
   */
  has(keyX, keyY) {
    return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);
  }
  /**
   * Clears all key combinations.
   */
  clear() {
    this.keysX.clear();
    this.totalKeysCount = 0;
  }
  /**
   * Converts the persisted data structure to an array of objects,
   * using the provided field names for the object props.
   */
  toArray(keyXField, keyYField) {
    return Array.from(this.keysX).reduce((pairs, pair) => {
      const [keyX, keysY] = pair;
      Array.from(keysY).forEach((keyY) => pairs.push({
        [keyXField]: keyX,
        [keyYField]: keyY
      }));
      return pairs;
    }, []);
  }
};
var Selection = class _Selection {
  ctx;
  cd;
  /**
   * Defines the collection that will store the selected item keys.
   * @default []
   */
  selectedKeys = [];
  /**
   * Defines the initial shift-click range selection starting row index.
   *
   * @default 0
   */
  rangeSelectionStartRow;
  /**
   * Defines the initial shift-click range selection starting column index when cell selection is enabled.
   *
   * @default 0
   */
  rangeSelectionStartColumnIndex = 0;
  /**
   * Defines the item key that will be stored in the `selectedKeys` collection. [See example](slug:grid_selection_persistence#by-a-custom-key).
   */
  selectionKey;
  /**
   * Defines a function that determines the column key of a data cell.
   *
   * The function should return an unique value for each column.
   * By default, the Grid uses the column index as a column key.
   */
  columnKey;
  /**
   * Fires when the `selectedKeys` collection has been updated.
   */
  selectedKeysChange = new EventEmitter();
  rowSelectionState = /* @__PURE__ */ new Set();
  cellSelectionState = new PairSet();
  /**
   * @hidden
   */
  get isCellSelectionMode() {
    return isPresent4(this.ctx.grid.selectable) && this.ctx.grid.selectable["cell"];
  }
  lastSelectionState;
  selectionChangeSubscription;
  constructor(ctx, cd) {
    this.ctx = ctx;
    this.cd = cd;
    this.init();
  }
  ngOnChanges(changes) {
    if (isPresent4(changes["selectedKeys"]) && this.lastSelectionState !== this.selectedKeys) {
      this.setState(this.selectedKeys);
    }
  }
  init() {
    if (!isPresent4(this.ctx.grid.rowSelected)) {
      this.ctx.grid.rowSelected = (row2) => this.rowSelectionState.has(this.getItemKey(row2));
    }
    if (!isPresent4(this.ctx.grid.isRowSelectable)) {
      this.ctx.grid.isRowSelectable = () => Boolean(this.ctx.grid.selectable);
    }
    if (!isPresent4(this.ctx.grid.cellSelected)) {
      this.ctx.grid.cellSelected = (row2, column, colIndex) => {
        const contender = this.getSelectionItem(row2, column, colIndex);
        return {
          selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),
          item: contender
        };
      };
    }
    this.selectionChangeSubscription = this.ctx.grid.selectionChange.subscribe(this.onSelectionChange.bind(this));
  }
  /**
   * @hidden
   */
  destroy() {
    this.selectionChangeSubscription.unsubscribe();
  }
  /**
   * @hidden
   */
  reset() {
    this.rowSelectionState.clear();
    this.cellSelectionState.clear();
  }
  /**
   * @hidden
   */
  getItemKey(row2) {
    if (this.selectionKey) {
      if (typeof this.selectionKey === "string") {
        return row2.dataItem[this.selectionKey];
      }
      if (typeof this.selectionKey === "function") {
        return this.selectionKey(row2);
      }
    }
    return row2.index;
  }
  /**
   * @hidden
   */
  stateToArray() {
    return this.isCellSelectionMode ? this.cellSelectionState.toArray("itemKey", "columnKey") : Array.from(this.rowSelectionState);
  }
  getSelectionItem(row2, col, colIndex) {
    const itemIdentifiers = {};
    itemIdentifiers.itemKey = this.getItemKey(row2);
    if (!isPresent4(col) && !isPresent4(colIndex)) {
      return itemIdentifiers;
    }
    if (this.columnKey) {
      if (typeof this.columnKey === "string") {
        itemIdentifiers.columnKey = row2.dataItem[this.columnKey];
      }
      if (typeof this.columnKey === "function") {
        itemIdentifiers.columnKey = this.columnKey(col, colIndex);
      }
    }
    return {
      itemKey: itemIdentifiers.itemKey,
      columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
    };
  }
  onSelectionChange(selection) {
    if (selection.selectedRows) {
      selection.deselectedRows.forEach((item) => {
        const itemKey = this.getItemKey(item);
        this.rowSelectionState.delete(itemKey);
      });
      if (this.ctx.grid.selectableSettings.mode === "single" && this.rowSelectionState.size > 0) {
        this.reset();
      }
      selection.selectedRows.forEach((item) => {
        const itemKey = this.getItemKey(item);
        this.rowSelectionState.add(itemKey);
      });
    } else {
      selection.deselectedCells.forEach(({
        itemKey,
        columnKey
      }) => {
        this.cellSelectionState.delete(itemKey, columnKey);
      });
      if (this.ctx.grid.selectableSettings.mode === "single" && this.cellSelectionState.size > 0) {
        this.reset();
      }
      selection.selectedCells.forEach(({
        itemKey,
        columnKey
      }) => {
        this.cellSelectionState.add(itemKey, columnKey);
      });
    }
    this.cd.markForCheck();
    this.notifyChange();
  }
  notifyChange() {
    this.lastSelectionState = this.stateToArray();
    this.selectedKeysChange.emit(this.lastSelectionState);
  }
  setState(selectedKeys) {
    this.reset();
    if (this.isCellSelectionMode) {
      this.cellSelectionState = new PairSet(selectedKeys, "itemKey", "columnKey");
    } else {
      this.rowSelectionState = new Set(selectedKeys);
    }
  }
  static ɵfac = function Selection_Factory(t) {
    return new (t || _Selection)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _Selection,
    selectors: [["kendo-grid-selection-base"]],
    inputs: {
      selectedKeys: "selectedKeys",
      rangeSelectionStartRow: "rangeSelectionStartRow",
      rangeSelectionStartColumnIndex: "rangeSelectionStartColumnIndex",
      selectionKey: [InputFlags.None, "kendoGridSelectBy", "selectionKey"],
      columnKey: "columnKey"
    },
    outputs: {
      selectedKeysChange: "selectedKeysChange"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Selection, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-grid-selection-base"
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    selectedKeys: [{
      type: Input
    }],
    rangeSelectionStartRow: [{
      type: Input
    }],
    rangeSelectionStartColumnIndex: [{
      type: Input
    }],
    selectionKey: [{
      type: Input,
      args: ["kendoGridSelectBy"]
    }],
    columnKey: [{
      type: Input
    }],
    selectedKeysChange: [{
      type: Output
    }]
  });
})();
var set = (value) => (pair) => pair.forEach((x) => x.style.height = value);
var clearHeight = (pairs) => pairs.filter(([left2, right2]) => left2.style.height || right2.style.height).forEach(set(""));
var zip2 = (arr1, arr2) => {
  const result = [];
  for (let idx2 = 0, len = arr1.length; idx2 < len; idx2++) {
    if (!arr2[idx2]) {
      break;
    }
    result.push([arr1[idx2], arr2[idx2]]);
  }
  return result;
};
var setHeight$1 = (heights) => (row2, idx2) => set(`${heights[idx2] + 1}px`)(row2);
var getHeights = (rows) => rows.map(([left2, right2]) => {
  const height2 = left2.offsetHeight;
  const offsetHeight2 = right2.offsetHeight;
  if (height2 < offsetHeight2) {
    return offsetHeight2;
  }
  return height2;
});
var syncRowsHeight = (table1, table2) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const activeElement = document.activeElement;
  const rows = zip2(table1.rows, table2.rows);
  clearHeight(rows);
  const heights = getHeights(rows);
  [table1, table2].forEach((x) => x.style.display = "none");
  rows.forEach(setHeight$1(heights));
  [table1, table2].forEach((x) => x.style.display = "");
  if (document.activeElement !== activeElement && (table1.contains(activeElement) || table2.contains(activeElement))) {
    activeElement.focus();
  }
};
var PDFExportEvent = class extends PreventableEvent4 {
  /**
   * @hidden
   */
  constructor() {
    super();
  }
};
var bootstrapToMedia = (media) => ({
  "xs": "(max-width: 576px)",
  "sm": "(min-width: 576px)",
  "md": "(min-width: 768px)",
  "lg": "(min-width: 992px)",
  "xl": "(min-width: 1200px)"
})[media] || media;
var browserMatchMedia = (media) => window.matchMedia(media).matches;
var ResponsiveService = class _ResponsiveService {
  /**
   * @hidden
   */
  matchMedia = browserMatchMedia;
  /**
   * @hidden
   */
  matchesMedia(media) {
    return !media || this.matchMedia(bootstrapToMedia(media));
  }
  static ɵfac = function ResponsiveService_Factory(t) {
    return new (t || _ResponsiveService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ResponsiveService,
    factory: _ResponsiveService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResponsiveService, [{
    type: Injectable
  }], null, null);
})();
var ToolbarTemplateDirective = class _ToolbarTemplateDirective {
  templateRef;
  _position = "top";
  /**
   * The position of the toolbar ([see example]({% slug toolbartemplate_grid %}#toc-setting-the-toolbar-position)).
   *
   * @default 'top'
   */
  set position(position2) {
    this._position = position2;
  }
  get position() {
    return this._position;
  }
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ToolbarTemplateDirective_Factory(t) {
    return new (t || _ToolbarTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ToolbarTemplateDirective,
    selectors: [["", "kendoGridToolbarTemplate", ""]],
    inputs: {
      position: "position"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridToolbarTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    position: [{
      type: Input,
      args: ["position"]
    }]
  });
})();
var NavigationMetadata = class {
  dataRows;
  headerRows;
  isVirtual;
  hasPager;
  hasDetailTemplate;
  gridElement;
  virtualColumns;
  columns;
  get maxLogicalRowIndex() {
    const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;
    return this.headerRows + dataRows - 1;
  }
  constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns) {
    this.dataRows = dataRows;
    this.headerRows = headerRows;
    this.isVirtual = isVirtual;
    this.hasPager = hasPager;
    this.hasDetailTemplate = hasDetailTemplate;
    this.gridElement = gridElement;
    this.virtualColumns = virtualColumns;
    this.columns = columns;
  }
};
var ColumnVisibilityChangeEvent = class {
  /**
   * The columns whose visibility is changed.
   */
  columns;
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var ColumnLockedChangeEvent = class {
  /**
   * The columns whose locked state is changed.
   */
  columns;
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var GROUP_CELL_WIDTH = 32;
var ColumnStickyChangeEvent = class {
  /**
   * The columns whose sticky state is changed.
   */
  columns;
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var isNextSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.nextElementSibling;
var isPreviousSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.previousElementSibling;
var isDifferentParent = (dropTarget, dragTarget) => dropTarget?.parentElement !== dragTarget?.parentElement;
function getOffset(element) {
  const {
    clientTop,
    clientLeft
  } = getDocument(element);
  const {
    pageYOffset,
    pageXOffset
  } = getWindow(element);
  const {
    top,
    left: left2
  } = element.getBoundingClientRect();
  return {
    top: top + pageYOffset - clientTop,
    left: left2 + pageXOffset - clientLeft
  };
}
var hintIcons = {
  forbidden: "cancel",
  before: "insert-middle",
  after: "insert-middle"
};
var hintSVGIcons = {
  forbidden: cancelIcon,
  before: insertMiddleIcon,
  after: insertMiddleIcon
};
var dropPosition = {
  forbidden: "forbidden",
  before: "before",
  after: "after"
};
var hintStyles = {
  zIndex: "20000",
  display: "flex",
  position: "fixed"
};
var hintClasses = ["k-drag-clue", "k-reorder-clue"];
var dropIndicatorStyles = {
  zIndex: "19000",
  position: "absolute"
};
var dropIndicatorClasses = ["k-drop-hint", "k-drop-hint-h"];
var defaultSelectors = {
  handle: ".k-table-td.k-drag-cell",
  dragTarget: ".k-master-row",
  dropTarget: ".k-master-row"
};
var getDocument = (element) => element?.ownerDocument.documentElement;
var getWindow = (element) => element?.ownerDocument.defaultView;
var RowReorderService = class _RowReorderService {
  renderer;
  hintElement = null;
  defaultSelectors = defaultSelectors;
  hintText = "";
  skip;
  dropIndicator;
  lastDropPosition = dropPosition.forbidden;
  dragTarget = null;
  dropTarget = null;
  offsetY;
  rowReorder = new EventEmitter();
  constructor(renderer) {
    this.renderer = renderer;
  }
  ngOnDestroy() {
    this.destroyDropIndicator();
    this.destroyHintElement();
  }
  press(ev) {
    this.dragTarget = ev.dragTarget;
    this.offsetY = ev.dragEvent.offsetY;
  }
  dragStart() {
    this.createDropIndicator();
  }
  drag(ev) {
    if (isPresent(ev.hintElement) && !isPresent(this.hintElement)) {
      this.hintElement = ev.hintElement;
      this.decorateHint();
    }
    const position2 = {
      x: ev.dragEvent.clientX,
      y: ev.dragEvent.clientY - this.offsetY
    };
    if (isPresent(this.hintElement)) {
      this.renderer.setStyle(this.hintElement, "left", `${position2.x}px`);
      this.renderer.setStyle(this.hintElement, "top", `${position2.y}px`);
    }
    this.positionDropIndicator(ev);
  }
  dragEnter(ev) {
    this.dropTarget = ev.dropTarget;
  }
  dragLeave() {
    this.dropTarget = null;
    this.hide();
  }
  dragEnd() {
    this.destroyDropIndicator();
    this.destroyHintElement();
    this.dragTarget = null;
    this.dropTarget = null;
    this.hintElement = null;
  }
  drop(ev) {
    this.destroyDropIndicator();
    this.destroyHintElement();
    const rowReorderArgs = this.rowReorderArgs(this.dragTarget, this.dropTarget, ev.dragData);
    this.rowReorder.emit(rowReorderArgs);
  }
  reorderRows(ev, collection) {
    if (this.lastDropPosition === dropPosition.forbidden) {
      return;
    }
    const {
      draggedRows,
      dropTargetRow
    } = ev;
    const draggedDataItem = draggedRows[0].dataItem;
    const dropTargetDataItem = dropTargetRow.dataItem;
    const draggedItemIndex = collection.indexOf(draggedDataItem);
    const dropTargetIndex = collection.indexOf(dropTargetDataItem);
    const idxToAdd = this.calculateIndexToAdd(draggedItemIndex, dropTargetIndex);
    collection.splice(draggedItemIndex, 1);
    collection.splice(idxToAdd, 0, draggedDataItem);
  }
  get hintIcon() {
    return hintIcons[this.lastDropPosition];
  }
  get hintSVGIcon() {
    return hintSVGIcons[this.lastDropPosition];
  }
  getDefaultHintText(columns, data) {
    let hintText = "";
    const columnFieldsArray = columns.toArray().filter((column) => !column.hidden && isPresent(column.field)).map((column) => column.field);
    const draggedDragRow = this.getDragRowPerElement(this.dragTarget, data);
    const draggedDataItem = draggedDragRow?.dataItem;
    isPresent(draggedDataItem) && columnFieldsArray.forEach((column) => {
      const columnValue = draggedDataItem[column];
      isPresent(columnValue) ? hintText += `${columnValue} ` : null;
    });
    return hintText.trim();
  }
  getDraggedRow(data) {
    return this.getDragRowPerElement(this.dragTarget, data);
  }
  rowReorderArgs(dragRow, dropRow, data) {
    const dragRowData = this.getDragRowPerElement(dragRow, data);
    const dropRowData = this.getDragRowPerElement(dropRow, data);
    return {
      draggedRows: [dragRowData],
      dropTargetRow: dropRowData,
      dropPosition: this.lastDropPosition
    };
  }
  getDragRowPerElement(row2, data) {
    let rowIndex = row2?.getAttribute("data-kendo-grid-item-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
    const skip3 = this.skip || 0;
    const dataItem = rowIndex === -1 ? null : data[rowIndex - skip3];
    return {
      dataItem,
      rowIndex,
      element: row2
    };
  }
  createDropIndicator() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dropIndicator = document.createElement("div");
    this.decorateDropIndicator();
    this.dropIndicator.innerHTML = `
            <div class="k-drop-hint-start"></div>
            <div class="k-drop-hint-line"></div>
        `;
    document.body.appendChild(this.dropIndicator);
    this.hide();
  }
  destroyDropIndicator() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.dropIndicator && this.dropIndicator.parentElement) {
      document.body.removeChild(this.dropIndicator);
      this.dropIndicator = null;
    }
  }
  destroyHintElement() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.hintElement?.parentElement) {
      this.hintElement.parentElement.removeChild(this.hintElement);
      this.hintElement = null;
    }
  }
  decorateHint() {
    hintClasses.forEach((className) => this.renderer.addClass(this.hintElement, className));
    Object.keys(hintStyles).forEach((style2) => this.renderer.setStyle(this.hintElement, style2, hintStyles[style2]));
  }
  positionDropIndicator(ev) {
    this.lastDropPosition = this.getDropPosition(ev.dragEvent);
    this.updateDropIndicatorPosition();
  }
  calculateIndexToAdd(dragIndex, dropIndex) {
    if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.after) {
      return dropIndex + 1;
    } else if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.before) {
      return dropIndex;
    } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.after) {
      return dropIndex;
    } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.before) {
      return dropIndex - 1;
    }
  }
  decorateDropIndicator() {
    dropIndicatorClasses.forEach((className) => this.renderer.addClass(this.dropIndicator, className));
    Object.keys(dropIndicatorStyles).forEach((style2) => this.renderer.setStyle(this.dropIndicator, style2, dropIndicatorStyles[style2]));
  }
  getDropPosition(e) {
    if (this.dropTarget === this.dragTarget || !isPresent(this.dropTarget)) {
      return dropPosition.forbidden;
    }
    if (isDifferentParent(this.dropTarget, this.dragTarget)) {
      return dropPosition.forbidden;
    }
    const itemViewPortCoords = this.dropTarget.getBoundingClientRect();
    const itemDivisionsCount = 2;
    const itemDivisionHeight = itemViewPortCoords.height / itemDivisionsCount;
    const pointerPosition = e.clientY;
    const itemTop = itemViewPortCoords.top;
    let currentDropPosition = null;
    if (pointerPosition < itemTop + itemDivisionHeight) {
      currentDropPosition = dropPosition.before;
    } else if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
      currentDropPosition = dropPosition.after;
    }
    if (currentDropPosition === dropPosition.before && isNextSibling(this.dropTarget, this.dragTarget)) {
      currentDropPosition = dropPosition.forbidden;
    } else if (currentDropPosition === dropPosition.after && isPreviousSibling(this.dropTarget, this.dragTarget)) {
      currentDropPosition = dropPosition.forbidden;
    }
    return currentDropPosition;
  }
  updateDropIndicatorPosition() {
    if (this.shouldHideDropIndicator() || !this.dropTarget) {
      this.hide();
      return;
    }
    this.show();
    const destinationItemOffset = getOffset(this.dropTarget);
    let indicatorOffsetTop = destinationItemOffset.top;
    const indicatorOffsetLeft = destinationItemOffset.left + this.dropIndicator.offsetWidth / 2;
    if (this.lastDropPosition === dropPosition.after) {
      indicatorOffsetTop += this.dropTarget.offsetHeight;
    }
    this.renderer.setStyle(this.dropIndicator, "left", `${indicatorOffsetLeft}px`);
    this.renderer.setStyle(this.dropIndicator, "top", `${indicatorOffsetTop}px`);
  }
  shouldHideDropIndicator() {
    return this.lastDropPosition === dropPosition.forbidden;
  }
  hide() {
    if (isPresent(this.dropIndicator)) {
      this.dropIndicator.style.display = "none";
    }
  }
  show() {
    if (isPresent(this.dropIndicator)) {
      this.dropIndicator.style.display = "";
    }
  }
  static ɵfac = function RowReorderService_Factory(t) {
    return new (t || _RowReorderService)(ɵɵinject(Renderer2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RowReorderService,
    factory: _RowReorderService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowReorderService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, {
    rowReorder: [{
      type: Output
    }]
  });
})();
var StatusBarTemplateDirective = class _StatusBarTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function StatusBarTemplateDirective_Factory(t) {
    return new (t || _StatusBarTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _StatusBarTemplateDirective,
    selectors: [["", "kendoGridStatusBarTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StatusBarTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridStatusBarTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClipboardService = class _ClipboardService {
  contextService;
  targetColField;
  targetRowIndex;
  constructor(contextService) {
    this.contextService = contextService;
  }
  createClipboardData(data, columns, options) {
    let result = {
      gridItems: [],
      dataString: ""
    };
    const fieldCols = columns.flatMap((c) => c instanceof ColumnComponent2 && isPresent(c.field) ? [c] : []);
    const clipboardData = {
      items: [],
      dataStrings: []
    };
    const colFields = fieldCols.map((c) => c.field);
    if (options.wholeRow) {
      this.targetColField = fieldCols[0]?.field;
      this.targetRowIndex = data[0].dataRowIndex;
      data.forEach((item) => {
        clipboardData.items.push({
          dataItem: __spreadValues({}, item.dataItem),
          fields: colFields
        });
        clipboardData.dataStrings.push(this.itemToString(item.dataItem, fieldCols));
      });
      result = {
        gridItems: options.operationType === "cut" ? clipboardData.items.map((item) => {
          item.fields.forEach((field) => item.dataItem[field] = null);
          return item;
        }) : [...clipboardData.items],
        dataString: options.copyHeaders ? this.addHeaders(clipboardData.dataStrings.join(`\r
`), fieldCols) : clipboardData.dataStrings.join(`
`)
      };
    } else {
      if (options.target === "selection") {
        const {
          tabular,
          groups
        } = this.groupSelection();
        const selectionDirective = this.contextService.grid.selectionDirective;
        const colIdentifier = selectionDirective.columnKey;
        if (tabular) {
          const selectionKeys = groups[0].items.map((item) => item.columnKey);
          const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
          const selectedColFields = selectedFieldCols.map((c) => c.field);
          this.targetColField = selectedColFields[0];
          result.dataString = data.flatMap((item) => {
            const itemString = this.itemToString(item.dataItem, selectedFieldCols);
            const existingItem = isPresent(itemString);
            if (!isPresent(this.targetRowIndex) && isPresent(itemString)) {
              this.targetRowIndex = item.dataRowIndex;
            }
            if (options.operationType === "cut") {
              selectedColFields.forEach((f) => item.dataItem[f] = null);
            }
            result.gridItems.push({
              dataItem: item.dataItem,
              fields: selectedColFields
            });
            return existingItem ? [itemString] : [];
          }).join(`\r
`);
          if (options.copyHeaders) {
            result.dataString = this.addHeaders(result.dataString, selectedFieldCols);
          }
        } else {
          const rowIdentifier = selectionDirective.selectionKey;
          result.dataString = data.flatMap((item) => {
            const key = rowIdentifier ? typeof rowIdentifier === "string" ? item.dataItem[rowIdentifier] : rowIdentifier({
              index: item.dataRowIndex,
              dataItem: item.dataItem
            }) : item.dataRowIndex;
            const selectionKeys = groups.find((gr) => gr.value === key).items.map((item2) => item2.columnKey);
            const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
            const selectedColFields = selectedFieldCols.map((c) => c.field);
            if (!this.targetColField) {
              this.targetColField = selectedColFields[0];
            }
            const itemString = this.itemToString(item.dataItem, selectedFieldCols);
            const existingItem = isPresent(itemString);
            if (!isPresent(this.targetRowIndex) && existingItem) {
              this.targetRowIndex = item.dataRowIndex;
            }
            if (existingItem) {
              if (options.operationType === "cut") {
                selectedColFields.forEach((f) => item.dataItem[f] = null);
              }
              result.gridItems.push({
                dataItem: item.dataItem,
                fields: selectedColFields
              });
            }
            return existingItem ? options.copyHeaders ? [this.addHeaders(itemString, selectedFieldCols)] : [itemString] : [];
          }).join(`\r
`);
        }
      } else {
        const item = data[0];
        const col = columns[item.colIndex];
        const colField = col.field;
        const title = col.title;
        const copiedData = item.dataItem[colField];
        this.targetRowIndex = item.dataRowIndex;
        this.targetColField = colField;
        if (options.operationType === "cut" && colField) {
          item.dataItem[colField] = null;
        }
        result = {
          gridItems: [{
            dataItem: item.dataItem,
            fields: colField ? [colField] : []
          }],
          dataString: options.copyHeaders ? [title || colField, copiedData].join(`\r
`) : colField ? copiedData : ``
        };
      }
    }
    return result;
  }
  getGridData(data, columns, targetType, targetRowIndex, options) {
    const separator = data.includes(`\r
`) ? `\r
` : data.includes(`
`) ? `
` : null;
    const dataRows = separator ? data.split(separator).filter((rowData) => rowData.length) : [data];
    this.targetRowIndex = targetRowIndex;
    if (targetType === "activeCell") {
      if (options.wholeRow) {
        this.targetColField = columns.find((c) => c instanceof ColumnComponent2 && c.field)?.field;
      } else {
        const activeCellIndex = this.contextService.grid.activeCell.colIndex;
        for (let i = 0; i < columns.length; i++) {
          const col = columns[i];
          if (col instanceof ColumnComponent2 && col.field && i >= activeCellIndex) {
            this.targetColField = col.field;
            break;
          }
        }
      }
    } else {
      if (options.wholeRow || !options.isCellSelection) {
        this.targetColField = columns.filter((c) => c instanceof ColumnComponent2 && c.field)[0]["field"];
      } else {
        const {
          groups
        } = this.groupSelection();
        const selectionDirective = this.contextService.grid.selectionDirective;
        const colIdentifier = selectionDirective.columnKey;
        const visibleCols = columns.filter((c) => c.isVisible);
        const selectionKeys = groups[0].items.map((item) => item.columnKey);
        const selectedFieldCols = visibleCols.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
        const selectedColFields = selectedFieldCols.map((c) => c.field);
        this.targetColField = selectedColFields[0];
      }
    }
    const items = dataRows.map((rowString) => {
      const cells = rowString.includes(`	`) ? rowString.split(`	`) : [rowString];
      const colFields = columns.flatMap((c) => c instanceof ColumnComponent2 && c.field ? [c.field] : []);
      const targetColFieldIndex = colFields.indexOf(this.targetColField);
      const affectedFields = colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length);
      const item = {};
      colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length).forEach((colField, index) => item[colField] = cells[index]);
      return {
        dataItem: item,
        fields: affectedFields
      };
    });
    return items;
  }
  itemToString = (item, cols) => {
    if (!cols.length) {
      return null;
    }
    return cols.map((col) => item[col.field]).join(`	`);
  };
  groupSelection() {
    const selection = this.contextService.grid.selection;
    const groups = groupBy(selection, [{
      field: "itemKey"
    }]).map((gr) => {
      gr.items.sort((a, b) => a.columnKey - b.columnKey);
      return gr;
    });
    for (let i = 1; i < groups.length; i++) {
      if (!this.areEqual(groups[i].items, groups[i - 1].items)) {
        return {
          tabular: false,
          groups
        };
      }
    }
    return {
      tabular: true,
      groups
    };
  }
  areEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i].columnKey !== arr2[i].columnKey) {
        return false;
      }
    }
    return true;
  }
  addHeaders(initialData, cols) {
    const headersRowData = cols.map((c) => c.title || c.field).join(`	`);
    return `${headersRowData}\r
${initialData}`;
  }
  static ɵfac = function ClipboardService_Factory(t) {
    return new (t || _ClipboardService)(ɵɵinject(ContextService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ClipboardService,
    factory: _ClipboardService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClipboardService, [{
    type: Injectable
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var StatusBarComponent = class _StatusBarComponent {
  aggregateService;
  hostClasses = true;
  get isStatusBarTemplate() {
    return this.statusBarTemplate ? "" : "none";
  }
  statusBarTemplate;
  constructor(aggregateService) {
    this.aggregateService = aggregateService;
  }
  ngOnInit() {
    this.aggregateService.init();
  }
  get aggregates() {
    return this.aggregateService.aggregates;
  }
  static ɵfac = function StatusBarComponent_Factory(t) {
    return new (t || _StatusBarComponent)(ɵɵdirectiveInject(CellSelectionAggregateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _StatusBarComponent,
    selectors: [["kendo-grid-status-bar"]],
    hostVars: 6,
    hostBindings: function StatusBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("display", ctx.isStatusBarTemplate);
        ɵɵclassProp("k-selection-aggregates", ctx.hostClasses)("k-grid-selection-aggregates", ctx.hostClasses);
      }
    },
    inputs: {
      statusBarTemplate: "statusBarTemplate"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 1,
    vars: 1,
    consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function StatusBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, StatusBarComponent_0_Template, 1, 4, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.statusBarTemplate);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StatusBarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-status-bar",
      template: `
        <ng-template
            *ngIf="statusBarTemplate"
            [ngTemplateOutlet]="statusBarTemplate?.templateRef"
            [ngTemplateOutletContext]="{ aggregates: aggregates }">
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: CellSelectionAggregateService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-selection-aggregates"]
    }, {
      type: HostBinding,
      args: ["class.k-grid-selection-aggregates"]
    }],
    isStatusBarTemplate: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    statusBarTemplate: [{
      type: Input
    }]
  });
})();
var createElement = () => {
  if (!isDocumentAvailable()) {
    return;
  }
  const marquee = document.createElement("div");
  marquee.className = "k-marquee";
  const marqueeColor = document.createElement("div");
  marqueeColor.className = "k-marquee-color";
  marquee.appendChild(marqueeColor);
  return marquee;
};
var POINTER_OFFSET = 2;
var MINIMAL_DRAG_DISTANCE = 5;
var offsets = {
  topLeft: {
    x: POINTER_OFFSET,
    y: POINTER_OFFSET
  },
  topRight: {
    x: -POINTER_OFFSET,
    y: POINTER_OFFSET
  },
  bottomLeft: {
    x: POINTER_OFFSET,
    y: -POINTER_OFFSET
  },
  bottomRight: {
    x: -POINTER_OFFSET,
    y: -POINTER_OFFSET
  }
};
var GridMarqueeDirective = class _GridMarqueeDirective {
  draggable;
  selection;
  cellSelection;
  domEvents;
  host;
  renderer;
  // possibly add snap
  pressArgs;
  marqueeElement;
  pressTarget;
  subscriptions;
  selectionStarted = false;
  dragEndSubscription;
  constructor(draggable, selection, cellSelection, domEvents, host, renderer) {
    this.draggable = draggable;
    this.selection = selection;
    this.cellSelection = cellSelection;
    this.domEvents = domEvents;
    this.host = host;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));
    this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.clean();
  }
  start(args) {
    const isInvalidTarget = args.originalEvent.target.matches(".k-grid-content, .k-grid-content-locked, .k-grid-aria-root, .k-checkbox");
    const isRowReorderColumn2 = isPresent(args.originalEvent.target.closest(".k-drag-cell"));
    if (isInvalidTarget || isRowReorderColumn2) {
      this.pressArgs = null;
      return;
    }
    this.pressArgs = args;
    this.pressTarget = null;
  }
  moveMarquee(args) {
    if (!this.pressTarget) {
      this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;
    }
    const press = this.pressArgs;
    if (!press) {
      return;
    }
    if (!this.selectionStarted) {
      const distance = Math.sqrt((args.pageX - press.pageX) ** 2 + (args.pageY - press.pageY) ** 2);
      if (distance > MINIMAL_DRAG_DISTANCE) {
        this.selectionStarted = true;
        this.renderer.addClass(this.host.nativeElement, "user-select-none");
        this.renderer.setStyle(this.host.nativeElement, "user-select", "none");
        this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1))).subscribe(this.endSelection.bind(this));
      } else {
        return;
      }
    }
    this.initMarquee();
    const element = this.marqueeElement;
    const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);
    let left2 = Math.min(args.pageX, press.pageX);
    let top = Math.min(args.pageY, press.pageY);
    const width2 = Math.abs(args.pageX - press.pageX);
    const height2 = Math.abs(args.pageY - press.pageY);
    if (marqueeQuadrant) {
      left2 += offsets[marqueeQuadrant].x;
      top += offsets[marqueeQuadrant].y;
    }
    element.style.left = `${left2}px`;
    element.style.top = `${top}px`;
    element.style.width = `${width2}px`;
    element.style.height = `${height2}px`;
  }
  endSelection(args) {
    if (args.type === "mouseup" || args.type === "touchend") {
      const modifier = args.originalEvent.ctrlKey || args.originalEvent.metaKey;
      const preserveCurrentSelection = modifier && (isMultipleRangesEnabled(this.selection.settings) || isMultipleRangesEnabled(this.cellSelection.settings));
      if (this.cellSelection.active) {
        this.cellSelection.dragging = true;
        this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex, preserveCurrentSelection));
      } else if (this.selection.active) {
        this.selection.dragging = true;
        this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex, preserveCurrentSelection));
      }
    }
    this.clean();
  }
  clean() {
    if (this.marqueeElement) {
      document.body.removeChild(this.marqueeElement);
      this.marqueeElement = null;
    }
    if (this.dragEndSubscription) {
      this.dragEndSubscription.unsubscribe();
    }
    this.renderer.removeClass(this.host.nativeElement, "user-select-none");
    this.renderer.removeStyle(this.host.nativeElement, "user-select");
    this.dragEndSubscription = null;
    this.pressTarget = null;
    this.pressArgs = null;
    this.selectionStarted = false;
    this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;
  }
  initMarquee() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (!this.marqueeElement) {
      this.marqueeElement = createElement();
      document.body.appendChild(this.marqueeElement);
    }
  }
  getMarqueeQuadrant(pointerX, pointerY, startX, startY) {
    const leftHalf = pointerX < startX;
    const rightHalf = pointerX > startX;
    const topHalf = pointerY < startY;
    const bottomHalf = pointerY > startY;
    if (leftHalf && topHalf) {
      return "topLeft";
    }
    if (leftHalf && bottomHalf) {
      return "bottomLeft";
    }
    if (rightHalf && topHalf) {
      return "topRight";
    }
    if (rightHalf && bottomHalf) {
      return "bottomRight";
    }
    return null;
  }
  static ɵfac = function GridMarqueeDirective_Factory(t) {
    return new (t || _GridMarqueeDirective)(ɵɵdirectiveInject(DraggableDirective), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridMarqueeDirective,
    selectors: [["", "kendoGridSelectionMarquee", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridMarqueeDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectionMarquee]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DraggableDirective
    }, {
      type: SelectionService2
    }, {
      type: CellSelectionService
    }, {
      type: DomEventsService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, null);
})();
var update2 = (arr, idx2, value) => [...arr.slice(0, idx2 + 1), ...arr.slice(idx2 + 1).map((x) => x + value)];
var RowHeightService2 = class {
  total;
  rowHeight;
  detailRowHeight;
  offsets = [];
  heights = [];
  constructor(total = 0, rowHeight, detailRowHeight) {
    this.total = total;
    this.rowHeight = rowHeight;
    this.detailRowHeight = detailRowHeight;
    let agg = 0;
    for (let idx2 = 0; idx2 < total; idx2++) {
      this.offsets.push(agg);
      agg += rowHeight;
      this.heights.push(rowHeight);
    }
  }
  height(rowIndex) {
    return this.heights[rowIndex];
  }
  expandDetail(rowIndex) {
    if (this.height(rowIndex) === this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight);
    }
  }
  collapseDetail(rowIndex) {
    if (this.height(rowIndex) > this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
    }
  }
  isExpanded(rowIndex) {
    return this.height(rowIndex) > this.rowHeight;
  }
  index(position2) {
    if (position2 < 0) {
      return void 0;
    }
    const result = this.offsets.reduce((prev, current3, idx2) => {
      if (prev !== void 0) {
        return prev;
      } else if (current3 === position2) {
        return idx2;
      } else if (current3 > position2) {
        return idx2 - 1;
      }
      return void 0;
    }, void 0);
    return result === void 0 ? this.total - 1 : result;
  }
  offset(rowIndex, adjustIndex = false) {
    if (adjustIndex) {
      let targetOffset = 0;
      let targetIndex = 0;
      for (let i = 0; i < rowIndex; i++) {
        targetOffset += this.rowHeight;
        targetIndex++;
        if (targetIndex === rowIndex) {
          return targetOffset;
        }
        if (this.isExpanded(i)) {
          targetOffset += this.detailRowHeight;
          targetIndex++;
          if (targetIndex === rowIndex) {
            return targetOffset;
          }
        }
      }
      return targetOffset;
    }
    return this.offsets[rowIndex];
  }
  totalHeight() {
    return this.heights.reduce((prev, curr) => prev + curr, 0);
  }
  updateRowHeight(rowIndex, value) {
    if (this.total > 0) {
      this.heights[rowIndex] += value;
      this.offsets = update2(this.offsets, rowIndex, value);
    }
  }
};
var ScrollAction2 = class {
  offset;
  constructor(offset3) {
    this.offset = offset3;
  }
};
var PageAction2 = class {
  skip;
  take;
  constructor(skip3, take2) {
    this.skip = skip3;
    this.take = take2;
  }
};
var ScrollBottomAction = class {
};
var SCROLL_BOTTOM_THRESHOLD = 2;
var ScrollerService2 = class {
  scrollObservable;
  firstLoaded = 0;
  lastLoaded;
  lastScrollTop;
  take;
  total;
  rowHeightService;
  scrollSubscription;
  subscription;
  constructor(scrollObservable) {
    this.scrollObservable = scrollObservable;
  }
  create(rowHeightService, skip3, take2, total) {
    this.rowHeightService = rowHeightService;
    this.firstLoaded = skip3;
    this.lastLoaded = skip3 + take2;
    this.take = take2;
    this.total = total;
    this.lastScrollTop = 0;
    const subject = new BehaviorSubject(new ScrollAction2(this.rowHeightService.offset(skip3)));
    this.subscription = Observable.create((observer) => {
      this.unsubscribe();
      this.scrollSubscription = this.scrollObservable.subscribe((x) => this.onScroll(x, observer));
    }).subscribe((x) => subject.next(x));
    return subject;
  }
  destroy() {
    this.unsubscribe();
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  onScroll({
    scrollTop,
    offsetHeight,
    scrollHeight,
    clientHeight
  }, observer) {
    if (!isDocumentAvailable() || this.lastScrollTop === scrollTop) {
      return;
    }
    const up = this.lastScrollTop >= scrollTop;
    this.lastScrollTop = scrollTop;
    let firstItemIndex = this.rowHeightService.index(scrollTop);
    let firstItemOffset = this.rowHeightService.offset(firstItemIndex);
    const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);
    if (!up) {
      if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
        const overflow = firstItemIndex + this.take - this.total;
        if (overflow > 0) {
          firstItemIndex = firstItemIndex - overflow;
          firstItemOffset = this.rowHeightService.offset(firstItemIndex);
        }
        this.firstLoaded = firstItemIndex;
        observer.next(new ScrollAction2(firstItemOffset));
        let nextTake = this.firstLoaded + this.take;
        this.lastLoaded = Math.min(nextTake, this.total);
        nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;
        observer.next(new PageAction2(this.firstLoaded, this.take));
      } else {
        const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;
        if (atBottom) {
          observer.next(new ScrollBottomAction());
        }
      }
    }
    if (up && firstItemIndex < this.firstLoaded) {
      const nonVisibleBuffer = Math.floor(this.take * 0.3);
      this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);
      observer.next(new ScrollAction2(this.rowHeightService.offset(this.firstLoaded)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction2(this.firstLoaded, this.take));
    }
  }
  unsubscribe() {
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
      this.scrollSubscription = void 0;
    }
  }
};
var columnsToResize = ({
  columns
}) => Math.max(1, resizableColumns(columns).filter((c) => !c.isColumnGroup).length);
var row = (selector) => (element) => element.querySelector(selector);
var headerRow = (index) => (element) => element.querySelectorAll("thead>tr")[index];
var cell = (index, selector = "td") => (element) => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];
var offsetWidth = (element) => element.offsetWidth;
var pipe2 = (...fns) => (data) => fns.reduce((state2, fn) => state2 ? fn(state2) : 0, data);
var TableDirective = class _TableDirective {
  element;
  renderer;
  service;
  zone;
  cdr;
  ctx;
  locked = false;
  virtualColumns;
  get minWidth() {
    return this.firstResize ? 0 : null;
  }
  firstResize = false;
  subscription;
  autoFitSubscription;
  constructor(element, renderer, service, zone, cdr, ctx) {
    this.element = element;
    this.renderer = renderer;
    this.service = service;
    this.zone = zone;
    this.cdr = cdr;
    this.ctx = ctx;
  }
  ngOnInit() {
    const obs = this.service.changes.pipe(filter((e) => this.locked === e.locked));
    this.subscription = obs.pipe(filter((e) => e.type === "start"), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take2) => obs.pipe(filter((e) => e.type === "resizeTable"), map((e) => e.delta), bufferCount(take2)))).subscribe(this.resize.bind(this));
    this.autoFitSubscription = this.service.registerTable({
      autoFit: this.autoFitObservable.bind(this),
      locked: this.locked
    });
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.autoFitSubscription) {
      this.autoFitSubscription();
      this.autoFitSubscription = null;
    }
  }
  initState() {
    this.firstResize = true;
    const constrainedWithVirtualColumns = this.ctx.grid?.resizable === "constrained" && this.virtualColumns;
    if (!this.virtualColumns || this.locked || constrainedWithVirtualColumns) {
      this.service.originalWidth = offsetWidth(this.element.nativeElement);
    }
  }
  resize(deltas) {
    const constrainedModeNoShift = this.ctx.grid?.resizable === "constrained" && !this.service.isShiftPressed;
    const unconstrainedModeShift = (this.ctx.grid?.resizable === true || this.ctx.grid?.resizable === "unconstrained") && this.service.isShiftPressed;
    const isConstrainedMode = constrainedModeNoShift || unconstrainedModeShift;
    if (isConstrainedMode && !this.service.autoFitResize) {
      this.renderer.setStyle(this.element.nativeElement, "width", this.service.originalWidth + "px");
    } else {
      if (!this.virtualColumns || this.locked) {
        const delta = deltas.reduce((sum, item) => sum + item, 0);
        const width2 = this.service.originalWidth + delta;
        this.renderer.setStyle(this.element.nativeElement, "width", width2 + "px");
      }
    }
    this.cdr.detectChanges();
  }
  autoFitObservable(columnInfo) {
    return Observable.create((observer) => {
      this.zone.runOutsideAngular(() => {
        this.renderer.addClass(this.element.nativeElement, "k-autofitting");
        this.cdr.detectChanges();
        const widths = columnInfo.map(this.measureColumn.bind(this));
        this.renderer.removeClass(this.element.nativeElement, "k-autofitting");
        observer.next(widths);
      });
    });
  }
  measureColumn(info) {
    const dom = this.element.nativeElement;
    const header = pipe2(headerRow(info.level), cell(info.headerIndex, "th"), offsetWidth)(dom);
    let data = 0;
    if (!info.isParentSpan || info.isParentSpan && info.isLastInSpan) {
      data = pipe2(row("tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)"), cell(info.index), offsetWidth)(dom);
    }
    const footer = pipe2(row("tfoot>tr"), cell(info.index), offsetWidth)(dom);
    return Math.max(header, data, footer);
  }
  static ɵfac = function TableDirective_Factory(t) {
    return new (t || _TableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TableDirective,
    selectors: [["", "kendoGridResizableTable", ""]],
    hostVars: 2,
    hostBindings: function TableDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("min-width", ctx.minWidth);
      }
    },
    inputs: {
      locked: "locked",
      virtualColumns: "virtualColumns"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridResizableTable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ColumnResizingService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }];
  }, {
    locked: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    minWidth: [{
      type: HostBinding,
      args: ["style.min-width"]
    }]
  });
})();
var elementAt = (index, elements, elementOffset) => {
  for (let idx2 = 0, elementIdx = 0; idx2 < elements.length; idx2++) {
    const offset3 = elementOffset(elements[idx2]);
    if (elementIdx <= index && index <= elementIdx + offset3 - 1) {
      return elements[idx2];
    }
    elementIdx += offset3;
  }
};
var rowAt = (index, rows) => elementAt(index, rows, () => 1);
var cellAt = (index, cells) => elementAt(index, cells, (cell2) => !hasClasses(cell2, NON_DATA_CELL_CLASSES) ? parseInt(cell2.getAttribute("colSpan"), 10) || 1 : 0);
var EMPTY_OBJECT = {};
var SCROLLER_FACTORY_TOKEN2 = new InjectionToken("grid-scroll-service-factory");
function DEFAULT_SCROLLER_FACTORY2(observable) {
  return new ScrollerService2(observable);
}
var wheelDeltaY = (e) => {
  const deltaY = e.wheelDeltaY;
  if (e.wheelDelta && (deltaY === void 0 || deltaY)) {
    return e.wheelDelta;
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    return -e.detail * 10;
  }
  return 0;
};
var preventLockedScroll = (args, element) => {
  const delta = wheelDeltaY(args);
  const scrollTop = element.scrollTop;
  const allowScroll = scrollTop === 0 && 0 < delta || element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0;
  if (!allowScroll) {
    event.preventDefault();
  }
};
var translateY = (renderer, value) => (el) => renderer.setStyle(el, "transform", `translateY(${value}px)`);
var maybeNativeElement = (el) => el ? el.nativeElement : null;
var hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;
var setHeight = (renderer) => ({
  el,
  height: height2
}) => renderer.setStyle(el, "height", `${height2}px`);
var bufferSize = 1;
var ListComponent = class _ListComponent {
  changeNotification;
  suspendService;
  groupsService;
  ngZone;
  renderer;
  scrollSyncService;
  resizeService;
  editService;
  supportService;
  navigationService;
  ctx;
  columnResizingService;
  changeDetector;
  pdfService;
  columnInfo;
  rowspanService;
  hostClass = true;
  hostRole = "presentation";
  data;
  groups = [];
  total;
  rowHeight;
  stickyRowHeight;
  detailRowHeight;
  take;
  skip = 0;
  columns = new ColumnsContainer(() => []);
  detailTemplate;
  noRecordsTemplate;
  selectable = false;
  groupable = false;
  filterable;
  rowClass;
  rowSticky;
  loading;
  trackBy = defaultTrackBy;
  virtualColumns;
  isVirtual;
  cellLoadingTemplate;
  loadingTemplate;
  sort = new Array();
  size = "medium";
  contentScroll = new EventEmitter();
  pageChange = new EventEmitter();
  scrollBottom = new EventEmitter();
  totalHeight;
  columnsStartIdx = 0;
  get showFooter() {
    return this.groupable && this.groupable.showFooter;
  }
  get totalWidth() {
    if (this.virtualColumns && this.columns.unlockedWidth) {
      return this.columns.unlockedWidth;
    }
  }
  container;
  lockedContainer;
  lockedTable;
  table;
  resizeSensors = new QueryList();
  scroller;
  subscriptions;
  scrollerSubscription;
  dispatcher = new Subject();
  rowHeightService;
  skipScroll;
  rebind;
  containerScrollTop = 0;
  viewportColumns;
  columnsEndIdx;
  viewportColumnsWidth;
  scrollLeft = 0;
  observer;
  get lockedLeafColumns() {
    return this.columns.lockedLeafColumns;
  }
  get nonLockedLeafColumns() {
    return this.columns.nonLockedLeafColumns;
  }
  get nonLockedColumnsToRender() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.viewportColumns;
    }
    return this.nonLockedLeafColumns;
  }
  get leafColumns() {
    return this.columns.leafColumnsToRender;
  }
  get lockedWidth() {
    const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;
    return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
  }
  get nonLockedWidth() {
    if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {
      return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));
    }
    return void 0;
  }
  get isLocked() {
    return this.lockedLeafColumns.length > 0;
  }
  rtl = false;
  columnUpdateFrame;
  hasLockedContainer;
  constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, ctx, columnResizingService, changeDetector, pdfService, columnInfo, rowspanService) {
    this.changeNotification = changeNotification;
    this.suspendService = suspendService;
    this.groupsService = groupsService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.scrollSyncService = scrollSyncService;
    this.resizeService = resizeService;
    this.editService = editService;
    this.supportService = supportService;
    this.navigationService = navigationService;
    this.ctx = ctx;
    this.columnResizingService = columnResizingService;
    this.changeDetector = changeDetector;
    this.pdfService = pdfService;
    this.columnInfo = columnInfo;
    this.rowspanService = rowspanService;
    this.scroller = scrollerFactory(this.dispatcher);
    this.subscriptions = detailsService.changes.subscribe((x) => this.detailExpand(x));
    this.subscriptions.add(scrollRequestService.requests.subscribe((req) => isPresent4(req.adjustIndex) ? this.scrollTo(req.request, req.adjustIndex) : this.scrollToItem(req.request)));
  }
  ngOnInit() {
    this.init();
    this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));
    this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));
    this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {
      if (this.virtualColumns) {
        this.ngZone.run(() => {
          this.updateViewportColumns();
          this.changeDetector.markForCheck();
        });
      }
    }));
    this.subscriptions.add(this.ctx.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl));
  }
  ngOnChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    const changesInSkip = changes["skip"];
    const hasInitialSkip = changesInSkip && changesInSkip.firstChange && changesInSkip.currentValue > 0;
    if (hasInitialSkip) {
      this.handleInitialScrollToSkip();
    }
    if (isChanged("skip", changes) && !this.rebind) {
      this.skipScroll = true;
      this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
    }
    if (anyChanged(["total", "take"], changes)) {
      this.init();
    }
    this.rebind = false;
  }
  ngDoCheck() {
    if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {
      this.updateViewportColumns();
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.skip && this.isVirtual) {
      this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
    }
    this.resetNavigationViewport();
    this.attachContainerScroll();
    this.initResizeService();
  }
  ngAfterViewChecked() {
    const isLocked2 = this.isLocked;
    if (isLocked2 && !this.hasLockedContainer) {
      this.syncRowsHeight();
    }
    this.hasLockedContainer = isLocked2;
  }
  syncRowsHeight() {
    if (this.lockedContainer) {
      syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);
    }
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.resizeService) {
      this.resizeService.destroy();
    }
    this.observer?.disconnect();
    this.cleanupScroller();
  }
  init() {
    if (this.suspendService.scroll) {
      return;
    }
    this.rowHeightService = new RowHeightService2(this.total, this.rowHeight, this.detailRowHeight);
    this.totalHeight = this.rowHeightService.totalHeight();
    if (!isUniversal()) {
      this.ngZone.runOutsideAngular(this.createScroller.bind(this));
    }
  }
  lockedScroll() {
    if (!this.suspendService.scroll) {
      const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;
      if (lockedScrollTop !== this.containerScrollTop) {
        this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;
      }
    }
  }
  lockedMousewheel(args) {
    if (!args.ctrlKey) {
      preventLockedScroll(args, this.container.nativeElement);
      const scrollDelta = wheelDeltaY(args);
      this.container.nativeElement.scrollTop -= scrollDelta;
    }
  }
  lockedKeydown(args) {
    if (args.keyCode === Keys.PageDown || args.keyCode === Keys.PageUp) {
      const dir2 = args.keyCode === Keys.PageDown ? 1 : -1;
      const element = this.container.nativeElement;
      element.scrollTop += element.offsetHeight * dir2 * 0.8;
      args.preventDefault();
    }
  }
  detailExpand({
    index,
    expand
  }) {
    if (expand) {
      this.rowHeightService.expandDetail(index);
    } else {
      this.rowHeightService.collapseDetail(index);
    }
    this.totalHeight = this.rowHeightService.totalHeight();
    this.resetNavigationViewport();
  }
  attachContainerScroll() {
    if (isUniversal()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(fromEvent(this.container.nativeElement, "scroll").pipe(map((event2) => event2.target), filter(() => !this.suspendService.scroll), tap((target) => {
        this.onContainerScroll(target);
        this.resetNavigationViewport();
        if (this.virtualColumns || this.isVirtual) {
          this.handleColumnScroll();
        }
        const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;
        const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;
        this.contentScroll.emit({
          scrollLeft: target.scrollLeft,
          scrollTop: target.scrollTop,
          startRow: rowViewport.firstItemIndex,
          endRow: rowViewport.lastItemIndex,
          startColumn: columnViewport.firstItemIndex,
          endColumn: columnViewport.lastItemIndex
        });
      })).subscribe(this.dispatcher));
    });
    this.scrollSyncService.registerEmitter(this.container.nativeElement, "body");
  }
  createScroller() {
    this.cleanupScroller();
    const observable = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total);
    this.skipScroll = false;
    this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction2), filter(() => {
      const temp = this.skipScroll;
      this.skipScroll = false;
      return !temp;
    }), tap(() => this.rebind = true)).subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));
    this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction2)).subscribe(this.scroll.bind(this)));
    this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction)).subscribe(() => this.scrollBottom.emit()));
  }
  scroll({
    offset: offset3 = 0
  }) {
    if (this.isVirtual) {
      [maybeNativeElement(this.table), maybeNativeElement(this.lockedTable)].filter(isPresent4).forEach(translateY(this.renderer, offset3));
    }
    this.resetNavigationViewport();
  }
  onContainerScroll({
    scrollTop
  }) {
    this.containerScrollTop = scrollTop;
    if (this.lockedContainer) {
      this.lockedContainer.nativeElement.scrollTop = scrollTop;
    }
  }
  handleInitialScrollToSkip() {
    const shouldScroll = () => this.isVirtual && this.skip > 0 && this.total > 0;
    const sub = this.changeNotification.changes.pipe(filter(shouldScroll)).subscribe(() => {
      this.scrollTo({
        row: this.skip
      });
      sub.unsubscribe();
    });
  }
  handleRowSync() {
    const isLocked2 = () => isPresent4(this.lockedContainer);
    const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));
    return merge(this.changeNotification.changes, this.groupsService.changes.pipe(filter(isLocked2), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes.pipe(filter((change) => change.type === "end")), this.supportService.changes).pipe(tap(() => {
      this.ngZone.run(() => this.rowspanService.reset());
      this.resetNavigationViewport();
    }), filter(isLocked2)).subscribe(() => {
      const scrollTop = this.container.nativeElement.scrollTop;
      const scrollLeft = this.container.nativeElement.scrollLeft;
      this.syncRowsHeight();
      this.syncContainerHeight();
      this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;
      this.container.nativeElement.scrollLeft = scrollLeft;
      this.resizeSensors.forEach((sensor) => sensor.acceptSize());
    });
  }
  handleRowNavigationLocked() {
    return this.navigationService.changes.pipe(filter(() => isPresent4(this.lockedContainer)), delay(10)).subscribe((args) => {
      if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {
        const cell2 = this.navigationService.activeCell;
        if (cell2 && cell2.colIndex + cell2.colSpan < args.prevColIndex) {
          this.container.nativeElement.scrollLeft = 0;
        }
      }
    });
  }
  scrollToVirtualRow(itemIndex, adjustIndexForDetailTemplate = true) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (isPresent4(this.detailTemplate) && adjustIndexForDetailTemplate) {
      itemIndex = Math.floor(itemIndex / 2);
    }
    const offset3 = this.rowHeightService.offset(itemIndex, !adjustIndexForDetailTemplate);
    this.container.nativeElement.scrollTop = offset3;
    this.resetNavigationViewport();
  }
  scrollTo({
    row: row2,
    column
  }, adjustIndex = false) {
    if (isNumber2(row2)) {
      if (this.isVirtual) {
        this.scrollToVirtualRow(row2, adjustIndex);
      } else {
        const element = rowAt(row2, this.table.nativeElement.rows);
        if (element) {
          this.container.nativeElement.scrollTop = element.offsetTop;
        }
      }
    }
    if (isNumber2(column)) {
      column -= this.lockedLeafColumns.length;
      if (this.virtualColumns) {
        const columns = this.columns.leafColumnsToRender;
        let offset3 = 0;
        for (let idx2 = 0; idx2 < column; idx2++) {
          offset3 += columns[idx2].width || 0;
        }
        const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);
        this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset3 + startOffset);
      } else if (column === 0 && this.detailTemplate) {
        this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);
      } else {
        const firstRow = rowAt(0, this.table.nativeElement.rows);
        if (firstRow) {
          const element = cellAt(column, firstRow.cells);
          if (element) {
            this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);
          }
        }
      }
    }
  }
  scrollToItem(item) {
    if (!isDocumentAvailable()) {
      return;
    }
    const data = this.ctx.grid.data;
    const gridData = Array.isArray(data) ? data : data.data;
    const gridDataItems = gridData.flatMap(recursiveFlatMap);
    const dataItemIndex = gridDataItems.findIndex((dataItem) => dataItem[item.idField] === item.id);
    if (dataItemIndex !== -1) {
      const row2 = Array.from(this.table.nativeElement.rows).find((r) => {
        const dataAttribute = r.getAttribute("data-kendo-grid-item-index");
        return dataAttribute && +dataAttribute === this.ctx.grid.skip + dataItemIndex;
      });
      row2 && row2.scrollIntoView();
      this.isVirtual && this.resetNavigationViewport();
    }
  }
  resetNavigationViewport() {
    if (!isDocumentAvailable) {
      return;
    }
    if (!this.container || !this.navigationService.tableEnabled || !this.navigationService.needsViewport() || this.data.length === 0) {
      return;
    }
    const {
      scrollTop,
      offsetHeight
    } = this.container.nativeElement;
    const scrollBottom = scrollTop + offsetHeight;
    const firstItemIndex = this.rowHeightService.index(scrollTop);
    const lastItemIndex = this.rowHeightService.index(scrollBottom);
    const lastItemOffset = this.rowHeightService.offset(lastItemIndex);
    let viewportStart = firstItemIndex;
    let viewportEnd = lastItemIndex;
    if (isPresent4(this.detailTemplate)) {
      viewportStart *= 2;
      viewportEnd *= 2;
      const firstItemHeight = this.rowHeightService.offset(firstItemIndex);
      if (firstItemHeight + this.rowHeight < scrollTop) {
        viewportStart++;
      }
      const lastItemHeight = this.rowHeightService.height(lastItemIndex);
      const lastItemExpanded = this.rowHeightService.isExpanded(lastItemIndex);
      const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;
      if (lastItemExpanded && !lastItemDetailOverflows) {
        viewportEnd++;
      }
    }
    this.navigationService.setViewport(viewportStart, viewportEnd);
  }
  cleanupScroller() {
    if (this.scrollerSubscription) {
      this.scrollerSubscription.unsubscribe();
    }
    if (this.scroller) {
      this.scroller.destroy();
    }
  }
  initResizeService() {
    this.resizeService.connect(merge(...this.resizeSensors.map((sensor) => sensor.resize)));
  }
  syncContainerHeight() {
    [maybeNativeElement(this.lockedContainer)].filter(isPresent4).map((el) => {
      el.style.height = "";
      let height2 = this.container.nativeElement.offsetHeight;
      if (hasScrollbar(this.table, this.container)) {
        height2 -= this.supportService.scrollbarWidth;
      }
      return {
        el,
        height: height2
      };
    }).forEach(setHeight(this.renderer));
  }
  updateViewportColumns(range2) {
    const columns = this.columns.nonLockedLeafColumns.toArray();
    let {
      startIdx,
      endIdx,
      offset: offset3
    } = range2 || this.calculateViewportColumns();
    const start = Math.max(0, startIdx - bufferSize);
    const end2 = Math.min(endIdx + bufferSize, columns.length - 1);
    if (start < startIdx) {
      for (let idx2 = startIdx - 1; idx2 >= start; idx2--) {
        offset3 -= columns[idx2].width;
      }
    }
    let currentColumns = columns.slice(start, end2 + 1);
    this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);
    const stickyBeforeStart = columns.slice(0, start).filter((c) => c.sticky && !currentColumns.some((col) => col === c));
    const stickyAfterEnd = columns.slice(end2, columns.length).filter((c) => c.sticky && !currentColumns.some((col) => col === c));
    currentColumns = [...stickyBeforeStart, ...currentColumns, ...stickyAfterEnd];
    if (start > 0) {
      const offsetColumn = new ColumnBase2();
      offsetColumn.width = offset3;
      currentColumns.unshift(offsetColumn);
    }
    this.viewportColumns = new QueryList();
    this.viewportColumns.reset(currentColumns);
    this.columnsStartIdx = start;
    this.columnsEndIdx = end2;
    this.columnInfo.columnRangeChange.emit({
      start,
      end: end2,
      offset: offset3
    });
    if (!range2) {
      this.updateColumnViewport(startIdx, endIdx);
    }
  }
  handleColumnScroll() {
    const container = this.container.nativeElement;
    const scrollLeft = container.scrollLeft;
    if (this.scrollLeft !== scrollLeft) {
      this.scrollLeft = scrollLeft;
      const range2 = this.calculateViewportColumns();
      this.updateColumnViewport(range2.startIdx, range2.endIdx);
      if (range2.startIdx < this.columnsStartIdx || this.columnsEndIdx < range2.endIdx) {
        cancelAnimationFrame(this.columnUpdateFrame);
        this.columnUpdateFrame = requestAnimationFrame(() => {
          this.ngZone.run(() => {
            this.updateViewportColumns(range2);
            this.changeDetector.markForCheck();
          });
        });
      }
    }
  }
  updateColumnViewport(startIdx, endIdx) {
    const lockedCount = this.lockedLeafColumns.length;
    const leafColumns2 = this.nonLockedLeafColumns.toArray();
    const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);
    let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);
    for (let idx2 = 0; idx2 < leafColumns2.length; idx2++) {
      const column = leafColumns2[idx2];
      if (column.isSpanColumn) {
        viewportEnd += column.children.length;
      }
    }
    this.navigationService.setColumnViewport(viewportStart, viewportEnd);
  }
  calculateViewportColumns() {
    const {
      scrollLeft,
      clientWidth
    } = this.container.nativeElement;
    const columns = this.columns.nonLockedLeafColumns.toArray();
    const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);
    const viewportEnd = normalizedScrollLeft + clientWidth;
    let startIdx;
    let endIdx = 0;
    let current3 = 0;
    let offset3 = 0;
    let idx2;
    for (idx2 = 0; idx2 < columns.length; idx2++) {
      const column = columns[idx2];
      current3 += column.width || 0;
      if (startIdx === void 0 && current3 > normalizedScrollLeft) {
        startIdx = idx2;
        offset3 = current3 - (column.width || 0);
      }
      if (current3 >= viewportEnd) {
        endIdx = idx2;
        break;
      }
    }
    if (!endIdx && idx2 > 0) {
      endIdx = columns.length - 1;
    }
    return {
      startIdx,
      endIdx,
      offset: offset3
    };
  }
  viewportWidthChange() {
    const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);
    return currentWidth !== this.viewportColumnsWidth;
  }
  normalizeScrollLeft(position2) {
    return this.rtl ? rtlScrollPosition(position2, this.container.nativeElement, this.supportService.rtlScrollLeft) : position2;
  }
  elementScrollLeft(element) {
    if (this.rtl) {
      return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);
    }
    return element.offsetLeft;
  }
  static ɵfac = function ListComponent_Factory(t) {
    return new (t || _ListComponent)(ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN2), ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(SuspendService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ScrollSyncService2), ɵɵdirectiveInject(ResizeService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(BrowserSupportService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(ScrollRequestService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(RowspanService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ListComponent,
    selectors: [["kendo-grid-list"]],
    viewQuery: function ListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c46, 7);
        ɵɵviewQuery(_c47, 5);
        ɵɵviewQuery(_c48, 5);
        ɵɵviewQuery(_c49, 7);
        ɵɵviewQuery(ResizeSensorComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedTable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.table = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeSensors = _t);
      }
    },
    hostVars: 3,
    hostBindings: function ListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.hostRole);
        ɵɵclassProp("k-grid-container", ctx.hostClass);
      }
    },
    inputs: {
      data: "data",
      groups: "groups",
      total: "total",
      rowHeight: "rowHeight",
      stickyRowHeight: "stickyRowHeight",
      detailRowHeight: "detailRowHeight",
      take: "take",
      skip: "skip",
      columns: "columns",
      detailTemplate: "detailTemplate",
      noRecordsTemplate: "noRecordsTemplate",
      selectable: "selectable",
      groupable: "groupable",
      filterable: "filterable",
      rowClass: "rowClass",
      rowSticky: "rowSticky",
      loading: "loading",
      trackBy: "trackBy",
      virtualColumns: "virtualColumns",
      isVirtual: "isVirtual",
      cellLoadingTemplate: "cellLoadingTemplate",
      loadingTemplate: "loadingTemplate",
      sort: "sort",
      size: "size"
    },
    outputs: {
      contentScroll: "contentScroll",
      pageChange: "pageChange",
      scrollBottom: "scrollBottom"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: SCROLLER_FACTORY_TOKEN2,
      useValue: DEFAULT_SCROLLER_FACTORY2
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 12,
    vars: 37,
    consts: [["container", ""], ["table", ""], ["lockedContainer", ""], ["lockedTable", ""], ["class", "k-grid-content-locked", "role", "presentation", "tabindex", "-1", 3, "width", "kendoEventsOutsideAngular", "scope", 4, "ngIf"], [1, "k-grid-content", "k-virtual-content", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation"], ["kendoGridResizableTable", "", "kendoGridTable", "", "role", "presentation", 1, "k-grid-table", 3, "virtualColumns", "size"], ["kendoGridColGroup", "", 3, "groups", "columns", "detailTemplate", "sort"], ["kendoGridTableBody", "", "role", "rowgroup", 3, "skipGroupDecoration", "data", "groups", "showGroupFooters", "columns", "allColumns", "detailTemplate", "noRecordsTemplate", "lockedColumnsCount", "totalColumnsCount", "totalColumns", "skip", "selectable", "trackBy", "filterable", "rowClass", "rowSticky", "virtualColumns", "isLoading", "isVirtual", "cellLoadingTemplate"], [4, "ngIf"], ["class", "k-height-container", "role", "presentation", 4, "ngIf"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-grid-content-locked", 3, "kendoEventsOutsideAngular", "scope"], ["kendoGridResizableTable", "", "role", "presentation", "kendoGridTable", "", 1, "k-grid-table", 3, "locked", "size"], ["kendoGridTableBody", "", "role", "presentation", 3, "groups", "isLocked", "data", "noRecordsText", "columns", "totalColumnsCount", "totalColumns", "detailTemplate", "showGroupFooters", "skip", "selectable", "trackBy", "filterable", "rowClass", "isLoading", "isVirtual", "cellLoadingTemplate"], ["role", "presentation", 1, "k-height-container"], ["role", "presentation", 1, "k-width-container"]],
    template: function ListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ListComponent_div_0_Template, 9, 35, "div", 4);
        ɵɵelementStart(1, "div", 5, 0)(3, "div", 6)(4, "table", 7, 1);
        ɵɵelement(6, "colgroup", 8)(7, "tbody", 9);
        ɵɵelementEnd();
        ɵɵtemplate(8, ListComponent_kendo_resize_sensor_8_Template, 1, 0, "kendo-resize-sensor", 10);
        ɵɵelementEnd();
        ɵɵtemplate(9, ListComponent_kendo_resize_sensor_9_Template, 1, 0, "kendo-resize-sensor", 10)(10, ListComponent_div_10_Template, 2, 2, "div", 11)(11, ListComponent_div_11_Template, 2, 2, "div", 12);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.isLocked);
        ɵɵadvance();
        ɵɵproperty("kendoGridResizableContainer", ctx.lockedLeafColumns.length > 0)("lockedWidth", ctx.lockedWidth + 1);
        ɵɵadvance(3);
        ɵɵstyleProp("width", ctx.nonLockedWidth, "px");
        ɵɵproperty("virtualColumns", ctx.virtualColumns)("size", ctx.size);
        ɵɵadvance(2);
        ɵɵproperty("groups", ctx.isLocked ? ɵɵpureFunction0(36, _c50) : ctx.groups)("columns", ctx.nonLockedColumnsToRender)("detailTemplate", ctx.detailTemplate)("sort", ctx.sort);
        ɵɵadvance();
        ɵɵproperty("skipGroupDecoration", ctx.isLocked)("data", ctx.data)("groups", ctx.groups)("showGroupFooters", ctx.showFooter)("columns", ctx.nonLockedColumnsToRender)("allColumns", ctx.nonLockedLeafColumns)("detailTemplate", ctx.detailTemplate)("noRecordsTemplate", ctx.noRecordsTemplate)("lockedColumnsCount", ctx.lockedLeafColumns.length)("totalColumnsCount", ctx.leafColumns.length)("totalColumns", ctx.columns)("skip", ctx.skip)("selectable", ctx.selectable)("trackBy", ctx.trackBy)("filterable", ctx.filterable)("rowClass", ctx.rowClass)("rowSticky", ctx.rowSticky)("virtualColumns", ctx.virtualColumns)("isLoading", ctx.loading)("isVirtual", ctx.isVirtual)("cellLoadingTemplate", ctx.cellLoadingTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isLocked);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isLocked || ctx.virtualColumns);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isVirtual);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.virtualColumns);
      }
    },
    dependencies: [NgIf, EventsOutsideAngularDirective, TableDirective, GridTableDirective, ColGroupComponent, TableBodyComponent, ResizeSensorComponent, ResizableContainerDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SCROLLER_FACTORY_TOKEN2,
        useValue: DEFAULT_SCROLLER_FACTORY2
      }],
      selector: "kendo-grid-list",
      template: `
    <div #lockedContainer class="k-grid-content-locked" role="presentation"
        *ngIf="isLocked" [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation">
            <table
                kendoGridResizableTable
                [locked]="true"
                #lockedTable
                class="k-grid-table"
                role="presentation"
                kendoGridTable
                [size]="size"
                [style.width.px]="lockedWidth">
                <colgroup kendoGridColGroup
                    [groups]="groups"
                    [columns]="$any(lockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="presentation"
                    [groups]="groups"
                    [isLocked]="true"
                    [data]="data"
                    [noRecordsText]="''"
                    [columns]="$any(lockedLeafColumns)"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [detailTemplate]="detailTemplate"
                    [showGroupFooters]="showFooter"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor></kendo-resize-sensor>
        </div>
        <div *ngIf="isVirtual" class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
    </div>
    <div 
        #container
        class="k-grid-content k-virtual-content"
        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
        [lockedWidth]="lockedWidth + 1"
    >
        <div role="presentation">
            <table
                [style.width.px]="nonLockedWidth"
                #table
                kendoGridResizableTable
                [virtualColumns]="virtualColumns"
                class="k-grid-table"
                kendoGridTable
                [size]="size"
                role="presentation">
                <colgroup kendoGridColGroup
                    [groups]="isLocked ? [] : groups"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="rowgroup"
                    [skipGroupDecoration]="isLocked"
                    [data]="data"
                    [groups]="groups"
                    [showGroupFooters]="showFooter"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [allColumns]="$any(nonLockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [lockedColumnsCount]="lockedLeafColumns.length"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [virtualColumns]="virtualColumns"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor *ngIf="isLocked"></kendo-resize-sensor>
        </div>
        <kendo-resize-sensor *ngIf="isLocked || virtualColumns"></kendo-resize-sensor>
        <div *ngIf="isVirtual" class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
            <div [style.width.px]="totalWidth"></div>
        </div>
    </div>
    `,
      standalone: true,
      imports: [NgIf, EventsOutsideAngularDirective, TableDirective, GridTableDirective, ColGroupComponent, TableBodyComponent, ResizeSensorComponent, ResizableContainerDirective]
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [SCROLLER_FACTORY_TOKEN2]
      }]
    }, {
      type: DetailsService
    }, {
      type: ChangeNotificationService
    }, {
      type: SuspendService
    }, {
      type: GroupsService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ScrollSyncService2
    }, {
      type: ResizeService
    }, {
      type: EditService
    }, {
      type: BrowserSupportService
    }, {
      type: NavigationService2
    }, {
      type: ScrollRequestService
    }, {
      type: ContextService
    }, {
      type: ColumnResizingService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PDFService
    }, {
      type: ColumnInfoService
    }, {
      type: RowspanService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid-container"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    data: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    stickyRowHeight: [{
      type: Input
    }],
    detailRowHeight: [{
      type: Input
    }],
    take: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    noRecordsTemplate: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    cellLoadingTemplate: [{
      type: Input
    }],
    loadingTemplate: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    contentScroll: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    scrollBottom: [{
      type: Output
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        static: true
      }]
    }],
    lockedContainer: [{
      type: ViewChild,
      args: ["lockedContainer", {
        static: false
      }]
    }],
    lockedTable: [{
      type: ViewChild,
      args: ["lockedTable", {
        static: false
      }]
    }],
    table: [{
      type: ViewChild,
      args: ["table", {
        static: true
      }]
    }],
    resizeSensors: [{
      type: ViewChildren,
      args: [ResizeSensorComponent]
    }]
  });
})();
var ToolbarComponent = class _ToolbarComponent {
  ctx;
  wrapper;
  context = {};
  role = "toolbar";
  hostClasses = true;
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  set position(value) {
    this.context.position = value;
  }
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-toolbar-sm", "k-toolbar-md");
    }
  }
  get size() {
    return this._size;
  }
  clickHandler(ev) {
    if (this.navigable && isDocumentAvailable()) {
      const closestFocusable = closest(ev.target, isFocusable);
      const targetIndex = this.navigationService.navigableElements.indexOf(closestFocusable);
      if (targetIndex > -1) {
        this.navigationService.currentActiveIndex = targetIndex;
      }
      this.navigationService.updateFocus();
      if (ev.target === this.wrapper.nativeElement) {
        this.navigationService.focus();
      }
    }
  }
  arrowLeftListener() {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      this.navigationService.currentActiveIndex--;
      if (this.navigationService.currentActiveIndex < 0) {
        this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
      }
      this.navigationService.updateFocus();
    }
  }
  arrowRightListener() {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      this.navigationService.currentActiveIndex++;
      if (this.navigationService.currentActiveIndex >= this.navigationService.navigableElements.length) {
        this.navigationService.currentActiveIndex = 0;
      }
      this.navigationService.updateFocus();
    }
  }
  homeKeyListener(e) {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      e.preventDefault();
      this.navigationService.currentActiveIndex = 0;
      this.navigationService.updateFocus();
    }
  }
  endKeyListener(e) {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      e.preventDefault();
      this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
      this.navigationService.updateFocus();
    }
  }
  navigable;
  get toolbarTemplateRef() {
    return this.ctx.grid.toolbarTemplate ? this.ctx.grid.toolbarTemplate.templateRef : void 0;
  }
  _size = "medium";
  navigationService;
  constructor(ctx, wrapper) {
    this.ctx = ctx;
    this.wrapper = wrapper;
    this.navigationService = this.ctx[`${this.wrapper.nativeElement.getAttribute("position")}ToolbarNavigation`];
  }
  static ɵfac = function ToolbarComponent_Factory(t) {
    return new (t || _ToolbarComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ToolbarComponent,
    selectors: [["kendo-grid-toolbar"]],
    hostVars: 11,
    hostBindings: function ToolbarComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function ToolbarComponent_click_HostBindingHandler($event) {
          return ctx.clickHandler($event);
        })("keydown.arrowleft", function ToolbarComponent_keydown_arrowleft_HostBindingHandler($event) {
          return ctx.arrowLeftListener($event);
        })("keydown.arrowright", function ToolbarComponent_keydown_arrowright_HostBindingHandler($event) {
          return ctx.arrowRightListener($event);
        })("keydown.home", function ToolbarComponent_keydown_home_HostBindingHandler($event) {
          return ctx.homeKeyListener($event);
        })("keydown.end", function ToolbarComponent_keydown_end_HostBindingHandler($event) {
          return ctx.endKeyListener($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx.role);
        ɵɵclassProp("k-toolbar", ctx.hostClasses)("k-grid-toolbar", ctx.hostClasses)("k-toolbar-solid", ctx.hostClasses)("k-toolbar-sm", ctx.sizeSmallClass)("k-toolbar-md", ctx.sizeMediumClass);
      }
    },
    inputs: {
      position: "position",
      size: "size",
      navigable: "navigable"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 1,
    vars: 1,
    consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function ToolbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ToolbarComponent_0_Template, 1, 2, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.toolbarTemplateRef);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-toolbar",
      template: `
        <ng-template
            *ngIf="toolbarTemplateRef"
            [ngTemplateOutlet]="toolbarTemplateRef"
            [ngTemplateOutletContext]="context"></ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ElementRef
    }];
  }, {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-toolbar"]
    }, {
      type: HostBinding,
      args: ["class.k-grid-toolbar"]
    }, {
      type: HostBinding,
      args: ["class.k-toolbar-solid"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-toolbar-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-toolbar-md"]
    }],
    position: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    clickHandler: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    arrowLeftListener: [{
      type: HostListener,
      args: ["keydown.arrowleft", ["$event"]]
    }],
    arrowRightListener: [{
      type: HostListener,
      args: ["keydown.arrowright", ["$event"]]
    }],
    homeKeyListener: [{
      type: HostListener,
      args: ["keydown.home", ["$event"]]
    }],
    endKeyListener: [{
      type: HostListener,
      args: ["keydown.end", ["$event"]]
    }],
    navigable: [{
      type: Input
    }]
  });
})();
var GridMessages = class _GridMessages extends ComponentMessages {
  /**
   * The text for the empty group panel.
   */
  groupPanelEmpty;
  /**
   * The no-records text.
   */
  noRecords;
  /**
   * The label of the pager. Follows the pattern **Page {currentPage} of {totalPages}** by default.
   * Тhe default label text when the current page is 1, and the total number of pages is 10 will be
   * **Page navigation, page 1 of 10**.
   *
   * The message consists of several parts - the current page number, the total number of pages, and a localizable string.
   * To allow for reordering its parts, the `pagerLabel` input accepts a string with placeholders for the current page
   * and total number of pages. The `{currentPage}` and `{totalPages}` placeholders will be replaced
   * internally with the respective actual values. [See example](slug:globalization_grid#toc-custom-messages).
   */
  pagerLabel;
  /**
   * The label for the **First page** button.
   */
  pagerFirstPage;
  /**
   * The label for the **Last page** button.
   */
  pagerLastPage;
  /**
   * The label for the **Previous page** button.
   */
  pagerPreviousPage;
  /**
   * The label for the **Next page** button.
   */
  pagerNextPage;
  /**
   * The text displayed before the pager input.
   */
  pagerPage;
  /**
   * The text displayed after the page-size selector.
   */
  pagerItemsPerPage;
  /**
   * The text displayed before the total-page number.
   */
  pagerOf;
  /**
   * The text displayed after the total number of items.
   */
  pagerItems;
  /**
   * The title attribute of the page number input element.
   */
  pagerPageNumberInputTitle;
  /**
   * The text of the aria-label attribute applied to the page number input element.
   */
  pagerInputLabel;
  /**
   * The text of the title and `aria-label` attributes applied to the page chooser in the Grid Pager.
   */
  pagerSelectPage;
  /**
   * The label of the filter cell or icon.
   */
  filter;
  /**
   * The label of the filter input.
   *
   * The filter input label consists of a two-part message - the name of the column and a localizable string.
   * For a column named **Product Name**, the default label will be **Product Name Filter**.
   *
   * To allow reordering the column name and the localizable part, the `filterInputLabel` accepts a string with a
   * placeholder for the column name, for example, **filter for {columnName}**. The `{columnName}` placeholder will be replaced
   * internally with the current column name, and the resulting label will be rendered as **filter for Product Name**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterInputLabel;
  /**
   * The title of the filter menu icon.
   *
   * The title consists of a two-part message - the name of the column and a localizable string.
   * For a column named **Product Name**, the default title will be **Product Name Filter Menu**.
   *
   * To allow reordering the column name and the localizable part, the `filterMenuTitle` accepts a string with a
   * placeholder for the column name, for example, **filter for {columnName}**. The `{columnName}` placeholder will be replaced
   * internally with the current column name, and the resulting title will be rendered as **filter for Product Name**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterMenuTitle;
  /**
   * The label of the filter menu operators DropDownList.
   *
   * The label consists of a two-part message - the name of the column and a localizable string.
   * For a column named **Product Name**, the default label will be **Product Name Filter Menu Operators**.
   *
   * To allow reordering the column name and the localizable part, the `filterMenuOperatorsDropDownLabel` accepts a string with a
   * placeholder for the column name, for example, **filter operators for {columnName**'. The `{columnName}` placeholder will be replaced
   * internally with the current column name, and the resulting label will be rendered as **filter operators for Product Name**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterMenuOperatorsDropDownLabel;
  /**
   * The label of the filter menu logic DropDownList.
   *
   * The label consists of a two-part message - the name of the column and a localizable string.
   * For a column named **Product Name**, the default label will be **Product Name Filter Menu Logic**.
   *
   * To allow reordering the column name and the localizable part, the `filterMenuLogicDropDownLabel` accepts a string with a
   * placeholder for the column name, for example, **filter logic for {columnName}**. The `{columnName}` placeholder will be replaced
   * internally with the current column name, and the resulting label will be rendered as **filter logic for Product Name**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterMenuLogicDropDownLabel;
  /**
   * The label of the filter cell operators DropDownList.
   *
   * The label consists of a two-part message - the name of the column and a localizable string.
   * For a column named **Product Name**, the default label will be **Filter cell operators for Product Name**.
   *
   * To allow reordering the column name and the localizable part, the `filterCellOperatorLabel` accepts a string with a
   * placeholder for the column name, for example, **Filter operators for {columnName}**. The `{columnName}` placeholder will be replaced
   * internally with the current column name, and the resulting label will be rendered as **Filter operators for Product Name**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  filterCellOperatorLabel;
  /**
   * The label of the boolean filter cell DropDownList.
   *
   * The label consists of a two-part message - the name of the column and a localizable string.
   * For a column named **Product Name**, the default label will be **Boolean filter cell for Product Name**.
   *
   * To allow reordering the column name and the localizable part, the `booleanFilterCellLabel` accepts a string with a
   * placeholder for the column name, for example, **Boolean Filter operator for {columnName}**. The `{columnName}` placeholder will be replaced
   * internally with the current column name, and the resulting label will be rendered as **Boolean Filter operator for Product Name**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  booleanFilterCellLabel;
  /**
   * The text of the `Equal` (**Is equal to**) filter operator.
   */
  filterEqOperator;
  /**
   * The text of the `NotEqual` (**Is not equal to**) filter operator.
   */
  filterNotEqOperator;
  /**
   * The text of the `IsNull` (**Is null**) filter operator.
   */
  filterIsNullOperator;
  /**
   * The text of the `IsNotNull` (**Is not null**) filter operator.
   */
  filterIsNotNullOperator;
  /**
   * The text of the `IsEmpty` (**Is empty**) filter operator.
   */
  filterIsEmptyOperator;
  /**
   * The text of the `IsNotEmpty` (**Is not empty**) filter operator.
   */
  filterIsNotEmptyOperator;
  /**
   * The text of the `StartsWith` (**Starts with**) filter operator.
   */
  filterStartsWithOperator;
  /**
   * The text of the `Contains` (**Contains**) filter operator.
   */
  filterContainsOperator;
  /**
   * The text of the `DoesNotContain` (**Does not contain**) filter operator.
   */
  filterNotContainsOperator;
  /**
   * The text of the `EndsWith` (**Ends with**) string filter operator.
   */
  filterEndsWithOperator;
  /**
   * The text of the `GreaterOrEqualTo` (**Is greater than or equal to**) numeric filter operator.
   */
  filterGteOperator;
  /**
   * The text of the `Greater` (**Is greater than**) numeric filter operator.
   */
  filterGtOperator;
  /**
   * The text of the `LessOrEqualTo` (**Is less than or equal to**) numeric filter operator.
   */
  filterLteOperator;
  /**
   * The text of the `Less` (**Is less than**) numeric filter operator.
   */
  filterLtOperator;
  /**
   * The text of the `IsTrue` Boolean filter option.
   */
  filterIsTrue;
  /**
   * The text of the `IsFalse` Boolean filter option.
   */
  filterIsFalse;
  /**
   * The text of the `(All)` option for Boolean filter.
   */
  filterBooleanAll;
  /**
   * The title that is displayed in the Operators ActionSheet.
   */
  adaptiveFilterOperatorsTitle;
  /**
   * The text of the `AfterOrEqualTo` (**Is after or equal to**) date filter operator.
   */
  filterAfterOrEqualOperator;
  /**
   * The text of the `After` (**Is after**) date filter operator.
   */
  filterAfterOperator;
  /**
   * The text of the `Before` (**Is before**) date filter operator.
   */
  filterBeforeOperator;
  /**
   * The text of the `BeforeOrEqualTo` (**Is before or equal to**) date filter operator.
   */
  filterBeforeOrEqualOperator;
  /**
   * The text of the **Filter** button.
   */
  filterFilterButton;
  /**
   * The text of the **Clear filter** button.
   */
  filterClearButton;
  /**
   * The title of the **Close** button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  /**
   * The title of the **Back** button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveBackButtonTitle;
  /**
   * The text of the `And` filter logic.
   */
  filterAndLogic;
  /**
   * The text of the `Or` filter logic.
   */
  filterOrLogic;
  /**
   * The button text of the Filter toolbar tool.
   */
  filterToolbarToolText;
  /**
   * The loading text. The `loading` property is part of the accessibility support of the Grid.
   * Its value is detectable by screen readers and is not otherwise visible.
   */
  loading;
  /**
   * The text of the `aria-label` attribute placed on the Grid focusable element.
   */
  gridLabel;
  /**
   * The title of the column menu icon.
   *
   * The title consists of a two-part message - the name of the column and a localizable string.
   * For a column named **Product Name**, the default title will be **Product Name Column Menu**.
   *
   * To allow reordering the column name and the localizable part, the `columnMenu` accepts a string with a
   * placeholder for the column name, for example, **menu for {columnName}**. The `{columnName}` placeholder will be replaced
   * internally with the current column name, and the resulting title will be rendered as **menu for Product Name**.
   * [See example](slug:globalization_grid#toc-custom-messages).
   */
  columnMenu;
  /**
   * The text that is displayed in the column menu for the set column position item.
   */
  setColumnPosition;
  /**
   * The text for the Grid Column Chooser and Column Chooser toolbar tool.
   */
  columns;
  /**
   * The subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool.
   */
  columnsSubtitle;
  /**
   * The title that is displayed in the adaptive Filter Toolbar Tool and Filter Menu.
   */
  adaptiveFilterTitle;
  /**
   * The title that is displayed in the adaptive Sort Toolbar Tool.
   */
  adaptiveSortTitle;
  /**
   * The title that is displayed in the adaptive Group Toolbar Tool.
   */
  adaptiveGroupTitle;
  /**
   * The text of the **Clear all filters** button located in the Filter Toolbar Tool and adaptive Filter Toolbar Tool.
   */
  filterClearAllButton;
  /**
   * The text of the **Clear grouping** button in the Group Toolbar Tool and adaptive Group Toolbar Tool.
   */
  groupClearButton;
  /**
   * The text of the clear sort button located in the Sort Toolbar Tool and adaptive Sort Toolbar Tool.
   */
  sortClearButton;
  /**
   * The text of the **Done** sort button.
   */
  sortDoneButton;
  /**
   * The text of the **Done** group button in the adaptive Group Toolbar Tool.
   */
  groupDoneButton;
  /**
   * The text that is displayed in the column menu for the lock item.
   */
  lock;
  /**
   * The text that is displayed in the column menu for the unlock item.
   */
  unlock;
  /**
   * The text that is displayed in the column menu for the stick item.
   */
  stick;
  /**
   * The text that is displayed in the column menu for the unstick item.
   */
  unstick;
  /**
   * The label of the sort icon.
   */
  sortable;
  /**
   * The text that is displayed in the column menu for the ascending sort item.
   */
  sortAscending;
  /**
   * The text that is displayed in the column menu for the descending sort item.
   */
  sortDescending;
  /**
   * The text shown in the column menu for the autosize this column item.
   */
  autosizeThisColumn;
  /**
   * The text shown in the column menu for the autosize all columns item.
   */
  autosizeAllColumns;
  /**
   * The title of the Group Chip indicating the ascending sorting order of the groups.
   */
  sortedAscending;
  /**
   * The title of the Group Chip indicating the descending sorting order of the groups
   */
  sortedDescending;
  /**
   * The status announcement when a column is no longer sorted.
   */
  sortedDefault;
  /**
   * The button text of the Sort toolbar tool.
   */
  sortToolbarToolText;
  /**
   * The text that is displayed in the column menu or in the column chooser item
   * for the **Apply** button of the columns.
   */
  columnsApply;
  /**
   * The text that is displayed in the column menu or in the column chooser item
   * for the **Reset** button of the columns.
   */
  columnsReset;
  /**
   * The title of the expand icon of detail rows.
   */
  detailExpand;
  /**
   * The title of the collapse icon of detail rows.
   */
  detailCollapse;
  /**
   * The text of the Today button of the Date filter.
   */
  filterDateToday;
  /**
   * The title of the Toggle button of the Date filter.
   */
  filterDateToggle;
  /**
   * The title of the Decrement button of the Numeric filter.
   */
  filterNumericDecrement;
  /**
   * The title of the Increment button of the Numeric filter.
   */
  filterNumericIncrement;
  /**
   * The labels of the checkbox column checkboxes.
   */
  selectionCheckboxLabel;
  /**
   * The label of the checkbox column select all checkbox.
   */
  selectAllCheckboxLabel;
  /**
   * The text of the title and `aria-label` attributes applied to the collapse icon of group rows.
   */
  groupCollapse;
  /**
   * The text of the title and `aria-label` attributes applied to the expand icon of group rows.
   */
  groupExpand;
  /**
   * The label for the top toolbar.
   */
  topToolbarLabel;
  /**
   * The label for the bottom toolbar.
   */
  bottomToolbarLabel;
  /**
   * The text for the Grid Edit toolbar tool.
   */
  editToolbarToolText;
  /**
   * The text for the Grid Save toolbar tool.
   */
  saveToolbarToolText;
  /**
   * The text for the Grid Add toolbar tool.
   */
  addToolbarToolText;
  /**
   * The text for the Grid Cancel toolbar tool.
   */
  cancelToolbarToolText;
  /**
   * The text for the Grid Remove toolbar tool.
   */
  removeToolbarToolText;
  /**
   * The text for the Grid Excel Export toolbar tool.
   */
  excelExportToolbarToolText;
  /**
   * The text for the Grid PDF Export toolbar tool.
   */
  pdfExportToolbarToolText;
  /**
   * The label for the group panel toolbar.
   */
  groupPanelLabel;
  /**
   * The label for the Grid drag row handle.
   */
  dragRowHandleLabel;
  /**
   * The title for the column menu Filter tab.
   */
  columnMenuFilterTabTitle;
  /**
   * The title for the column menu General tab.
   */
  columnMenuGeneralTabTitle;
  /**
   * The title for the column menu Columns tab.
   */
  columnMenuColumnsTabTitle;
  /**
   * The text for the Group pane Chip Menu Move as previous item.
   */
  groupChipMenuPrevious;
  /**
   * The text for the Group pane Chip Menu Move as next item.
   */
  groupChipMenuNext;
  /**
   * The button text of the Group toolbar tool.
   */
  groupToolbarToolText;
  /**
   * The default text of a form validation error when using the built-in external editing.
   * <br/><br/>
   * The text consists of a three-part message&mdash;the name of the data item property the respective Grid column is bound to,
   * the name of the error, coming from the respective `FormControl` object, and a localizable string.
   * <br/><br/>
   * For a field named `ProductName`, and an error named `required`, the default error text will be `ProductName has required validation error`.
   * <br/><br/>
   * To customize the default text of the form validation error, use the `{errorName}` and `{fieldName}` placeholders and a custom localizable string.
   * For example, `{errorName} detected for {fieldName} field`.
   * <br/><br/>
   * The `{errorName}` and `{fieldName}` placeholders will be replaced internally with the field and error names for the respective invalid form control,
   * and the resulting error message will be rendered as `required error detected for ProductName field`.
   * [See example](slug:globalization_grid#toc-custom-messages).
   *
   */
  formValidationErrorText;
  /**
   * The title of the remove item confirmation Dialog.
   */
  removeConfirmationDialogTitle;
  /**
   * The content of the remove item confirmation Dialog.
   */
  removeConfirmationDialogContent;
  /**
   * The text of the confirm action button in the remove confirmation Dialog.
   */
  removeConfirmationDialogConfirmText;
  /**
   * The text of the reject action button in the remove confirmation Dialog.
   */
  removeConfirmationDialogRejectText;
  /**
   * The title of the external editing Dialog or ActionSheet when editing an item.
   */
  externalEditingTitle;
  /**
   * The title of the external editing Dialog or ActionSheet when adding a new item.
   */
  externalEditingAddTitle;
  /**
   * The text of the external editing Dialog <b>Save</b> button.
   */
  externalEditingSaveText;
  /**
   * The text of the external editing Dialog <b>Cancel</b> button.
   */
  externalEditingCancelText;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵGridMessages_BaseFactory;
    return function GridMessages_Factory(t) {
      return (ɵGridMessages_BaseFactory || (ɵGridMessages_BaseFactory = ɵɵgetInheritedFactory(_GridMessages)))(t || _GridMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _GridMessages,
    selectors: [["kendo-grid-messages-base"]],
    inputs: {
      groupPanelEmpty: "groupPanelEmpty",
      noRecords: "noRecords",
      pagerLabel: "pagerLabel",
      pagerFirstPage: "pagerFirstPage",
      pagerLastPage: "pagerLastPage",
      pagerPreviousPage: "pagerPreviousPage",
      pagerNextPage: "pagerNextPage",
      pagerPage: "pagerPage",
      pagerItemsPerPage: "pagerItemsPerPage",
      pagerOf: "pagerOf",
      pagerItems: "pagerItems",
      pagerPageNumberInputTitle: "pagerPageNumberInputTitle",
      pagerInputLabel: "pagerInputLabel",
      pagerSelectPage: "pagerSelectPage",
      filter: "filter",
      filterInputLabel: "filterInputLabel",
      filterMenuTitle: "filterMenuTitle",
      filterMenuOperatorsDropDownLabel: "filterMenuOperatorsDropDownLabel",
      filterMenuLogicDropDownLabel: "filterMenuLogicDropDownLabel",
      filterCellOperatorLabel: "filterCellOperatorLabel",
      booleanFilterCellLabel: "booleanFilterCellLabel",
      filterEqOperator: "filterEqOperator",
      filterNotEqOperator: "filterNotEqOperator",
      filterIsNullOperator: "filterIsNullOperator",
      filterIsNotNullOperator: "filterIsNotNullOperator",
      filterIsEmptyOperator: "filterIsEmptyOperator",
      filterIsNotEmptyOperator: "filterIsNotEmptyOperator",
      filterStartsWithOperator: "filterStartsWithOperator",
      filterContainsOperator: "filterContainsOperator",
      filterNotContainsOperator: "filterNotContainsOperator",
      filterEndsWithOperator: "filterEndsWithOperator",
      filterGteOperator: "filterGteOperator",
      filterGtOperator: "filterGtOperator",
      filterLteOperator: "filterLteOperator",
      filterLtOperator: "filterLtOperator",
      filterIsTrue: "filterIsTrue",
      filterIsFalse: "filterIsFalse",
      filterBooleanAll: "filterBooleanAll",
      adaptiveFilterOperatorsTitle: "adaptiveFilterOperatorsTitle",
      filterAfterOrEqualOperator: "filterAfterOrEqualOperator",
      filterAfterOperator: "filterAfterOperator",
      filterBeforeOperator: "filterBeforeOperator",
      filterBeforeOrEqualOperator: "filterBeforeOrEqualOperator",
      filterFilterButton: "filterFilterButton",
      filterClearButton: "filterClearButton",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle",
      adaptiveBackButtonTitle: "adaptiveBackButtonTitle",
      filterAndLogic: "filterAndLogic",
      filterOrLogic: "filterOrLogic",
      filterToolbarToolText: "filterToolbarToolText",
      loading: "loading",
      gridLabel: "gridLabel",
      columnMenu: "columnMenu",
      setColumnPosition: "setColumnPosition",
      columns: "columns",
      columnsSubtitle: "columnsSubtitle",
      adaptiveFilterTitle: "adaptiveFilterTitle",
      adaptiveSortTitle: "adaptiveSortTitle",
      adaptiveGroupTitle: "adaptiveGroupTitle",
      filterClearAllButton: "filterClearAllButton",
      groupClearButton: "groupClearButton",
      sortClearButton: "sortClearButton",
      sortDoneButton: "sortDoneButton",
      groupDoneButton: "groupDoneButton",
      lock: "lock",
      unlock: "unlock",
      stick: "stick",
      unstick: "unstick",
      sortable: "sortable",
      sortAscending: "sortAscending",
      sortDescending: "sortDescending",
      autosizeThisColumn: "autosizeThisColumn",
      autosizeAllColumns: "autosizeAllColumns",
      sortedAscending: "sortedAscending",
      sortedDescending: "sortedDescending",
      sortedDefault: "sortedDefault",
      sortToolbarToolText: "sortToolbarToolText",
      columnsApply: "columnsApply",
      columnsReset: "columnsReset",
      detailExpand: "detailExpand",
      detailCollapse: "detailCollapse",
      filterDateToday: "filterDateToday",
      filterDateToggle: "filterDateToggle",
      filterNumericDecrement: "filterNumericDecrement",
      filterNumericIncrement: "filterNumericIncrement",
      selectionCheckboxLabel: "selectionCheckboxLabel",
      selectAllCheckboxLabel: "selectAllCheckboxLabel",
      groupCollapse: "groupCollapse",
      groupExpand: "groupExpand",
      topToolbarLabel: "topToolbarLabel",
      bottomToolbarLabel: "bottomToolbarLabel",
      editToolbarToolText: "editToolbarToolText",
      saveToolbarToolText: "saveToolbarToolText",
      addToolbarToolText: "addToolbarToolText",
      cancelToolbarToolText: "cancelToolbarToolText",
      removeToolbarToolText: "removeToolbarToolText",
      excelExportToolbarToolText: "excelExportToolbarToolText",
      pdfExportToolbarToolText: "pdfExportToolbarToolText",
      groupPanelLabel: "groupPanelLabel",
      dragRowHandleLabel: "dragRowHandleLabel",
      columnMenuFilterTabTitle: "columnMenuFilterTabTitle",
      columnMenuGeneralTabTitle: "columnMenuGeneralTabTitle",
      columnMenuColumnsTabTitle: "columnMenuColumnsTabTitle",
      groupChipMenuPrevious: "groupChipMenuPrevious",
      groupChipMenuNext: "groupChipMenuNext",
      groupToolbarToolText: "groupToolbarToolText",
      formValidationErrorText: "formValidationErrorText",
      removeConfirmationDialogTitle: "removeConfirmationDialogTitle",
      removeConfirmationDialogContent: "removeConfirmationDialogContent",
      removeConfirmationDialogConfirmText: "removeConfirmationDialogConfirmText",
      removeConfirmationDialogRejectText: "removeConfirmationDialogRejectText",
      externalEditingTitle: "externalEditingTitle",
      externalEditingAddTitle: "externalEditingAddTitle",
      externalEditingSaveText: "externalEditingSaveText",
      externalEditingCancelText: "externalEditingCancelText"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-grid-messages-base"
    }]
  }], null, {
    groupPanelEmpty: [{
      type: Input
    }],
    noRecords: [{
      type: Input
    }],
    pagerLabel: [{
      type: Input
    }],
    pagerFirstPage: [{
      type: Input
    }],
    pagerLastPage: [{
      type: Input
    }],
    pagerPreviousPage: [{
      type: Input
    }],
    pagerNextPage: [{
      type: Input
    }],
    pagerPage: [{
      type: Input
    }],
    pagerItemsPerPage: [{
      type: Input
    }],
    pagerOf: [{
      type: Input
    }],
    pagerItems: [{
      type: Input
    }],
    pagerPageNumberInputTitle: [{
      type: Input
    }],
    pagerInputLabel: [{
      type: Input
    }],
    pagerSelectPage: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    filterInputLabel: [{
      type: Input
    }],
    filterMenuTitle: [{
      type: Input
    }],
    filterMenuOperatorsDropDownLabel: [{
      type: Input
    }],
    filterMenuLogicDropDownLabel: [{
      type: Input
    }],
    filterCellOperatorLabel: [{
      type: Input
    }],
    booleanFilterCellLabel: [{
      type: Input
    }],
    filterEqOperator: [{
      type: Input
    }],
    filterNotEqOperator: [{
      type: Input
    }],
    filterIsNullOperator: [{
      type: Input
    }],
    filterIsNotNullOperator: [{
      type: Input
    }],
    filterIsEmptyOperator: [{
      type: Input
    }],
    filterIsNotEmptyOperator: [{
      type: Input
    }],
    filterStartsWithOperator: [{
      type: Input
    }],
    filterContainsOperator: [{
      type: Input
    }],
    filterNotContainsOperator: [{
      type: Input
    }],
    filterEndsWithOperator: [{
      type: Input
    }],
    filterGteOperator: [{
      type: Input
    }],
    filterGtOperator: [{
      type: Input
    }],
    filterLteOperator: [{
      type: Input
    }],
    filterLtOperator: [{
      type: Input
    }],
    filterIsTrue: [{
      type: Input
    }],
    filterIsFalse: [{
      type: Input
    }],
    filterBooleanAll: [{
      type: Input
    }],
    adaptiveFilterOperatorsTitle: [{
      type: Input
    }],
    filterAfterOrEqualOperator: [{
      type: Input
    }],
    filterAfterOperator: [{
      type: Input
    }],
    filterBeforeOperator: [{
      type: Input
    }],
    filterBeforeOrEqualOperator: [{
      type: Input
    }],
    filterFilterButton: [{
      type: Input
    }],
    filterClearButton: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }],
    adaptiveBackButtonTitle: [{
      type: Input
    }],
    filterAndLogic: [{
      type: Input
    }],
    filterOrLogic: [{
      type: Input
    }],
    filterToolbarToolText: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    gridLabel: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    setColumnPosition: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    columnsSubtitle: [{
      type: Input
    }],
    adaptiveFilterTitle: [{
      type: Input
    }],
    adaptiveSortTitle: [{
      type: Input
    }],
    adaptiveGroupTitle: [{
      type: Input
    }],
    filterClearAllButton: [{
      type: Input
    }],
    groupClearButton: [{
      type: Input
    }],
    sortClearButton: [{
      type: Input
    }],
    sortDoneButton: [{
      type: Input
    }],
    groupDoneButton: [{
      type: Input
    }],
    lock: [{
      type: Input
    }],
    unlock: [{
      type: Input
    }],
    stick: [{
      type: Input
    }],
    unstick: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    sortAscending: [{
      type: Input
    }],
    sortDescending: [{
      type: Input
    }],
    autosizeThisColumn: [{
      type: Input
    }],
    autosizeAllColumns: [{
      type: Input
    }],
    sortedAscending: [{
      type: Input
    }],
    sortedDescending: [{
      type: Input
    }],
    sortedDefault: [{
      type: Input
    }],
    sortToolbarToolText: [{
      type: Input
    }],
    columnsApply: [{
      type: Input
    }],
    columnsReset: [{
      type: Input
    }],
    detailExpand: [{
      type: Input
    }],
    detailCollapse: [{
      type: Input
    }],
    filterDateToday: [{
      type: Input
    }],
    filterDateToggle: [{
      type: Input
    }],
    filterNumericDecrement: [{
      type: Input
    }],
    filterNumericIncrement: [{
      type: Input
    }],
    selectionCheckboxLabel: [{
      type: Input
    }],
    selectAllCheckboxLabel: [{
      type: Input
    }],
    groupCollapse: [{
      type: Input
    }],
    groupExpand: [{
      type: Input
    }],
    topToolbarLabel: [{
      type: Input
    }],
    bottomToolbarLabel: [{
      type: Input
    }],
    editToolbarToolText: [{
      type: Input
    }],
    saveToolbarToolText: [{
      type: Input
    }],
    addToolbarToolText: [{
      type: Input
    }],
    cancelToolbarToolText: [{
      type: Input
    }],
    removeToolbarToolText: [{
      type: Input
    }],
    excelExportToolbarToolText: [{
      type: Input
    }],
    pdfExportToolbarToolText: [{
      type: Input
    }],
    groupPanelLabel: [{
      type: Input
    }],
    dragRowHandleLabel: [{
      type: Input
    }],
    columnMenuFilterTabTitle: [{
      type: Input
    }],
    columnMenuGeneralTabTitle: [{
      type: Input
    }],
    columnMenuColumnsTabTitle: [{
      type: Input
    }],
    groupChipMenuPrevious: [{
      type: Input
    }],
    groupChipMenuNext: [{
      type: Input
    }],
    groupToolbarToolText: [{
      type: Input
    }],
    formValidationErrorText: [{
      type: Input
    }],
    removeConfirmationDialogTitle: [{
      type: Input
    }],
    removeConfirmationDialogContent: [{
      type: Input
    }],
    removeConfirmationDialogConfirmText: [{
      type: Input
    }],
    removeConfirmationDialogRejectText: [{
      type: Input
    }],
    externalEditingTitle: [{
      type: Input
    }],
    externalEditingAddTitle: [{
      type: Input
    }],
    externalEditingSaveText: [{
      type: Input
    }],
    externalEditingCancelText: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective3 = class _LocalizedMessagesDirective extends GridMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(t) {
    return new (t || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoGridLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: GridMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective3, [{
    type: Directive,
    args: [{
      providers: [{
        provide: GridMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective3)
      }],
      selector: "[kendoGridLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var FilterToolbarToolComponent = class _FilterToolbarToolComponent {
  element;
  filterService;
  ctx;
  columnInfoService;
  ngZone;
  adaptiveGridService;
  filterItems;
  menuItems;
  filterContainers;
  close = new EventEmitter();
  get hostStyles() {
    return {
      "maxHeight": "400px",
      "overflowX": "hidden",
      "overflowY": "auto"
    };
  }
  columnMenuService;
  columns;
  filter;
  isFilterApplied(column) {
    if (!this.filter?.filters) {
      return false;
    }
    if (Array.isArray(this.filter.filters)) {
      for (const filterGroup of this.filter.filters) {
        if (filterGroup.filters && Array.isArray(filterGroup.filters)) {
          for (const filter3 of filterGroup.filters) {
            if (filter3.field === column.field) {
              return true;
            }
          }
        } else if (filterGroup.field === column.field) {
          return true;
        }
      }
    }
    return false;
  }
  isItemFocused(filterItem) {
    return this.currentFocusedItem === filterItem;
  }
  onItemFocus(item) {
    this.currentFocusedItem = item;
  }
  onItemFocusOut() {
    this.currentFocusedItem = null;
  }
  currentFocusedItem = null;
  subscriptions;
  constructor(element, filterService, ctx, columnInfoService, ngZone, adaptiveGridService) {
    this.element = element;
    this.filterService = filterService;
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.ngZone = ngZone;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.columns = this.columnInfoService.leafNamedColumns.filter((column) => column?.filterable);
    this.filter = this.ctx.grid.filter;
    this.subscriptions = this.filterService.changes.subscribe((filter3) => {
      this.filter = cloneFilters(filter3);
    });
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.filterItems?.get(0)?.nativeElement.focus();
    });
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  navigateView(column) {
    if (this.ctx.grid.isActionSheetExpanded && this.adaptiveGridService.viewType === "filterToolbarTool") {
      const componentRef = this.ctx.grid.adaptiveRenderer.filterToolbarToolTemplate.createComponent(FilterMenuContainerComponent);
      componentRef.instance.column = this.getColumnComponent(column);
      componentRef.instance.filter = this.filter;
      this.subscriptions.add(componentRef.instance.close.subscribe(() => {
        this.adaptiveGridService.reset();
      }));
      this.adaptiveGridService.filterMenuContainerComponentRef = componentRef;
      this.adaptiveGridService.secondaryView = "columnFilter";
      this.adaptiveGridService.column = this.getColumnComponent(column);
      this.ctx.grid.adaptiveRenderer.actionSheet.nextView();
    }
  }
  getColumnComponent(column) {
    return column;
  }
  handleClose(filterItem) {
    filterItem.expanded = false;
    filterItem.contentState = "collapsed";
    const filterContainer = this.filterContainers.find((container) => container.column === filterItem.column);
    if (filterContainer) {
      filterContainer.resetChildFilters();
    }
  }
  toggleItem(event2, index) {
    const menuItem = this.menuItems.get(index);
    if (!menuItem || event2.target.closest(".k-filter-menu-container")) {
      return;
    }
    if (menuItem.expanded) {
      this.filterContainers.get(index).isExpanded = false;
      menuItem.expanded = false;
      menuItem.contentState = "collapsed";
    } else {
      this.filterContainers.get(index).isExpanded = true;
      menuItem.expanded = true;
      menuItem.contentState = "expanded";
    }
  }
  static ɵfac = function FilterToolbarToolComponent_Factory(t) {
    return new (t || _FilterToolbarToolComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterToolbarToolComponent,
    selectors: [["kendo-filter-toolbar-tool"]],
    viewQuery: function FilterToolbarToolComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c522, 5, ElementRef);
        ɵɵviewQuery(_c522, 5);
        ɵɵviewQuery(_c532, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterItems = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuItems = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterContainers = _t);
      }
    },
    outputs: {
      close: "close"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 2,
    vars: 3,
    consts: [["filterItem", ""], ["filterContainer", ""], ["class", "k-columnmenu-item-wrapper", "role", "button", "tabindex", "0", 3, "column", "text", "indicatorIcon", "expanded", "focused", "focus", "focusout", "keydown.enter", "itemClick", 4, "ngFor", "ngForOf"], ["role", "button", "tabindex", "0", 1, "k-columnmenu-item-wrapper", 3, "focus", "focusout", "keydown.enter", "itemClick", "column", "text", "indicatorIcon", "expanded", "focused"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "keydown.shift.tab", "close", "column", "filter", "isExpanded"]],
    template: function FilterToolbarToolComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵtemplate(1, FilterToolbarToolComponent_kendo_grid_columnmenu_item_1_Template, 3, 5, "kendo-grid-columnmenu-item", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵstyleMap(ctx.hostStyles);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.columns);
      }
    },
    dependencies: [NgForOf, FilterMenuContainerComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterToolbarToolComponent, [{
    type: Component,
    args: [{
      selector: "kendo-filter-toolbar-tool",
      template: `
        <div [style]="hostStyles">
            <kendo-grid-columnmenu-item *ngFor="let column of columns; let i = index"
                class="k-columnmenu-item-wrapper" #filterItem
                role="button"
                tabindex="0"
                [column]="getColumnComponent(column)"
                [text]="column.title || getColumnComponent(column).field"
                (focus)="onItemFocus(filterItem)"
                (focusout)="onItemFocusOut()"
                (keydown.enter)="toggleItem($event, i)"
                [indicatorIcon]="isFilterApplied(column)"
                (itemClick)="navigateView(getColumnComponent(column))"
                [expanded]="false"
                [focused]="isItemFocused(filterItem)">
                <ng-template kendoGridColumnMenuItemContentTemplate>
                    <kendo-grid-filter-menu-container
                        #filterContainer
                        (keydown.shift.tab)="$event.stopImmediatePropagation()"
                        [column]="getColumnComponent(column)"
                        [filter]="filter"
                        [isExpanded]="false"
                        (close)="handleClose(filterItem)">
                    </kendo-grid-filter-menu-container>
                </ng-template>
            </kendo-grid-columnmenu-item>
        </div>
    `,
      standalone: true,
      imports: [NgForOf, KENDO_BUTTON, FilterMenuContainerComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: NgZone
    }, {
      type: AdaptiveGridService
    }];
  }, {
    filterItems: [{
      type: ViewChildren,
      args: ["filterItem", {
        read: ElementRef
      }]
    }],
    menuItems: [{
      type: ViewChildren,
      args: ["filterItem"]
    }],
    filterContainers: [{
      type: ViewChildren,
      args: ["filterContainer"]
    }],
    close: [{
      type: Output
    }]
  });
})();
var directions = (initialDirection) => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
var SortToolbarToolComponent = class _SortToolbarToolComponent {
  element;
  ngZone;
  sortItems;
  wrapperClasses = true;
  onEscKeyDown(event2) {
    event2.preventDefault();
    this.hostButton?.focus(event2);
    this.close.emit();
  }
  close = new EventEmitter();
  sortClear = new EventEmitter();
  sort = new Array();
  columns = [];
  sortAscSmallIcon = sortAscSmallIcon;
  sortDescSmallIcon = sortDescSmallIcon;
  clearIcon = xIcon;
  _columnInfoService;
  set columnInfoService(columnInfoService) {
    this._columnInfoService = columnInfoService;
    this.columns = this.columnInfoService.leafNamedColumns.filter((column) => column?.sortable);
  }
  get columnInfoService() {
    return this._columnInfoService;
  }
  _ctx;
  set ctx(ctx) {
    this._ctx = ctx;
    this.sort = ctx.grid.sort;
  }
  get ctx() {
    return this._ctx;
  }
  _sortService;
  set sortService(sortService) {
    this._sortService = sortService;
    this.subscription = this._sortService.changes.subscribe((sort) => {
      this.sort = sort;
    });
  }
  get sortService() {
    return this._sortService;
  }
  subscription;
  hostButton;
  constructor(element, ngZone) {
    this.element = element;
    this.ngZone = ngZone;
  }
  ngAfterViewInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.sortItems?.get(0)?.nativeElement.focus();
    });
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  toggleSort(column, ev) {
    if (this.hostButton.location !== "toolbar") {
      ev.stopImmediatePropagation();
    }
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptor = this.getDescriptor(column);
    this.sort = descriptor;
    this.sortService.sort(descriptor);
  }
  getColumnComponent(column) {
    return column;
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
  getDescriptor(column) {
    const {
      allowUnsort,
      mode,
      initialDirection
    } = normalize$1(this.ctx.grid.sortable, column.sortable);
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptorT = this.sort.find((item) => item.field === field) || {
      field
    };
    const [first, second] = directions(initialDirection);
    let dir2 = first;
    if (descriptorT.dir === first) {
      dir2 = second;
    } else if (descriptorT.dir === second && allowUnsort) {
      dir2 = void 0;
    }
    const descriptor = {
      field,
      dir: dir2
    };
    if (mode === "single") {
      return [descriptor];
    }
    return [...this.sort.filter((desc) => desc.field !== field), descriptor];
  }
  showSortNumbering(column) {
    return this.sort && this.sort.filter(({
      dir: dir2
    }) => isPresent(dir2)).length > 1 && this.sortOrder(column.field) > 0;
  }
  sortOrder(field) {
    return this.sort.filter(({
      dir: dir2
    }) => isPresent(dir2)).findIndex((x) => x.field === field) + 1;
  }
  clearSorting() {
    if (!this.sort || this.sort.length === 0) {
      return;
    }
    this.sort = [];
    this.sortService.sort([]);
    this.sortClear.emit();
  }
  static ɵfac = function SortToolbarToolComponent_Factory(t) {
    return new (t || _SortToolbarToolComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SortToolbarToolComponent,
    selectors: [["kendo-sort-toolbar-tool"]],
    viewQuery: function SortToolbarToolComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c54, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sortItems = _t);
      }
    },
    hostVars: 4,
    hostBindings: function SortToolbarToolComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.escape", function SortToolbarToolComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.onEscKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-column-menu", ctx.wrapperClasses)("k-column-menu-md", ctx.wrapperClasses);
      }
    },
    outputs: {
      close: "close",
      sortClear: "sortClear"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 5,
    vars: 9,
    consts: [["sortItem", ""], [1, "k-column-menu-item-wrapper"], ["role", "button", "class", "k-columnmenu-item", 3, "tabindex", "click", "keydown.enter", 4, "ngFor", "ngForOf"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-column-menu-footer"], ["kendoButton", "", "icon", "x", 3, "click", "svgIcon"], ["role", "button", 1, "k-columnmenu-item", 3, "click", "keydown.enter", "tabindex"], [1, "k-columnmenu-indicators"], [3, "name", "svgIcon", 4, "ngIf"], ["class", "k-sort-index", 4, "ngIf"], [3, "name", "svgIcon"], [1, "k-sort-index"]],
    template: function SortToolbarToolComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1);
        ɵɵtemplate(1, SortToolbarToolComponent_div_1_Template, 6, 4, "div", 2);
        ɵɵelementEnd();
        ɵɵelementStart(2, "div", 3)(3, "button", 4);
        ɵɵlistener("click", function SortToolbarToolComponent_Template_button_click_3_listener() {
          return ctx.clearSorting();
        });
        ɵɵtext(4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵstyleProp("max-height", 200, "px")("overflow-x", "hidden")("overflow-y", "auto");
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.columns);
        ɵɵadvance(2);
        ɵɵproperty("svgIcon", ctx.clearIcon);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.ctx == null ? null : ctx.ctx.localization.get("sortClearButton"), " ");
      }
    },
    dependencies: [NgForOf, NgIf, IconWrapperComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SortToolbarToolComponent, [{
    type: Component,
    args: [{
      selector: "kendo-sort-toolbar-tool",
      template: `
        <div
            class="k-column-menu-item-wrapper"
            [style.max-height.px]="200"
            [style.overflow-x]="'hidden'"
            [style.overflow-y]="'auto'"
        >
            <div *ngFor="let column of columns"
                #sortItem
                role="button"
                class="k-columnmenu-item"
                (click)="toggleSort(column, $event)"
                (keydown.enter)="toggleSort(column, $event)"
                [tabindex]="'0'"
            >
                {{column.title || getColumnComponent(column).field}}

                <span class="k-columnmenu-indicators">
                    <kendo-icon-wrapper
                        *ngIf="sortDescriptor(getColumnComponent(column).field).dir"
                        name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                        [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                    ></kendo-icon-wrapper>
                    <span *ngIf="showSortNumbering(getColumnComponent(column))" class="k-sort-index">{{sortOrder(getColumnComponent(column).field)}}</span>
                </span>
            </div>
        </div>

        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
                    [svgIcon]="clearIcon"
                    icon="x"
                    (click)="clearSorting()">
                    {{ctx?.localization.get('sortClearButton')}}
                </button>
        </div>
    `,
      standalone: true,
      imports: [NgForOf, NgIf, IconWrapperComponent, KENDO_BUTTON]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    sortItems: [{
      type: ViewChildren,
      args: ["sortItem", {
        read: ElementRef
      }]
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-column-menu"]
    }, {
      type: HostBinding,
      args: ["class.k-column-menu-md"]
    }],
    onEscKeyDown: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    close: [{
      type: Output
    }],
    sortClear: [{
      type: Output
    }]
  });
})();
var FormFormFieldComponent = class _FormFormFieldComponent {
  localization;
  cdr;
  control;
  floatingLabel;
  showError;
  input;
  constructor(localization, cdr) {
    this.localization = localization;
    this.cdr = cdr;
  }
  // required to avoid ExpressionChangedAfterItHasBeenCheckedError caused by
  // binding to the label's 'for' attribute dynamically
  ngAfterContentInit() {
    this.cdr.detectChanges();
  }
  messageFor(key, errorName, field) {
    return replaceMessagePlaceholder2(replaceMessagePlaceholder2(this.localization.get(key), "fieldName", field), "errorName", errorName);
  }
  static ɵfac = function FormFormFieldComponent_Factory(t) {
    return new (t || _FormFormFieldComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FormFormFieldComponent,
    selectors: [["kendo-form-formfield"]],
    viewQuery: function FormFormFieldComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c55, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    inputs: {
      control: "control",
      floatingLabel: "floatingLabel",
      showError: "showError"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 9,
    vars: 9,
    consts: [["input", ""], ["cb", ""], [3, "orientation"], ["labelCssClass", "k-form-label", 3, "text", 4, "ngIf"], ["labelCssClass", "k-form-label", 3, "align-items", "text", "for", 4, "ngIf"], [3, "formControl", 4, "ngIf"], ["class", "k-form-field-checkbox-wrap", 4, "ngIf"], [4, "ngIf"], ["labelCssClass", "k-form-label", 3, "text"], [3, "formControl"], ["labelCssClass", "k-form-label", 3, "text", "for"], [1, "k-form-field-checkbox-wrap"], ["class", "k-checkbox-label", 3, "for", "text", 4, "ngIf"], [1, "k-checkbox-label", 3, "for", "text"], [4, "ngFor", "ngForOf"]],
    template: function FormFormFieldComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "kendo-formfield", 2);
        ɵɵtemplate(1, FormFormFieldComponent_kendo_floatinglabel_1_Template, 4, 4, "kendo-floatinglabel", 3)(2, FormFormFieldComponent_kendo_label_2_Template, 1, 4, "kendo-label", 4)(3, FormFormFieldComponent_kendo_textbox_3_Template, 2, 1, "kendo-textbox", 5)(4, FormFormFieldComponent_kendo_numerictextbox_4_Template, 2, 1, "kendo-numerictextbox", 5)(5, FormFormFieldComponent_kendo_datepicker_5_Template, 2, 1, "kendo-datepicker", 5)(6, FormFormFieldComponent_div_6_Template, 4, 2, "div", 6)(7, FormFormFieldComponent_kendo_formhint_7_Template, 2, 1, "kendo-formhint", 7)(8, FormFormFieldComponent_ng_container_8_Template, 3, 3, "ng-container", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("orientation", ctx.control.orientation);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.control.label && ctx.floatingLabel && ctx.control.dataType !== "boolean");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.control.label && !ctx.floatingLabel && ctx.control.dataType !== "boolean");
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.floatingLabel && ctx.control.dataType === "text");
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.floatingLabel && ctx.control.dataType === "numeric");
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.floatingLabel && ctx.control.dataType === "date");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.control.label && ctx.control.dataType === "boolean");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.control == null ? null : ctx.control.hint);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showError && (ctx.control.formControl == null ? null : ctx.control.formControl.invalid) && ctx.control.formControl.touched);
      }
    },
    dependencies: [KeyValuePipe, NgForOf, NgIf, ReactiveFormsModule, NgControlStatus, FormControlDirective, LabelComponent, FloatingLabelComponent, FormFieldComponent, HintComponent, ErrorComponent, TextBoxComponent, NumericTextBoxComponent, CheckBoxComponent, DatePickerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormFormFieldComponent, [{
    type: Component,
    args: [{
      selector: "kendo-form-formfield",
      standalone: true,
      imports: [KeyValuePipe, NgForOf, NgIf, ReactiveFormsModule, KENDO_LABELS, KENDO_FORMFIELD, KENDO_TEXTBOX, KENDO_NUMERICTEXTBOX, KENDO_BUTTON, KENDO_CHECKBOX, KENDO_DATEPICKER],
      template: `
        <kendo-formfield
            [orientation]="control.orientation">
            <kendo-floatinglabel
                *ngIf="control.label && floatingLabel && $any(control.dataType) !== 'boolean'"
                labelCssClass="k-form-label"
                [text]="control.label">
                <kendo-textbox
                    *ngIf="$any(control.dataType) === 'text'" 
                    [formControl]="control.formControl"></kendo-textbox>
                <kendo-numerictextbox
                    *ngIf="$any(control.dataType) === 'numeric'" 
                    [formControl]="control.formControl"></kendo-numerictextbox>
                <kendo-datepicker
                    *ngIf="$any(control.dataType) === 'date'" 
                    [formControl]="control.formControl"></kendo-datepicker>
            </kendo-floatinglabel>
            <kendo-label [style.align-items]="'start'"
                *ngIf="control.label && !floatingLabel && $any(control.dataType) !== 'boolean'"
                labelCssClass="k-form-label"
                [text]="control.label"
                [for]="input">
            </kendo-label>
            <kendo-textbox #input
                *ngIf="!floatingLabel && (control.dataType) === 'text'" 
                [formControl]="control.formControl"></kendo-textbox>
            <kendo-numerictextbox #input
                *ngIf="!floatingLabel && $any(control.dataType) === 'numeric'" 
                [formControl]="control.formControl"></kendo-numerictextbox>
            <kendo-datepicker #input
                *ngIf="!floatingLabel && $any(control.dataType) === 'date'" 
                [formControl]="control.formControl"></kendo-datepicker>
            <div
                *ngIf="control.label && $any(control.dataType) === 'boolean'"
                class="k-form-field-checkbox-wrap">
                <kendo-checkbox #cb [formControl]="control.formControl"></kendo-checkbox>
                <kendo-label
                    *ngIf="control.label"
                    class="k-checkbox-label"
                    [for]="cb"
                    [text]="control.label">
                </kendo-label>
            </div>
            
            <kendo-formhint *ngIf="control?.hint">{{control.hint}}</kendo-formhint>
            <ng-container *ngIf="showError && control.formControl?.invalid && control.formControl.touched">
                <kendo-formerror *ngFor="let err of control?.formControl?.errors | keyvalue">{{control.errors ? control.errors[err.key] : messageFor('formValidationError', err.key, control.name)}}</kendo-formerror>
            </ng-container>
        </kendo-formfield>
    `
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    control: [{
      type: Input
    }],
    floatingLabel: [{
      type: Input
    }],
    showError: [{
      type: Input
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }]
  });
})();
var idx = 0;
var FormComponent = class _FormComponent {
  controls = [];
  set formSettings(value) {
    this._formSettings = __spreadValues(__spreadValues({}, this._formSettings), value);
  }
  get formSettings() {
    return this._formSettings;
  }
  formGroup;
  set actionButtons(value) {
    if (typeof value === "boolean") {
      this.normalizeActionButtonSettings(value);
    } else {
      this._actionButtons = value;
    }
  }
  get actionButtons() {
    return this._actionButtons;
  }
  formSubmit = new EventEmitter();
  get componentIndex() {
    return idx++;
  }
  _formSettings = {
    orientation: "vertical",
    showErrors: true,
    floatingLabels: false
  };
  defaultActionButtons = [{
    actionType: "submit",
    text: "Submit",
    svgIcon: saveIcon,
    icon: "save",
    themeColor: "primary"
  }, {
    actionType: "reset",
    svgIcon: cancelIcon,
    text: "Reset",
    icon: "cancel"
  }];
  _actionButtons = this.defaultActionButtons;
  ngOnInit() {
    idx++;
  }
  normalizeActionButtonSettings(value) {
    this._actionButtons = value ? this.defaultActionButtons : [];
  }
  static ɵfac = function FormComponent_Factory(t) {
    return new (t || _FormComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FormComponent,
    selectors: [["kendo-grid-external-form"]],
    inputs: {
      controls: "controls",
      formSettings: "formSettings",
      formGroup: "formGroup",
      actionButtons: "actionButtons"
    },
    outputs: {
      formSubmit: "formSubmit"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 3,
    vars: 5,
    consts: [["template", ""], ["role", "form", 1, "k-form", "k-form-md", 3, "ngSubmit", "reset", "formGroup"], [4, "ngFor", "ngForOf"], ["class", "k-form-buttons", 4, "ngIf"], [4, "ngIf", "ngIfElse"], [3, "control", "showError", "floatingLabel"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-form-buttons"], ["kendoButton", "", 3, "k-form-submit", "size", "themeColor", "rounded", "svgIcon", "icon", 4, "ngFor", "ngForOf"], ["kendoButton", "", 3, "size", "themeColor", "rounded", "svgIcon", "icon"]],
    template: function FormComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1);
        ɵɵlistener("ngSubmit", function FormComponent_Template_div_ngSubmit_0_listener($event) {
          return ctx.formSubmit.next({
            originalEvent: $event,
            formGroup: ctx.formGroup
          });
        })("reset", function FormComponent_Template_div_reset_0_listener($event) {
          return $event.preventDefault();
        });
        ɵɵtemplate(1, FormComponent_ng_container_1_Template, 4, 2, "ng-container", 2)(2, FormComponent_div_2_Template, 2, 1, "div", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("k-form-horizontal", ctx.formSettings.orientation === "horizontal");
        ɵɵproperty("formGroup", ctx.formGroup);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.controls);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.actionButtons.length);
      }
    },
    dependencies: [NgForOf, NgIf, NgTemplateOutlet, ReactiveFormsModule, NgControlStatusGroup, FormGroupDirective, FormFormFieldComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-external-form",
      standalone: true,
      template: `
        <div role="form"
            class="k-form k-form-md"
            [class.k-form-horizontal]="formSettings.orientation === 'horizontal'"
            [formGroup]="formGroup"
            (ngSubmit)="formSubmit.next({originalEvent: $event, formGroup})"
            (reset)="$event.preventDefault()">
            <ng-container  *ngFor="let control of controls; let idx = index;">
                <ng-container *ngIf="!control.template; else template">
                    <kendo-form-formfield
                        [control]="control"
                        [showError]="formSettings.showErrors"
                        [floatingLabel]="formSettings.floatingLabels"></kendo-form-formfield>
                </ng-container>
                <ng-template #template>
                    <ng-container
                        [ngTemplateOutlet]="control.template"
                        [ngTemplateOutletContext]="control.templateContext"></ng-container>
                </ng-template>
            </ng-container>
            <div class="k-form-buttons" *ngIf="$any(actionButtons).length">
                <button kendoButton *ngFor="let button of $any(actionButtons)" 
                    [class.k-form-submit]="button.actionType === 'submit'"
                    [size]="button.size"
                    [themeColor]="button.themeColor || button.actionType === 'submit' ? 'primary' : undefined"
                    [rounded]="button.rounded"
                    [attr.type]="button.actionType"
                    [svgIcon]="button.svgIcon"
                    [icon]="button.icon">
                    {{button.text}}
                </button>
            </div>
        </div>
    `,
      imports: [NgForOf, NgIf, NgTemplateOutlet, ReactiveFormsModule, FormFormFieldComponent, KENDO_BUTTON]
    }]
  }], null, {
    controls: [{
      type: Input
    }],
    formSettings: [{
      type: Input
    }],
    formGroup: [{
      type: Input
    }],
    actionButtons: [{
      type: Input
    }],
    formSubmit: [{
      type: Output
    }]
  });
})();
var DialogFormComponent = class _DialogFormComponent extends DialogContentBase {
  localization;
  controls;
  formGroup;
  formSettings;
  saveIcon = saveIcon;
  cancelIcon = cancelIcon;
  constructor(dialogRef, localization) {
    super(dialogRef);
    this.localization = localization;
  }
  save() {
    this.dialog.close({
      text: this.localization.get("externalEditingSaveText")
    });
  }
  cancel() {
    this.dialog.close({
      text: this.localization.get("externalEditingCancelText")
    });
  }
  messageFor(key) {
    return this.localization.get(key);
  }
  static ɵfac = function DialogFormComponent_Factory(t) {
    return new (t || _DialogFormComponent)(ɵɵdirectiveInject(DialogRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DialogFormComponent,
    selectors: [["kendo-grid-dialog-form"]],
    inputs: {
      controls: "controls",
      formGroup: "formGroup",
      formSettings: "formSettings"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 6,
    vars: 10,
    consts: [[3, "controls", "formGroup", "formSettings", "actionButtons"], [3, "layout"], ["kendoButton", "", "themeColor", "primary", 3, "click", "svgIcon", "disabled"], ["kendoButton", "", 3, "click", "svgIcon"]],
    template: function DialogFormComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelement(0, "kendo-grid-external-form", 0);
        ɵɵelementStart(1, "kendo-dialog-actions", 1)(2, "button", 2);
        ɵɵlistener("click", function DialogFormComponent_Template_button_click_2_listener() {
          return ctx.save();
        });
        ɵɵtext(3);
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 3);
        ɵɵlistener("click", function DialogFormComponent_Template_button_click_4_listener() {
          return ctx.cancel();
        });
        ɵɵtext(5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("controls", ctx.controls)("formGroup", ctx.formGroup)("formSettings", ctx.formSettings)("actionButtons", false);
        ɵɵadvance();
        ɵɵproperty("layout", ctx.dialog == null ? null : ctx.dialog.dialog == null ? null : ctx.dialog.dialog.instance == null ? null : ctx.dialog.dialog.instance.actionsLayout);
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.saveIcon)("disabled", !ctx.formGroup.valid);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.messageFor("externalEditingSaveText"), " ");
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.cancelIcon);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.messageFor("externalEditingCancelText"), " ");
      }
    },
    dependencies: [FormComponent, DialogActionsComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogFormComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-dialog-form",
      standalone: true,
      imports: [FormComponent, DialogActionsComponent, KENDO_BUTTON],
      template: `
        <kendo-grid-external-form
            [controls]="controls"
            [formGroup]="formGroup"
            [formSettings]="formSettings"
            [actionButtons]="false"></kendo-grid-external-form>
        <kendo-dialog-actions [layout]="this.dialog?.dialog?.instance?.actionsLayout">
            <button
                kendoButton
                themeColor="primary"
                [svgIcon]="saveIcon"
                [disabled]="!formGroup.valid"
                (click)="save()"
            >
                {{messageFor('externalEditingSaveText')}}
            </button>
            <button
                kendoButton
                [svgIcon]="cancelIcon"
                (click)="cancel()">
                {{messageFor('externalEditingCancelText')}}
            </button>
        </kendo-dialog-actions>
    `
    }]
  }], function() {
    return [{
      type: DialogRef
    }, {
      type: LocalizationService
    }];
  }, {
    controls: [{
      type: Input
    }],
    formGroup: [{
      type: Input
    }],
    formSettings: [{
      type: Input
    }]
  });
})();
var GroupToolbarToolComponent = class _GroupToolbarToolComponent {
  element;
  ngZone;
  hostClass = true;
  get lgClass() {
    return this.adaptive;
  }
  get mdClass() {
    return !this.adaptive;
  }
  onEscKeyDown(event2) {
    event2.preventDefault();
    this.hostButton?.focus(event2);
    this.close.emit();
  }
  set groupItems(items) {
    this._groupItems = items;
    if (items?.first && (!isPresent(this.currentFocusedItemIndex) || this.currentFocusedItemIndex >= items.length || this.currentFocusedItemIndex < 0)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.currentFocusedItemIndex = 0;
        this.groupItems.first.nativeElement.focus();
      });
      return;
    }
    if (items?.first) {
      items.get(this.currentFocusedItemIndex).nativeElement.focus();
    }
  }
  get groupItems() {
    return this._groupItems;
  }
  _groupItems;
  adaptive = false;
  close = new EventEmitter();
  groupClear = new EventEmitter();
  currentFocusedItemIndex;
  group = new Array();
  columns = [];
  iconSize = "medium";
  upIcon = chevronUpIcon;
  downIcon = chevronDownIcon;
  removeIcon = xCircleIcon;
  addIcon = plusCircleIcon;
  clearIcon = xIcon;
  _ctx;
  set ctx(ctx) {
    if (!ctx || !ctx.grid) {
      return;
    }
    this._ctx = ctx;
    this.group = ctx.grid.group;
    this.subscription = ctx.grid.groupChange.subscribe((group) => {
      this.group = group;
      this.updateGroupedColumns();
    });
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.updateGroupedColumns();
    });
  }
  get ctx() {
    return this._ctx;
  }
  groupedColumns = [];
  ungroupedColumns = [];
  subscription;
  hostButton;
  constructor(element, ngZone) {
    this.element = element;
    this.ngZone = ngZone;
  }
  ngOnInit() {
    this.iconSize = this.adaptive ? "large" : "medium";
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  addGroup(column, ev) {
    ev.stopImmediatePropagation();
    const index = this.group.length;
    const groups = this.group.filter((x) => x.field !== column?.field);
    if (groups.length || this.group.length === 0) {
      this.group = [...groups.slice(0, index), {
        field: column?.field
      }, ...groups.slice(index)];
      this.ctx.grid.groupChange.emit(this.group);
      this.updateGroupedColumns();
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        const newIndex = this.groupedColumns.length - 1;
        const newItem = this.groupItems.get(newIndex);
        if (newItem) {
          this.currentFocusedItemIndex = (this.groupedColumns?.length || 0) + newIndex;
          newItem.nativeElement.focus();
        }
      });
    }
  }
  removeGroup(column, ev) {
    ev.stopImmediatePropagation();
    this.group = this.group.filter((x) => x.field !== column?.field);
    this.ctx.grid.groupChange.emit(this.group);
    this.updateGroupedColumns();
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      const newIndex = this.ungroupedColumns.findIndex((ungroupedColumn) => ungroupedColumn?.field === column?.field);
      const newItem = this.groupItems.get(newIndex + this.groupedColumns.length);
      if (newItem) {
        newItem.nativeElement.focus();
      }
    });
  }
  moveGroupUp(column, ev) {
    ev.stopImmediatePropagation();
    const index = this.group.findIndex((x) => x.field === column?.field);
    if (index > 0) {
      const groupToMove = this.group[index];
      this.group.splice(index, 1);
      this.group.splice(index - 1, 0, groupToMove);
      this.ctx.grid.groupChange.emit(this.group);
      this.updateGroupedColumns();
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        const newItem = this.groupItems.get(index - 1);
        if (newItem) {
          newItem.nativeElement.focus();
          this.currentFocusedItemIndex = index - 1;
        }
      });
    }
  }
  moveGroupDown(column, ev) {
    ev.stopImmediatePropagation();
    const index = this.group.findIndex((x) => x.field === column?.field);
    if (index < this.group.length - 1) {
      const groupToMove = this.group[index];
      this.group.splice(index, 1);
      this.group.splice(index + 1, 0, groupToMove);
      this.ctx.grid.groupChange.emit(this.group);
      this.updateGroupedColumns();
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        const newItem = this.groupItems.get(index + 1);
        if (newItem) {
          newItem.nativeElement.focus();
          this.currentFocusedItemIndex = index + 1;
        }
      });
    }
  }
  clear() {
    this.group = [];
    this.ctx.grid.groupChange.emit(this.group);
    this.groupClear.emit(this.group);
  }
  getColumnComponent(column) {
    return column;
  }
  onItemFocus(groupIndex, index) {
    const currentIndex = (typeof groupIndex === "number" ? groupIndex : this.groupedColumns?.length || 0) + index;
    this.currentFocusedItemIndex = currentIndex;
  }
  handleGroupedKeydown(column, index, ev) {
    if (ev.code === "Enter" || ev.code === "Backspace" || ev.code === "Delete") {
      this.removeGroup(column, ev);
    } else if (ev.code === "ArrowUp" && ev.shiftKey) {
      this.moveGroupUp(column, ev);
    } else if (ev.code === "ArrowDown" && ev.shiftKey) {
      this.moveGroupDown(column, ev);
    } else if (ev.code === "ArrowUp") {
      this.navigateToPreviousItem();
    } else if (ev.code === "ArrowDown") {
      this.navigateToNextItem();
    }
  }
  handleUngroupedKeydown(column, index, ev) {
    if (ev.code === "Enter") {
      this.addGroup(column, ev);
    } else if (ev.code === "ArrowUp") {
      this.navigateToPreviousItem();
    } else if (ev.code === "ArrowDown") {
      this.navigateToNextItem();
    }
  }
  updateGroupedColumns() {
    this.groupedColumns = this.group.map((group) => this.ctx.grid.columns.find((column) => column?.field === group.field)).filter((column) => !!column);
    this.ungroupedColumns = this.ctx.grid.columns.filter((column) => column?.groupable && !this.groupedColumns.some((gc) => gc?.field === column?.field));
  }
  navigateToNextItem() {
    if (this.currentFocusedItemIndex < this.groupItems.length - 1) {
      this.currentFocusedItemIndex++;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    } else if (this.currentFocusedItemIndex === this.groupItems.length - 1) {
      this.currentFocusedItemIndex = 0;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    }
  }
  navigateToPreviousItem() {
    if (this.currentFocusedItemIndex > 0) {
      this.currentFocusedItemIndex--;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    } else if (this.currentFocusedItemIndex === 0) {
      this.currentFocusedItemIndex = this.groupItems.length - 1;
      this.groupItems.get(this.currentFocusedItemIndex).nativeElement.focus();
    }
  }
  static ɵfac = function GroupToolbarToolComponent_Factory(t) {
    return new (t || _GroupToolbarToolComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GroupToolbarToolComponent,
    selectors: [["kendo-group-toolbar-tool"]],
    viewQuery: function GroupToolbarToolComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c56, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupItems = _t);
      }
    },
    hostVars: 6,
    hostBindings: function GroupToolbarToolComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.escape", function GroupToolbarToolComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.onEscKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-group-menu", ctx.hostClass)("k-group-menu-lg", ctx.lgClass)("k-group-menu-md", ctx.mdClass);
      }
    },
    inputs: {
      adaptive: "adaptive"
    },
    outputs: {
      close: "close",
      groupClear: "groupClear"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 3,
    vars: 3,
    consts: [["groupItem", ""], ["class", "k-group-menu-item-wrap", 4, "ngIf"], ["class", "k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer", 4, "ngIf"], [1, "k-group-menu-item-wrap"], ["role", "button", "class", "k-group-menu-item", "tabindex", "0", 3, "keydown", "focus", 4, "ngFor", "ngForOf"], ["role", "button", "tabindex", "0", 1, "k-group-menu-item", 3, "keydown", "focus"], ["class", "k-group-menu-item-actions", 4, "ngIf"], [1, "k-group-item-text"], [1, "k-spacer"], [1, "k-group-menu-item-actions"], [1, "k-group-menu-item-action", "k-group-menu-item-remove-action", 3, "click"], ["name", "x-circle", 3, "svgIcon", "size"], [1, "k-group-menu-item-action", "k-group-menu-item-up-action", 3, "click"], ["name", "arrow-chevron-up", 3, "svgIcon", "size"], [1, "k-group-menu-item-action", "k-group-menu-item-down-action", 3, "click"], ["name", "arrow-chevron-down", 3, "svgIcon", "size"], [1, "k-group-menu-item-action", "k-group-menu-item-add-action", 3, "click"], ["name", "plus-circle", 3, "svgIcon", "size"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-column-menu-footer"], ["kendoButton", "", "icon", "x", 3, "click", "svgIcon"]],
    template: function GroupToolbarToolComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, GroupToolbarToolComponent_div_0_Template, 2, 1, "div", 1)(1, GroupToolbarToolComponent_div_1_Template, 2, 1, "div", 1)(2, GroupToolbarToolComponent_div_2_Template, 3, 2, "div", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.groupedColumns.length);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.ungroupedColumns.length);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.adaptive);
      }
    },
    dependencies: [NgForOf, NgIf, IconWrapperComponent, ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupToolbarToolComponent, [{
    type: Component,
    args: [{
      selector: "kendo-group-toolbar-tool",
      template: `
        <div *ngIf="groupedColumns.length" class="k-group-menu-item-wrap">
            <div *ngFor="let column of groupedColumns; let i = index"
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleGroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(i, 0)"
            >
                <span class="k-group-menu-item-actions" *ngIf="groupedColumns.length > 1">
                    <span
                        class="k-group-menu-item-action k-group-menu-item-up-action"
                        (click)="moveGroupUp(column, $event)"
                        [attr.aria-disabled]="i === 0"
                        [class.k-disabled]="i === 0"
                    >
                        <kendo-icon-wrapper
                            name="arrow-chevron-up"
                            [svgIcon]="upIcon"
                            [size]="iconSize"
                        ></kendo-icon-wrapper>
                    </span>
                    <span
                        class="k-group-menu-item-action k-group-menu-item-down-action"
                        (click)="moveGroupDown(column, $event)"
                        [attr.aria-disabled]="i === groupedColumns.length - 1"
                        [class.k-disabled]="i === groupedColumns.length - 1"
                    >
                        <kendo-icon-wrapper
                            name="arrow-chevron-down"
                            [svgIcon]="downIcon"
                            [size]="iconSize"
                        ></kendo-icon-wrapper>
                    </span>
                </span>
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                    <span class="k-group-menu-item-action k-group-menu-item-remove-action" (click)="removeGroup(column, $event)">
                        <kendo-icon-wrapper
                            name="x-circle"
                            [svgIcon]="removeIcon"
                            [size]="iconSize"
                        ></kendo-icon-wrapper>
                    </span>
                </span>
            </div>
        </div>

        <div *ngIf="ungroupedColumns.length" class="k-group-menu-item-wrap">
            <div *ngFor="let column of ungroupedColumns; let i = index"
                #groupItem
                role="button"
                class="k-group-menu-item"
                tabindex="0"
                (keydown)="handleUngroupedKeydown(column, i, $event)"
                (focus)="onItemFocus(null, i)"
            >
                <span class="k-group-item-text">{{column.title || getColumnComponent(column).field}}</span>
                <span class="k-spacer"></span>
                <span class="k-group-menu-item-actions">
                    <span class="k-group-menu-item-action k-group-menu-item-add-action" (click)="addGroup(column, $event)">
                        <kendo-icon-wrapper
                            name="plus-circle"
                            [svgIcon]="addIcon"
                            [size]="iconSize"
                        ></kendo-icon-wrapper>
                    </span>
                </span>
            </div>
        </div>

        <div *ngIf="!adaptive" class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
                [svgIcon]="clearIcon"
                (click)="clear()"
                icon="x"
            >
                {{ctx?.localization.get('groupClearButton')}}
            </button>
        </div>
    `,
      standalone: true,
      imports: [NgForOf, NgIf, IconWrapperComponent, KENDO_BUTTON]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-group-menu"]
    }],
    lgClass: [{
      type: HostBinding,
      args: ["class.k-group-menu-lg"]
    }],
    mdClass: [{
      type: HostBinding,
      args: ["class.k-group-menu-md"]
    }],
    onEscKeyDown: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    groupItems: [{
      type: ViewChildren,
      args: ["groupItem", {
        read: ElementRef
      }]
    }],
    adaptive: [{
      type: Input
    }],
    close: [{
      type: Output
    }],
    groupClear: [{
      type: Output
    }]
  });
})();
var AdaptiveRendererComponent = class _AdaptiveRendererComponent {
  service;
  adaptiveGridService;
  filterService;
  ctx;
  adaptiveService;
  sortService;
  columnInfoService;
  xIcon = xIcon;
  checkIcon = checkIcon;
  filterIcon = filterIcon;
  arrowRotateCcwIcon = arrowRotateCcwIcon;
  chevronLeft = chevronLeftIcon;
  filterClearIcon = filterClearIcon;
  cancelIcon = cancelIcon;
  saveIcon = saveIcon;
  columns;
  actionsClass = "k-actions";
  externalEditingSettings;
  get hasSort() {
    return hasSort(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasColumnChooser() {
    return hasColumnChooser(this.ctx.grid.columnMenu);
  }
  get hasFilter() {
    return hasFilter(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasAutoSizeColumn() {
    return hasAutoSizeColumn(this.ctx.grid.columnMenu);
  }
  get hasAutoSizeAllColumns() {
    return hasAutoSizeAllColumns(this.ctx.grid.columnMenu);
  }
  get hasLock() {
    return hasLock(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasStick() {
    return hasStick(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  get hasPosition() {
    return hasPosition(this.ctx.grid.columnMenu, this.adaptiveGridService.column);
  }
  getColumnComponent(column) {
    return column;
  }
  get hasTitle() {
    const hasTitle = this.adaptiveGridService.viewType === "columnMenu" || this.adaptiveGridService.viewType === "filterToolbarTool" || this.adaptiveGridService.viewType === "columnChooserToolbarTool" || this.adaptiveGridService.viewType === "filterMenu" || this.adaptiveGridService.viewType === "sortToolbarTool" || this.adaptiveGridService.viewType === "groupToolbarTool" || this.adaptiveGridService.viewType === "externalEditing";
    return hasTitle;
  }
  get hasSubtitle() {
    const hasSubtitle = this.adaptiveGridService.viewType === "columnMenu" && this.adaptiveGridService.secondaryView === "columnChooser" || this.adaptiveGridService.viewType === "columnChooserToolbarTool";
    return hasSubtitle;
  }
  get actionSheetTitle() {
    if (this.adaptiveGridService.viewType === "columnMenu") {
      if (this.adaptiveGridService.secondaryView === "columnChooser") {
        return this.messageFor("columns");
      }
      if (this.adaptiveGridService.secondaryView === "columnPosition") {
        return this.messageFor("setColumnPosition");
      }
      if (this.adaptiveGridService.secondaryView === "columnFilter") {
        return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
      }
      return this.columnMenuTitle;
    }
    if (this.adaptiveGridService.viewType === "filterToolbarTool") {
      if (this.adaptiveGridService.secondaryView === "columnFilter") {
        return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
      }
      return this.messageFor("adaptiveFilterTitle");
    }
    if (this.adaptiveGridService.viewType === "filterMenu") {
      return this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    }
    if (this.adaptiveGridService.viewType === "columnChooserToolbarTool") {
      return this.messageFor("columns");
    }
    if (this.adaptiveGridService.viewType === "sortToolbarTool") {
      return this.messageFor("adaptiveSortTitle");
    }
    if (this.adaptiveGridService.viewType === "groupToolbarTool") {
      return this.messageFor("adaptiveGroupTitle");
    }
    if (this.adaptiveGridService.viewType === "externalEditing") {
      return this.messageFor(this.externalEditingSettings.event.isNew ? "externalEditingAddTitle" : "externalEditingTitle");
    }
  }
  get adaptiveFilterTitle() {
    const columnTitle = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    return `${this.messageFor("adaptiveFilterTitle")} ${columnTitle}`;
  }
  get columnMenuTitle() {
    const columnName = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    return columnName;
  }
  get filterLabel() {
    const localizationMsg = this.messageFor("filterMenuTitle") || "";
    const columnName = this.adaptiveGridService.column.title || this.adaptiveGridService.column.field;
    return replaceMessagePlaceholder2(localizationMsg, "columnName", columnName);
  }
  get hasXCloseIcon() {
    return this.adaptiveGridService.viewType !== "sortToolbarTool" && this.adaptiveGridService.viewType !== "groupToolbarTool";
  }
  get hasCheckCloseIcon() {
    return this.adaptiveGridService.viewType === "sortToolbarTool" || this.adaptiveGridService.viewType === "groupToolbarTool";
  }
  columnList;
  filterToolbarToolTemplate;
  filterMenuContainer;
  actionSheet;
  set groupToolbarTool(value) {
    value && (value.ctx = this.ctx);
  }
  adaptiveSizeChangeSubscription;
  constructor(service, adaptiveGridService, filterService, ctx, adaptiveService, sortService, columnInfoService) {
    this.service = service;
    this.adaptiveGridService = adaptiveGridService;
    this.filterService = filterService;
    this.ctx = ctx;
    this.adaptiveService = adaptiveService;
    this.sortService = sortService;
    this.columnInfoService = columnInfoService;
    this.adaptiveSizeChangeSubscription = this.adaptiveService.sizeChanges.subscribe(() => {
      if (this.ctx.grid.isOpen) {
        if (this.actionSheet.expanded) {
          this.actionSheet.toggle(false);
        } else {
          this.adaptiveGridService.popupRef.close();
          this.adaptiveGridService.popupRef = null;
        }
      }
    });
  }
  ngOnInit() {
    this.columns = this.columnInfoService.leafNamedColumns.filter((column) => column?.sortable);
  }
  ngOnDestroy() {
    if (this.adaptiveSizeChangeSubscription) {
      this.adaptiveSizeChangeSubscription.unsubscribe();
    }
  }
  messageFor = (token) => this.ctx.localization.get(token);
  close() {
    this.actionSheet.toggle(false);
    this.adaptiveGridService.reset();
  }
  prevView() {
    this.adaptiveGridService.secondaryView = null;
    this.adaptiveGridService.filterMenuContainerComponentRef?.destroy();
    this.actionSheet.prevView();
  }
  clearFilters() {
    const emptyFilter = {
      logic: "and",
      filters: []
    };
    this.filterService.filter(emptyFilter);
    this.actionSheet.toggle(false);
  }
  navigateToColumnsView() {
    this.adaptiveGridService.secondaryView = "columnChooser";
    this.actionSheet.nextView();
  }
  navigateToFilterView() {
    this.adaptiveGridService.secondaryView = "columnFilter";
    this.actionSheet.nextView();
  }
  navigateToPositionView() {
    this.adaptiveGridService.secondaryView = "columnPosition";
    this.actionSheet.nextView();
  }
  applyChanges() {
    this.columnList.applyChanges();
    this.actionSheet.toggle(false);
  }
  sortBy(column) {
    this.toggleSort(this.getColumnComponent(column));
  }
  toggleSort(column) {
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptor = this.getDescriptor(column);
    this.sortService.sort(descriptor);
  }
  getDescriptor(column) {
    const {
      allowUnsort,
      mode,
      initialDirection
    } = normalize$1(this.ctx.grid.sortable, column.sortable);
    const field = column?.field;
    if (!field) {
      return;
    }
    const descriptorT = this.ctx.grid.sort.find((item) => item.field === field) || {
      field
    };
    const [first, second] = directions(initialDirection);
    let dir2 = first;
    if (descriptorT.dir === first) {
      dir2 = second;
    } else if (descriptorT.dir === second && allowUnsort) {
      dir2 = void 0;
    }
    const descriptor = {
      field,
      dir: dir2
    };
    if (mode === "single") {
      return [descriptor];
    }
    return [...this.ctx.grid.sort.filter((desc) => desc.field !== field), descriptor];
  }
  clearSorting() {
    if (this.ctx.grid.sort.length > 0) {
      this.sortService.sort([]);
    }
    this.actionSheet.toggle(false);
  }
  clearGrouping() {
    if (this.ctx.grid.group.length > 0) {
      this.ctx.grid.group = [];
      this.ctx.grid.groupChange.emit(this.ctx.grid.group);
    }
    this.actionSheet.toggle(false);
  }
  onAnimationEnd() {
    this.adaptiveGridService.notifyAnimationEnd();
  }
  cancelChanges() {
    this.columnList.cancelChanges();
  }
  onTab(event2) {
    this.columnList.onTab(event2);
  }
  saveEditing() {
    const {
      event: event2,
      formGroup,
      externalEditingDirective
    } = this.externalEditingSettings;
    externalEditingDirective.saveHandler(__spreadProps(__spreadValues({}, event2), {
      formGroup
    }));
    this.actionSheet.toggle(false);
  }
  static ɵfac = function AdaptiveRendererComponent_Factory(t) {
    return new (t || _AdaptiveRendererComponent)(ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(AdaptiveService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ColumnInfoService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AdaptiveRendererComponent,
    selectors: [["kendo-grid-adaptive-renderer"]],
    viewQuery: function AdaptiveRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c202, 5);
        ɵɵviewQuery(_c57, 5, ViewContainerRef);
        ɵɵviewQuery(_c58, 5);
        ɵɵviewQuery(ActionSheetComponent, 5);
        ɵɵviewQuery(GroupToolbarToolComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterToolbarToolTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenuContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupToolbarTool = _t.first);
      }
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 16,
    vars: 17,
    consts: [["actionSheetHeaderTemplate", ""], ["actionSheetFooterTemplate", ""], ["filterFooterButtons", ""], ["columnList", ""], ["filterToolbarToolTemplate", ""], ["filterMenuContainer", ""], ["sortItem", ""], ["lockItem", ""], ["stickItem", ""], ["positionItem", ""], ["chooserItem", ""], ["autoSizeColumnItem", ""], ["autoSizeAllColumnsItem", ""], ["filterItem", ""], ["resetButton", ""], ["applyButton", ""], [3, "collapse", "cssClass", "cssStyle", "overlayClickClose"], [4, "ngIf"], [3, "kendoEventsOutsideAngular", "scope", 4, "ngIf"], ["kendoActionSheetHeaderTemplate", ""], ["kendoActionSheetContentTemplate", ""], ["kendoActionSheetFooterTemplate", ""], [3, "ngTemplateOutlet"], [1, "k-column-menu", "k-column-menu-lg"], [1, "k-columnmenu-item-wrapper"], [3, "column", "text", "itemClick", 4, "ngFor", "ngForOf"], [3, "itemClick", "column", "text"], ["kendoButton", "", "size", "large", "fillMode", "solid", "icon", "x", 3, "click", "svgIcon"], ["kendoButton", "", "size", "large", "fillMode", "solid", "icon", "check", "themeColor", "primary", 3, "click", "svgIcon"], [3, "columns", "ariaLabel", "isLast", "showActions", "applyText", "resetText", "autoSync", "actionsClass", "allowHideAll"], [3, "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "icon", "filter-clear", "size", "large", 3, "click", "svgIcon"], [3, "close", "keydown.enter", "column", "filter"], [3, "kendoGridColumnMenuItem", "service", 4, "ngIf"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded", "collapse", 4, "ngIf"], ["class", "k-separator", 3, "borderColor", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service", "expanded", "collapse", 4, "ngIf"], [3, "service", "kendoGridColumnMenuItem", "column", 4, "ngIf"], [3, "service", "kendoGridColumnMenuItem", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service"], [3, "collapse", "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded"], [1, "k-separator"], [3, "collapse", "kendoGridColumnMenuItem", "service", "expanded"], [3, "service", "kendoGridColumnMenuItem", "column"], [3, "service", "kendoGridColumnMenuItem"], [3, "columns", "ariaLabel", "isLast", "showActions", "applyText", "resetText", "autoSync", "actionsClass", "allowHideAll", 4, "ngIf"], [3, "column", "filter", "kendoEventsOutsideAngular", "scope", "close", 4, "ngIf"], [3, "service", 4, "ngIf"], [3, "close", "column", "filter", "kendoEventsOutsideAngular", "scope"], [3, "service"], [3, "controls", "formGroup", "formSettings", "actionButtons"], ["kendoButton", "", "size", "large", "icon", "cancel", 3, "click", "svgIcon"], ["kendoButton", "", "themeColor", "primary", "size", "large", "icon", "save", 3, "click", "svgIcon", "disabled"], [3, "adaptive"], [1, "k-actionsheet-titlebar-group"], ["class", "k-actionsheet-actions", 4, "ngIf"], [1, "k-actionsheet-title"], ["class", "k-text-center", 4, "ngIf"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-actionsheet-actions"], ["kendoButton", "", "icon", "chevron-left", "fillMode", "flat", "size", "large", 3, "click", "svgIcon", "title"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], ["kendoButton", "", "icon", "x", "fillMode", "flat", "size", "large", 3, "click", "svgIcon", "title"], ["kendoButton", "", "icon", "check", "fillMode", "flat", "size", "large", "themeColor", "primary", 3, "click", "svgIcon", "title"], ["kendoButton", "", "size", "large", "fillMode", "solid", "icon", "arrow-rotate-ccw", "type", "button", 3, "svgIcon", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "type", "button", "icon", "check", "size", "large", "fillMode", "solid", "themeColor", "primary", 3, "svgIcon", "kendoEventsOutsideAngular", "scope"], ["kendoButton", "", "size", "large", "fillMode", "solid", 3, "click"], ["kendoButton", "", "size", "large", "fillMode", "solid", "themeColor", "primary", 3, "click", "disabled"]],
    template: function AdaptiveRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-actionsheet", 16);
        ɵɵlistener("collapse", function AdaptiveRendererComponent_Template_kendo_actionsheet_collapse_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.adaptiveGridService.reset());
        });
        ɵɵtemplate(1, AdaptiveRendererComponent_kendo_actionsheet_view_1_Template, 4, 0, "kendo-actionsheet-view", 17)(2, AdaptiveRendererComponent_kendo_actionsheet_view_2_Template, 4, 0, "kendo-actionsheet-view", 17)(3, AdaptiveRendererComponent_kendo_actionsheet_view_3_Template, 4, 4, "kendo-actionsheet-view", 18)(4, AdaptiveRendererComponent_kendo_actionsheet_view_4_Template, 4, 0, "kendo-actionsheet-view", 17)(5, AdaptiveRendererComponent_kendo_actionsheet_view_5_Template, 4, 0, "kendo-actionsheet-view", 17)(6, AdaptiveRendererComponent_kendo_actionsheet_view_6_Template, 3, 4, "kendo-actionsheet-view", 18)(7, AdaptiveRendererComponent_kendo_actionsheet_view_7_Template, 5, 2, "kendo-actionsheet-view", 17)(8, AdaptiveRendererComponent_kendo_actionsheet_view_8_Template, 4, 0, "kendo-actionsheet-view", 17)(9, AdaptiveRendererComponent_kendo_actionsheet_view_9_Template, 4, 0, "kendo-actionsheet-view", 17);
        ɵɵelementEnd();
        ɵɵtemplate(10, AdaptiveRendererComponent_ng_template_10_Template, 7, 5, "ng-template", null, 0, ɵɵtemplateRefExtractor)(12, AdaptiveRendererComponent_ng_template_12_Template, 6, 17, "ng-template", null, 1, ɵɵtemplateRefExtractor)(14, AdaptiveRendererComponent_ng_template_14_Template, 4, 3, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("cssClass", ɵɵpureFunction2(12, _c59, ctx.adaptiveService.size === "small", ctx.adaptiveService.size === "medium"))("cssStyle", ɵɵpureFunction1(15, _c60, ctx.adaptiveService.size === "small" ? "100vh" : "60vh"))("overlayClickClose", true);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "sortToolbarTool");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "columnChooserToolbarTool");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "filterToolbarTool");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "filterToolbarTool");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "filterMenu");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "columnMenu");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "columnMenu");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "externalEditing");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.adaptiveGridService.viewType === "groupToolbarTool");
      }
    },
    dependencies: [NgIf, NgForOf, NgTemplateOutlet, ActionSheetComponent, ActionSheetViewComponent, FilterToolbarToolComponent, GroupToolbarToolComponent, ButtonComponent, ActionSheetHeaderTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuItemComponent, ColumnMenuItemDirective, ColumnListComponent, FilterMenuContainerComponent, EventsOutsideAngularDirective, FormComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveRendererComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-adaptive-renderer",
      template: `
        <kendo-actionsheet
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': adaptiveService.size === 'small',
                'k-actionsheet-bottom': adaptiveService.size === 'medium'
            }"
            [cssStyle]="{
                height: adaptiveService.size === 'small' ? '100vh' : '60vh'
            }"
            [overlayClickClose]="true"
            (collapse)="adaptiveGridService.reset()">

            <!-- sortToolbarTool view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'sortToolbarTool'">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>
                <ng-template kendoActionSheetContentTemplate>
                    <div class="k-column-menu k-column-menu-lg">
                        <div class="k-columnmenu-item-wrapper">
                            <kendo-grid-columnmenu-item *ngFor="let column of columns"
                                            [column]="getColumnComponent(column)"
                                            [text]="column.title || getColumnComponent(column).field"
                                            (itemClick)="sortBy(column)">
                            </kendo-grid-columnmenu-item>
                        </div>
                    </div>
                </ng-template>
                <ng-template kendoActionSheetFooterTemplate>
                    <button
                        kendoButton
                        size="large"
                        fillMode="solid"
                        icon="x"
                        [svgIcon]="xIcon"
                        (click)="clearSorting()">
                        {{messageFor('sortClearButton')}}
                    </button>
                    <button
                        kendoButton
                        size="large"
                        fillMode="solid"
                        icon="check"
                        [svgIcon]="checkIcon"
                        themeColor="primary"
                        (click)="actionSheet.toggle(false)">
                        {{messageFor('sortDoneButton')}}
                    </button>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- columnChooserToolbarTool view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'columnChooserToolbarTool'">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>
                <ng-template kendoActionSheetContentTemplate>
                    <kendo-grid-columnlist
                        #columnList
                        [columns]="adaptiveGridService.columns"
                        [ariaLabel]="messageFor('columns')"
                        [isLast]="true"
                        [showActions]="false"
                        [applyText]="messageFor('columnsApply')"
                        [resetText]="messageFor('columnsReset')"
                        [autoSync]="false"
                        [actionsClass]="actionsClass"
                        [allowHideAll]="false"
                        >
                    </kendo-grid-columnlist>
                </ng-template>
                <ng-template kendoActionSheetFooterTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                    </ng-container>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- filterToolbarTool first view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'filterToolbarTool'"
                                    [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
                                    [scope]="this">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>
                <ng-template kendoActionSheetContentTemplate>
                    <div class="k-column-menu k-column-menu-lg">
                        <kendo-filter-toolbar-tool></kendo-filter-toolbar-tool>
                    </div>
                </ng-template>
                <ng-template kendoActionSheetFooterTemplate>
                    <button kendoButton
                            icon="filter-clear"
                            [svgIcon]="filterClearIcon"
                            size="large"
                            (click)="clearFilters()">
                            {{messageFor('filterClearAllButton')}}
                    </button>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- filterToolbarTool second view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'filterToolbarTool'">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>
                <ng-template kendoActionSheetContentTemplate>
                    <ng-container #filterToolbarToolTemplate></ng-container>
                </ng-template>
                <ng-template kendoActionSheetFooterTemplate>
                    <ng-container [ngTemplateOutlet]="filterFooterButtons">
                    </ng-container>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- filterMenu view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'filterMenu'">
                <ng-template kendoActionSheetHeaderTemplate >
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>
                <ng-template kendoActionSheetContentTemplate>
                    <kendo-grid-filter-menu-container
                        #filterMenuContainer
                        [column]="adaptiveGridService.column"
                        [filter]="ctx.grid.filter"
                        (close)="close()"
                        (keydown.enter)="$event.stopImmediatePropagation()">
                    </kendo-grid-filter-menu-container>
                </ng-template>
                <ng-template kendoActionSheetFooterTemplate>
                    <ng-container [ngTemplateOutlet]="filterFooterButtons">
                    </ng-container>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- columnMenu first view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'columnMenu'"
                [kendoEventsOutsideAngular]="{transitionend: onAnimationEnd}"
                [scope]="this">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>    
                <ng-template kendoActionSheetContentTemplate>
                    <div class="k-column-menu k-column-menu-lg">
                        <kendo-grid-columnmenu-container>
                            <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="adaptiveGridService.columnMenuService">
                            </kendo-grid-columnmenu-sort>
                            <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="adaptiveGridService.columnMenuService">
                            </kendo-grid-columnmenu-lock>
                            <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="adaptiveGridService.columnMenuService">
                            </kendo-grid-columnmenu-stick>
                            <kendo-grid-columnmenu-position
                                #positionItem
                                *ngIf="hasPosition"
                                [showLock]="hasLock"
                                [showStick]="hasStick"
                                [kendoGridColumnMenuItem]="positionItem"
                                [service]="adaptiveGridService.columnMenuService"
                                [expanded]="false"
                                (collapse)="navigateToPositionView()">
                            </kendo-grid-columnmenu-position>
                            <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasLock || hasStick || adaptiveGridService.column.sortable" class="k-separator"></span>
                            <kendo-grid-columnmenu-chooser
                                #chooserItem
                                *ngIf="hasColumnChooser"
                                [kendoGridColumnMenuItem]="chooserItem"
                                [service]="adaptiveGridService.columnMenuService"
                                [expanded]="false"
                                (collapse)="navigateToColumnsView()">
                            </kendo-grid-columnmenu-chooser>
                            <kendo-grid-columnmenu-autosize-column
                                #autoSizeColumnItem
                                *ngIf="hasAutoSizeColumn"
                                [service]="adaptiveGridService.columnMenuService"
                                [kendoGridColumnMenuItem]="autoSizeColumnItem"
                                [column]="adaptiveGridService.column"
                            >
                            </kendo-grid-columnmenu-autosize-column>

                            <kendo-grid-columnmenu-autosize-all-columns
                                #autoSizeAllColumnsItem
                                *ngIf="hasAutoSizeAllColumns"
                                [service]="adaptiveGridService.columnMenuService"
                                [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                            >
                            </kendo-grid-columnmenu-autosize-all-columns>
                            <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="adaptiveGridService.column.filterable" class="k-separator"></span>
                            <kendo-grid-columnmenu-filter
                                #filterItem
                                *ngIf="hasFilter"
                                [kendoGridColumnMenuItem]="filterItem"
                                [service]="adaptiveGridService.columnMenuService"
                                [expanded]="false"
                                (collapse)="navigateToFilterView()">
                            </kendo-grid-columnmenu-filter>
                        </kendo-grid-columnmenu-container>
                    </div>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- columnMenu second view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'columnMenu'">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>

                <ng-template kendoActionSheetContentTemplate>
                    <kendo-grid-columnlist
                        *ngIf="adaptiveGridService.secondaryView === 'columnChooser'"
                        #columnList
                        [columns]="adaptiveGridService.columns"
                        [ariaLabel]="messageFor('columns')"
                        [isLast]="true"
                        [showActions]="false"
                        [applyText]="messageFor('columnsApply')"
                        [resetText]="messageFor('columnsReset')"
                        [autoSync]="false"
                        [actionsClass]="actionsClass"
                        [allowHideAll]="false"
                        >
                    </kendo-grid-columnlist>
                    <kendo-grid-filter-menu-container
                        *ngIf="adaptiveGridService.secondaryView === 'columnFilter'"
                        [column]="adaptiveGridService.column"
                        [filter]="ctx.grid.filter"
                        (close)="close()"
                        [kendoEventsOutsideAngular]="{'keydown.escape': close}"
                        [scope]="this">
                    </kendo-grid-filter-menu-container>
                    <kendo-grid-columnmenu-lock
                        *ngIf="adaptiveGridService.secondaryView === 'columnPosition' && hasLock"
                        [service]="adaptiveGridService.columnMenuService">
                    </kendo-grid-columnmenu-lock>
                    <kendo-grid-columnmenu-stick
                        *ngIf="adaptiveGridService.secondaryView === 'columnPosition' && hasStick"
                        [service]="adaptiveGridService.columnMenuService">
                    </kendo-grid-columnmenu-stick>
                </ng-template>
                <ng-template *ngIf="adaptiveGridService.secondaryView === 'columnChooser'" kendoActionSheetFooterTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetFooterTemplate">
                    </ng-container>
                </ng-template>

                <ng-template *ngIf="adaptiveGridService.secondaryView === 'columnFilter'" kendoActionSheetFooterTemplate>
                    <ng-container [ngTemplateOutlet]="filterFooterButtons">
                    </ng-container>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- external editing view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'externalEditing'">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>

                <ng-template kendoActionSheetContentTemplate>
                    <kendo-grid-external-form
                        [controls]="externalEditingSettings.formControls"
                        [formGroup]="externalEditingSettings.formGroup"
                        [formSettings]="externalEditingSettings.formSettings"
                        [actionButtons]="false">
                    </kendo-grid-external-form>
                </ng-template>

                <ng-template kendoActionSheetFooterTemplate>
                    <button kendoButton
                        size="large"
                        icon="cancel"
                        [svgIcon]="cancelIcon"
                        (click)="actionSheet.toggle(false)">
                        {{messageFor('externalEditingCancelText')}}
                    </button>
                    <button kendoButton
                        themeColor="primary"
                        size="large"
                        icon="save"
                        [svgIcon]="saveIcon"
                        (click)="saveEditing()"
                        [disabled]="!externalEditingSettings.formGroup.valid">
                        {{messageFor('externalEditingSaveText')}}
                    </button>
                </ng-template>
            </kendo-actionsheet-view>

            <!-- groupToolbarTool view -->
            <kendo-actionsheet-view *ngIf="adaptiveGridService.viewType === 'groupToolbarTool'">
                <ng-template kendoActionSheetHeaderTemplate>
                    <ng-container [ngTemplateOutlet]="actionSheetHeaderTemplate">
                    </ng-container>
                </ng-template>
                <ng-template kendoActionSheetContentTemplate>
                    <kendo-group-toolbar-tool [adaptive]="true"></kendo-group-toolbar-tool>
                </ng-template>
                <ng-template kendoActionSheetFooterTemplate>
                    <button
                        kendoButton
                        size="large"
                        fillMode="solid"
                        icon="x"
                        [svgIcon]="xIcon"
                        (click)="clearGrouping()">
                        {{messageFor('groupClearButton')}}
                    </button>
                    <button
                        kendoButton
                        size="large"
                        fillMode="solid"
                        icon="check"
                        [svgIcon]="checkIcon"
                        themeColor="primary"
                        (click)="actionSheet.toggle(false)">
                        {{messageFor('groupDoneButton')}}
                    </button>
                </ng-template>
            </kendo-actionsheet-view>
        </kendo-actionsheet>

        <ng-template #actionSheetHeaderTemplate>
            <div class="k-actionsheet-titlebar-group">
                <div *ngIf="adaptiveGridService.secondaryView" class="k-actionsheet-actions">
                    <button
                    kendoButton
                    icon="chevron-left"
                    [svgIcon]="chevronLeft"
                    fillMode="flat"
                    size="large"
                    [title]="messageFor('adaptiveBackButtonTitle')"
                    (click)="prevView()">
                    </button>
                </div>
                <div class="k-actionsheet-title">
                    <div *ngIf="hasTitle" class="k-text-center">
                       {{actionSheetTitle}}
                    </div>
                    <div *ngIf="hasSubtitle"
                        class="k-actionsheet-subtitle k-text-center">
                        {{messageFor('columnsSubtitle')}}
                    </div>
                </div>
                <div *ngIf="hasXCloseIcon" class="k-actionsheet-actions">
                    <button
                    kendoButton
                    icon="x"
                    [svgIcon]="xIcon"
                    fillMode="flat"
                    size="large"
                    [title]="messageFor('adaptiveCloseButtonTitle')"
                    (click)="close()">
                    </button>
                </div>
                <div *ngIf="hasCheckCloseIcon" class="k-actionsheet-actions">
                    <button
                    kendoButton
                    icon="check"
                    [svgIcon]="checkIcon"
                    fillMode="flat"
                    size="large"
                    themeColor="primary"
                    [title]="messageFor('adaptiveCloseButtonTitle')"
                    (click)="actionSheet.toggle(false)">
                    </button>
                </div>
            </div>
        </ng-template>

        <ng-template #actionSheetFooterTemplate>
            <button
                #resetButton
                kendoButton
                size="large"
                fillMode="solid"
                [svgIcon]="arrowRotateCcwIcon"
                icon="arrow-rotate-ccw"
                type="button"
                [kendoEventsOutsideAngular]="{click: cancelChanges, 
                                            'keydown.enter': cancelChanges,
                                            'keydown.space': cancelChanges,
                                            'keydown.tab': onTab
                                            }"
                [scope]="this">
                {{ messageFor('columnsReset') }}
            </button>
            <button
                #applyButton
                kendoButton
                type="button"
                [svgIcon]="checkIcon"
                icon="check"
                size="large"
                fillMode="solid"
                themeColor="primary"
                [kendoEventsOutsideAngular]="{click: applyChanges,
                                            'keydown.enter': applyChanges,
                                            'keydown.space': applyChanges
                                            }"
                [scope]="this">
                {{ messageFor('columnsApply') }}
            </button>
        </ng-template>

        <ng-template #filterFooterButtons>
            <button
                kendoButton
                size="large"
                fillMode="solid"
                (click)="adaptiveGridService.resetFilter()">
                {{messageFor('filterClearButton')}}
            </button>
            <button
                kendoButton
                size="large"
                fillMode="solid"
                themeColor="primary"
                [disabled]="adaptiveGridService.filterMenuContainer.disabled"
                (click)="adaptiveGridService.submitFilter()">
                {{messageFor('filterFilterButton')}}
            </button>
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgForOf, NgTemplateOutlet, ActionSheetComponent, ActionSheetViewComponent, FilterToolbarToolComponent, GroupToolbarToolComponent, ButtonComponent, ActionSheetHeaderTemplateDirective, ActionSheetContentTemplateDirective, ActionSheetFooterTemplateDirective, ButtonComponent, ColumnMenuContainerComponent, ColumnMenuFilterComponent, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, ColumnMenuItemComponent, ColumnMenuItemDirective, ColumnListComponent, FilterMenuContainerComponent, ColumnMenuLockComponent, EventsOutsideAngularDirective, FormComponent]
    }]
  }], function() {
    return [{
      type: ColumnMenuService
    }, {
      type: AdaptiveGridService
    }, {
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: AdaptiveService
    }, {
      type: SortService
    }, {
      type: ColumnInfoService
    }];
  }, {
    columnList: [{
      type: ViewChild,
      args: ["columnList", {
        static: false
      }]
    }],
    filterToolbarToolTemplate: [{
      type: ViewChild,
      args: ["filterToolbarToolTemplate", {
        read: ViewContainerRef,
        static: false
      }]
    }],
    filterMenuContainer: [{
      type: ViewChild,
      args: ["filterMenuContainer"]
    }],
    actionSheet: [{
      type: ViewChild,
      args: [ActionSheetComponent]
    }],
    groupToolbarTool: [{
      type: ViewChild,
      args: [GroupToolbarToolComponent]
    }]
  });
})();
var createControl = (source) => (acc, key) => {
  acc[key] = new FormControl(source[key]);
  return acc;
};
var validateColumnsField = (columns) => expandColumns(columns.toArray()).filter(isColumnComponent).filter(({
  field
}) => !isValidFieldName(field)).forEach(({
  field
}) => console.warn(ColumnConfigurationErrorMessages.fieldName(field)));
var handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map3) => service.changes.pipe(filter(({
  group,
  emit: emit2
}) => emit2 && isPresent4(group))).subscribe((x) => x.expand ? expandEmitter.emit(map3(x)) : collapseEmitter.emit(map3(x)));
var handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map3) => service.changes.pipe(filter(({
  dataItem
}) => isPresent4(dataItem))).subscribe((x) => x.expand ? expandEmitter.emit(map3(x)) : collapseEmitter.emit(map3(x)));
var isInEditedCell = (element, gridElement) => closest3(element, matchesClasses("k-grid-edit-cell")) && closest3(element, matchesNodeName("kendo-grid")) === gridElement;
var NOTIFY_DELAY = 500;
var GridComponent = class _GridComponent {
  supportService;
  selectionService;
  cellSelectionService;
  wrapper;
  groupInfoService;
  groupsService;
  changeNotification;
  detailsService;
  editService;
  filterService;
  pdfService;
  responsiveService;
  renderer;
  excelService;
  ngZone;
  scrollSyncService;
  domEvents;
  columnResizingService;
  changeDetectorRef;
  columnReorderService;
  columnInfoService;
  navigationService;
  sortService;
  scrollRequestService;
  localization;
  ctx;
  sizingService;
  adaptiveService;
  adaptiveGridService;
  rowReorderService;
  /**
   * Sets the data of the Grid. If an array is provided, the Grid automatically gets the total count
   * ([more information and example]({% slug binding_grid %})).
   */
  set data(value) {
    this._data = value;
    if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
      this.blockArrowSelection = false;
    }
    if (this.notifyTimeout) {
      clearTimeout(this.notifyTimeout);
      this.notifyTimeout = null;
    }
    if (this.rowReorderable) {
      this.ngZone.runOutsideAngular(() => {
        this.notifyTimeout = setTimeout(() => {
          this.notifyReorderContainers();
        }, NOTIFY_DELAY);
      });
    }
  }
  get data() {
    return this._data;
  }
  get hintText() {
    return this.rowReorderService.getDefaultHintText(this.columnList, this.flatData);
  }
  /**
   * @hidden
   */
  get customHintTemplate() {
    if (this.rowReorderable) {
      const allColumns = this.columnList.toArray();
      const rowReorderColumn = allColumns.find((column) => column.isRowReorderColumn);
      return rowReorderColumn.rowDragHintTemplateRef;
    }
  }
  /**
   * @hidden
   */
  get hintContext() {
    if (this.customHintTemplate) {
      const draggedRow = this.rowReorderService?.getDraggedRow(this.flatData);
      return {
        $implicit: draggedRow?.dataItem,
        rowIndex: draggedRow?.rowIndex
      };
    }
  }
  /**
   * Defines the page size used by the Grid pager.
   * Required by the [paging]({% slug paging_grid %}) functionality.
   */
  pageSize;
  /**
   * Defines the height (in pixels) that is used when the `scrollable` option of the Grid is set.
   * To set the height of the Grid, you can also use `style.height`. The `style.height`
   * option supports units such as `px`, `%`, `em`, `rem`, and others.
   */
  height;
  /**
   * Represent the actual height of each Grid row (`tr`) element in the DOM.
   * Required by the [virtual scrolling functionality]({% slug scrollmmodes_grid %}).
   * Set the `rowHeight` option to the exact pixels as the height of the `tr` element appears in the DOM.
   */
  rowHeight;
  /**
   * Enables or disables the adaptive mode. By default, adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Represent the actual height of each Grid detail row (`tr`) element in the DOM.
   * Required by the [virtual scrolling functionality]({% slug scrollmmodes_grid %}).
   * Set the `detailRowHeight` option to the exact pixels as the height of the detail Grid `tr` element appears in the DOM.
   */
  detailRowHeight;
  /**
   * Defines the number of records to be skipped by the pager.
   * Required by the [paging]({% slug paging_grid %}) functionality.
   */
  get skip() {
    return this._skip;
  }
  set skip(value) {
    if (typeof value === "number" && value >= 0) {
      this._skip = this.rowReorderService.skip = value;
    }
  }
  /**
   * Defines the scroll mode used by the Grid.
   *
   * @default 'scrollable'
   */
  scrollable = "scrollable";
  /**
   * Enables the [single-row selection](slug:grid_row_selection) of the Grid.
   *
   * @default false
   */
  selectable = false;
  /**
   * The descriptors by which the data will be sorted ([see example]({% slug sorting_grid %})).
   */
  set sort(value) {
    if (isArray(value)) {
      this._sort = value;
    }
  }
  get sort() {
    return this._sort;
  }
  /**
   * Specifies the sizing of various Grid building blocks (e.g. tables, buttons, inputs, dropdowns, etc.)
   * @default 'medium'
   */
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-grid-sm", "k-grid-md");
    }
    this.sizingService.changes.next(this.size);
  }
  get size() {
    return this._size;
  }
  /**
   * A function that defines how to track changes for the data rows.
   * By default, the Grid tracks changes by the index of the data item.
   * Edited rows are tracked by reference.
   * [See example](slug:track_changes_grid)
   */
  trackBy = defaultTrackBy;
  /**
   * The descriptor by which the data will be filtered ([see examples]({% slug filtering_grid %})).
   */
  filter;
  /**
   * The descriptors by which the data will be grouped ([see example]({% slug grouping_grid %})).
   */
  set group(value) {
    if (isArray(value)) {
      this._group = value;
    }
  }
  get group() {
    return this._group;
  }
  /**
   * If set to `true`, the grid will render only the columns in the current viewport.
   * @default false
   */
  virtualColumns = false;
  /**
   * @hidden
   */
  get showStatusBar() {
    return !!this.selectable;
  }
  /**
   * @hidden
   */
  get showTopToolbar() {
    return this.toolbarTemplate && ["top", "both"].indexOf(this.toolbarTemplate.position) > -1;
  }
  /**
   * @hidden
   */
  get showBottomToolbar() {
    return this.toolbarTemplate && ["bottom", "both"].indexOf(this.toolbarTemplate.position) > -1;
  }
  /**
   * @hidden
   */
  get isLocked() {
    return this.lockedLeafColumns.length > 0;
  }
  /**
   * @hidden
   */
  get showTopPager() {
    const position2 = this.pageable.position;
    return !this.isVirtual && this.pageable !== false && ["top", "both"].indexOf(position2) > -1;
  }
  /**
   * @hidden
   */
  get showBottomPager() {
    const position2 = this.pageable.position;
    return !this.isVirtual && this.pageable !== false && position2 !== "top";
  }
  /**
   * @hidden
   */
  get hasPager() {
    return this.showTopPager || this.showBottomPager;
  }
  /**
   * @hidden
   */
  get showGroupPanel() {
    return this.groupable && this.groupable.enabled !== false;
  }
  /**
   * @hidden
   */
  get groupableEmptyText() {
    return this.groupable.emptyText;
  }
  /**
   * @hidden
   */
  get marqueeSelection() {
    return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   *
   * The `isOpen` property is used to determine if a Grid Popup or ActionSheet is open.
   */
  get isOpen() {
    return isPresent4(this.adaptiveGridService.popupRef) || this.isActionSheetExpanded;
  }
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return Boolean(this.adaptiveRenderer?.actionSheet?.expanded);
  }
  /**
   * @hidden
   */
  gridData = () => {
    return this.flatData;
  };
  /**
   * Enables the [filtering]({% slug filtering_grid %}) of the Grid columns that have their `field` option set.
   * @default false
   */
  filterable = false;
  /**
   * Enables the [sorting]({% slug sorting_grid %}) of the Grid columns that have their `field` option set.
   * @default false
   */
  sortable = false;
  /**
   * Configures the pager of the Grid ([see example](slug:paging_grid_settings)).
   * @default false
   */
  pageable = false;
  get normalizedPageableSettings() {
    return normalize3(this.pageable);
  }
  /**
   * If set to `true`, the user can group the Grid by dragging the column header cells ([see example]({% slug grouping_grid %})).
   * @default false
   */
  groupable = false;
  /**
   * Determines whether the Grid can be resized.
   * @default false
   */
  gridResizable = false;
  /**
   * Enables the [row reordering]({% slug reordering_rows_grid %}) of the Grid.
   * @default false
   */
  set rowReorderable(value) {
    this._rowReorderable = value;
    if (value) {
      this.rowReorderSubscription = this.rowReorderService.rowReorder.subscribe((args) => {
        this.ngZone.run(() => {
          this.rowReorder.emit(args);
        });
      });
    } else {
      this.rowReorderSubscription?.unsubscribe();
    }
  }
  get rowReorderable() {
    return this._rowReorderable;
  }
  /**
   * When the keyboard navigation is enabled, the user can use dedicated shortcuts to interact with the Grid.
   * By default, navigation is enabled. To disable it altogether, and include the Grid content in the normal tab sequence, set the property to `false`.
   * To enable navigation through separate Grid sections only, provide a [`GridNavigableSection`]({% slug api_grid_gridnavigablesection %}) array.
   */
  set navigable(value) {
    if (typeof value === "boolean") {
      this._navigable = value ? ["table", "pager", "toolbar"] : [];
      this.ctx.navigable = value;
      return;
    } else {
      this.ctx.navigable = value.includes("table");
    }
    this._navigable = value;
  }
  get navigable() {
    return this._navigable;
  }
  /**
   * Indicates whether the Grid columns will be resized during initialization so that
   * they fit their headers and row content.
   * Columns with `autoSize` set to `false` are excluded.
   * To dynamically update the column width to match the new content,
   * refer to [this example]({% slug resizing_columns_grid %}).
   * @default false
   */
  autoSize = false;
  /**
   * Defines a function that is executed for every data row in the component
   * ([see example](slug:styling_grid_rows)).
   */
  set rowClass(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowClass", fn));
    }
    this._rowClass = fn;
  }
  get rowClass() {
    return this._rowClass;
  }
  /**
   * Defines a function that is executed for every data row in the component,
   * and determines whether the row will be sticky, i.e. always visible after scrolling.
   */
  set rowSticky(fn) {
    if (isDevMode() && isPresent4(fn) && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowSticky", fn));
    }
    if (isPresent4(fn)) {
      this._rowSticky = fn;
    }
  }
  get rowSticky() {
    return this._rowSticky;
  }
  /**
   * Defines a Boolean function that is executed for each data row in the component
   * ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).
   * Determines whether the row will be selected.
   */
  set rowSelected(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowSelected", fn));
    }
    this._rowSelected = fn;
  }
  get rowSelected() {
    return this._rowSelected;
  }
  /**
   * Defines a Boolean function that is executed for each data row in the component.
   * Determines whether the row will be selectable.
   */
  set isRowSelectable(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("isRowSelectable", fn));
    }
    this._isRowSelectable = fn;
  }
  get isRowSelectable() {
    return this._isRowSelectable;
  }
  /**
   * Defines a function that determines the selected state of a data cell.
   * Returns an object with `selected` and `item` properties.
   * The cell is marked as selected only if the `selected` property equals `true`.
   *
   * The function is executed for each data cell and may be called more than once
   * as part of a change detection cycle. ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells))
   */
  set cellSelected(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("cellSelected", fn));
    }
    this._cellSelected = fn;
  }
  get cellSelected() {
    return this._cellSelected;
  }
  /**
   * Returns the currently focused cell (if any).
   */
  get activeCell() {
    return this.navigationService.activeCell;
  }
  /**
   * Returns the currently focused row (if any).
   */
  get activeRow() {
    return this.navigationService.activeRow;
  }
  /**
   * Returns the current Grid selection.
   *
   * @hidden
   */
  get selection() {
    return this.selectable || this.selectionDirective ? this.defaultSelection ? this.defaultSelection.stateToArray() : this.selectionDirective.stateToArray() : [];
  }
  /**
   * The current Grid `GridState` objects. Contains the information about data operations and column state, required
   * to store and restore the Grid state.
   */
  get currentState() {
    return {
      filter: this.filter,
      group: this.group,
      sort: this.sort,
      skip: this.skip,
      take: this.pageSize,
      columnsState: this.columns.toArray().flatMap(recursiveColumnsFlatMap),
      currentData: structuredClone(this.data)
    };
  }
  /**
   * If set to `true`, the user can resize columns by dragging the edges (resize handles) of their header cells
   * ([see example]({% slug resizing_columns_grid %})).
   *
   * @default false
   */
  resizable = false;
  /**
   * If set to `true`, the user can reorder columns by dragging their header cells
   * ([see example]({% slug reordering_columns_grid %})).
   *
   * @default false
   */
  reorderable = false;
  /**
   * Specifies if the loading indicator of the Grid will be displayed ([see example]({% slug binding_grid %})).
   *
   * @default false
   */
  set loading(value) {
    this._loading = value;
    this.rowReorderable && this.notifyReorderContainers();
  }
  get loading() {
    return this._loading;
  }
  /**
   * Specifies if the column menu of the columns will be displayed ([see example]({% slug columnmenu_grid %})).
   *
   * @default false
   */
  columnMenu = false;
  /**
   * Specifies if the header of the grid will be hidden. The header is visible by default.
   * The header includes column headers and the [filter row](slug:filter_row).
   * @default false
   */
  hideHeader = false;
  /**
   * Specifies if the currently inactive toolbar tools will be visible. Applicable when the toolbar is configured using the `<kendo-toolbar>` component. By default, such tools are hidden.
   *
   * @default false
   */
  showInactiveTools = false;
  /**
   * A function which determines if a specific row is expanded.
   */
  set isDetailExpanded(callback) {
    this.detailsService.userCallback = callback;
  }
  get isDetailExpanded() {
    return this.detailsService.userCallback;
  }
  /**
   * A function which determines if a specific group row is expanded.
   */
  set isGroupExpanded(callback) {
    this.groupsService.userCallback = callback;
    this.groupable = isPresent4(callback);
  }
  get isGroupExpanded() {
    return this.groupsService.userCallback;
  }
  /**
   * Fires when the Grid filter is modified through the UI.
   * You have to handle the event yourself and filter the data.
   */
  filterChange = new EventEmitter();
  /**
   * Fires when the page of the Grid is changed ([see example]({% slug paging_grid %})).
   * You have to handle the event yourself and page the data.
   */
  pageChange = new EventEmitter();
  /**
   * Fires when the grouping of the Grid is changed.
   * You have to handle the event yourself and group the data ([see example]({% slug grouping_grid %})).
   */
  groupChange;
  /**
   * Fires when the sorting of the Grid is changed ([see example]({% slug sorting_grid %})).
   * You have to handle the event yourself and sort the data.
   */
  sortChange = new EventEmitter();
  /**
   * Fires when the user selects a Grid row.
   */
  selectionChange = new EventEmitter();
  /**
   * Fires when the user drops the dragged row and reordering is performed.
   */
  rowReorder = new EventEmitter();
  /**
   * Fires when the data state of the Grid is changed.
   */
  dataStateChange = new EventEmitter();
  /**
   * Fires when the data or columns state of the Grid is changed.
   */
  gridStateChange = new EventEmitter();
  /**
   * Fires when the user expands a group header.
   */
  groupExpand = new EventEmitter();
  /**
   * Fires when the user collapses a group header.
   */
  groupCollapse = new EventEmitter();
  /**
   * Fires when the user expands a master row.
   */
  detailExpand = new EventEmitter();
  /**
   * Fires when the user collapses a master row.
   */
  detailCollapse = new EventEmitter();
  /**
   * Fires when the user clicks the **Edit** command button to edit a row
   * ([see example](slug:inline_editing_grid#editing-records-1)).
   */
  edit = new EventEmitter();
  /**
   * Fires when the user clicks the **Cancel** command button to close a row
   * ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
   */
  cancel = new EventEmitter();
  /**
   * Fires when the user clicks the **Save** command button to save changes in a row
   * ([see example]({% slug inline_editing_grid %}#toc-saving-records-1)).
   */
  save = new EventEmitter();
  /**
   * Fires when the user clicks the **Remove** command button to remove a row
   * ([see example]({% slug inline_editing_grid %}#toc-removing-records-1)).
   */
  remove = new EventEmitter();
  /**
   * Fires when the user clicks the **Add** command button to add a new row
   * ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
   */
  add = new EventEmitter();
  /**
   * Fires when the user leaves an edited cell ([see example](slug:editing_incell_grid)).
   */
  cellClose = new EventEmitter();
  /**
   * Fires when the user clicks a cell ([see example](slug:editing_incell_grid)).
   */
  cellClick;
  /**
   * Fires when the user clicks the **Export to PDF** command button.
   */
  pdfExport = new EventEmitter();
  /**
   * Fires when the user clicks the **Export to Excel** command button.
   */
  excelExport = new EventEmitter();
  /**
   * Fires when the user completes the resizing of the column.
   */
  columnResize;
  /**
   * Fires when the user completes the reordering of the column.
   */
  columnReorder = new EventEmitter();
  /**
   * Fires when the user changes the visibility of the columns from the column menu or column chooser.
   */
  columnVisibilityChange = new EventEmitter();
  /**
   * Fires when the user changes the locked state of the columns from the column menu or by reordering the columns.
   */
  columnLockedChange = new EventEmitter();
  /**
   * Fires when the user changes the sticky state of the columns from the column menu.
   */
  columnStickyChange = new EventEmitter();
  /**
   * Fires when the user scrolls to the last record on the page and enables endless scrolling
   * ([see example]({% slug scrollmmodes_grid %}#toc-endless-scrolling)).
   * You have to handle the event yourself and page the data.
   */
  scrollBottom = new EventEmitter();
  /**
   * Fires when the grid content is scrolled.
   * For performance reasons, the event is triggered outside the Angular zone. Enter the Angular zone if you make any changes that require change detection.
   */
  contentScroll = new EventEmitter();
  /**
   * A query list of all declared columns.
   */
  columns = new QueryList();
  get dir() {
    return this.direction;
  }
  hostClass = true;
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  get lockedClasses() {
    return this.lockedLeafColumns.length > 0;
  }
  get virtualClasses() {
    return this.isVirtual;
  }
  get noScrollbarClass() {
    return this.scrollbarWidth === 0;
  }
  get isResizable() {
    return Boolean(this.gridResizable);
  }
  get minWidth() {
    return this.gridResizable.minWidth;
  }
  get maxWidth() {
    return this.gridResizable.maxWidth;
  }
  get minHeight() {
    return this.gridResizable.minHeight;
  }
  get maxHeight() {
    return this.gridResizable.maxHeight;
  }
  detailTemplateChildren;
  get detailTemplate() {
    if (this._customDetailTemplate) {
      return this._customDetailTemplate;
    }
    return this.detailTemplateChildren ? this.detailTemplateChildren.first : void 0;
  }
  set detailTemplate(detailTemplate) {
    this._customDetailTemplate = detailTemplate;
  }
  cellLoadingTemplateChildren;
  get cellLoadingTemplate() {
    if (this._cellLoadingTemplate) {
      return this._customDetailTemplate;
    }
    return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : void 0;
  }
  set cellLoadingTemplate(cellLoadingTemplate) {
    this._cellLoadingTemplate = cellLoadingTemplate;
  }
  loadingTemplateChildren;
  get loadingTemplate() {
    if (this._loadingTemplate) {
      return this._loadingTemplate;
    }
    return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : void 0;
  }
  set loadingTemplate(loadingTemplate) {
    this._loadingTemplate = loadingTemplate;
  }
  statusBarTemplateChildren;
  get statusBarTemplate() {
    if (this._statusBarTemplate) {
      return this._statusBarTemplate;
    }
    return this.statusBarTemplateChildren ? this.statusBarTemplateChildren.first : void 0;
  }
  set statusBarTemplate(statusBarTemplate) {
    this._statusBarTemplate = statusBarTemplate;
  }
  noRecordsTemplateChildren;
  get noRecordsTemplate() {
    if (this._customNoRecordsTemplate) {
      return this._customNoRecordsTemplate;
    }
    return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : void 0;
  }
  set noRecordsTemplate(customNoRecordsTemplate) {
    this._customNoRecordsTemplate = customNoRecordsTemplate;
  }
  pagerTemplateChildren;
  get pagerTemplate() {
    if (this._customPagerTemplate) {
      return this._customPagerTemplate;
    }
    return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : void 0;
  }
  set pagerTemplate(customPagerTemplate) {
    this._customPagerTemplate = customPagerTemplate;
  }
  toolbarTemplateChildren;
  get toolbarTemplate() {
    if (this._customToolbarTemplate) {
      return this._customToolbarTemplate;
    }
    return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : void 0;
  }
  set toolbarTemplate(customToolbarTemplate) {
    this._customToolbarTemplate = customToolbarTemplate;
  }
  columnMenuTemplates;
  lockedHeader;
  header;
  footer = new QueryList();
  ariaRoot;
  dragTargetContainer;
  dropTargetContainer;
  dialogContainer;
  /**
   * @hidden
   */
  adaptiveRenderer;
  get scrollbarWidth() {
    return this.supportService.scrollbarWidth;
  }
  get showPagerInput() {
    return this._showPagerInput;
  }
  set showPagerInput(value) {
    if (this._showPagerInput === value) {
      return;
    }
    this._showPagerInput = value;
  }
  get showPagerPageText() {
    return this._showPagerPageText;
  }
  set showPagerPageText(value) {
    if (!this.normalizedPageableSettings?.responsive) {
      this._showPagerPageText = true;
    }
    if (this._showPagerPageText === value) {
      return;
    }
    this._showPagerPageText = value;
  }
  get showPagerItemsText() {
    return this._showPagerItemsText;
  }
  set showPagerItemsText(value) {
    if (!this.normalizedPageableSettings?.responsive) {
      this._showPagerItemsText = true;
    }
    if (this._showPagerItemsText === value) {
      return;
    }
    this._showPagerItemsText = value;
  }
  get headerPadding() {
    if (isUniversal()) {
      return "";
    }
    const padding = Math.max(0, this.scrollbarWidth) + "px";
    const right2 = this.rtl ? 0 : padding;
    const left2 = this.rtl ? padding : 0;
    return `0 ${right2} 0 ${left2}`;
  }
  columnMenuOptions;
  columnList;
  selectionDirective = false;
  ariaRootId = `k-${guid()}`;
  showLicenseWatermark = false;
  columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy((column) => {
    if (!isUniversal()) {
      column.matchesMedia = this.matchesMedia(column);
    }
    return column.isVisible;
  }));
  view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));
  get hasGroupFooters() {
    return this.columnsContainer.hasGroupFooter;
  }
  get showFooter() {
    return this.columnsContainer.hasFooter;
  }
  get showGroupFooters() {
    return this.groupable && this.groupable.showFooter;
  }
  get ariaRowCount() {
    return this.totalColumnLevels + 1 + this.view.total + (hasFilterRow(this.filterable) ? 1 : 0);
  }
  get ariaColCount() {
    return this.columnsContainer.leafColumnsToRender.length;
  }
  get navigation() {
    return this.navigationService;
  }
  /**
   * @hidden
   */
  get flatData() {
    return isArray(this.data) ? this.data : this.data.data;
  }
  shouldGenerateColumns = true;
  direction;
  notifyTimeout = null;
  _sort = new Array();
  _group = new Array();
  _skip = 0;
  _data = [];
  cachedWindowWidth = 0;
  defaultSelection;
  _rowSelected = null;
  _isRowSelectable = null;
  _cellSelected = null;
  _customDetailTemplate;
  _cellLoadingTemplate;
  _loadingTemplate;
  _statusBarTemplate;
  _customNoRecordsTemplate;
  _customPagerTemplate;
  _customToolbarTemplate;
  _rowReorderable = false;
  leafViewportColumns;
  viewportColumns;
  _navigable = ["table", "pager", "toolbar"];
  _size = "medium";
  _loading = false;
  _showPagerInput = true;
  _showPagerPageText = true;
  _showPagerItemsText = true;
  get isVirtual() {
    return this.scrollable === "virtual";
  }
  get isScrollable() {
    return this.scrollable !== "none";
  }
  get visibleColumns() {
    return this.columnsContainer.allColumns;
  }
  get lockedColumns() {
    return this.columnsContainer.lockedColumns;
  }
  get nonLockedColumns() {
    return this.columnsContainer.nonLockedColumns;
  }
  get lockedLeafColumns() {
    return this.columnsContainer.lockedLeafColumns;
  }
  get stickyColumns() {
    return this.columns.filter((column) => column.sticky);
  }
  get nonLockedLeafColumns() {
    return this.columnsContainer.nonLockedLeafColumns;
  }
  get leafColumns() {
    return this.columnsContainer.leafColumns;
  }
  get totalColumnLevels() {
    return this.columnsContainer.totalLevels;
  }
  get headerColumns() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.viewportColumns;
    }
    return this.nonLockedColumns;
  }
  get headerLeafColumns() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.leafViewportColumns;
    }
    return this.nonLockedLeafColumns;
  }
  get lockedWidth() {
    const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;
    return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
  }
  get nonLockedWidth() {
    if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {
      return !this.virtualColumns ? this.columnsContainer.unlockedWidth : this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);
    }
    return void 0;
  }
  get selectableSettings() {
    if (this.selectionService) {
      return this.selectionService.options;
    }
    return void 0;
  }
  get columnMenuTemplate() {
    const template = this.columnMenuTemplates.first;
    return template ? template.templateRef : null;
  }
  get totalCount() {
    if (this.isVirtual || !isPresent4(this.pageSize)) {
      return this.view.total;
    }
    return this.pageSize;
  }
  /**
   * @hidden
   */
  getDefaultSelectors(type) {
    return this.rowReorderService.defaultSelectors[type];
  }
  /**
   * @hidden
   */
  getHintSettings(type) {
    return this.rowReorderService[type];
  }
  /**
   * @hidden
   */
  blockArrowSelection = false;
  undoRedoService;
  selectionSubscription;
  stateChangeSubscription;
  groupExpandCollapseSubscription;
  editServiceSubscription;
  detailsServiceSubscription;
  filterSubscription;
  sortSubscription;
  columnsChangeSubscription;
  pdfSubscription;
  excelSubscription;
  columnsContainerChangeSubscription;
  cellClickSubscription;
  footerChangeSubscription;
  columnResizingSubscription;
  columnReorderSubscription;
  detachElementEventHandlers;
  localizationSubscription;
  columnVisibilityChangeSubscription;
  columnLockedChangeSubscription;
  columnStickyChangeSubscription;
  focusElementSubscription;
  columnRangeChangeSubscription;
  rowReorderSubscription;
  rtl = false;
  _rowSticky;
  constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization, ctx, sizingService, adaptiveService, adaptiveGridService, rowReorderService) {
    this.supportService = supportService;
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.wrapper = wrapper;
    this.groupInfoService = groupInfoService;
    this.groupsService = groupsService;
    this.changeNotification = changeNotification;
    this.detailsService = detailsService;
    this.editService = editService;
    this.filterService = filterService;
    this.pdfService = pdfService;
    this.responsiveService = responsiveService;
    this.renderer = renderer;
    this.excelService = excelService;
    this.ngZone = ngZone;
    this.scrollSyncService = scrollSyncService;
    this.domEvents = domEvents;
    this.columnResizingService = columnResizingService;
    this.changeDetectorRef = changeDetectorRef;
    this.columnReorderService = columnReorderService;
    this.columnInfoService = columnInfoService;
    this.navigationService = navigationService;
    this.sortService = sortService;
    this.scrollRequestService = scrollRequestService;
    this.localization = localization;
    this.ctx = ctx;
    this.sizingService = sizingService;
    this.adaptiveService = adaptiveService;
    this.adaptiveGridService = adaptiveGridService;
    this.rowReorderService = rowReorderService;
    const isValid = validatePackage(packageMetadata5);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.ctx.grid = this;
    this.groupChange = new ZoneAwareEventEmitter(this.ngZone);
    this.cellClick = new ZoneAwareEventEmitter(this.ngZone);
    this.columnResize = new ZoneAwareEventEmitter(this.ngZone);
    this.localizationSubscription = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
    this.groupInfoService.registerColumnsContainer(() => this.columnList);
    this.columnInfoService.init(this.columnsContainer, () => this.columnList);
    this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe((changed) => {
      this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));
    });
    this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe((changed) => {
      this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));
    });
    this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe((changed) => {
      this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));
    });
    this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({
      group,
      groupIndex,
      parentGroup
    }) => ({
      group,
      groupIndex,
      parentGroup
    }));
    this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, (args) => args);
    this.filterSubscription = this.filterService.changes.subscribe((x) => {
      this.filterChange.emit(x);
    });
    this.sortSubscription = this.sortService.changes.subscribe((x) => {
      this.sortChange.emit(x);
    });
    this.attachStateChangesEmitter();
    this.attachEditHandlers();
    this.attachDomEventHandlers();
    this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));
    this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));
    this.columnsContainerChange();
    this.handleColumnResize();
    this.columnList = new ColumnList(this.columns);
    this.columnReorderSubscription = this.columnReorderService.changes.subscribe(this.reorder.bind(this));
    this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));
  }
  /**
   * Expands the specified master row ([see example]({% slug hierarchy_grid %})).
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded state internally using the data row index.
   *
   * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
   * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
   * for examples on how to control the expanded state.
   *
   * @param index - The data row index of the master row.
   */
  expandRow(index) {
    this.toggleDetailRowLegacy(index, true);
  }
  /**
   * Collapses the specified master row ([see example]({% slug hierarchy_grid %})).
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded state internally using the data row index.
   *
   * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
   * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
   * for examples on how to control the expanded state.
   *
   * @param index - The data row index of the master row.
   */
  collapseRow(index) {
    this.toggleDetailRowLegacy(index, false);
  }
  /**
   * Expands a group header item for the given index. For example,
   * `0_1` expands the second inner group of the first master group.
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded group state internally using the hierarchical group index.
   *
   * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
   *
   * @param {string} index - The underscore separated hierarchical index of the group.
   */
  expandGroup(index) {
    this.toggleGroupRowLegacy(index, true);
  }
  /**
   * Collapses a group header item for the given index. For example,
   * `0_1` collapses the second inner group of the first master group.
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded group state internally using the hierarchical group index.
   *
   * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
   *
   * @param {string} index - The underscore separated hierarchical index of the group.
   */
  collapseGroup(index) {
    this.toggleGroupRowLegacy(index, false);
  }
  /**
   * @hidden
   */
  resetGroupsState() {
    this.groupsService.reset();
  }
  /**
   * @hidden
   */
  onDataChange() {
    this.autoGenerateColumns();
    this.changeNotification.notify();
    this.pdfService.dataChanged.emit();
    if (isPresent4(this.defaultSelection)) {
      this.defaultSelection.reset();
    }
    this.initSelectionService();
    this.updateNavigationMetadata();
  }
  ngOnChanges(changes) {
    if (isChanged("data", changes)) {
      this.onDataChange();
    }
    if (this.lockedLeafColumns.length && anyChanged(["pageSize", "skip", "sort", "group"], changes)) {
      this.changeNotification.notify();
    }
    if (anyChanged(["pageSize", "scrollable", "virtualColumns"], changes)) {
      this.updateNavigationMetadata();
    }
    if (isChanged("virtualColumns", changes)) {
      this.viewportColumns = this.leafViewportColumns = null;
    }
    if (isChanged("height", changes, false)) {
      this.renderer.setStyle(this.wrapper.nativeElement, "height", `${this.height}px`);
    }
    if (isChanged("filterable", changes) && this.lockedColumns.length) {
      this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));
    }
    if (anyChanged(["columnMenu", "sortable", "filterable"], changes, false)) {
      this.columnMenuOptions = this.columnMenu && Object.assign({
        filter: Boolean(this.filterable),
        sort: Boolean(this.sortable)
      }, this.columnMenu);
    }
    if (isChanged("scrollable", changes) && this.isScrollable) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());
    }
    if (isChanged("selectable", changes) && this.shouldResetSelection(changes["selectable"])) {
      if (this.defaultSelection) {
        this.defaultSelection.reset();
      } else if (this.selectionDirective) {
        this.selectionDirective.reset();
      }
    }
    if (isChanged("groupable", changes, true)) {
      this.groupable = changes["groupable"].currentValue;
    }
    if (isChanged("navigable", changes, true)) {
      if (this.navigationService.enabled) {
        this.navigationService.setActiveSections(this.navigable);
      } else {
        if (this.navigable.length) {
          this.navigationService.init(this.navigationMetadata(), this.navigable);
        }
      }
    }
  }
  ngAfterContentInit() {
    this.shouldGenerateColumns = !this.columns.length;
    this.autoGenerateColumns();
    this.columnList = new ColumnList(this.columns);
    this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());
  }
  ngAfterViewInit() {
    this.attachScrollSync();
    this.attachElementEventHandlers();
    this.updateNavigationMetadata();
    this.applyAutoSize();
    const toolbarComponentWrapper = this.wrapper?.nativeElement?.querySelector("kendo-toolbar");
    if (toolbarComponentWrapper) {
      this.renderer.addClass(toolbarComponentWrapper, "k-grid-toolbar");
    }
  }
  ngAfterContentChecked() {
    this.columnsContainer.refresh();
    this.verifySettings();
    this.initSelectionService();
  }
  ngOnInit() {
    if (this.navigable.length) {
      this.navigationService.init(this.navigationMetadata(), this.navigable);
    }
  }
  ngOnDestroy() {
    if (this.selectionSubscription) {
      this.selectionSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
    if (this.columnReorderSubscription) {
      this.columnReorderSubscription.unsubscribe();
    }
    if (this.stateChangeSubscription) {
      this.stateChangeSubscription.unsubscribe();
    }
    if (this.groupExpandCollapseSubscription) {
      this.groupExpandCollapseSubscription.unsubscribe();
    }
    if (this.detailsServiceSubscription) {
      this.detailsServiceSubscription.unsubscribe();
    }
    if (this.editServiceSubscription) {
      this.editServiceSubscription.unsubscribe();
    }
    if (this.pdfSubscription) {
      this.pdfSubscription.unsubscribe();
    }
    if (this.filterSubscription) {
      this.filterSubscription.unsubscribe();
    }
    if (this.sortSubscription) {
      this.sortSubscription.unsubscribe();
    }
    if (this.columnsChangeSubscription) {
      this.columnsChangeSubscription.unsubscribe();
    }
    if (this.excelSubscription) {
      this.excelSubscription.unsubscribe();
    }
    if (this.columnsContainerChangeSubscription) {
      this.columnsContainerChangeSubscription.unsubscribe();
    }
    if (this.scrollSyncService) {
      this.scrollSyncService.destroy();
    }
    if (this.detachElementEventHandlers) {
      this.detachElementEventHandlers();
    }
    if (this.defaultSelection) {
      this.defaultSelection.destroy();
    }
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
    }
    if (this.footerChangeSubscription) {
      this.footerChangeSubscription.unsubscribe();
    }
    this.ngZone = null;
    if (this.columnResizingSubscription) {
      this.columnResizingSubscription.unsubscribe();
    }
    if (this.columnReorderSubscription) {
      this.columnReorderSubscription.unsubscribe();
    }
    if (this.localizationSubscription) {
      this.localizationSubscription.unsubscribe();
    }
    if (this.columnVisibilityChangeSubscription) {
      this.columnVisibilityChangeSubscription.unsubscribe();
    }
    if (this.columnLockedChangeSubscription) {
      this.columnLockedChangeSubscription.unsubscribe();
    }
    if (this.columnStickyChangeSubscription) {
      this.columnStickyChangeSubscription.unsubscribe();
    }
    if (this.focusElementSubscription) {
      this.focusElementSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
    this.columnRangeChangeSubscription.unsubscribe();
  }
  /**
   * @hidden
   */
  attachScrollSync() {
    if (isUniversal()) {
      return;
    }
    if (this.header) {
      this.scrollSyncService.registerEmitter(this.header.nativeElement, "header");
    }
    if (this.footer) {
      this.footerChangeSubscription = observe(this.footer).subscribe((footers) => footers.map((footer) => footer.nativeElement).filter(isPresent4).forEach((element) => {
        this.scrollSyncService.registerEmitter(element, "footer");
        element.scrollLeft = this.wrapper.nativeElement.querySelector(".k-grid-content")?.scrollLeft;
      }));
    }
  }
  /**
   * @hidden
   */
  get ariaLabel() {
    return this.localization.get("gridLabel");
  }
  /**
   * @hidden
   */
  messageFor = (token) => this.localization.get(token);
  /**
   * Switches the specified table row in the edit mode ([see example]({% slug inline_editing_grid %}#toc-editing-records-1)).
   *
   * @param rowIndex - The data row index that will be switched in the edit mode.
   * @param group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])
   * that describes the edit form.
   * @param options - Additional options configuring the focus target once the editor opens.
   */
  editRow(rowIndex, group, options) {
    this.editService.editRow(rowIndex, group);
    if (isPresent4(options) && options.skipFocus) {
      return;
    }
    const row2 = `tr[data-kendo-grid-item-index="${rowIndex}"]`;
    const columnIndex = options && options.columnIndex;
    const target = isNaN(columnIndex) ? row2 : `${row2} td[data-kendo-grid-column-index="${columnIndex}"]`;
    this.focusEditElement(target);
  }
  /**
   * @hidden
   */
  handleReorderEvents(ev, evType) {
    this.rowReorderService[evType](ev);
  }
  /**
   * Closes the editor for a given row ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
   *
   * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed
   * that the new item editor will be closed.
   */
  closeRow(index) {
    this.editService.close(index);
  }
  /**
   * Creates a new row editor ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
   *
   * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi']) that describes
   * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.
   */
  addRow(group) {
    const isFormGroup = group instanceof FormGroup;
    if (!isFormGroup) {
      const fields = Object.keys(group).reduce(createControl(group), {});
      group = new FormGroup(fields);
    }
    this.editService.addRow(group);
    this.focusEditElement(".k-grid-add-row");
  }
  /**
   * Puts the cell that is specified by the table row and column in edit mode ([see example](slug:editing_incell_grid)).
   *
   * @param {number} rowIndex - The data row index that will be switched in the edit mode.
   * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.
   * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])
   * that describes the edit form.
   */
  editCell(rowIndex, column, group) {
    const instance = this.columnInstance(column);
    this.editService.editCell(rowIndex, instance, group);
    this.focusEditElement(".k-grid-edit-cell");
  }
  /**
   * Closes the current cell in edit mode and fires
   * the [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event.
   *
   * @return {boolean} Indicates whether the edited cell was closed.
   * A `false` value indicates that the
   * [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.
   */
  closeCell() {
    return !this.editService.closeCell();
  }
  /**
   * Closes the current cell in edit mode.
   */
  cancelCell() {
    this.editService.cancelCell();
  }
  /**
   * Returns a flag which indicates if a row or a cell is currently edited.
   *
   * @return {boolean} A flag which indicates if a row or a cell is currently edited.
   */
  isEditing() {
    return this.editService.isEditing();
  }
  /**
   * Returns a flag which indicates if a cell is currently edited.
   *
   * @return {boolean} A flag which indicates if a cell is currently being edited.
   */
  isEditingCell() {
    return this.editService.isEditingCell();
  }
  /**
   * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).
   */
  saveAsPDF() {
    this.pdfService.save(this);
  }
  /**
   * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) by using the `kendo-grid-pdf` component options.
   * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).
   *
   * @return {Promise} A promise that will be resolved with the Drawing `Group`.
   */
  drawPDF() {
    const promise = createPromise();
    this.pdfService.draw(this, promise);
    return promise;
  }
  /**
   * Initiates the Excel export ([see example]({% slug excelexport_grid %})).
   */
  saveAsExcel() {
    this.excelService.save(this);
  }
  /**
   * Applies the provided `GridState` object to the Grid.
   */
  loadState(state2) {
    if (state2.columnsState) {
      this.traverseColumns(this.columns, (column) => {
        const columnState = state2.columnsState.find((col) => col.id === column.id);
        if (columnState) {
          column.width = columnState.width;
          column.hidden = columnState.hidden;
          column.locked = columnState.locked;
          column.sticky = columnState.sticky;
          column.orderIndex = columnState.orderIndex;
        }
      });
      this.columns.reset(this.columns.toArray());
      this.columnsContainer.refresh();
    }
    this.sort = state2.sort;
    this.group = state2.group;
    this.filter = state2.filter;
    this.group = state2.group;
    this.skip = state2.skip;
    this.pageSize = state2.take;
    this.data = state2.currentData;
    this.changeNotification.notify();
    this.changeDetectorRef.detectChanges();
  }
  traverseColumns(columns, callback) {
    columns.forEach((column) => {
      if (column.isColumnGroup || column.isSpanColumn) {
        this.traverseColumns(column.children, callback);
      } else {
        callback(column);
      }
    });
  }
  /**
   * Applies the minimum possible width for the specified column,
   * so that the whole text fits without wrapping. This method expects the Grid
   * to be [resizable](slug:resizing_columns_grid). The method must be executed
   * after the Grid is already populated with data.
   * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
   */
  autoFitColumn(column) {
    this.columnResizingService.autoFit(column);
  }
  /**
   * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
   * If no columns are specified, `autoFitColumns` is applied to all columns.The method must be executed
   * after the Grid is already populated with data.
   * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
   *
   */
  autoFitColumns(columns = this.columns) {
    let cols;
    if (columns instanceof QueryList) {
      cols = columns.toArray();
    } else {
      cols = columns;
    }
    this.columnResizingService.autoFit(...cols);
  }
  /**
   * @hidden
   */
  notifyPageChange(source, event2) {
    if (source === "list" && !this.isVirtual) {
      return;
    }
    this.pageChange.emit(event2);
  }
  /**
   * @hidden
   */
  handlePagerVisibilityChange(prop, ev) {
    this[prop] = ev;
  }
  /**
   * @hidden
   */
  notifyScrollBottom() {
    if (this.scrollable === "none") {
      return;
    }
    if (hasObservers(this.scrollBottom)) {
      this.ngZone.run(() => this.scrollBottom.emit({
        sender: this
      }));
    }
  }
  /**
   * @hidden
   */
  focusEditElement(containerSelector) {
    if (this.focusElementSubscription) {
      this.focusElementSubscription.unsubscribe();
    }
    this.ngZone.runOutsideAngular(() => {
      this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
        const wrapper = this.wrapper.nativeElement;
        if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {
          this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));
        }
        this.focusElementSubscription = null;
      });
    });
  }
  /**
   * Focuses the last active or the first cell of the Grid.
   *
   * @returns {NavigationCell} The focused cell.
   */
  focus() {
    this.assertNavigable();
    return this.navigationService.focusCell();
  }
  /**
   * Focuses the cell with the specified row and column index.
   *
   * The row index is based on the logical structure of the Grid and does not correspond to the data item index.
   * Header rows are included, starting at index 0.
   * Group headers and footers are included.
   * The row indexing is absolute and does not change with paging.
   *
   * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.
   * If the row is not present on the current page, the method will have no effect.
   *
   * @param rowIndex - The logical row index to focus. The top header row has an index 0.
   * @param colIndex - The column index to focus.
   * @returns {NavigationCell} The focused cell.
   *
   */
  focusCell(rowIndex, colIndex) {
    this.assertNavigable();
    return this.navigationService.focusCell(rowIndex, colIndex);
  }
  /**
   * Focuses the next cell, optionally wrapping to the next row.
   *
   * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
   * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
   */
  focusNextCell(wrap = true) {
    this.assertNavigable();
    return this.navigationService.focusNextCell(wrap);
  }
  /**
   * Focuses the previous cell. Optionally wraps to the previous row.
   *
   * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
   * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
   */
  focusPrevCell(wrap = true) {
    this.assertNavigable();
    return this.navigationService.focusPrevCell(wrap);
  }
  /**
   * Scrolls to the specified row and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-row-and-column)).
   */
  scrollTo(request) {
    this.scrollRequestService.scrollTo(request, false);
  }
  /**
   * Scrolls to the specified data item and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-item)).
   */
  scrollToItem(request) {
    this.scrollRequestService.scrollToItem(request);
  }
  /**
   * Changes the position of the specified column.
   * The reordering of columns operates only on the level
   * which is inferred by the source column.
   * For the `reorderColumn` method to work properly,
   * the `source` column has to be visible.
   *
   * @param {ColumnBase} source - The column whose position will be changed.
   * @param {number} destIndex - The new position of the column.
   * @param {ColumnReorderConfig} options - Additional options.
   *
   */
  reorderColumn(source, destIndex, options = {
    before: false
  }) {
    const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
    let target = columnsForLevel[destIndex];
    if (!target) {
      return;
    }
    const lastNonLocked2 = target.isLocked && !source.isLocked && this.columnsContainer.nonLockedColumns.length === 1;
    if (lastNonLocked2) {
      return;
    }
    if (isSpanColumnComponent(target) && !options.before) {
      target = target.children.last;
    }
    this.reorder({
      before: options.before,
      source,
      target
    });
  }
  /**
   * @hidden
   */
  updateNavigationMetadata() {
    this.navigationService.metadata = this.navigationMetadata();
  }
  reorder({
    target,
    source,
    before,
    changeContainer
  }) {
    this.ngZone.run(() => {
      const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
      let newIndex = columnsForLevel.indexOf(target);
      if (target.parent && target.parent.isSpanColumn) {
        newIndex = columnsForLevel.indexOf(target.parent);
        if (before) {
          target = target.parent;
        }
      }
      const oldIndex = columnsForLevel.indexOf(source);
      if (changeContainer) {
        if (before && 0 < newIndex && oldIndex < newIndex) {
          newIndex--;
        } else if (!before && oldIndex > newIndex) {
          newIndex++;
        }
      }
      const args = new ColumnReorderEvent({
        column: source,
        oldIndex,
        newIndex
      });
      this.columnReorder.emit(args);
      if (args.isDefaultPrevented()) {
        return;
      }
      if (changeContainer) {
        this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));
      }
      this.updateColumnIndices({
        columnsForLevel,
        source,
        target,
        before
      });
      if (source.locked !== target.locked) {
        source.locked = target.locked;
      }
      this.columnsContainer.refresh();
      this.changeDetectorRef.markForCheck();
    });
  }
  updateColumnIndices({
    columnsForLevel,
    source,
    target,
    before
  }) {
    const expandedColumns = expandColumnsWithSpan(columnsForLevel);
    const sourceColumnIndex = expandedColumns.indexOf(source);
    let nextSourceIndex = 0;
    let nextIndex = 0;
    let toSkip = 1;
    if (source.isSpanColumn) {
      toSkip += source.children.length;
    }
    let i = 0;
    while (i < expandedColumns.length) {
      const column = expandedColumns[i];
      if (column === target) {
        nextSourceIndex = before ? nextIndex : nextIndex + 1;
        nextIndex = before ? nextIndex + toSkip : nextIndex;
        column.orderIndex = nextIndex;
        if (nextSourceIndex === nextIndex + 1) {
          nextIndex += toSkip;
        }
      } else if (column === source) {
        i += toSkip;
        column.isReordered = true;
        continue;
      } else {
        column.orderIndex = nextIndex;
      }
      column.isReordered = true;
      nextIndex++;
      i++;
    }
    for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {
      expandedColumns[i].orderIndex = nextSourceIndex++;
      expandedColumns[i].isReordered = true;
    }
    this.updateIndicesForLevel(source.level + 1);
    this.columnResizingService.areColumnsReordered = true;
  }
  updateIndicesForLevel(level) {
    const colsForParentLevel = this.allColumnsForLevel(level - 1);
    const colsForLevel = [];
    sortColumns(colsForParentLevel).forEach((c) => {
      if (c.isColumnGroup) {
        colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));
      }
    });
    expandColumnsWithSpan(colsForLevel).forEach((c, i) => {
      c.orderIndex = i;
      c.isReordered = true;
    });
    if (level < this.columnList.totalColumnLevels()) {
      this.updateIndicesForLevel(level + 1);
    }
  }
  allColumnsForLevel(level) {
    return this.columnList.toArray().filter((column) => column.level === level);
  }
  initSelectionService() {
    if (!this.selectable) {
      this.selectionService.ngOnDestroy();
      this.cellSelectionService.ngOnDestroy();
      return;
    }
    if (!this.selectionDirective && !isPresent4(this.defaultSelection)) {
      this.defaultSelection = new Selection(this.ctx, this.changeDetectorRef);
    }
    const cellSelectionMode = this.selectable["cell"];
    const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;
    const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;
    if (inactiveService.active) {
      inactiveService.ngOnDestroy();
      activeService.addSubscriptions();
      inactiveService.active = false;
    }
    activeService.active = true;
    activeService.init({
      cellSelected: cellSelectionMode ? this.cellSelected : void 0,
      rowSelected: cellSelectionMode ? void 0 : this.rowSelected,
      isRowSelectable: this.isRowSelectable,
      selectable: this.selectable,
      view: this.view,
      columns: cellSelectionMode ? this.columnList.toArray() : void 0
    });
    if (!this.selectionDirective && !this.selectableSettings.enabled) {
      this.defaultSelection.reset();
    }
    if (this.selectionSubscription) {
      this.selectionSubscription.unsubscribe();
    }
    if (cellSelectionMode) {
      this.selectionSubscription = this.cellSelectionService.changes.subscribe((event2) => {
        this.ngZone.run(() => this.selectionChange.emit(event2));
      });
    } else {
      this.selectionSubscription = this.selectionService.changes.subscribe((event2) => {
        this.ngZone.run(() => this.selectionChange.emit(event2));
      });
    }
  }
  setEditFocus(element) {
    if (element) {
      return this.navigationService.tryFocus(element);
    }
  }
  columnInstance(column) {
    let instance;
    if (typeof column === "number") {
      instance = this.columnsContainer.lockedLeafColumns.toArray().concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];
    } else if (typeof column === "string") {
      instance = this.columnList.filter((item) => item.field === column)[0];
    } else {
      instance = column;
    }
    if (!instance && isDevMode()) {
      throw new Error(ColumnConfigurationErrorMessages.invalidColumn(column));
    }
    return instance;
  }
  verifySettings() {
    if (isDevMode()) {
      const locked = this.lockedLeafColumns.length || this.columnMenu && this.columnMenu.lock;
      const stickyColumns = this.stickyColumns.length || this.columnMenu && this.columnMenu.stick;
      if (locked && this.detailTemplate) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("detail template", "locked columns"));
      }
      if (stickyColumns && this.detailTemplate) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("detail template", "sticky columns"));
      }
      if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {
        console.warn(GridConfigurationErrorMessages.nonLockedColumnPresent);
      }
      if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter((column) => !column.width && !isColumnGroupComponent(column)).length) {
        console.warn(ColumnConfigurationErrorMessages.requiredWidth(locked ? "Locked" : "Virtual"));
      }
      if (locked && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Locked"));
      }
      if (stickyColumns && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Sticky"));
      }
      if (this.virtualColumns && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Virtual"));
      }
      if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {
        throw new Error(ColumnConfigurationErrorMessages.groupColumnContent);
      }
      if (this.columnList.filter((x) => x.locked && x.parent && !x.parent.isLocked).length) {
        throw new Error(ColumnConfigurationErrorMessages.lockedParent);
      }
      if ((this.rowHeight || this.detailRowHeight) && !this.isVirtual) {
        console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
      }
      if (!this.rowHeight && this.isVirtual) {
        console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
      }
      if (!this.detailRowHeight && this.isVirtual && this.detailTemplate) {
        console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
      }
      if (stickyColumns && expandColumns(this.columnList.toArray()).filter((column) => !column.width && !isColumnGroupComponent(column)).length) {
        console.warn(ColumnConfigurationErrorMessages.requiredWidth("Sticky"));
      }
      if (this.rowSticky && this.scrollable === "virtual") {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("sticky rows", 'row virtualization (scrollable="virtual")'));
      }
      if (this.rowSticky && this.groupable) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("sticky rows", "grouping"));
      }
      if (this.wrapper?.nativeElement?.querySelector("kendo-toolbar") && this.toolbarTemplate) {
        console.warn(GridConfigurationErrorMessages.unsupportedToolbarConfig);
      }
      validateColumnsField(this.columnList);
    }
  }
  autoGenerateColumns() {
    if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {
      this.columns.reset(Object.keys(this.view.at(0)).map((field) => {
        const column = new ColumnComponent2();
        column.field = field;
        return column;
      }));
    }
  }
  attachStateChangesEmitter() {
    this.stateChangeSubscription = merge(this.pageChange.pipe(map((x) => ({
      filter: this.filter,
      group: this.group,
      skip: x.skip,
      sort: this.sort,
      take: x.take
    }))), this.sortChange.pipe(map((sort) => ({
      filter: this.filter,
      group: this.group,
      skip: this.skip,
      sort,
      take: this.pageSize
    }))), this.groupChange.pipe(map((group) => ({
      filter: this.filter,
      group,
      skip: this.skip,
      sort: this.sort,
      take: this.pageSize
    }))), this.filterChange.pipe(map((filter3) => ({
      filter: filter3,
      group: this.group,
      skip: 0,
      sort: this.sort,
      take: this.pageSize
    })))).subscribe((x) => {
      this.closeCell();
      this.cancelCell();
      if (this.selectable && this.selectableSettings?.enabled && this.isVirtual) {
        this.blockArrowSelection = true;
      }
      this.dataStateChange.emit(x);
      hasObservers(this.gridStateChange) && this.gridStateChange.emit(__spreadValues(__spreadValues({}, this.currentState), x));
      if (this.undoRedoService) {
        this.undoRedoService.originalEvent = x;
      }
    });
    this.stateChangeSubscription.add(merge(this.columnReorder, this.columnResize, this.columnVisibilityChange, this.columnLockedChange, this.columnStickyChange).pipe(flatMap(() => this.ngZone.onStable.pipe(take(1)))).subscribe(() => this.ngZone.run(() => hasObservers(this.gridStateChange) && this.gridStateChange.emit(this.currentState))));
  }
  attachEditHandlers() {
    if (!this.editService) {
      return;
    }
    this.editServiceSubscription = this.editService.changes.subscribe(this.emitCRUDEvent.bind(this));
  }
  emitCRUDEvent(args) {
    const {
      action,
      rowIndex,
      formGroup
    } = args;
    let dataItem = this.view.at(rowIndex - this.skip);
    if (action !== "add" && !dataItem) {
      dataItem = formGroup.value;
    }
    this.closeCell();
    Object.assign(args, {
      dataItem,
      sender: this
    });
    switch (action) {
      case "add":
        this.add.emit(args);
        break;
      case "cancel":
        this.cancel.emit(args);
        break;
      case "edit":
        this.edit.emit(args);
        break;
      case "remove":
        this.remove.emit(args);
        break;
      case "save":
        this.save.emit(args);
        break;
      case "cellClose":
        this.cellClose.emit(args);
        break;
      default:
        break;
    }
  }
  attachDomEventHandlers() {
    this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
      this.cellClick.emit(Object.assign({
        sender: this
      }, args));
    });
  }
  attachElementEventHandlers() {
    if (isUniversal()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    const ariaRoot = this.ariaRoot.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      const resizeCheck = this.resizeCheck.bind(this);
      const resizeSubscription = this.renderer.listen("window", "resize", resizeCheck);
      const orientationSubscription = this.renderer.listen("window", "orientationchange", resizeCheck);
      const documentClickSubscription = this.renderer.listen("document", "click", (args) => {
        const activeElement = document.activeElement;
        if (this.editService.shouldCloseCell() && !closest3(args.target, matchesClasses("k-animation-container k-grid-ignore-click")) && !(activeElement && (closest3(activeElement, matchesClasses("k-animation-container")) || isInEditedCell(activeElement, this.wrapper.nativeElement)))) {
          this.editService.closeCell(args);
        }
      });
      const windowBlurSubscription = this.renderer.listen("window", "blur", (args) => {
        const activeElement = document.activeElement;
        if (activeElement && !(matchesNodeName("input")(activeElement) && activeElement.type === "file" && isInEditedCell(activeElement, this.wrapper.nativeElement))) {
          this.editService.closeCell(args);
        }
        this.domEvents.windowBlur.emit(args);
      });
      const clickSubscription = this.renderer.listen(wrapper, "click", (args) => {
        this.domEvents.click.emit(args);
      });
      const keydownSubscription = this.renderer.listen(wrapper, "keydown", (args) => {
        this.domEvents.keydown.emit(args);
      });
      const shiftKeyupSubscription = this.renderer.listen(wrapper, "keyup", (args) => {
        if (args.key === "Shift") {
          this.domEvents.shiftKeyup.emit(args);
        }
      });
      let focused = false;
      const focusInSubscription = this.renderer.listen(ariaRoot, "focusin", (args) => {
        this.domEvents.focus.emit(args);
        if (!focused) {
          this.domEvents.focusIn.emit(args);
          focused = true;
        }
      });
      const focusOutSubscription = this.renderer.listen(ariaRoot, "focusout", (args) => {
        const next = args.relatedTarget || document.activeElement;
        const outside = !closest3(next, (node) => node === ariaRoot);
        if (outside) {
          this.domEvents.focusOut.emit(args);
          this.domEvents.shiftKeyup.emit(args);
          focused = false;
        }
      });
      this.detachElementEventHandlers = () => {
        resizeSubscription();
        orientationSubscription();
        documentClickSubscription();
        windowBlurSubscription();
        clickSubscription();
        keydownSubscription();
        shiftKeyupSubscription();
        focusInSubscription();
        focusOutSubscription();
      };
    });
  }
  matchesMedia(c) {
    return this.responsiveService.matchesMedia(c.media);
  }
  resizeCheck() {
    if (window.innerWidth !== this.cachedWindowWidth) {
      this.cachedWindowWidth = window.innerWidth;
      let hasChanges = false;
      this.columnList.filterHierarchy((column) => {
        const matchesMedia = this.matchesMedia(column);
        if (column.matchesMedia !== matchesMedia) {
          hasChanges = true;
          column.matchesMedia = matchesMedia;
        }
        return column.isVisible;
      });
      if (hasChanges) {
        this.ngZone.run(() => {
          this.changeDetectorRef.markForCheck();
        });
      }
    }
  }
  emitPDFExportEvent() {
    const args = new PDFExportEvent();
    this.pdfExport.emit(args);
    if (!args.isDefaultPrevented()) {
      this.saveAsPDF();
    }
  }
  syncHeaderHeight(observable) {
    return observable.pipe(filter(() => isPresent4(this.lockedHeader))).subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));
  }
  columnsContainerChange() {
    this.columnsContainerChangeSubscription = this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));
  }
  handleColumnResize() {
    const resizes = this.columnResizingService.changes;
    this.columnResizingSubscription = resizes.pipe(tap((e) => {
      if (e.type === "start") {
        this.renderer.addClass(this.wrapper.nativeElement, "k-grid-column-resizing");
      } else if (e.type === "end") {
        this.renderer.removeClass(this.wrapper.nativeElement, "k-grid-column-resizing");
      }
    }), filter((e) => e.type === "start"), switchMap(() => resizes.pipe(takeUntil(resizes.pipe(filter((e) => e.type === "triggerAutoFit"))), filter((e) => e.type === "end")))).subscribe(this.notifyResize.bind(this));
  }
  notifyResize(e) {
    const args = e.resizedColumns.filter((item) => isTruthy(item.column.resizable) && !item.column.isColumnGroup).map((item) => ({
      column: item.column,
      newWidth: roundDown(item.column.width),
      oldWidth: roundDown(item.oldWidth)
    }));
    this.columnResize.emit(args);
  }
  assertNavigable() {
    if (isDevMode() && !this.navigationService.enabled) {
      throw new Error(GridConfigurationErrorMessages.focusNavigable);
    }
  }
  _rowClass = () => null;
  navigationMetadata() {
    const isVirtual = this.isVirtual;
    const pageSize = this.pageSize;
    const dataRows = isVirtual ? this.view.total : pageSize;
    const addRowOffset = this.editService.hasNewItem ? 1 : 0;
    const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
    const headerRows = this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;
    return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent4(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer);
  }
  applyAutoSize() {
    const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);
    if (cols.length > 0) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.autoFitColumns(cols));
    }
  }
  onColumnRangeChange(range2) {
    const viewportColumns = this.viewportColumns = [];
    const columnsArray = this.columnsContainer.nonLockedLeafColumns.toArray();
    let leafViewportColumns = columnsArray.slice(range2.start, range2.end + 1);
    const stickyBeforeStart = columnsArray.slice(0, range2.start).filter((c) => c.sticky && !leafViewportColumns.some((col) => col === c));
    const stickyAfterEnd = columnsArray.slice(range2.end, columnsArray.length).filter((c) => c.sticky && !leafViewportColumns.some((col) => col === c));
    leafViewportColumns = [...stickyBeforeStart, ...leafViewportColumns, ...stickyAfterEnd];
    for (let idx2 = 0; idx2 < leafViewportColumns.length; idx2++) {
      let column = leafViewportColumns[idx2];
      while (column.parent) {
        column = column.parent;
      }
      const toAdd = [column];
      while (toAdd.length) {
        column = toAdd.shift();
        viewportColumns.push(column);
        if (column.isColumnGroup) {
          toAdd.unshift(...column.childrenArray);
        }
      }
      const lastFromGroup = viewportColumns[viewportColumns.length - 1];
      column = leafViewportColumns[idx2];
      while (column !== lastFromGroup && idx2 < leafViewportColumns.length) {
        idx2++;
        column = leafViewportColumns[idx2];
      }
    }
    if (range2.start > 0) {
      const first = leafViewportColumns[0];
      let offset3 = range2.offset;
      let current3 = viewportColumns[0];
      let index = 0;
      while (current3 !== first) {
        offset3 -= current3.isColumnGroup ? 0 : current3.width;
        index++;
        current3 = viewportColumns[index];
      }
      if (offset3 > 0) {
        const totalLevels = this.columnsContainer.totalLevels;
        let previous;
        for (let idx2 = 0; idx2 <= totalLevels; idx2++) {
          const offsetColumn = idx2 < totalLevels ? new ColumnGroupComponent2(previous) : new ColumnBase2(previous);
          previous = offsetColumn;
          offsetColumn.title = " ";
          offsetColumn.width = offset3;
          viewportColumns.unshift(offsetColumn);
        }
      }
    }
    this.leafViewportColumns = viewportColumns.filter((c) => !c.isColumnGroup);
  }
  toggleDetailRowLegacy(index, expand) {
    const hasCallback = typeof this.isDetailExpanded === "function";
    if (isDevMode() && hasCallback) {
      throw new Error(GridConfigurationErrorMessages.expandCollapseMethods("expandRow", "collapseRow", "kendoGridDetailsExpandBy", "isDetailExpanded"));
    }
    if (!isDevMode() && hasCallback) {
      return;
    }
    if (this.detailsService.isExpanded(index, null) !== expand) {
      this.detailsService.toggleRow(index, null);
    }
  }
  toggleGroupRowLegacy(index, expand) {
    const hasCallback = typeof this.isGroupExpanded === "function";
    if (isDevMode() && hasCallback) {
      throw new Error(GridConfigurationErrorMessages.expandCollapseMethods("expandGroup", "collapseGroup", "kendoGridExpandGroupBy", "isGroupExpanded"));
    }
    if (!isDevMode() && hasCallback) {
      return;
    }
    if (this.groupsService.isExpanded({
      groupIndex: index
    }) !== expand) {
      this.groupsService.toggleRow({
        index
      }, false);
      if (this.ctx.groupBindingDirective) {
        this.ctx.groupBindingDirective[`group${expand ? "Expand" : "Collapse"}`]({
          groupIndex: index
        });
      }
    }
  }
  shouldResetSelection(selectableChanges) {
    const previousValue = selectableChanges.previousValue;
    if (!previousValue) {
      return false;
    }
    const currentValue = selectableChanges.currentValue;
    if (!currentValue || currentValue.enabled === false) {
      return true;
    }
    return previousValue.cell !== currentValue.cell;
  }
  notifyReorderContainers() {
    this.dragTargetContainer?.notify();
    this.dropTargetContainer?.notify();
  }
  static ɵfac = function GridComponent_Factory(t) {
    return new (t || _GridComponent)(ɵɵdirectiveInject(BrowserSupportService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ResponsiveService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ScrollSyncService2), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnReorderService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ScrollRequestService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService), ɵɵdirectiveInject(AdaptiveService), ɵɵdirectiveInject(AdaptiveGridService), ɵɵdirectiveInject(RowReorderService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GridComponent,
    selectors: [["kendo-grid"]],
    contentQueries: function GridComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnBase2, 4);
        ɵɵcontentQuery(dirIndex, DetailTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, CellLoadingTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, LoadingTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, StatusBarTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, NoRecordsTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, PagerTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, ToolbarTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.detailTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellLoadingTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.loadingTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.statusBarTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noRecordsTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pagerTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarTemplateChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
      }
    },
    viewQuery: function GridComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c65, 5);
        ɵɵviewQuery(_c66, 5);
        ɵɵviewQuery(_c67, 7);
        ɵɵviewQuery(DragTargetContainerDirective, 5);
        ɵɵviewQuery(DropTargetContainerDirective, 5);
        ɵɵviewQuery(_c68, 5, ViewContainerRef);
        ɵɵviewQuery(AdaptiveRendererComponent, 5);
        ɵɵviewQuery(_c69, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedHeader = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.ariaRoot = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragTargetContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargetContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialogContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRenderer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footer = _t);
      }
    },
    hostVars: 23,
    hostBindings: function GridComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵstyleProp("min-width", ctx.minWidth)("max-width", ctx.maxWidth)("min-height", ctx.minHeight)("max-height", ctx.maxHeight);
        ɵɵclassProp("k-grid", ctx.hostClass)("k-grid-sm", ctx.sizeSmallClass)("k-grid-md", ctx.sizeMediumClass)("k-grid-lockedcolumns", ctx.lockedClasses)("k-grid-virtual", ctx.virtualClasses)("k-grid-no-scrollbar", ctx.noScrollbarClass)("k-grid-resizable", ctx.isResizable);
      }
    },
    inputs: {
      data: "data",
      pageSize: "pageSize",
      height: "height",
      rowHeight: "rowHeight",
      adaptiveMode: "adaptiveMode",
      detailRowHeight: "detailRowHeight",
      skip: "skip",
      scrollable: "scrollable",
      selectable: "selectable",
      sort: "sort",
      size: "size",
      trackBy: "trackBy",
      filter: "filter",
      group: "group",
      virtualColumns: "virtualColumns",
      filterable: "filterable",
      sortable: "sortable",
      pageable: "pageable",
      groupable: "groupable",
      gridResizable: "gridResizable",
      rowReorderable: "rowReorderable",
      navigable: "navigable",
      autoSize: "autoSize",
      rowClass: "rowClass",
      rowSticky: "rowSticky",
      rowSelected: "rowSelected",
      isRowSelectable: "isRowSelectable",
      cellSelected: "cellSelected",
      resizable: "resizable",
      reorderable: "reorderable",
      loading: "loading",
      columnMenu: "columnMenu",
      hideHeader: "hideHeader",
      showInactiveTools: "showInactiveTools",
      isDetailExpanded: "isDetailExpanded",
      isGroupExpanded: "isGroupExpanded"
    },
    outputs: {
      filterChange: "filterChange",
      pageChange: "pageChange",
      groupChange: "groupChange",
      sortChange: "sortChange",
      selectionChange: "selectionChange",
      rowReorder: "rowReorder",
      dataStateChange: "dataStateChange",
      gridStateChange: "gridStateChange",
      groupExpand: "groupExpand",
      groupCollapse: "groupCollapse",
      detailExpand: "detailExpand",
      detailCollapse: "detailCollapse",
      edit: "edit",
      cancel: "cancel",
      save: "save",
      remove: "remove",
      add: "add",
      cellClose: "cellClose",
      cellClick: "cellClick",
      pdfExport: "pdfExport",
      excelExport: "excelExport",
      columnResize: "columnResize",
      columnReorder: "columnReorder",
      columnVisibilityChange: "columnVisibilityChange",
      columnLockedChange: "columnLockedChange",
      columnStickyChange: "columnStickyChange",
      scrollBottom: "scrollBottom",
      contentScroll: "contentScroll"
    },
    exportAs: ["kendoGrid"],
    standalone: true,
    features: [ɵɵProvidersFeature([BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService2, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {
      provide: CELL_CONTEXT,
      useValue: EMPTY_CELL_CONTEXT
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.grid"
    }, FilterService, ResponsiveService, PagerContextService, PagerNavigationService, ExcelService, ScrollSyncService2, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService2, FocusRoot, IdService, CellSelectionAggregateService, ScrollRequestService, SortService, ContextService, SizingOptionsService, RowReorderService, ClipboardService, RowspanService, AdaptiveGridService, ColumnMenuService, MenuTabbingService]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    ngContentSelectors: _c71,
    decls: 22,
    vars: 34,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_0 = goog.getMsg("Drag a column header and drop it here to group by that column");
        i18n_0 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty:Drag a column header and drop it here to group by that column`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_1 = goog.getMsg("No records available.");
        i18n_1 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.grid.noRecords|The label visible in the Grid when there are no records:No records available.`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_2 = goog.getMsg("Go to the first page");
        i18n_2 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.grid.pagerFirstPage|The label for the first page button in Grid pager:Go to the first page`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_3 = goog.getMsg("Go to the previous page");
        i18n_3 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager:Go to the previous page`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_4 = goog.getMsg("Go to the next page");
        i18n_4 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.grid.pagerNextPage|The label for the next page button in Grid pager:Go to the next page`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_5 = goog.getMsg("Go to the last page");
        i18n_5 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.grid.pagerLastPage|The label for the last page button in Grid pager:Go to the last page`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_6 = goog.getMsg("Page");
        i18n_6 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.grid.pagerPage|The label before the current page number in the Grid pager:Page`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_7 = goog.getMsg("of");
        i18n_7 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.grid.pagerOf|The label before the total pages number in the Grid pager:of`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_8 = goog.getMsg("items");
        i18n_8 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.grid.pagerItems|The label after the total pages number in the Grid pager:items`;
      }
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_9 = goog.getMsg("Page Number");
        i18n_9 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager:Page Number`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_10 = goog.getMsg("items per page");
        i18n_10 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager:items per page`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_11 = goog.getMsg("Type a page number");
        i18n_11 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number:Type a page number`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_12 = goog.getMsg("Filter");
        i18n_12 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.grid.filter|The label of the filter cell or icon:Filter`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_13 = goog.getMsg("Is equal to");
        i18n_13 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.grid.filterEqOperator|The text of the equal filter operator:Is equal to`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_14 = goog.getMsg("Is not equal to");
        i18n_14 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.grid.filterNotEqOperator|The text of the not equal filter operator:Is not equal to`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_15 = goog.getMsg("Is null");
        i18n_15 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.grid.filterIsNullOperator|The text of the is null filter operator:Is null`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_16 = goog.getMsg("Is not null");
        i18n_16 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator:Is not null`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_17 = goog.getMsg("Is empty");
        i18n_17 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator:Is empty`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_18 = goog.getMsg("Is not empty");
        i18n_18 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator:Is not empty`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_19 = goog.getMsg("Starts with");
        i18n_19 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.grid.filterStartsWithOperator|The text of the starts with filter operator:Starts with`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_20 = goog.getMsg("Contains");
        i18n_20 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.grid.filterContainsOperator|The text of the contains filter operator:Contains`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_21 = goog.getMsg("Does not contain");
        i18n_21 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator:Does not contain`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_22 = goog.getMsg("Ends with");
        i18n_22 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.grid.filterEndsWithOperator|The text of the ends with filter operator:Ends with`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_23 = goog.getMsg("Is greater than or equal to");
        i18n_23 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.grid.filterGteOperator|The text of the greater than or equal filter operator:Is greater than or equal to`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_24 = goog.getMsg("Is greater than");
        i18n_24 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.grid.filterGtOperator|The text of the greater than filter operator:Is greater than`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_25 = goog.getMsg("Is less than or equal to");
        i18n_25 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.grid.filterLteOperator|The text of the less than or equal filter operator:Is less than or equal to`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_26 = goog.getMsg("Is less than");
        i18n_26 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.grid.filterLtOperator|The text of the less than filter operator:Is less than`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_27 = goog.getMsg("Is True");
        i18n_27 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option:Is True`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_28 = goog.getMsg("Is False");
        i18n_28 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option:Is False`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_29 = goog.getMsg("(All)");
        i18n_29 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.grid.filterBooleanAll|The text of the (All) boolean filter option:(All)`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_30 = goog.getMsg("Is after or equal to");
        i18n_30 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator:Is after or equal to`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_31 = goog.getMsg("Is after");
        i18n_31 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.grid.filterAfterOperator|The text of the after date filter operator:Is after`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_32 = goog.getMsg("Is before");
        i18n_32 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.grid.filterBeforeOperator|The text of the before date filter operator:Is before`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_33 = goog.getMsg("Is before or equal to");
        i18n_33 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator:Is before or equal to`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_34 = goog.getMsg("Filter");
        i18n_34 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.grid.filterFilterButton|The text of the filter button:Filter`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_35 = goog.getMsg("Clear");
        i18n_35 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.grid.filterClearButton|The text of the clear filter button:Clear`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_36 = goog.getMsg("Clear sorting");
        i18n_36 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.grid.sortClearButton|The text of the clear sort button located in the Sort Toolbar Tool and adaptive Sort Toolbar Tool:Clear sorting`;
      }
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_37 = goog.getMsg("Close");
        i18n_37 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.grid.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_38 = goog.getMsg("Back");
        i18n_38 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.grid.adaptiveBackButtonTitle|The title of the Back button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Back`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_39 = goog.getMsg("Clear all filters");
        i18n_39 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.grid.filterClearAllButton|The text of the clear all filters button located in the Filter Toolbar Tool and adaptive Filter Toolbar Tool:Clear all filters`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_40 = goog.getMsg("Clear grouping");
        i18n_40 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.grid.groupClearButton|The text of the clear grouping button in the Group Toolbar Tool and adaptive Group Toolbar Tool:Clear grouping`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_41 = goog.getMsg("Done");
        i18n_41 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.grid.sortDoneButton|The text of the done sort button:Done`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_42 = goog.getMsg("Done");
        i18n_42 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.grid.groupDoneButton|The text of the done group button in the adaptive Group Toolbar Tool:Done`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_43 = goog.getMsg("And");
        i18n_43 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.grid.filterAndLogic|The text of the And filter logic:And`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_44 = goog.getMsg("Or");
        i18n_44 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.grid.filterOrLogic|The text of the Or filter logic:Or`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_45 = goog.getMsg("Filter");
        i18n_45 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.grid.filterToolbarToolText|The button text of the Filter toolbar tool:Filter`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_46 = goog.getMsg("Loading");
        i18n_46 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.grid.loading|The loading text:Loading`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_47 = goog.getMsg("Data table");
        i18n_47 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.grid.gridLabel|The Grid aria-label:Data table`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_48 = goog.getMsg("Columns");
        i18n_48 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.grid.columns|The text for the Grid Column Chooser and Column Chooser toolbar tool:Columns`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_49 = goog.getMsg("Selected fields are visible");
        i18n_49 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.grid.columnsSubtitle|The subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool:Selected fields are visible`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_50 = goog.getMsg("Filter by");
        i18n_50 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.grid.adaptiveFilterTitle|The title that is displayed in the adaptive Filter Toolbar Tool and Filter Menu:Filter by`;
      }
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_51 = goog.getMsg("Operators");
        i18n_51 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.grid.adaptiveFilterOperatorsTitle|The title that is displayed in the Operators Action Sheet:Operators`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_52 = goog.getMsg("Sort by");
        i18n_52 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.grid.adaptiveSortTitle|The title that is displayed in the adaptive Sort Toolbar Tool:Sort by`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_53 = goog.getMsg("Group by");
        i18n_53 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.grid.adaptiveGroupTitle|The title that is displayed in the adaptive Group Toolbar Tool.:Group by`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_54 = goog.getMsg("Lock");
        i18n_54 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.grid.lock|The text shown in the column menu for the lock item:Lock`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_55 = goog.getMsg("Unlock");
        i18n_55 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.grid.unlock|The text shown in the column menu for the unlock item:Unlock`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_56 = goog.getMsg("Set Column Position");
        i18n_56 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item:Set Column Position`;
      }
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_57 = goog.getMsg("Stick");
        i18n_57 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.grid.stick|The text shown in the column menu for the stick item:Stick`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_58 = goog.getMsg("Unstick");
        i18n_58 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.grid.unstick|The text shown in the column menu for the unstick item:Unstick`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_59 = goog.getMsg("Sortable");
        i18n_59 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.grid.sortable|The label of the sort icon:Sortable`;
      }
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_60 = goog.getMsg("Sort Ascending");
        i18n_60 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item:Sort Ascending`;
      }
      let i18n_61;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_61 = goog.getMsg("Sort Descending");
        i18n_61 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_61;
      } else {
        i18n_61 = $localize`:kendo.grid.sortDescending|The text shown in the column menu for the sort descending item:Sort Descending`;
      }
      let i18n_62;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_62 = goog.getMsg("Autosize All Columns");
        i18n_62 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_62;
      } else {
        i18n_62 = $localize`:kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item:Autosize All Columns`;
      }
      let i18n_63;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_63 = goog.getMsg("Autosize This Column");
        i18n_63 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_63;
      } else {
        i18n_63 = $localize`:kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item:Autosize This Column`;
      }
      let i18n_64;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_64 = goog.getMsg("Not Sorted");
        i18n_64 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_64;
      } else {
        i18n_64 = $localize`:kendo.grid.sortedDefault|The status announcement when a column is no longer sorted:Not Sorted`;
      }
      let i18n_65;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_65 = goog.getMsg("Sorted Ascending");
        i18n_65 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_65;
      } else {
        i18n_65 = $localize`:kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups:Sorted Ascending`;
      }
      let i18n_66;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_66 = goog.getMsg("Sorted Descending");
        i18n_66 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_66;
      } else {
        i18n_66 = $localize`:kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups:Sorted Descending`;
      }
      let i18n_67;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_67 = goog.getMsg("Apply");
        i18n_67 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_67;
      } else {
        i18n_67 = $localize`:kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button:Apply`;
      }
      let i18n_68;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_68 = goog.getMsg("Reset");
        i18n_68 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_68;
      } else {
        i18n_68 = $localize`:kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button:Reset`;
      }
      let i18n_69;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_69 = goog.getMsg("Expand Details");
        i18n_69 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_69;
      } else {
        i18n_69 = $localize`:kendo.grid.detailExpand|The title of the expand icon of detail rows.:Expand Details`;
      }
      let i18n_70;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_70 = goog.getMsg("Collapse Details");
        i18n_70 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_70;
      } else {
        i18n_70 = $localize`:kendo.grid.detailCollapse|The title of the collapse icon of detail rows.:Collapse Details`;
      }
      let i18n_71;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_71 = goog.getMsg("TODAY");
        i18n_71 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_71;
      } else {
        i18n_71 = $localize`:kendo.grid.filterDateToday|The text of the Today button of the Date filter.:TODAY`;
      }
      let i18n_72;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_72 = goog.getMsg("Toggle Calendar");
        i18n_72 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_72;
      } else {
        i18n_72 = $localize`:kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter.:Toggle Calendar`;
      }
      let i18n_73;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_73 = goog.getMsg("Decrement");
        i18n_73 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_73;
      } else {
        i18n_73 = $localize`:kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter.:Decrement`;
      }
      let i18n_74;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_74 = goog.getMsg("Increment");
        i18n_74 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_74;
      } else {
        i18n_74 = $localize`:kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter.:Increment`;
      }
      let i18n_75;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_75 = goog.getMsg("Select Row");
        i18n_75 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_75;
      } else {
        i18n_75 = $localize`:kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes.:Select Row`;
      }
      let i18n_76;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_76 = goog.getMsg("Select All Rows");
        i18n_76 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_76;
      } else {
        i18n_76 = $localize`:kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox.:Select All Rows`;
      }
      let i18n_77;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_77 = goog.getMsg("Sort");
        i18n_77 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_77;
      } else {
        i18n_77 = $localize`:kendo.grid.sortToolbarToolText|The button text of the Sort toolbar tool.:Sort`;
      }
      let i18n_78;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_78 = goog.getMsg("Collapse Group");
        i18n_78 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_78;
      } else {
        i18n_78 = $localize`:kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows.:Collapse Group`;
      }
      let i18n_79;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_79 = goog.getMsg("Expand Group");
        i18n_79 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_79;
      } else {
        i18n_79 = $localize`:kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows.:Expand Group`;
      }
      let i18n_80;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_80 = goog.getMsg("Select page");
        i18n_80 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_80;
      } else {
        i18n_80 = $localize`:kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager:Select page`;
      }
      let i18n_81;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_81 = goog.getMsg("Top toolbar");
        i18n_81 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_81;
      } else {
        i18n_81 = $localize`:kendo.grid.topToolbarLabel|The label for the Grid top toolbar:Top toolbar`;
      }
      let i18n_82;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_82 = goog.getMsg("Bottom toolbar");
        i18n_82 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_82;
      } else {
        i18n_82 = $localize`:kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar:Bottom toolbar`;
      }
      let i18n_83;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_83 = goog.getMsg("Edit");
        i18n_83 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_83;
      } else {
        i18n_83 = $localize`:kendo.grid.editToolbarToolText|The text for the Grid Edit toolbar tool:Edit`;
      }
      let i18n_84;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_84 = goog.getMsg("Save");
        i18n_84 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_84;
      } else {
        i18n_84 = $localize`:kendo.grid.saveToolbarToolText|The text for the Grid Save toolbar tool:Save`;
      }
      let i18n_85;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_85 = goog.getMsg("Add");
        i18n_85 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_85;
      } else {
        i18n_85 = $localize`:kendo.grid.addToolbarToolText|The text for the Grid Add toolbar tool:Add`;
      }
      let i18n_86;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_86 = goog.getMsg("Cancel");
        i18n_86 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_86;
      } else {
        i18n_86 = $localize`:kendo.grid.cancelToolbarToolText|The text for the Grid Cancel toolbar tool:Cancel`;
      }
      let i18n_87;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_87 = goog.getMsg("Delete");
        i18n_87 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_87;
      } else {
        i18n_87 = $localize`:kendo.grid.removeToolbarToolText|The text for the Grid Remove toolbar tool:Delete`;
      }
      let i18n_88;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_88 = goog.getMsg("Excel Export");
        i18n_88 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_88;
      } else {
        i18n_88 = $localize`:kendo.grid.excelExportToolbarToolText|The text for the Grid Excel export toolbar tool:Excel Export`;
      }
      let i18n_89;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_89 = goog.getMsg("PDF Export");
        i18n_89 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_89;
      } else {
        i18n_89 = $localize`:kendo.grid.pdfExportToolbarToolText|The text for the Grid PDF export toolbar tool:PDF Export`;
      }
      let i18n_90;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_90 = goog.getMsg("Group panel");
        i18n_90 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_90;
      } else {
        i18n_90 = $localize`:kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar:Group panel`;
      }
      let i18n_91;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_91 = goog.getMsg("Drag row");
        i18n_91 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_91;
      } else {
        i18n_91 = $localize`:kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle:Drag row`;
      }
      let i18n_92;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_92 = goog.getMsg("Filter");
        i18n_92 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_92;
      } else {
        i18n_92 = $localize`:kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab:Filter`;
      }
      let i18n_93;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_93 = goog.getMsg("General");
        i18n_93 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_93;
      } else {
        i18n_93 = $localize`:kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab:General`;
      }
      let i18n_94;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_94 = goog.getMsg("Columns");
        i18n_94 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_94;
      } else {
        i18n_94 = $localize`:kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab:Columns`;
      }
      let i18n_95;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_95 = goog.getMsg("Move as previous");
        i18n_95 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_95;
      } else {
        i18n_95 = $localize`:kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item:Move as previous`;
      }
      let i18n_96;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_96 = goog.getMsg("Move as next");
        i18n_96 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_96;
      } else {
        i18n_96 = $localize`:kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item:Move as next`;
      }
      let i18n_97;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_97 = goog.getMsg("Group");
        i18n_97 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_97;
      } else {
        i18n_97 = $localize`:kendo.grid.groupToolbarToolText|The button text of the Group toolbar tool:Group`;
      }
      let i18n_98;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_98 = goog.getMsg("Please confirm");
        i18n_98 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_98;
      } else {
        i18n_98 = $localize`:kendo.grid.removeConfirmationDialogTitle|The title of the built-in remove item confirmation Dialog:Please confirm`;
      }
      let i18n_99;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_99 = goog.getMsg("Are you sure you want to delete this item?");
        i18n_99 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_99;
      } else {
        i18n_99 = $localize`:kendo.grid.removeConfirmationDialogContent|The content of the built-in remove item confirmation Dialog:Are you sure you want to delete this item?`;
      }
      let i18n_100;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_100 = goog.getMsg("Yes");
        i18n_100 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_100;
      } else {
        i18n_100 = $localize`:kendo.grid.removeConfirmationDialogConfirmText|The text of the built-in remove item confirmation Dialog confirm action button:Yes`;
      }
      let i18n_101;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_101 = goog.getMsg("No");
        i18n_101 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_101;
      } else {
        i18n_101 = $localize`:kendo.grid.removeConfirmationDialogRejectText|The text of the built-in remove item confirmation Dialog reject action button:No`;
      }
      let i18n_102;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_102 = goog.getMsg("Edit");
        i18n_102 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_102;
      } else {
        i18n_102 = $localize`:kendo.grid.externalEditingTitle|The title of the built-in external editing form container when editing an item:Edit`;
      }
      let i18n_103;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_103 = goog.getMsg("Add");
        i18n_103 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_103;
      } else {
        i18n_103 = $localize`:kendo.grid.externalEditingAddTitle|The title of the built-in external editing form container when adding a new item:Add`;
      }
      let i18n_104;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_104 = goog.getMsg("Save");
        i18n_104 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_104;
      } else {
        i18n_104 = $localize`:kendo.grid.externalEditingSaveText|The text of the external editing form Save button:Save`;
      }
      let i18n_105;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_105 = goog.getMsg("Cancel");
        i18n_105 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_105;
      } else {
        i18n_105 = $localize`:kendo.grid.externalEditingCancelText|The text of the external editing form Cancel button:Cancel`;
      }
      let i18n_106;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_106 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Page navigation, page {currentPage} of {totalPages}' }}"
          }
        });
        i18n_106 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_106;
      } else {
        i18n_106 = $localize`:kendo.grid.pagerLabel|The label for the Grid pager:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_107;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_107 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter' }}"
          }
        });
        i18n_107 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_107;
      } else {
        i18n_107 = $localize`:kendo.grid.filterInputLabel|The label of the filter row and menu inputs:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_108;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_108 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter Menu' }}"
          }
        });
        i18n_108 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_108;
      } else {
        i18n_108 = $localize`:kendo.grid.filterMenuTitle|The title of the filter menu icon:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_109;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_109 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter Operators' }}"
          }
        });
        i18n_109 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_109;
      } else {
        i18n_109 = $localize`:kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_110;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_110 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Filter cell operators for {columnName}' }}"
          }
        });
        i18n_110 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_110;
      } else {
        i18n_110 = $localize`:kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_111;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_111 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Boolean filter cell for {columnName}' }}"
          }
        });
        i18n_111 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_111;
      } else {
        i18n_111 = $localize`:kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_112;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_112 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Filter Logic' }}"
          }
        });
        i18n_112 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_112;
      } else {
        i18n_112 = $localize`:kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_113;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_113 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ '{columnName} Column Menu' }}"
          }
        });
        i18n_113 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_113;
      } else {
        i18n_113 = $localize`:kendo.grid.columnMenu|The title of the column menu icon:${"�0�"}:INTERPOLATION:`;
      }
      let i18n_114;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_114 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'The {fieldName} field has {errorName} validation error' }}"
          }
        });
        i18n_114 = MSG__USERS_VISHNU_DESKTOP_PROJECTS_BH_IEP_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2022_PROGRESS_KENDO_ANGULAR_GRID_MJS_114;
      } else {
        i18n_114 = $localize`:kendo.grid.formValidationErrorText|The default text of a form validation error when using external editing.:${"�0�"}:INTERPOLATION:`;
      }
      return [["ariaRoot", ""], ["defaultHint", ""], ["defaultPager", ""], ["dialogContainer", ""], ["topPager", ""], ["header", ""], ["lockedHeader", ""], ["footer", ""], ["bottomPager", ""], ["pagerLabel", i18n_106, "filterInputLabel", i18n_107, "filterMenuTitle", i18n_108, "filterMenuOperatorsDropDownLabel", i18n_109, "filterCellOperatorLabel", i18n_110, "booleanFilterCellLabel", i18n_111, "filterMenuLogicDropDownLabel", i18n_112, "columnMenu", i18n_113, "formValidationErrorText", i18n_114], ["kendoGridLocalizedMessages", "", "groupPanelEmpty", i18n_0, "noRecords", i18n_1, "pagerFirstPage", i18n_2, "pagerPreviousPage", i18n_3, "pagerNextPage", i18n_4, "pagerLastPage", i18n_5, "pagerPage", i18n_6, "pagerOf", i18n_7, "pagerItems", i18n_8, "pagerPageNumberInputTitle", i18n_9, "pagerItemsPerPage", i18n_10, "pagerInputLabel", i18n_11, "filter", i18n_12, "filterEqOperator", i18n_13, "filterNotEqOperator", i18n_14, "filterIsNullOperator", i18n_15, "filterIsNotNullOperator", i18n_16, "filterIsEmptyOperator", i18n_17, "filterIsNotEmptyOperator", i18n_18, "filterStartsWithOperator", i18n_19, "filterContainsOperator", i18n_20, "filterNotContainsOperator", i18n_21, "filterEndsWithOperator", i18n_22, "filterGteOperator", i18n_23, "filterGtOperator", i18n_24, "filterLteOperator", i18n_25, "filterLtOperator", i18n_26, "filterIsTrue", i18n_27, "filterIsFalse", i18n_28, "filterBooleanAll", i18n_29, "filterAfterOrEqualOperator", i18n_30, "filterAfterOperator", i18n_31, "filterBeforeOperator", i18n_32, "filterBeforeOrEqualOperator", i18n_33, "filterFilterButton", i18n_34, "filterClearButton", i18n_35, "sortClearButton", i18n_36, "adaptiveCloseButtonTitle", i18n_37, "adaptiveBackButtonTitle", i18n_38, "filterClearAllButton", i18n_39, "groupClearButton", i18n_40, "sortDoneButton", i18n_41, "groupDoneButton", i18n_42, "filterAndLogic", i18n_43, "filterOrLogic", i18n_44, "filterToolbarToolText", i18n_45, "loading", i18n_46, "gridLabel", i18n_47, "columns", i18n_48, "columnsSubtitle", i18n_49, "adaptiveFilterTitle", i18n_50, "adaptiveFilterOperatorsTitle", i18n_51, "adaptiveSortTitle", i18n_52, "adaptiveGroupTitle", i18n_53, "lock", i18n_54, "unlock", i18n_55, "setColumnPosition", i18n_56, "stick", i18n_57, "unstick", i18n_58, "sortable", i18n_59, "sortAscending", i18n_60, "sortDescending", i18n_61, "autosizeAllColumns", i18n_62, "autosizeThisColumn", i18n_63, "sortedDefault", i18n_64, "sortedAscending", i18n_65, "sortedDescending", i18n_66, "columnsApply", i18n_67, "columnsReset", i18n_68, "detailExpand", i18n_69, "detailCollapse", i18n_70, "filterDateToday", i18n_71, "filterDateToggle", i18n_72, "filterNumericDecrement", i18n_73, "filterNumericIncrement", i18n_74, "selectionCheckboxLabel", i18n_75, "selectAllCheckboxLabel", i18n_76, "sortToolbarToolText", i18n_77, "groupCollapse", i18n_78, "groupExpand", i18n_79, "pagerSelectPage", i18n_80, "topToolbarLabel", i18n_81, "bottomToolbarLabel", i18n_82, "editToolbarToolText", i18n_83, "saveToolbarToolText", i18n_84, "addToolbarToolText", i18n_85, "cancelToolbarToolText", i18n_86, "removeToolbarToolText", i18n_87, "excelExportToolbarToolText", i18n_88, "pdfExportToolbarToolText", i18n_89, "groupPanelLabel", i18n_90, "dragRowHandleLabel", i18n_91, "columnMenuFilterTabTitle", i18n_92, "columnMenuGeneralTabTitle", i18n_93, "columnMenuColumnsTabTitle", i18n_94, "groupChipMenuPrevious", i18n_95, "groupChipMenuNext", i18n_96, "groupToolbarToolText", i18n_97, "removeConfirmationDialogTitle", i18n_98, "removeConfirmationDialogContent", i18n_99, "removeConfirmationDialogConfirmText", i18n_100, "removeConfirmationDialogRejectText", i18n_101, "externalEditingTitle", i18n_102, "externalEditingAddTitle", i18n_103, "externalEditingSaveText", i18n_104, "externalEditingCancelText", i18n_105, 6, "pagerLabel", "filterInputLabel", "filterMenuTitle", "filterMenuOperatorsDropDownLabel", "filterCellOperatorLabel", "booleanFilterCellLabel", "filterMenuLogicDropDownLabel", "columnMenu", "formValidationErrorText"], ["position", "top", 3, "size", "navigable", 4, "ngIf"], ["class", "k-grid-pager k-grid-pager-top", 3, "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type", "pageChange", "pagerInputVisibilityChange", "pageTextVisibilityChange", "itemsTextVisibilityChange", 4, "ngIf"], ["role", "toolbar", 3, "navigable", "text", "groups", "change", 4, "ngIf"], ["role", "grid", "kendoDragTargetContainer", "", "kendoDropTargetContainer", "", "mode", "manual", 1, "k-grid-aria-root", 3, "onPress", "onDragStart", "onDrag", "onDragEnter", "onDragLeave", "onDragEnd", "onDrop", "dragDisabled", "dropDisabled", "dragTargetFilter", "dropTargetFilter", "dragHandle", "hint", "hintContext", "dragData", "id"], [4, "ngIf"], ["kendoGridLoading", "", 3, "loadingTemplate", 4, "ngIf"], [3, "statusBarTemplate", 4, "ngIf"], ["class", "k-grid-pager", 3, "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type", "pageChange", "pagerInputVisibilityChange", "pageTextVisibilityChange", "itemsTextVisibilityChange", 4, "ngIf"], ["class", "k-grid-toolbar-bottom", "position", "bottom", 3, "size", "navigable", 4, "ngIf"], ["kendoWatermarkOverlay", "", 4, "ngIf"], ["position", "top", 3, "size", "navigable"], [1, "k-grid-pager", "k-grid-pager-top", 3, "pageChange", "pagerInputVisibilityChange", "pageTextVisibilityChange", "itemsTextVisibilityChange", "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type"], ["kendoPagerTemplate", ""], [3, "ariaLabel", "firstPage", "inputLabel", "previousPage", "nextPage", "lastPage", "selectPage", "page", "itemsPerPage", "items", "of", "pageNumberInputTitle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "toolbar", 3, "change", "navigable", "text", "groups"], ["class", "k-grid-header", "role", "presentation", 3, "k-grid-draggable-header", "padding", 4, "ngIf"], ["kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "pageChange", "scrollBottom", "contentScroll", "data", "rowHeight", "detailRowHeight", "total", "take", "groups", "groupable", "skip", "trackBy", "columns", "selectable", "filterable", "detailTemplate", "noRecordsTemplate", "size", "rowClass", "rowSticky", "loading", "isVirtual", "cellLoadingTemplate", "loadingTemplate", "virtualColumns", "enableDrag", "sort"], ["class", "k-grid-footer", 3, "padding", 4, "ngIf"], ["role", "presentation", 1, "k-grid-header"], ["role", "presentation", "class", "k-grid-header-locked", 3, "width", 4, "ngIf"], ["role", "presentation", "data-scrollable", "", 1, "k-grid-header-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation", "kendoGridResizableTable", "", "kendoGridTable", "", 1, "k-grid-header-table", 3, "virtualColumns", "size"], ["kendoGridColGroup", "", 3, "columns", "groups", "detailTemplate"], ["kendoGridHeader", "", "role", "rowgroup", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "filter", "filterable", "groupable", "reorderable", "groups", "sortable", "columnMenu", "columnMenuTemplate", "lockedColumnsCount", "totalColumnsCount", "totalColumns", "detailTemplate", "tabIndex"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["role", "presentation", 1, "k-grid-header-locked"], ["kendoGridResizableTable", "", "role", "presentation", "kendoGridTable", "", 1, "k-grid-header-table", 3, "locked", "size"], ["kendoGridHeader", "", "role", "rowgroup", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "groups", "filter", "filterable", "groupable", "reorderable", "sortable", "columnMenu", "columnMenuTemplate", "totalColumnsCount", "totalColumns", "detailTemplate", "tabIndex"], ["role", "presentation", 1, "k-width-container"], [1, "k-grid-footer"], ["class", "k-grid-footer-locked", 3, "width", 4, "ngIf"], ["data-scrollable", "", 1, "k-grid-footer-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation", "kendoGridTable", "", "kendoGridResizableTable", "", 1, "k-grid-footer-table", 3, "size"], ["kendoGridFooter", "", 3, "logicalRowIndex", "scrollable", "groups", "columns", "lockedColumnsCount", "detailTemplate", "totalColumns", "totalColumnsCount"], [1, "k-grid-footer-locked"], ["role", "presentation", "kendoGridResizableTable", "", "kendoGridTable", "", 1, "k-grid-footer-table", 3, "locked", "size"], ["kendoGridFooter", "", 3, "scrollable", "groups", "columns", "detailTemplate", "logicalRowIndex", "totalColumns", "totalColumnsCount"], ["kendoGridTable", "", "kendoGridResizableTable", "", "role", "presentation", 3, "size"], ["kendoGridColGroup", "", 3, "columns", "groups", "sort", "detailTemplate"], ["kendoGridHeader", "", "class", "k-grid-header", "role", "rowgroup", 3, "k-grid-draggable-header", "resizable", "scrollable", "columns", "totalColumnLevels", "totalColumns", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex", 4, "ngIf"], ["kendoGridTableBody", "", "kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "isLoading", "groups", "data", "skip", "columns", "selectable", "filterable", "noRecordsTemplate", "detailTemplate", "showGroupFooters", "trackBy", "rowClass", "enableDrag"], ["kendoGridFooter", "", 3, "scrollable", "logicalRowIndex", "groups", "columns", "detailTemplate", "totalColumns", "totalColumnsCount", 4, "ngIf"], ["kendoGridHeader", "", "role", "rowgroup", 1, "k-grid-header", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "totalColumns", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex"], ["kendoGridFooter", "", 3, "scrollable", "logicalRowIndex", "groups", "columns", "detailTemplate", "totalColumns", "totalColumnsCount"], ["kendoGridLoading", "", 3, "loadingTemplate"], [3, "statusBarTemplate"], [1, "k-grid-pager", 3, "pageChange", "pagerInputVisibilityChange", "pageTextVisibilityChange", "itemsTextVisibilityChange", "navigable", "pageSize", "total", "skip", "size", "responsive", "buttonCount", "info", "pageSizeValues", "previousNext", "type"], ["position", "bottom", 1, "k-grid-toolbar-bottom", 3, "size", "navigable"], ["innerCssClass", "k-drag-status", 3, "name", "svgIcon"], [1, "k-pager-numbers-wrap"], [3, "size", 4, "ngIf"], [3, "size", "buttonCount", 4, "ngIf"], [3, "size", "showPageText", 4, "ngIf"], [3, "size", "pageSizes", "showItemsText", 4, "ngIf"], [3, "size"], [3, "size", "buttonCount"], [3, "size", "showPageText"], [3, "size", "pageSizes", "showItemsText"], ["kendoWatermarkOverlay", ""]];
    },
    template: function GridComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c70);
        ɵɵelementContainerStart(0, 10);
        ɵɵi18nAttributes(1, 9);
        ɵɵelementContainerEnd();
        ɵɵtemplate(2, GridComponent_kendo_grid_toolbar_2_Template, 1, 4, "kendo-grid-toolbar", 11);
        ɵɵprojection(3);
        ɵɵtemplate(4, GridComponent_kendo_pager_4_Template, 4, 23, "kendo-pager", 12)(5, GridComponent_kendo_grid_group_panel_5_Template, 1, 5, "kendo-grid-group-panel", 13);
        ɵɵelementStart(6, "div", 14, 0);
        ɵɵlistener("onPress", function GridComponent_Template_div_onPress_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "press"));
        })("onDragStart", function GridComponent_Template_div_onDragStart_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragStart"));
        })("onDrag", function GridComponent_Template_div_onDrag_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "drag"));
        })("onDragEnter", function GridComponent_Template_div_onDragEnter_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragEnter"));
        })("onDragLeave", function GridComponent_Template_div_onDragLeave_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragLeave"));
        })("onDragEnd", function GridComponent_Template_div_onDragEnd_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "dragEnd"));
        })("onDrop", function GridComponent_Template_div_onDrop_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleReorderEvents($event, "drop"));
        });
        ɵɵtemplate(8, GridComponent_ng_container_8_Template, 4, 26, "ng-container", 15)(9, GridComponent_ng_container_9_Template, 6, 22, "ng-container", 15)(10, GridComponent_div_10_Template, 1, 1, "div", 16);
        ɵɵelementEnd();
        ɵɵtemplate(11, GridComponent_kendo_grid_status_bar_11_Template, 1, 1, "kendo-grid-status-bar", 17)(12, GridComponent_kendo_pager_12_Template, 4, 23, "kendo-pager", 18)(13, GridComponent_kendo_grid_toolbar_13_Template, 1, 4, "kendo-grid-toolbar", 19)(14, GridComponent_ng_template_14_Template, 2, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor)(16, GridComponent_ng_template_16_Template, 7, 6, "ng-template", null, 2, ɵɵtemplateRefExtractor);
        ɵɵelement(18, "div", null, 3);
        ɵɵtemplate(20, GridComponent_kendo_grid_adaptive_renderer_20_Template, 1, 0, "kendo-grid-adaptive-renderer", 15)(21, GridComponent_div_21_Template, 1, 0, "div", 20);
      }
      if (rf & 2) {
        const defaultHint_r10 = ɵɵreference(15);
        ɵɵi18nExp("Page navigation, page {currentPage} of {totalPages}")("{columnName} Filter")("{columnName} Filter Menu")("{columnName} Filter Operators")("Filter cell operators for {columnName}")("Boolean filter cell for {columnName}")("{columnName} Filter Logic")("{columnName} Column Menu")("The {fieldName} field has {errorName} validation error");
        ɵɵi18nApply(1);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showTopToolbar);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showTopPager);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showGroupPanel);
        ɵɵadvance();
        ɵɵproperty("dragDisabled", !ctx.rowReorderable)("dropDisabled", !ctx.rowReorderable)("dragTargetFilter", ctx.getDefaultSelectors("dragTarget"))("dropTargetFilter", ctx.getDefaultSelectors("dropTarget"))("dragHandle", ctx.getDefaultSelectors("handle"))("hint", ɵɵpureFunction1(32, _c722, ctx.customHintTemplate || defaultHint_r10))("hintContext", ctx.hintContext)("dragData", ctx.gridData)("id", ctx.ariaRootId);
        ɵɵattribute("aria-label", ctx.ariaLabel)("aria-rowcount", ctx.ariaRowCount)("aria-colcount", ctx.ariaColCount);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.isScrollable);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.isScrollable);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showStatusBar);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showBottomPager);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showBottomToolbar);
        ɵɵadvance(7);
        ɵɵproperty("ngIf", ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showLicenseWatermark);
      }
    },
    dependencies: [LocalizedMessagesDirective3, NgIf, ToolbarComponent, GroupPanelComponent, TableDirective, GridTableDirective, ColGroupComponent, HeaderComponent2, ResizableContainerDirective, ListComponent, DragTargetContainerDirective, DropTargetContainerDirective, DraggableDirective, GridMarqueeDirective, FooterComponent2, TableBodyComponent, LoadingComponent, StatusBarComponent, IconWrapperComponent, WatermarkOverlayComponent, CustomMessagesComponent, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, NgTemplateOutlet, AdaptiveRendererComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      exportAs: "kendoGrid",
      providers: [BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService2, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {
        provide: CELL_CONTEXT,
        useValue: EMPTY_CELL_CONTEXT
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.grid"
      }, FilterService, ResponsiveService, PagerContextService, PagerNavigationService, ExcelService, ScrollSyncService2, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService2, FocusRoot, IdService, CellSelectionAggregateService, ScrollRequestService, SortService, ContextService, SizingOptionsService, RowReorderService, ClipboardService, RowspanService, AdaptiveGridService, ColumnMenuService, MenuTabbingService],
      selector: "kendo-grid",
      template: `
        <ng-container kendoGridLocalizedMessages
            i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
            groupPanelEmpty="Drag a column header and drop it here to group by that column"

            i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
            noRecords="No records available."

            i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
            pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

            i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
            pagerFirstPage="Go to the first page"

            i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
            pagerPreviousPage="Go to the previous page"

            i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
            pagerNextPage="Go to the next page"

            i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
            pagerLastPage="Go to the last page"

            i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
            pagerPage="Page"

            i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
            pagerOf="of"

            i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
            pagerItems="items"

            i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
            pagerPageNumberInputTitle="Page Number"

            i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
            pagerItemsPerPage="items per page"

            i18n-pagerInputLabel="kendo.grid.pagerInputLabel|The text of the aria-label attribute applied to the input element for entering the page number"
            pagerInputLabel="Type a page number"

            i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
            filter="Filter"

            i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
            filterInputLabel="{{ '{columnName} Filter' }}"

            i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
            filterMenuTitle="{{ '{columnName} Filter Menu' }}"

            i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
            filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"

            i18n-filterCellOperatorLabel="kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown"
            filterCellOperatorLabel="{{ 'Filter cell operators for {columnName}' }}"

            i18n-booleanFilterCellLabel="kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown"
            booleanFilterCellLabel="{{ 'Boolean filter cell for {columnName}' }}"

            i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
            filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

            i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
            filterEqOperator="Is equal to"

            i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
            filterNotEqOperator="Is not equal to"

            i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
            filterIsNullOperator="Is null"

            i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
            filterIsNotNullOperator="Is not null"

            i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
            filterIsEmptyOperator="Is empty"

            i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
            filterIsNotEmptyOperator="Is not empty"

            i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
            filterStartsWithOperator="Starts with"

            i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
            filterContainsOperator="Contains"

            i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
            filterNotContainsOperator="Does not contain"

            i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
            filterEndsWithOperator="Ends with"

            i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
            filterGteOperator="Is greater than or equal to"

            i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
            filterGtOperator="Is greater than"

            i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
            filterLteOperator="Is less than or equal to"

            i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
            filterLtOperator="Is less than"

            i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
            filterIsTrue="Is True"

            i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
            filterIsFalse="Is False"

            i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
            filterBooleanAll="(All)"

            i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
            filterAfterOrEqualOperator="Is after or equal to"

            i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
            filterAfterOperator="Is after"

            i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
            filterBeforeOperator="Is before"

            i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
            filterBeforeOrEqualOperator="Is before or equal to"

            i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
            filterFilterButton="Filter"

            i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
            filterClearButton="Clear"

            i18n-sortClearButton="kendo.grid.sortClearButton|The text of the clear sort button located in the Sort Toolbar Tool and adaptive Sort Toolbar Tool"
            sortClearButton="Clear sorting"

            i18n-adaptiveCloseButtonTitle="kendo.grid.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"

            i18n-adaptiveBackButtonTitle="kendo.grid.adaptiveBackButtonTitle|The title of the Back button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveBackButtonTitle="Back"

            i18n-filterClearAllButton="kendo.grid.filterClearAllButton|The text of the clear all filters button located in the Filter Toolbar Tool and adaptive Filter Toolbar Tool"
            filterClearAllButton="Clear all filters"

            i18n-groupClearButton="kendo.grid.groupClearButton|The text of the clear grouping button in the Group Toolbar Tool and adaptive Group Toolbar Tool"
            groupClearButton="Clear grouping"

            i18n-sortDoneButton="kendo.grid.sortDoneButton|The text of the done sort button"
            sortDoneButton="Done"

            i18n-groupDoneButton="kendo.grid.groupDoneButton|The text of the done group button in the adaptive Group Toolbar Tool"
            groupDoneButton="Done"

            i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
            filterAndLogic="And"

            i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
            filterOrLogic="Or"

            i18n-filterToolbarToolText="kendo.grid.filterToolbarToolText|The button text of the Filter toolbar tool"
            filterToolbarToolText="Filter"

            i18n-loading="kendo.grid.loading|The loading text"
            loading="Loading"

            i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
            gridLabel="Data table"

            i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
            columnMenu="{{ '{columnName} Column Menu' }}"

            i18n-columns="kendo.grid.columns|The text for the Grid Column Chooser and Column Chooser toolbar tool"
            columns="Columns"

            i18n-columnsSubtitle="kendo.grid.columnsSubtitle|The subtitle for the adaptive Grid Column Chooser and Column Chooser toolbar tool"
            columnsSubtitle="Selected fields are visible"

            i18n-adaptiveFilterTitle="kendo.grid.adaptiveFilterTitle|The title that is displayed in the adaptive Filter Toolbar Tool and Filter Menu"
            adaptiveFilterTitle="Filter by"

            i18n-adaptiveFilterOperatorsTitle="kendo.grid.adaptiveFilterOperatorsTitle|The title that is displayed in the Operators Action Sheet"
            adaptiveFilterOperatorsTitle="Operators"

            i18n-adaptiveSortTitle="kendo.grid.adaptiveSortTitle|The title that is displayed in the adaptive Sort Toolbar Tool"
            adaptiveSortTitle="Sort by"

            i18n-adaptiveGroupTitle="kendo.grid.adaptiveGroupTitle|The title that is displayed in the adaptive Group Toolbar Tool."
            adaptiveGroupTitle="Group by"

            i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
            lock="Lock"

            i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
            unlock="Unlock"

            i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
            setColumnPosition="Set Column Position"

            i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
            stick="Stick"

            i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
            unstick="Unstick"

            i18n-sortable="kendo.grid.sortable|The label of the sort icon"
            sortable="Sortable"

            i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
            sortAscending="Sort Ascending"

            i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
            sortDescending="Sort Descending"

            i18n-autosizeAllColumns="kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item"
            autosizeAllColumns="Autosize All Columns"

            i18n-autosizeThisColumn="kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item"
            autosizeThisColumn="Autosize This Column"

            i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
            sortedDefault="Not Sorted"

            i18n-sortedAscending="kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups"
            sortedAscending="Sorted Ascending"

            i18n-sortedDescending="kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups"
            sortedDescending="Sorted Descending"

            i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
            columnsApply="Apply"

            i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
            columnsReset="Reset"

            i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows."
            detailExpand="Expand Details"

            i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows."
            detailCollapse="Collapse Details"

            i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
            filterDateToday="TODAY"

            i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
            filterDateToggle="Toggle Calendar"

            i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
            filterNumericDecrement="Decrement"

            i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
            filterNumericIncrement="Increment"

            i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
            selectionCheckboxLabel="Select Row"

            i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
            selectAllCheckboxLabel="Select All Rows"

            i18n-sortToolbarToolText="kendo.grid.sortToolbarToolText|The button text of the Sort toolbar tool."
            sortToolbarToolText="Sort"

            i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
            groupCollapse="Collapse Group"

            i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
            groupExpand="Expand Group"

            i18n-pagerSelectPage="kendo.grid.pagerSelectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager"
            pagerSelectPage="Select page"

            i18n-topToolbarLabel="kendo.grid.topToolbarLabel|The label for the Grid top toolbar"
            topToolbarLabel="Top toolbar"

            i18n-bottomToolbarLabel="kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar"
            bottomToolbarLabel="Bottom toolbar"

            i18n-editToolbarToolText="kendo.grid.editToolbarToolText|The text for the Grid Edit toolbar tool"
            editToolbarToolText="Edit"

            i18n-saveToolbarToolText="kendo.grid.saveToolbarToolText|The text for the Grid Save toolbar tool"
            saveToolbarToolText="Save"

            i18n-addToolbarToolText="kendo.grid.addToolbarToolText|The text for the Grid Add toolbar tool"
            addToolbarToolText="Add"

            i18n-cancelToolbarToolText="kendo.grid.cancelToolbarToolText|The text for the Grid Cancel toolbar tool"
            cancelToolbarToolText="Cancel"

            i18n-removeToolbarToolText="kendo.grid.removeToolbarToolText|The text for the Grid Remove toolbar tool"
            removeToolbarToolText="Delete"

            i18n-excelExportToolbarToolText="kendo.grid.excelExportToolbarToolText|The text for the Grid Excel export toolbar tool"
            excelExportToolbarToolText="Excel Export"

            i18n-pdfExportToolbarToolText="kendo.grid.pdfExportToolbarToolText|The text for the Grid PDF export toolbar tool"
            pdfExportToolbarToolText="PDF Export"

            i18n-groupPanelLabel="kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar"
            groupPanelLabel="Group panel"

            i18n-dragRowHandleLabel="kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle"
            dragRowHandleLabel="Drag row"

            i18n-columnMenuFilterTabTitle="kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab"
            columnMenuFilterTabTitle="Filter"

            i18n-columnMenuGeneralTabTitle="kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab"
            columnMenuGeneralTabTitle="General"

            i18n-columnMenuColumnsTabTitle="kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab"
            columnMenuColumnsTabTitle="Columns"

            i18n-groupChipMenuPrevious="kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item"
            groupChipMenuPrevious="Move as previous"

            i18n-groupChipMenuNext="kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item"
            groupChipMenuNext="Move as next"

            i18n-groupToolbarToolText="kendo.grid.groupToolbarToolText|The button text of the Group toolbar tool"
            groupToolbarToolText="Group"

            i18n-formValidationErrorText="kendo.grid.formValidationErrorText|The default text of a form validation error when using external editing."
            formValidationErrorText="{{ 'The {fieldName} field has {errorName} validation error' }}"

            i18n-removeConfirmationDialogTitle="kendo.grid.removeConfirmationDialogTitle|The title of the built-in remove item confirmation Dialog"
            removeConfirmationDialogTitle="Please confirm"

            i18n-removeConfirmationDialogContent="kendo.grid.removeConfirmationDialogContent|The content of the built-in remove item confirmation Dialog"
            removeConfirmationDialogContent="Are you sure you want to delete this item?"

            i18n-removeConfirmationDialogConfirmText="kendo.grid.removeConfirmationDialogConfirmText|The text of the built-in remove item confirmation Dialog confirm action button"
            removeConfirmationDialogConfirmText="Yes"

            i18n-removeConfirmationDialogRejectText="kendo.grid.removeConfirmationDialogRejectText|The text of the built-in remove item confirmation Dialog reject action button"
            removeConfirmationDialogRejectText="No"

            i18n-externalEditingTitle="kendo.grid.externalEditingTitle|The title of the built-in external editing form container when editing an item"
            externalEditingTitle="Edit"

            i18n-externalEditingAddTitle="kendo.grid.externalEditingAddTitle|The title of the built-in external editing form container when adding a new item"
            externalEditingAddTitle="Add"

            i18n-externalEditingSaveText="kendo.grid.externalEditingSaveText|The text of the external editing form Save button"
            externalEditingSaveText="Save"

            i18n-externalEditingCancelText="kendo.grid.externalEditingCancelText|The text of the external editing form Cancel button"
            externalEditingCancelText="Cancel"
        >
        </ng-container>
        <kendo-grid-toolbar
            *ngIf="showTopToolbar"
            [size]="size"
            [attr.aria-label]="messageFor('topToolbarLabel')"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-controls]="ariaRootId"
            position="top"></kendo-grid-toolbar>
        <ng-content select="kendo-toolbar"></ng-content>
        <kendo-pager
            *ngIf="showTopPager"
            #topPager
            [navigable]="navigation.pagerEnabled"
            class="k-grid-pager k-grid-pager-top"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
                <ng-container
                    [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
                    [ngTemplateOutletContext]="topPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
                [ariaLabel]="messageFor('pagerLabel')"
                [firstPage]="messageFor('pagerFirstPage')"
                [inputLabel]="messageFor('pagerInputLabel')"
                [previousPage]="messageFor('pagerPreviousPage')"
                [nextPage]="messageFor('pagerNextPage')"
                [lastPage]="messageFor('pagerLastPage')"
                [selectPage]="messageFor('pagerSelectPage')"
                [page]="messageFor('pagerPage')"
                [itemsPerPage]="messageFor('pagerItemsPerPage')"
                [items]="messageFor('pagerItems')"
                [of]="messageFor('pagerOf')"
                [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
        </kendo-pager>
        <kendo-grid-group-panel
            *ngIf="showGroupPanel"
            [navigable]="navigation.toolbarEnabled"
            [text]="groupableEmptyText"
            [groups]="group"
            role="toolbar"
            [attr.aria-label]="messageFor('groupPanelLabel')"
            [attr.aria-controls]="ariaRootId"
            (change)="groupChange.emit($event)">
        </kendo-grid-group-panel>
        <div #ariaRoot
            class="k-grid-aria-root"
            role="grid"
            kendoDragTargetContainer
            kendoDropTargetContainer
            mode="manual"
            [dragDisabled]="!rowReorderable"
            [dropDisabled]="!rowReorderable"
            [dragTargetFilter]="getDefaultSelectors('dragTarget')"
            [dropTargetFilter]="getDefaultSelectors('dropTarget')"
            [dragHandle]="getDefaultSelectors('handle')"
            [hint]="{hintTemplate: customHintTemplate || defaultHint}"
            [hintContext]="hintContext"
            (onPress)="handleReorderEvents($event, 'press')"
            (onDragStart)="handleReorderEvents($event, 'dragStart')"
            (onDrag)="handleReorderEvents($event, 'drag')"
            (onDragEnter)="handleReorderEvents($event, 'dragEnter')"
            (onDragLeave)="handleReorderEvents($event, 'dragLeave')"
            (onDragEnd)="handleReorderEvents($event, 'dragEnd')"
            (onDrop)="handleReorderEvents($event, 'drop')"
            [dragData]="gridData"
            [id]="ariaRootId"
            [attr.aria-label]="ariaLabel"
            [attr.aria-rowcount]="ariaRowCount"
            [attr.aria-colcount]="ariaColCount">
            <ng-container *ngIf="isScrollable">
                <div *ngIf="!hideHeader"
                    class="k-grid-header"
                    [class.k-grid-draggable-header]="groupable || reorderable"
                    role="presentation"
                    [style.padding]="headerPadding">
                    <div *ngIf="isLocked"
                        #lockedHeader
                        role="presentation"
                        class="k-grid-header-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            kendoGridResizableTable
                            [locked]="true"
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                role="rowgroup"
                                [resizable]="resizable"
                                [scrollable]="true"
                                [columns]="$any(lockedColumns)"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [groups]="group"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                    </div>
                    <div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                        <table
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="nonLockedWidth"
                            kendoGridResizableTable
                            [virtualColumns]="virtualColumns"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="headerLeafColumns"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                [resizable]="resizable"
                                role="rowgroup"
                                [scrollable]="true"
                                [columns]="headerColumns"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [groups]="isLocked ? [] : group"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
                            <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                        </div>
                    </div>
                </div>
                <kendo-grid-list
                    [data]="$any(view)"
                    [rowHeight]="rowHeight"
                    [detailRowHeight]="detailRowHeight"
                    [total]="totalCount"
                    [take]="pageSize"
                    [groups]="group"
                    [groupable]="groupable"
                    [skip]="skip"
                    [trackBy]="trackBy"
                    [columns]="columnsContainer"
                    [selectable]="selectable"
                    [filterable]="filterable"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [size]="size"
                    (pageChange)="notifyPageChange('list', $event)"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [loading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
                    [loadingTemplate]="loadingTemplate?.templateRef"
                    [virtualColumns]="virtualColumns"
                    (scrollBottom)="notifyScrollBottom()"
                    (contentScroll)="contentScroll.emit($event)"
                    kendoDraggable
                    kendoGridSelectionMarquee
                    [enableDrag]="marqueeSelection"
                    [sort]="sort">
                </kendo-grid-list>
                <div
                    *ngIf="showFooter"
                    class="k-grid-footer"
                    [style.padding]="headerPadding">
                    <div
                        *ngIf="lockedLeafColumns.length"
                        class="k-grid-footer-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            kendoGridResizableTable
                            [locked]="true"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [scrollable]="true"
                                [groups]="group"
                                [columns]="$any(lockedLeafColumns)"
                                [detailTemplate]="detailTemplate"
                                [logicalRowIndex]="ariaRowCount"
                                [totalColumns]="columnsContainer"
                                [totalColumnsCount]="leafColumns.length">
                            </tfoot>
                        </table>
                    </div>
                    <div #footer
                        class="k-grid-footer-wrap" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 3">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            [style.width.px]="nonLockedWidth"
                            kendoGridTable
                            kendoGridResizableTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(headerLeafColumns)"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [logicalRowIndex]="ariaRowCount"
                                [scrollable]="true"
                                [groups]="isLocked ? [] : group"
                                [columns]="$any(headerColumns)"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [detailTemplate]="detailTemplate"
                                [totalColumns]="columnsContainer"
                                [totalColumnsCount]="leafColumns.length">
                            </tfoot>
                        </table>
                    </div>
                </div>
            </ng-container>
            <ng-container *ngIf="!isScrollable">
                <table
                    [style.table-layout]="resizable ? 'fixed' : null"
                    kendoGridTable
                    kendoGridResizableTable
                    role="presentation"
                    [size]="size">
                    <colgroup kendoGridColGroup
                        [columns]="$any(leafColumns)"
                        [groups]="group"
                        [sort]="sort"
                        [detailTemplate]="detailTemplate">
                    </colgroup>
                    <thead kendoGridHeader
                        *ngIf="!hideHeader"
                        class="k-grid-header"
                        [class.k-grid-draggable-header]="groupable || reorderable"
                        role="rowgroup"
                        [resizable]="resizable"
                        [scrollable]="false"
                        [columns]="$any(visibleColumns)"
                        [totalColumnLevels]="totalColumnLevels"
                        [totalColumns]="columnsContainer"
                        [groups]="group"
                        [groupable]="showGroupPanel"
                        [reorderable]="reorderable"
                        [sort]="sort"
                        [sortable]="sortable"
                        [filter]="filter"
                        [filterable]="filterable"
                        [columnMenu]="columnMenuOptions"
                        [columnMenuTemplate]="columnMenuTemplate"
                        [detailTemplate]="detailTemplate"
                        [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                    </thead>
                    <tbody kendoGridTableBody
                        [isLoading]="loading"
                        [groups]="group"
                        [data]="$any(view)"
                        [skip]="skip"
                        [columns]="$any(leafColumns)"
                        [selectable]="selectable"
                        [filterable]="filterable"
                        [noRecordsTemplate]="noRecordsTemplate"
                        [detailTemplate]="detailTemplate"
                        [showGroupFooters]="showGroupFooters"
                        [trackBy]="trackBy"
                        [rowClass]="rowClass"
                        kendoDraggable
                        kendoGridSelectionMarquee
                        [enableDrag]="marqueeSelection">
                    </tbody>
                    <tfoot kendoGridFooter
                        *ngIf="showFooter"
                        [scrollable]="false"
                        [logicalRowIndex]="ariaRowCount"
                        [groups]="group"
                        [columns]="$any(leafColumns)"
                        [detailTemplate]="detailTemplate"
                        [totalColumns]="columnsContainer"
                        [totalColumnsCount]="leafColumns.length">
                    </tfoot>
                </table>
            </ng-container>
            <div [loadingTemplate]="loadingTemplate" *ngIf="loading" kendoGridLoading></div>
        </div>
        <kendo-grid-status-bar
            *ngIf="showStatusBar"
            [statusBarTemplate]="statusBarTemplate">
        </kendo-grid-status-bar>
        <kendo-pager
            *ngIf="showBottomPager"
            #bottomPager
            class="k-grid-pager"
            [navigable]="navigation.pagerEnabled"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [responsive]="normalizedPageableSettings.responsive && !pagerTemplate"
            [buttonCount]="normalizedPageableSettings.buttonCount"
            [info]="normalizedPageableSettings.info"
            [pageSizeValues]="normalizedPageableSettings.pageSizes"
            [previousNext]="normalizedPageableSettings.previousNext"
            [type]="normalizedPageableSettings.type"
            (pageChange)="notifyPageChange('pager', $event)"
            (pagerInputVisibilityChange)="handlePagerVisibilityChange('showPagerInput', $event)"
            (pageTextVisibilityChange)="handlePagerVisibilityChange('showPagerPageText', $event)"
            (itemsTextVisibilityChange)="handlePagerVisibilityChange('showPagerItemsText', $event)">
            <ng-template kendoPagerTemplate>
                <ng-container
                    [ngTemplateOutlet]="pagerTemplate ? pagerTemplate?.templateRef : defaultPager"
                    [ngTemplateOutletContext]="bottomPager.templateContext"></ng-container>
            </ng-template>
            <kendo-pager-messages
                [ariaLabel]="messageFor('pagerLabel')"
                [firstPage]="messageFor('pagerFirstPage')"
                [inputLabel]="messageFor('pagerInputLabel')"
                [previousPage]="messageFor('pagerPreviousPage')"
                [nextPage]="messageFor('pagerNextPage')"
                [lastPage]="messageFor('pagerLastPage')"
                [selectPage]="messageFor('pagerSelectPage')"
                [page]="messageFor('pagerPage')"
                [itemsPerPage]="messageFor('pagerItemsPerPage')"
                [items]="messageFor('pagerItems')"
                [of]="messageFor('pagerOf')"
                [pageNumberInputTitle]="messageFor('pagerPageNumberInputTitle')">
            </kendo-pager-messages>
        </kendo-pager>
        <kendo-grid-toolbar
            class="k-grid-toolbar-bottom"
            *ngIf="showBottomToolbar"
            [size]="size"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-label]="messageFor('bottomToolbarLabel')"
            [attr.aria-controls]="ariaRootId"
            position="bottom">
        </kendo-grid-toolbar>

        <ng-template #defaultHint>
            <kendo-icon-wrapper
                [name]="getHintSettings('hintIcon')"
                [svgIcon]="getHintSettings('hintSVGIcon')"
                innerCssClass="k-drag-status">
            </kendo-icon-wrapper>
            {{hintText}}
        </ng-template>

        <ng-template #defaultPager>
            <div class="k-pager-numbers-wrap">
                <kendo-pager-prev-buttons [size]="size" *ngIf="normalizedPageableSettings.previousNext"></kendo-pager-prev-buttons>
                <kendo-pager-numeric-buttons
                    [size]="size"
                    *ngIf="normalizedPageableSettings.type === 'numeric' && normalizedPageableSettings.buttonCount > 0"
                    [buttonCount]="normalizedPageableSettings.buttonCount">
                </kendo-pager-numeric-buttons>
                <kendo-pager-input [size]="size" *ngIf="normalizedPageableSettings.type === 'input' || showPagerInput" [showPageText]="showPagerPageText"></kendo-pager-input>
                <kendo-pager-next-buttons [size]="size" *ngIf="normalizedPageableSettings.previousNext"></kendo-pager-next-buttons>
            </div>
            <kendo-pager-page-sizes *ngIf="normalizedPageableSettings.pageSizes"
                [size]="size"
                [pageSizes]="normalizedPageableSettings.pageSizes"
                [showItemsText]="showPagerItemsText">
            </kendo-pager-page-sizes>
            <kendo-pager-info *ngIf="normalizedPageableSettings.info">
            </kendo-pager-info>
        </ng-template>
        <div #dialogContainer></div>

        <kendo-grid-adaptive-renderer *ngIf="isAdaptiveModeEnabled"></kendo-grid-adaptive-renderer>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective3, NgIf, ToolbarComponent, GroupPanelComponent, TableDirective, GridTableDirective, ColGroupComponent, HeaderComponent2, ResizableContainerDirective, ListComponent, DragTargetContainerDirective, DropTargetContainerDirective, DraggableDirective, GridMarqueeDirective, FooterComponent2, TableBodyComponent, LoadingComponent, StatusBarComponent, IconWrapperComponent, WatermarkOverlayComponent, ...KENDO_PAGER, NgTemplateOutlet, AdaptiveRendererComponent]
    }]
  }], function() {
    return [{
      type: BrowserSupportService
    }, {
      type: SelectionService2
    }, {
      type: CellSelectionService
    }, {
      type: ElementRef
    }, {
      type: GroupInfoService
    }, {
      type: GroupsService
    }, {
      type: ChangeNotificationService
    }, {
      type: DetailsService
    }, {
      type: EditService
    }, {
      type: FilterService
    }, {
      type: PDFService
    }, {
      type: ResponsiveService
    }, {
      type: Renderer2
    }, {
      type: ExcelService
    }, {
      type: NgZone
    }, {
      type: ScrollSyncService2
    }, {
      type: DomEventsService
    }, {
      type: ColumnResizingService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ColumnReorderService
    }, {
      type: ColumnInfoService
    }, {
      type: NavigationService2
    }, {
      type: SortService
    }, {
      type: ScrollRequestService
    }, {
      type: LocalizationService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }, {
      type: AdaptiveService
    }, {
      type: AdaptiveGridService
    }, {
      type: RowReorderService
    }];
  }, {
    data: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    detailRowHeight: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    pageable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    gridResizable: [{
      type: Input
    }],
    rowReorderable: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    autoSize: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    rowSelected: [{
      type: Input
    }],
    isRowSelectable: [{
      type: Input
    }],
    cellSelected: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    hideHeader: [{
      type: Input
    }],
    showInactiveTools: [{
      type: Input
    }],
    isDetailExpanded: [{
      type: Input
    }],
    isGroupExpanded: [{
      type: Input
    }],
    filterChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    groupChange: [{
      type: Output
    }],
    sortChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    rowReorder: [{
      type: Output
    }],
    dataStateChange: [{
      type: Output
    }],
    gridStateChange: [{
      type: Output
    }],
    groupExpand: [{
      type: Output
    }],
    groupCollapse: [{
      type: Output
    }],
    detailExpand: [{
      type: Output
    }],
    detailCollapse: [{
      type: Output
    }],
    edit: [{
      type: Output
    }],
    cancel: [{
      type: Output
    }],
    save: [{
      type: Output
    }],
    remove: [{
      type: Output
    }],
    add: [{
      type: Output
    }],
    cellClose: [{
      type: Output
    }],
    cellClick: [{
      type: Output
    }],
    pdfExport: [{
      type: Output
    }],
    excelExport: [{
      type: Output
    }],
    columnResize: [{
      type: Output
    }],
    columnReorder: [{
      type: Output
    }],
    columnVisibilityChange: [{
      type: Output
    }],
    columnLockedChange: [{
      type: Output
    }],
    columnStickyChange: [{
      type: Output
    }],
    scrollBottom: [{
      type: Output
    }],
    contentScroll: [{
      type: Output
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-grid-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-grid-md"]
    }],
    lockedClasses: [{
      type: HostBinding,
      args: ["class.k-grid-lockedcolumns"]
    }],
    virtualClasses: [{
      type: HostBinding,
      args: ["class.k-grid-virtual"]
    }],
    noScrollbarClass: [{
      type: HostBinding,
      args: ["class.k-grid-no-scrollbar"]
    }],
    isResizable: [{
      type: HostBinding,
      args: ["class.k-grid-resizable"]
    }],
    minWidth: [{
      type: HostBinding,
      args: ["style.minWidth"]
    }],
    maxWidth: [{
      type: HostBinding,
      args: ["style.maxWidth"]
    }],
    minHeight: [{
      type: HostBinding,
      args: ["style.minHeight"]
    }],
    maxHeight: [{
      type: HostBinding,
      args: ["style.maxHeight"]
    }],
    detailTemplateChildren: [{
      type: ContentChildren,
      args: [DetailTemplateDirective]
    }],
    cellLoadingTemplateChildren: [{
      type: ContentChildren,
      args: [CellLoadingTemplateDirective]
    }],
    loadingTemplateChildren: [{
      type: ContentChildren,
      args: [LoadingTemplateDirective]
    }],
    statusBarTemplateChildren: [{
      type: ContentChildren,
      args: [StatusBarTemplateDirective]
    }],
    noRecordsTemplateChildren: [{
      type: ContentChildren,
      args: [NoRecordsTemplateDirective]
    }],
    pagerTemplateChildren: [{
      type: ContentChildren,
      args: [PagerTemplateDirective]
    }],
    toolbarTemplateChildren: [{
      type: ContentChildren,
      args: [ToolbarTemplateDirective]
    }],
    columnMenuTemplates: [{
      type: ContentChildren,
      args: [ColumnMenuTemplateDirective]
    }],
    lockedHeader: [{
      type: ViewChild,
      args: ["lockedHeader"]
    }],
    header: [{
      type: ViewChild,
      args: ["header"]
    }],
    footer: [{
      type: ViewChildren,
      args: ["footer"]
    }],
    ariaRoot: [{
      type: ViewChild,
      args: ["ariaRoot", {
        static: true
      }]
    }],
    dragTargetContainer: [{
      type: ViewChild,
      args: [DragTargetContainerDirective]
    }],
    dropTargetContainer: [{
      type: ViewChild,
      args: [DropTargetContainerDirective]
    }],
    dialogContainer: [{
      type: ViewChild,
      args: ["dialogContainer", {
        read: ViewContainerRef
      }]
    }],
    adaptiveRenderer: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent]
    }]
  });
})();
var CustomMessagesComponent2 = class _CustomMessagesComponent extends GridMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(t) {
    return new (t || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-grid-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: GridMessages,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: GridMessages,
        useExisting: forwardRef(() => CustomMessagesComponent2)
      }],
      selector: "kendo-grid-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DataBindingDirective = class _DataBindingDirective {
  grid;
  changeDetector;
  localDataChangesService;
  rowReorderService;
  /**
   * Defines the number of records that will be skipped by the pager.
   * @default 0
   */
  set skip(value) {
    if (!isPresent4(value)) {
      value = 0;
    }
    this.grid.skip = this.state.skip = value;
    if (this.rowReorderService) {
      this.rowReorderService.skip = value;
    }
  }
  /**
   * Defines the descriptors by which the data will be sorted.
   */
  set sort(value) {
    this.grid.sort = this.state.sort = value;
  }
  /**
   * Defines the descriptor by which the data will be filtered.
   */
  set filter(value) {
    this.grid.filter = this.state.filter = value;
  }
  /**
   * Defines the page size used by the Grid pager.
   */
  set pageSize(value) {
    this.grid.pageSize = this.state.take = value;
  }
  /**
   * The descriptors by which the data will be grouped.
   */
  set group(value) {
    this.grid.group = this.state.group = value;
  }
  /**
   * The array of data which will be used to populate the Grid.
   */
  set data(value) {
    this.originalData = value || [];
    if (this.localDataChangesService) {
      this.localDataChangesService.data = value;
    }
    this.dataChanged = true;
  }
  state = {
    skip: 0
  };
  originalData = [];
  dataChanged;
  stateChangeSubscription;
  dataChangedSubscription;
  rowReorderSubscription;
  constructor(grid, changeDetector, localDataChangesService, rowReorderService) {
    this.grid = grid;
    this.changeDetector = changeDetector;
    this.localDataChangesService = localDataChangesService;
    this.rowReorderService = rowReorderService;
    if (localDataChangesService) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
    }
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.applyState(this.state);
    this.stateChangeSubscription = this.grid.dataStateChange.subscribe(this.onStateChange.bind(this));
    if (this.rowReorderService) {
      this.rowReorderSubscription = this.grid.rowReorder.subscribe(this.onRowReorder.bind(this));
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.stateChangeSubscription) {
      this.stateChangeSubscription.unsubscribe();
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(["pageSize", "skip", "sort", "group", "filter"], changes)) {
      this.rebind();
    }
  }
  ngDoCheck() {
    if (this.dataChanged) {
      this.updateGridData();
    }
  }
  /**
   * @hidden
   */
  onStateChange(state2) {
    this.applyState(state2);
    this.rebind();
  }
  /**
   * @hidden
   */
  onRowReorder(ev) {
    this.rowReorderService.reorderRows(ev, this.originalData);
    this.rebind();
  }
  /**
   * @hidden
   */
  rebind() {
    this.data = this.originalData;
    this.updateGridData();
    this.notifyDataChange();
  }
  /**
   * Notifies the Grid that its data has changed.
   */
  notifyDataChange() {
    this.grid.onDataChange();
    if (this.changeDetector) {
      this.changeDetector.markForCheck();
    }
  }
  process(state2) {
    return process(this.originalData, state2);
  }
  applyState({
    skip: skip3,
    take: take2,
    sort,
    group,
    filter: filter3
  }) {
    this.skip = skip3;
    this.pageSize = take2;
    this.sort = sort;
    this.group = group;
    this.filter = filter3;
  }
  updateGridData() {
    this.grid.data = this.process(this.state);
    this.grid.updateNavigationMetadata();
    this.dataChanged = false;
  }
  static ɵfac = function DataBindingDirective_Factory(t) {
    return new (t || _DataBindingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(RowReorderService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DataBindingDirective,
    selectors: [["", "kendoGridBinding", ""]],
    inputs: {
      skip: "skip",
      sort: "sort",
      filter: "filter",
      pageSize: "pageSize",
      group: "group",
      data: [InputFlags.None, "kendoGridBinding", "data"]
    },
    exportAs: ["kendoGridBinding"],
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridBinding]",
      exportAs: "kendoGridBinding",
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalDataChangesService
    }, {
      type: RowReorderService
    }];
  }, {
    skip: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    data: [{
      type: Input,
      args: ["kendoGridBinding"]
    }]
  });
})();
var SelectionDirective = class _SelectionDirective extends Selection {
  ctx;
  constructor(ctx, cd) {
    super(ctx, cd);
    this.ctx = ctx;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.ctx.grid.selectable === false) {
      this.ctx.grid.selectable = true;
    }
    this.ctx.grid.selectionDirective = this;
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    super.destroy();
  }
  static ɵfac = function SelectionDirective_Factory(t) {
    return new (t || _SelectionDirective)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectionDirective,
    selectors: [["", "kendoGridSelectBy", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectBy]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var LocalEditService = class {
  grid;
  localDataChangesService;
  constructor(grid, localDataChangesService) {
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  create(item) {
    if (this.hasLocalData && this.grid.skip) {
      this.localDataChangesService.data.splice(this.grid.skip, 0, item);
    } else {
      this.data.unshift(item);
    }
    this.dataChanged();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  update(_item) {
  }
  remove(item) {
    const data = this.data;
    for (let idx2 = 0; idx2 < data.length; idx2++) {
      if (item === data[idx2]) {
        data.splice(idx2, 1);
        this.dataChanged({
          action: "remove",
          item
        });
        break;
      }
    }
  }
  assignValues(target, source) {
    Object.assign(target, source);
  }
  dataChanged(args = {}) {
    if (this.hasLocalData) {
      this.localDataChangesService.changes.emit(args);
    }
  }
  get hasLocalData() {
    return Array.isArray(this.localDataChangesService.data);
  }
  get data() {
    if (this.hasLocalData) {
      return this.localDataChangesService.data;
    }
    const data = this.grid.data;
    if (Array.isArray(data)) {
      return data;
    }
    if (isDevMode()) {
      throw new Error(GridConfigurationErrorMessages.requiredEditService);
    }
    return [];
  }
};
var EditingDirectiveBase = class _EditingDirectiveBase {
  grid;
  localDataChangesService;
  // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.
  // The Input should still be kept.
  /**
   * The edit service that will handle the operations.
   */
  set editService(value) {
    this.userEditService = value;
  }
  get editService() {
    return this.userEditService || this.defaultEditService;
  }
  removeConfirmationSubject = new Subject();
  dialogService;
  localization;
  defaultRemoveConfirmation = (_item) => {
    const dialog = this.dialogService.open({
      appendTo: this.grid.dialogContainer,
      title: this.localization.get("removeConfirmationDialogTitle"),
      content: this.localization.get("removeConfirmationDialogContent"),
      actions: [{
        text: this.localization.get("removeConfirmationDialogConfirmText"),
        themeColor: "primary",
        svgIcon: checkIcon,
        icon: "check"
      }, {
        text: this.localization.get("removeConfirmationDialogRejectText"),
        svgIcon: xIcon,
        icon: "x"
      }]
    });
    dialog.result.pipe(take(1)).subscribe((e) => this.removeConfirmationSubject.next(e.text === this.localization.get("removeConfirmationDialogConfirmText")));
    return this.removeConfirmationSubject;
  };
  /**
   * A function that is called to confirm if the `dataItem` will be removed.
   * By default, the Grid displays its built-in confirmation dialog. To use a custom dialog, provide a `RemoveConfirmationCallback` function.
   * To prevent showing a confirmation dialog, set the `removeConfirmation` property to `false`.
   *
   * @default true
   */
  removeConfirmation = true;
  subscriptions = new Subscription();
  defaultEditService;
  userEditService;
  constructor(grid, localDataChangesService) {
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.defaultEditService = this.createDefaultService();
    this.dialogService = inject(DialogService);
    this.localization = inject(LocalizationService);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions.add(this.grid.add.subscribe(this.addHandler.bind(this)));
    this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));
    this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));
    this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));
    this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  createDefaultService() {
    return new LocalEditService(this.grid, this.localDataChangesService);
  }
  addHandler(_args) {
    this.grid.addRow(this.createModel({
      isNew: true
    }));
  }
  saveHandler(args) {
    const item = this.saveModel(args);
    if (item) {
      if (args.isNew) {
        this.editService.create(item);
      } else {
        this.editService.update(item);
      }
    }
    this.grid.closeRow(args.rowIndex);
  }
  cancelHandler({
    rowIndex
  }) {
    this.closeEditor(rowIndex);
  }
  removeHandler({
    dataItem
  }) {
    const removeItem = (shouldRemove) => {
      if (shouldRemove) {
        this.editService.remove(dataItem);
      }
    };
    if (this.removeConfirmation) {
      const confirmationCallback = typeof this.removeConfirmation === "boolean" ? this.defaultRemoveConfirmation : this.removeConfirmation;
      const result = confirmationCallback(dataItem);
      if (result instanceof Promise) {
        result.then(removeItem);
      } else if (result instanceof Observable) {
        result.pipe(take(1)).subscribe(removeItem);
      } else {
        removeItem(result);
      }
    } else {
      removeItem(true);
    }
  }
  onStateChange() {
    this.closeEditor();
  }
  closeEditor(rowIndex) {
    this.grid.closeRow(rowIndex);
  }
  static ɵfac = function EditingDirectiveBase_Factory(t) {
    return new (t || _EditingDirectiveBase)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditingDirectiveBase,
    selectors: [["", "kendoGridEditingDirectiveBase", ""]],
    inputs: {
      editService: "editService",
      removeConfirmation: "removeConfirmation"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditingDirectiveBase, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditingDirectiveBase]"
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }];
  }, {
    editService: [{
      type: Input
    }],
    removeConfirmation: [{
      type: Input
    }]
  });
})();
var LocalRowEditService = class extends LocalEditService {
  update() {
    this.dataChanged();
  }
};
var RowEditingDirectiveBase = class _RowEditingDirectiveBase extends EditingDirectiveBase {
  rowIndex;
  /**
   * @hidden
   */
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.edit.subscribe(this.editHandler.bind(this)));
  }
  createDefaultService() {
    return new LocalRowEditService(this.grid, this.localDataChangesService);
  }
  addHandler() {
    this.closeEditor();
    super.addHandler();
  }
  editHandler(args) {
    this.closeEditor();
    this.rowIndex = args.rowIndex;
    this.grid.editRow(args.rowIndex, this.createModel(args));
  }
  saveHandler(args) {
    super.saveHandler(args);
    this.clean();
  }
  closeEditor(rowIndex = this.rowIndex) {
    super.closeEditor(rowIndex);
    this.clean();
  }
  clean() {
    delete this.rowIndex;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRowEditingDirectiveBase_BaseFactory;
    return function RowEditingDirectiveBase_Factory(t) {
      return (ɵRowEditingDirectiveBase_BaseFactory || (ɵRowEditingDirectiveBase_BaseFactory = ɵɵgetInheritedFactory(_RowEditingDirectiveBase)))(t || _RowEditingDirectiveBase);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RowEditingDirectiveBase,
    selectors: [["", "kendoGridRowEditingDirectiveBase", ""]],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowEditingDirectiveBase, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRowEditingDirectiveBase]"
    }]
  }], null, null);
})();
var TemplateEditingDirective = class _TemplateEditingDirective extends RowEditingDirectiveBase {
  grid;
  localDataChangesService;
  /**
   * The function that creates the `dataItem` for the new rows.
   */
  createNewItem;
  dataItem;
  originalValues;
  constructor(grid, localDataChangesService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  editHandler(args) {
    super.editHandler(args);
    this.dataItem = args.dataItem;
    this.originalValues = {};
    this.editService.assignValues(this.originalValues, this.dataItem);
  }
  closeEditor(rowIndex) {
    if (this.dataItem) {
      this.editService.assignValues(this.dataItem, this.originalValues);
    }
    super.closeEditor(rowIndex);
  }
  createModel(args) {
    if (args.isNew) {
      return this.createNewItem();
    }
  }
  saveModel(args) {
    return args.dataItem;
  }
  clean() {
    super.clean();
    delete this.dataItem;
  }
  static ɵfac = function TemplateEditingDirective_Factory(t) {
    return new (t || _TemplateEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TemplateEditingDirective,
    selectors: [["", "kendoGridTemplateEditing", ""]],
    inputs: {
      createNewItem: [InputFlags.None, "kendoGridTemplateEditing", "createNewItem"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplateEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridTemplateEditing]",
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }];
  }, {
    createNewItem: [{
      type: Input,
      args: ["kendoGridTemplateEditing"]
    }]
  });
})();
var markAllAsTouched = (control) => {
  control.markAsTouched();
  if (control.hasOwnProperty("controls")) {
    const controls = control.controls;
    for (const inner in controls) {
      if (controls.hasOwnProperty(inner)) {
        markAllAsTouched(controls[inner]);
      }
    }
  }
};
var ReactiveEditingDirective = class _ReactiveEditingDirective extends RowEditingDirectiveBase {
  grid;
  localDataChangesService;
  /**
   * The function that creates the `FormGroup` for the edited model.
   */
  createFormGroup;
  constructor(grid, localDataChangesService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  createModel(args) {
    return this.createFormGroup(args);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      this.editService.assignValues(dataItem, formGroup.value);
      return dataItem;
    }
    markAllAsTouched(formGroup);
  }
  static ɵfac = function ReactiveEditingDirective_Factory(t) {
    return new (t || _ReactiveEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ReactiveEditingDirective,
    selectors: [["", "kendoGridReactiveEditing", ""]],
    inputs: {
      createFormGroup: [InputFlags.None, "kendoGridReactiveEditing", "createFormGroup"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridReactiveEditing]",
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }];
  }, {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridReactiveEditing"]
    }]
  });
})();
var InCellEditingDirective = class _InCellEditingDirective extends EditingDirectiveBase {
  grid;
  localDataChangesService;
  cdr;
  /**
   * The function that creates the `FormGroup` for the edited model.
   */
  createFormGroup;
  constructor(grid, localDataChangesService, cdr) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.cdr = cdr;
  }
  // Need mixin
  createModel(args) {
    return this.createFormGroup(args);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      this.editService.assignValues(dataItem, formGroup.value);
      return dataItem;
    }
    markAllAsTouched(formGroup);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));
    this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));
  }
  removeHandler(args) {
    super.removeHandler(args);
    this.grid.cancelCell();
  }
  cellClickHandler(args) {
    if (!args.isEdited && args.type !== "contextmenu") {
      this.grid.editCell(args.rowIndex, args.columnIndex, this.createFormGroup(args));
      this.cdr.markForCheck();
    }
  }
  cellCloseHandler(args) {
    const {
      formGroup,
      dataItem
    } = args;
    if (!formGroup.valid) {
      args.preventDefault();
    } else if (formGroup.dirty) {
      if (args.originalEvent && args.originalEvent.keyCode === Keys.Escape) {
        return;
      }
      this.editService.assignValues(dataItem, formGroup.value);
      this.editService.update(dataItem);
    }
  }
  static ɵfac = function InCellEditingDirective_Factory(t) {
    return new (t || _InCellEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _InCellEditingDirective,
    selectors: [["", "kendoGridInCellEditing", ""]],
    inputs: {
      createFormGroup: [InputFlags.None, "kendoGridInCellEditing", "createFormGroup"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InCellEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridInCellEditing]",
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridInCellEditing"]
    }]
  });
})();
var ExternalEditingDirective = class _ExternalEditingDirective extends EditingDirectiveBase {
  grid;
  localDataChangesService;
  adaptiveGridService;
  /**
   * The function that creates the `FormGroup` for the edited model.
   */
  createFormGroup;
  /**
   * Allows you to customize form orientation, hints, labels and error messages.
   */
  formSettings;
  /**
   * Allows you to customize the Dialog that contains the edit form.
   */
  dialogSettings;
  constructor(grid, localDataChangesService, adaptiveGridService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.edit.subscribe(this.editHandler.bind(this)));
  }
  /**
   * @hidden
   * Opens a Dialog that contains the edit form.
   */
  openEditFormDialog(editEventArgs, formGroup, formSettings) {
    const formControls = this.normalizeFormSettings(formGroup, editEventArgs);
    if (this.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "externalEditing";
        this.grid.adaptiveRenderer.externalEditingSettings = {
          formControls,
          formGroup,
          formSettings,
          event: editEventArgs,
          externalEditingDirective: this
        };
        this.grid.adaptiveRenderer.actionSheet.toggle(true);
      }
    } else {
      const settings = __spreadValues({
        appendTo: this.grid.dialogContainer,
        content: DialogFormComponent,
        title: this.localization.get("externalEditingTitle")
      }, this.dialogSettings);
      const dialog = this.dialogService.open(settings);
      this.adaptiveGridService.popupRef = dialog;
      dialog.content.setInput("controls", formControls);
      formSettings && dialog.content.setInput("formSettings", formSettings);
      dialog.content.setInput("formGroup", formGroup);
      dialog.result.subscribe((r) => {
        const resultType = r["text"];
        if (resultType === this.localization.get("externalEditingSaveText")) {
          this.saveHandler(__spreadProps(__spreadValues({}, editEventArgs), {
            formGroup
          }));
        }
        dialog.close();
      });
    }
  }
  createModel(args) {
    return this.createFormGroup(args);
  }
  editHandler(args) {
    const formGroup = this.createModel(args);
    this.openEditFormDialog(args, formGroup, this.formSettings);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      const item = dataItem || [];
      this.editService.assignValues(item, formGroup.value);
      return item;
    }
    markAllAsTouched(formGroup);
  }
  addHandler(args) {
    const formGroup = this.createModel(args);
    this.openEditFormDialog(args, formGroup, this.formSettings);
  }
  normalizeFormSettings(args, editEventArgs) {
    const editableColumnFields = this.grid.columns.toArray().filter((c) => c.field && c.editable && isPresent(args.get(c.field))).map((c) => c.field);
    const settings = editableColumnFields.map((k) => {
      const column = this.grid.columns.toArray().find((c) => c.field === k);
      const title = column.title || k;
      const template = column.editTemplateRef;
      const templateContext = template ? {
        $implicit: args,
        isNew: editEventArgs.isNew,
        column,
        dataItem: editEventArgs.dataItem,
        formGroup: args,
        rowIndex: editEventArgs.rowIndex
      } : null;
      const customSettings = this.formSettings?.fields?.[k];
      return {
        name: k,
        label: customSettings?.label || title,
        hint: customSettings?.hint,
        errors: customSettings?.errors,
        formControl: args.get(k),
        dataType: column.editor,
        orientation: this.formSettings?.orientation || "vertical",
        template,
        templateContext
      };
    });
    return settings.filter((item) => isPresent(item));
  }
  static ɵfac = function ExternalEditingDirective_Factory(t) {
    return new (t || _ExternalEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExternalEditingDirective,
    selectors: [["", "kendoGridExternalEditing", ""]],
    inputs: {
      createFormGroup: [InputFlags.None, "kendoGridExternalEditing", "createFormGroup"],
      formSettings: "formSettings",
      dialogSettings: "dialogSettings"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExternalEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExternalEditing]",
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }, {
      type: AdaptiveGridService
    }];
  }, {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridExternalEditing"]
    }],
    formSettings: [{
      type: Input
    }],
    dialogSettings: [{
      type: Input
    }]
  });
})();
var ExpandDetailsDirective = class _ExpandDetailsDirective {
  grid;
  /**
   * Fires when the expandedDetailKeys are changed.
   */
  expandedDetailKeysChange = new EventEmitter();
  /**
   * Defines the item key that will be stored in the `expandedDetailKeys` collection ([see example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).
   */
  get expandDetailsKey() {
    return this._expandBy;
  }
  set expandDetailsKey(key) {
    if (isString(key)) {
      this._expandBy = getter(key);
    } else {
      this._expandBy = key;
    }
  }
  /**
   *
   * @hidden
   * A deprecated alias for setting the `expandDetailsKey` property.
   */
  get expandDetailBy() {
    return this.expandDetailsKey;
  }
  set expandDetailBy(key) {
    this.expandDetailsKey = key;
  }
  /**
   * Defines the collection that will store the expanded keys.
   */
  expandedDetailKeys = [];
  /**
   * Specifies if the items should be initially expanded.
   * When set to `true` items added to the `expandedDetailKeys` collection will be collapsed, and items that are not present in it will be expanded.
   *
   * @default false
   */
  initiallyExpanded = false;
  expandedState = /* @__PURE__ */ new Set();
  lastExpandedState;
  _expandBy;
  subscriptions = new Subscription();
  constructor(grid) {
    this.grid = grid;
    this.grid.isDetailExpanded = this.isExpanded.bind(this);
    this.subscriptions.add(merge(this.grid.detailExpand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.grid.detailCollapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleState.bind(this)));
  }
  ngOnChanges(changes) {
    if (isPresent4(changes["expandedDetailKeys"]) && this.lastExpandedState !== this.expandedDetailKeys) {
      this.expandedState = new Set(this.expandedDetailKeys);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get keyGetter() {
    return this._expandBy || getter(void 0);
  }
  /**
   * @hidden
   */
  isExpanded(args) {
    const key = this.keyGetter(args.dataItem);
    const hasKey = this.expandedState.has(key);
    return this.initiallyExpanded ? !hasKey : hasKey;
  }
  toggleState(args) {
    const key = this.keyGetter(args.dataItem);
    if (Boolean(this.initiallyExpanded) !== args.expand) {
      this.expandedState.add(key);
    } else {
      this.expandedState.delete(key);
    }
    this.notifyChange();
  }
  notifyChange() {
    this.lastExpandedState = Array.from(this.expandedState);
    this.expandedDetailKeysChange.emit(this.lastExpandedState);
  }
  static ɵfac = function ExpandDetailsDirective_Factory(t) {
    return new (t || _ExpandDetailsDirective)(ɵɵdirectiveInject(GridComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExpandDetailsDirective,
    selectors: [["", "kendoGridExpandDetailsBy", ""]],
    inputs: {
      expandDetailsKey: [InputFlags.None, "kendoGridExpandDetailsBy", "expandDetailsKey"],
      expandDetailBy: "expandDetailBy",
      expandedDetailKeys: "expandedDetailKeys",
      initiallyExpanded: "initiallyExpanded"
    },
    outputs: {
      expandedDetailKeysChange: "expandedDetailKeysChange"
    },
    exportAs: ["kendoGridExpandDetailsBy"],
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandDetailsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExpandDetailsBy]",
      exportAs: "kendoGridExpandDetailsBy",
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }];
  }, {
    expandedDetailKeysChange: [{
      type: Output
    }],
    expandDetailsKey: [{
      type: Input,
      args: ["kendoGridExpandDetailsBy"]
    }],
    expandDetailBy: [{
      type: Input
    }],
    expandedDetailKeys: [{
      type: Input
    }],
    initiallyExpanded: [{
      type: Input
    }]
  });
})();
var mapParentGroup = (parentGroup) => {
  const parentGroupKeys = [];
  while (parentGroup) {
    parentGroupKeys.push({
      field: parentGroup.group.field,
      value: parentGroup.group.value
    });
    parentGroup = parentGroup.parentGroup;
  }
  return parentGroupKeys;
};
var DEFAULT_KEY_GETTER = (groupRowArgs) => ({
  field: groupRowArgs.group.field,
  value: groupRowArgs.group.value,
  parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)
});
var ExpandGroupDirective = class _ExpandGroupDirective {
  grid;
  /**
   * Fires when the expandedGroupKeys are changed.
   */
  expandedGroupKeysChange = new EventEmitter();
  /**
   * Defines the item format that will be stored in the `expandedGroupKeys`
   * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).
   */
  get expandGroupBy() {
    return this._expandGroupBy;
  }
  set expandGroupBy(key) {
    if (typeof key === "function") {
      this._expandGroupBy = key;
    }
  }
  /**
   * Defines the collection that will store the expanded group keys.
   */
  get expandedGroupKeys() {
    return this._expandedGroupKeys;
  }
  set expandedGroupKeys(expandedGroups) {
    this._expandedGroupKeys = (expandedGroups || []).slice();
  }
  /**
   * Specifies if the group items should be initially expanded.
   * @default false
   */
  groupsInitiallyExpanded = false;
  _expandGroupBy;
  _expandedGroupKeys;
  subscriptions = new Subscription();
  constructor(grid) {
    this.grid = grid;
    this.grid.isGroupExpanded = this.isExpanded.bind(this);
    this.subscriptions.add(merge(this.grid.groupExpand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.grid.groupCollapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleState.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get keyGetter() {
    return this.expandGroupBy || DEFAULT_KEY_GETTER;
  }
  /**
   * @hidden
   */
  isExpanded(groupArgs) {
    const itemIndex = this.getItemIndex(groupArgs);
    return itemIndex > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;
  }
  getItemIndex(groupArgs) {
    if (this.expandGroupBy) {
      return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));
    }
    return this.expandedGroupKeys.findIndex((item) => {
      let index = 0;
      let parentGroup = groupArgs.parentGroup;
      while (isPresent4(parentGroup)) {
        if (!isPresent4(item.parentGroupKeys) || !isPresent4(item.parentGroupKeys[index]) || parentGroup.group.value !== item.parentGroupKeys[index].value || parentGroup.group.field !== item.parentGroupKeys[index].field) {
          return false;
        }
        parentGroup = parentGroup.parentGroup;
        index++;
      }
      return item.value === groupArgs.group.value && item.field === groupArgs.group.field;
    });
  }
  toggleState(groupArgs) {
    const key = this.keyGetter(groupArgs);
    if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {
      this.expandedGroupKeys.push(key);
    } else {
      const index = this.expandedGroupKeys.findIndex((group) => {
        if (this.expandGroupBy) {
          return group === key;
        } else if (key.parentGroupKeys?.length === 0) {
          return group.value === key.value;
        }
        return JSON.stringify(group) === JSON.stringify(key);
      });
      this.expandedGroupKeys.splice(index, 1);
    }
    this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());
  }
  static ɵfac = function ExpandGroupDirective_Factory(t) {
    return new (t || _ExpandGroupDirective)(ɵɵdirectiveInject(GridComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExpandGroupDirective,
    selectors: [["", "kendoGridExpandGroupBy", ""]],
    inputs: {
      expandGroupBy: [InputFlags.None, "kendoGridExpandGroupBy", "expandGroupBy"],
      expandedGroupKeys: "expandedGroupKeys",
      groupsInitiallyExpanded: "groupsInitiallyExpanded"
    },
    outputs: {
      expandedGroupKeysChange: "expandedGroupKeysChange"
    },
    exportAs: ["kendoGridExpandGroupBy"],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExpandGroupBy]",
      exportAs: "kendoGridExpandGroupBy",
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }];
  }, {
    expandedGroupKeysChange: [{
      type: Output
    }],
    expandGroupBy: [{
      type: Input,
      args: ["kendoGridExpandGroupBy"]
    }],
    expandedGroupKeys: [{
      type: Input
    }],
    groupsInitiallyExpanded: [{
      type: Input
    }]
  });
})();
var hasGroups = (items) => items && items.length && items[0].field && items[0].items;
var groupDescriptorsPresent = (descriptors) => isPresent4(descriptors) && descriptors.length > 0;
var processGroups = (data, state2) => process(data, state2).data;
var removeParentDescriptors = (parents, owner) => (g) => g.field !== owner.field && !parents.some((y) => y.field === g.field);
var findGroup = (groupIndex, groups) => {
  const parents = [];
  return {
    group: groupIndex.split("_").reduce((acc, x) => {
      const idx2 = parseInt(x, 10);
      if (acc.items) {
        parents.push(acc);
        return acc.items[idx2];
      }
      return isArray(acc) ? acc[idx2] : acc;
    }, groups),
    parents
  };
};
var findChildren = (data, parents) => {
  const filters = parents.map((p) => ({
    field: p.field,
    operator: "eq",
    value: p.value
  }));
  return filterBy(data, {
    filters,
    logic: "and"
  });
};
var count = (groups, includeFooters = false) => groups.reduce((acc, group) => {
  if (!group.skipHeader) {
    acc++;
  }
  if (group.items) {
    const children2 = count(group.items, includeFooters);
    if (includeFooters && children2 && !group.hideFooter) {
      acc++;
    }
    acc += children2;
  }
  return acc;
}, 0);
var noDescriptors = (descriptors) => !isPresent4(descriptors) || !descriptors.length;
var slice = (groups, skip3, take2, includeFooters = false) => {
  if (!isPresent4(take2)) {
    return groups;
  }
  const result = [];
  for (let idx2 = 0, length2 = groups.length; idx2 < length2; idx2++) {
    if (take2 <= 0) {
      break;
    }
    const group = groups[idx2];
    const groupItems = group.items;
    let itemCount = count(groupItems, includeFooters);
    if (includeFooters && groupItems.length) {
      itemCount++;
    }
    const skipHeader = skip3 > 0;
    if (skip3) {
      skip3--;
      if (itemCount && skip3 >= itemCount) {
        skip3 -= itemCount;
        continue;
      }
    }
    if (!skipHeader || itemCount) {
      const items = [];
      let hideFooter = true;
      if (!skipHeader) {
        take2--;
      }
      if (take2) {
        if (hasGroups(groupItems)) {
          const children2 = slice(groupItems, skip3, take2, includeFooters);
          items.push(...children2);
          take2 -= count(children2, includeFooters);
        } else {
          items.push(...groupItems.slice(skip3, Math.min(skip3 + take2, groupItems.length)));
          take2 -= items.length;
        }
        if (take2 && includeFooters) {
          hideFooter = false;
          take2--;
        }
        skip3 = 0;
      }
      result.push({
        aggregates: group.aggregates,
        field: group.field,
        hideFooter,
        items,
        offset: idx2,
        skipHeader,
        value: group.value
      });
    }
  }
  return result;
};
var skippedHeaders = (groupItem) => {
  let total = 0;
  while (groupItem) {
    if (groupItem.skipHeader) {
      total++;
    }
    groupItem = groupItem.items && groupItem.items[0] || null;
  }
  return total;
};
var GroupBindingDirective = class _GroupBindingDirective extends DataBindingDirective {
  groupsService;
  /**
   * The array of data which will be used to populate the Grid.
   */
  set kendoGridGroupBinding(value) {
    this.groups = null;
    this.grid.resetGroupsState();
    this.data = value;
  }
  /**
   * @hidden
   */
  set data(value) {
    this.originalData = value || [];
    this.dataChanged = true;
  }
  /**
   * Defines the descriptors by which the data will be sorted.
   */
  set sort(value) {
    const noCurrentDescriptors = noDescriptors(this.state.sort);
    const noIncomingDescriptors = noDescriptors(value);
    const clear = this.state.sort !== value && !(noCurrentDescriptors && noIncomingDescriptors);
    this.grid.sort = this.state.sort = value;
    if (clear) {
      this.groups = null;
      this.grid.resetGroupsState();
    }
  }
  /**
   * Defines the descriptor by which the data will be filtered.
   */
  set filter(value) {
    const clear = diffFilters(this.state.filter, value);
    if (clear) {
      this.state.filter = value;
      this.grid.filter = cloneFilters(value);
      this.groups = null;
      this.grid.resetGroupsState();
    }
  }
  /**
   * Defines the descriptors by which the data will be grouped.
   */
  set group(value) {
    const groupsPresent = groupDescriptorsPresent(this.state.group) || groupDescriptorsPresent(value);
    const clear = this.state.group !== value && groupsPresent;
    this.grid.group = this.state.group = value;
    if (clear) {
      this.groups = null;
      this.grid.resetGroupsState();
      this.skip = 0;
    }
  }
  groups;
  gridSubs = new Subscription();
  constructor(changeDetector, localDataChangesService, ctxService, groupsService) {
    super(ctxService.grid, changeDetector, localDataChangesService);
    this.groupsService = groupsService;
    ctxService.groupBindingDirective = this;
  }
  ngOnInit() {
    super.ngOnInit();
    this.gridSubs.add(this.grid.groupExpand.subscribe(this.groupExpand.bind(this)));
    this.gridSubs.add(this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this)));
  }
  ngAfterContentInit() {
    if (isDevMode() && this.grid.isGroupExpanded) {
      throw new Error(GridConfigurationErrorMessages.groupBindingDirectives);
    }
  }
  ngOnDestroy() {
    this.gridSubs.unsubscribe();
  }
  /**
   * @hidden
   */
  toggleAll(expand) {
    this.skip = 0;
    this.grid.scrollTo({
      row: 0,
      column: 0
    });
    this.groups.forEach((gr, idx2) => {
      const expanded = this.groupsService.isExpanded({
        group: gr,
        groupIndex: idx2.toString(),
        parentGroup: void 0
      });
      const performToggle = expand && !expanded || !expand && expanded;
      if (performToggle) {
        this.grid.groupsService.toggleRow({
          type: "group",
          data: gr,
          index: idx2.toString(),
          level: 0,
          parentGroup: void 0
        });
        this[expand ? "groupExpand" : "groupCollapse"]({
          groupIndex: idx2.toString()
        });
      }
    });
  }
  /**
   * Collapses all expanded root level groups.
   */
  collapseAll() {
    this.toggleAll(false);
  }
  /**
   * Expands all expanded root level groups.
   */
  expandAll() {
    this.toggleAll(true);
  }
  /**
   * @hidden
   */
  groupExpand({
    groupIndex
  }) {
    const {
      group,
      parents
    } = findGroup(groupIndex, this.groups);
    if (!group) {
      return;
    }
    this.groupsService.expandChildren(groupIndex);
    if (!group.items.length) {
      const descriptors = this.state.group.filter(removeParentDescriptors(parents, group));
      const children2 = findChildren(this.originalData, parents.concat(group));
      group.items = processGroups(children2, {
        filter: this.state.filter,
        group: descriptors,
        sort: this.state.sort
      });
    }
    this.grid.data = this.dataResult(this.state.skip, this.state.take);
  }
  /**
   * @hidden
   */
  groupCollapse({
    groupIndex
  }) {
    const {
      group
    } = findGroup(groupIndex, this.groups);
    if (group) {
      group.items = [];
    } else {
      return;
    }
    this.grid.data = this.dataResult(this.state.skip, this.state.take);
  }
  process(state2) {
    if (state2.group && state2.group.length) {
      const groups = this.processGroups(state2);
      this.grid.skip -= skippedHeaders(groups.data[0]);
      return groups;
    } else {
      this.groups = null;
    }
    return super.process(state2);
  }
  processGroups(state2) {
    if (!this.groups || !this.groups.length) {
      this.groups = processGroups(this.originalData, {
        filter: state2.filter,
        group: state2.group,
        sort: state2.sort
      });
    }
    return this.dataResult(state2.skip, state2.take);
  }
  dataResult(skip3, take2) {
    const includeFooters = this.grid.showGroupFooters;
    return {
      data: slice(this.groups, skip3, take2, includeFooters),
      total: count(this.groups, includeFooters)
    };
  }
  applyState({
    skip: skip3,
    take: take2,
    sort,
    group,
    filter: filter3
  }) {
    this.skip = skip3;
    this.state.take = take2;
    this.sort = sort;
    this.group = group;
    this.filter = filter3;
  }
  static ɵfac = function GroupBindingDirective_Factory(t) {
    return new (t || _GroupBindingDirective)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(GroupsService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupBindingDirective,
    selectors: [["", "kendoGridGroupBinding", ""]],
    inputs: {
      kendoGridGroupBinding: "kendoGridGroupBinding",
      sort: "sort",
      filter: "filter",
      group: "group"
    },
    exportAs: ["kendoGridGroupBinding"],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupBinding]",
      exportAs: "kendoGridGroupBinding",
      standalone: true
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: LocalDataChangesService
    }, {
      type: ContextService
    }, {
      type: GroupsService
    }];
  }, {
    kendoGridGroupBinding: [{
      type: Input,
      args: ["kendoGridGroupBinding"]
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    group: [{
      type: Input
    }]
  });
})();
var GridSpacerComponent = class _GridSpacerComponent {
  hostClass = true;
  get sizedClass() {
    return isPresent4(this.width);
  }
  get flexBasisStyle() {
    return this.width;
  }
  /**
   * Specifies the width of the GridSpacer.
   * Accepts the [string values of the CSS `flex-basis` property](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis).
   *
   * If not set, the GridSpacer will take all the available space.
   */
  width;
  static ɵfac = function GridSpacerComponent_Factory(t) {
    return new (t || _GridSpacerComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _GridSpacerComponent,
    selectors: [["kendo-grid-spacer"]],
    hostVars: 6,
    hostBindings: function GridSpacerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("flex-basis", ctx.flexBasisStyle);
        ɵɵclassProp("k-spacer", ctx.hostClass)("k-spacer-sized", ctx.sizedClass);
      }
    },
    inputs: {
      width: "width"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function GridSpacerComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridSpacerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-spacer",
      template: ``,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-spacer"]
    }],
    sizedClass: [{
      type: HostBinding,
      args: ["class.k-spacer-sized"]
    }],
    flexBasisStyle: [{
      type: HostBinding,
      args: ["style.flexBasis"]
    }],
    width: [{
      type: Input
    }]
  });
})();
var GridToolbarFocusableDirective = class _GridToolbarFocusableDirective {
  host;
  ctx;
  /**
   * @hidden
   */
  get element() {
    return this.host.nativeElement;
  }
  /**
   * @hidden
   */
  get toolbarPosition() {
    return isDocumentAvailable() && this.host.nativeElement.closest(".k-toolbar")?.getAttribute("position");
  }
  constructor(host, ctx) {
    this.host = host;
    this.ctx = ctx;
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable() || !this.toolbarPosition) {
      return;
    }
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.navigableElements.push(this.element);
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.notify();
  }
  ngOnDestroy() {
    if (!isDocumentAvailable() || !this.toolbarPosition) {
      return;
    }
    const elements = this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements;
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements = elements.filter((el) => el !== this.element);
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`].notify();
  }
  static ɵfac = function GridToolbarFocusableDirective_Factory(t) {
    return new (t || _GridToolbarFocusableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridToolbarFocusableDirective,
    selectors: [["", "kendoGridToolbarFocusable", ""], ["", "kendoGridAddCommand", ""], ["", "kendoGridCancelCommand", ""], ["", "kendoGridEditCommand", ""], ["", "kendoGridRemoveCommand", ""], ["", "kendoGridSaveCommand", ""], ["", "kendoGridExcelCommand", ""], ["", "kendoGridPDFCommand", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridToolbarFocusableDirective, [{
    type: Directive,
    args: [{
      selector: `
        [kendoGridToolbarFocusable],
        [kendoGridAddCommand],
        [kendoGridCancelCommand],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridExcelCommand],
        [kendoGridPDFCommand]
    `,
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ContextService
    }];
  }, null);
})();
var GridClipboardDirective = class _GridClipboardDirective {
  host;
  clipboardService;
  renderer;
  zone;
  /**
   * Determines the target of the clipboard operation ([see example]({% slug clipboard_grid %}#toc-clipboard-target)). The possible options are:
   * - `activeCell`
   * - `selection`
   *
   * @default 'selection'
   */
  set clipboardTarget(value) {
    if (isDevMode()) {
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        if (value === "activeCell" && !this.host.navigable.length) {
          console.warn(ClipboardErrorMessages.clipboardTarget.activeCellNavigable);
        } else if (value === "selection" && !(this.host.selectable || this.host.selectionDirective)) {
          console.warn(ClipboardErrorMessages.selectionSelectable);
        }
      });
    }
    this._target = value;
  }
  get clipboardTarget() {
    return this._target;
  }
  /**
   * The `GridClipboardDirective` settings.
   *
   * @default { wholeRow: false, copyHeaders: false copy: true, cut: true, paste: true }
   */
  set clipboardSettings(value) {
    this._clipboardSettings = Object.assign({}, this._clipboardSettings, value);
  }
  get clipboardSettings() {
    return this._clipboardSettings;
  }
  /**
   * Fires when the user performs `cut`, `copy` or `paste` action within the Grid content area.
   */
  clipboard = new EventEmitter();
  _target = "selection";
  _clipboardSettings = {
    wholeRow: false,
    copyHeaders: false,
    copy: true,
    cut: true,
    paste: true
  };
  subs = new Subscription();
  constructor(host, clipboardService, renderer, zone) {
    this.host = host;
    this.clipboardService = clipboardService;
    this.renderer = renderer;
    this.zone = zone;
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.clipboardTarget === "selection" && !(this.host.selectable || this.host.selectionDirective)) {
      console.warn(ClipboardErrorMessages.selectionSelectable);
    }
    this.zone.runOutsideAngular(() => {
      this.subs.add(this.renderer.listen(document, "copy", (args) => this.onClipboard("copy", args)));
      this.subs.add(this.renderer.listen(document, "cut", (args) => this.onClipboard("cut", args)));
      this.subs.add(this.renderer.listen(document, "paste", (args) => this.onClipboard("paste", args)));
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  onClipboard = (operationType, args) => {
    if (!this.clipboardSettings[operationType] || !this.inGrid(args)) {
      return;
    }
    const gridData = Array.isArray(this.host.data) ? this.host.data : this.host.data.data;
    const gridDataItems = gridData.flatMap(recursiveFlatMap);
    const selection = this.host.selection;
    const selectionDirective = this.host.selectionDirective;
    const targetType = this.clipboardTarget;
    const isCellSelection = this.host.selectable?.cell || selectionDirective.isCellSelectionMode;
    let clipboardData = [];
    switch (targetType) {
      case "activeCell":
        {
          const targetCell2 = __spreadValues({}, this.host.activeCell);
          clipboardData = targetCell2 && [{
            dataItem: targetCell2.dataItem,
            dataRowIndex: targetCell2.dataRowIndex,
            colIndex: targetCell2.colIndex
          }];
        }
        break;
      case "selection":
        {
          const identifier = selectionDirective.selectionKey;
          clipboardData = gridDataItems.flatMap((item, index) => {
            if (identifier) {
              const key = typeof identifier === "string" ? item[identifier] : identifier({
                index: index + this.host.skip,
                dataItem: item
              });
              return isCellSelection ? selection.some((s) => s.itemKey === key) ? [{
                dataItem: item,
                dataRowIndex: index + this.host.skip
              }] : [] : selection.indexOf(key) > -1 ? [{
                dataItem: item,
                dataRowIndex: index + this.host.skip
              }] : [];
            }
            return isCellSelection ? selection.some((s) => s.itemKey === index + this.host.skip) ? [{
              dataItem: item,
              dataRowIndex: index + this.host.skip
            }] : [] : selection.indexOf(index + this.host.skip) > -1 ? [{
              dataItem: item,
              dataRowIndex: index + this.host.skip
            }] : [];
          });
        }
        break;
    }
    const isPaste = operationType === "paste";
    const pastedData = args.clipboardData.getData("text");
    const visibleCols = this.host.columns.toArray().filter((c) => c.isVisible);
    const data = isPaste ? {
      dataString: pastedData,
      gridItems: this.clipboardService.getGridData(pastedData, visibleCols, this.clipboardTarget, clipboardData[0]?.dataRowIndex, {
        wholeRow: this.clipboardSettings.wholeRow,
        isCellSelection
      })
    } : this.clipboardService.createClipboardData(clipboardData || [], visibleCols, {
      wholeRow: this.clipboardSettings.wholeRow || this.clipboardTarget === "selection" && !isCellSelection,
      target: this.clipboardTarget,
      copyHeaders: this.clipboardSettings.copyHeaders,
      operationType
    });
    !isPaste && navigator.clipboard.writeText(data.dataString);
    if (hasObservers(this.clipboard)) {
      this.zone.run(() => {
        this.clipboard.emit({
          type: operationType,
          originalEvent: args,
          clipboardData: data.dataString,
          gridData: data.gridItems,
          target: {
            dataRowIndex: this.clipboardService.targetRowIndex,
            colField: this.clipboardService.targetColField,
            dataItem: clipboardData.find((item) => item.dataRowIndex === this.clipboardService.targetRowIndex)?.dataItem
          }
        });
      });
    }
    this.clipboardService.targetColField = this.clipboardService.targetRowIndex = null;
  };
  inGrid = (args) => {
    const target = document.activeElement.matches(".k-table-td") ? document.activeElement : args.target;
    const inContentArea = closest3(target, (node) => node.parentElement?.classList.contains("k-grid-container"));
    const inHost = contains$1(this.host.wrapper.nativeElement, target);
    return target && inHost && inContentArea;
  };
  static ɵfac = function GridClipboardDirective_Factory(t) {
    return new (t || _GridClipboardDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(ClipboardService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GridClipboardDirective,
    selectors: [["", "kendoGridClipboard", ""]],
    inputs: {
      clipboardTarget: "clipboardTarget",
      clipboardSettings: "clipboardSettings"
    },
    outputs: {
      clipboard: "clipboard"
    },
    exportAs: ["kendoGridClipboard"],
    standalone: true,
    features: [ɵɵProvidersFeature([ClipboardService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridClipboardDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridClipboard]",
      exportAs: "kendoGridClipboard",
      providers: [ClipboardService],
      standalone: true
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: ClipboardService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    clipboardTarget: [{
      type: Input
    }],
    clipboardSettings: [{
      type: Input
    }],
    clipboard: [{
      type: Output
    }]
  });
})();
var PDFCommandToolbarDirective = class _PDFCommandToolbarDirective extends ToolbarToolBase {
  pdfService;
  host;
  constructor(pdfService, host, ctx, zone, cdr) {
    super(host, ToolbarToolName.pdfExport, ctx, zone, cdr);
    this.pdfService = pdfService;
    this.host = host;
  }
  ngOnInit() {
    super.ngOnInit();
    this.host.className = "k-grid-pdf";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.pdfService.exportClick.emit();
  }
  static ɵfac = function PDFCommandToolbarDirective_Factory(t) {
    return new (t || _PDFCommandToolbarDirective)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PDFCommandToolbarDirective,
    selectors: [["", "kendoGridPDFTool", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridPDFTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: PDFService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var ExcelCommandToolbarDirective = class _ExcelCommandToolbarDirective extends ToolbarToolBase {
  excelService;
  constructor(excelService, host, ctx, zone, cdr) {
    super(host, ToolbarToolName.excelExport, ctx, zone, cdr);
    this.excelService = excelService;
  }
  ngOnInit() {
    super.ngOnInit();
    this.host.className = "k-grid-excel";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.excelService.exportClick.emit();
  }
  static ɵfac = function ExcelCommandToolbarDirective_Factory(t) {
    return new (t || _ExcelCommandToolbarDirective)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExcelCommandToolbarDirective,
    selectors: [["", "kendoGridExcelTool", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExcelTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ExcelService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var ToolbarEditingToolBase = class _ToolbarEditingToolBase extends ToolbarToolBase {
  host;
  commandName;
  ctx;
  editService;
  selection;
  isEdited = false;
  lastToolState = null;
  constructor(host, commandName, ctx, zone, cdr, editService, selection) {
    super(host, commandName, ctx, zone, cdr);
    this.host = host;
    this.commandName = commandName;
    this.ctx = ctx;
    this.editService = editService;
    this.selection = selection;
  }
  ngDoCheck() {
    if (!isPresent(this.editService)) {
      return;
    }
    this.isEdited = this.editService.isEditing();
    const isAddNewItem = this.editService.hasNewItem;
    let isToolInactive = false;
    let formGroup;
    const selectionPresent = isPresent(this.lastSelectionIndex);
    if (this.isEdited || isAddNewItem) {
      formGroup = isAddNewItem ? this.editService.context()?.group : this.editService.editedIndices[0].group;
    }
    switch (this.commandName) {
      case ToolbarToolName.edit:
        isToolInactive = this.isEdited || !selectionPresent;
        break;
      case ToolbarToolName.save:
        isToolInactive = !(this.isEdited || isAddNewItem) || !formGroup?.valid;
        break;
      case ToolbarToolName.remove:
        isToolInactive = this.isEdited || !selectionPresent;
        break;
      case ToolbarToolName.cancel:
        isToolInactive = !(this.isEdited || isAddNewItem);
        break;
    }
    if (this.lastToolState !== isToolInactive) {
      this.lastToolState = isToolInactive;
      if (this.ctx.grid.showInactiveTools) {
        this.host.disabled = isToolInactive;
      } else if (this.host.isHidden !== isToolInactive) {
        this.host.isHidden = isToolInactive;
        const toolbar = this.host.host;
        toolbar.refreshService.refresh(this.host);
        this.zone.onStable.pipe(take(1)).subscribe(() => {
          toolbar.onResize();
        });
      }
    }
  }
  get lastSelectionIndex() {
    return this.selection?.selected[this.selection?.selected.length - 1];
  }
  get isSelectionPresent() {
    return isPresent(this.lastSelectionIndex) && this.lastSelectionIndex > -1;
  }
  static ɵfac = function ToolbarEditingToolBase_Factory(t) {
    return new (t || _ToolbarEditingToolBase)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject("command"), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(SelectionService2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ToolbarEditingToolBase,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarEditingToolBase, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: ToolBarButtonComponent
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: ["command"]
      }]
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: EditService
    }, {
      type: SelectionService2
    }];
  }, null);
})();
var AddCommandToolbarDirective = class _AddCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  host;
  constructor(editService, host, ctx, zone, cdr) {
    super(host, ToolbarToolName.add, ctx, zone, cdr, editService);
    this.editService = editService;
    this.host = host;
  }
  ngOnInit() {
    super.ngOnInit();
    this.host.className = "k-grid-add-command";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginAdd();
  }
  static ɵfac = function AddCommandToolbarDirective_Factory(t) {
    return new (t || _AddCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AddCommandToolbarDirective,
    selectors: [["", "kendoGridAddTool", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridAddTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var UndoRedoStack = class {
  maxSize;
  /** The current active node in the undo-redo history */
  currentNode = null;
  /** The root node of the stack (first state) */
  rootNode = null;
  /** Track the size of the stack */
  _size = 0;
  /**
   * Creates a new UndoRedoStack.
   * @param maxSize Optional maximum number of states to maintain (unlimited if not provided)
   */
  constructor(maxSize = -1) {
    this.maxSize = maxSize;
  }
  /**
   * Gets the current number of states in the stack
   */
  get size() {
    return this._size;
  }
  /**
   * Gets the current active state
   */
  get current() {
    return this.currentNode ? this.currentNode.state : null;
  }
  /**
   * Checks if undo is available (if there's a previous state)
   */
  get canUndo() {
    return isPresent(this.currentNode?.previous);
  }
  /**
   * Checks if redo is available (if there's a next state)
   */
  get canRedo() {
    return isPresent(this.currentNode?.next);
  }
  /**
   * Adds a new state to the undo-redo stack
   * @param state The state to add
   * @param id Optional identifier for the state
   * @returns The newly created node
   */
  add(state2, id2) {
    const newNode = {
      state: state2,
      previous: this.currentNode,
      next: null,
      id: id2
    };
    if (this.currentNode) {
      if (this.currentNode.next) {
        this.truncateForward(this.currentNode);
      }
      this.currentNode.next = newNode;
    } else {
      this.rootNode = newNode;
    }
    this.currentNode = newNode;
    this._size++;
    this.enforceMaxSize();
    return newNode;
  }
  /**
   * Finds a node by its identifier
   * @param id The identifier to search for
   * @returns The found node or null if not found
   */
  find(id2) {
    if (!this.rootNode) {
      return null;
    }
    let node = this.rootNode;
    while (node) {
      if (node.id === id2) {
        return node;
      }
      node = node.next;
    }
    return null;
  }
  /**
   * Removes a node by its identifier
   * @param id The identifier of the node to remove
   * @returns True if the node was found and removed, false otherwise
   */
  remove(id2) {
    const nodeToRemove = this.find(id2);
    if (!nodeToRemove) {
      return false;
    }
    if (nodeToRemove === this.currentNode) {
      this.currentNode = nodeToRemove.previous || nodeToRemove.next;
    }
    if (nodeToRemove.previous) {
      nodeToRemove.previous.next = nodeToRemove.next;
    } else {
      this.rootNode = nodeToRemove.next;
    }
    if (nodeToRemove.next) {
      nodeToRemove.next.previous = nodeToRemove.previous;
    }
    nodeToRemove.previous = null;
    nodeToRemove.next = null;
    this._size--;
    return true;
  }
  /**
   * Performs an undo operation, moving to the previous state
   * @returns The previous state or null if can't undo
   */
  undo() {
    if (!this.canUndo) {
      return null;
    }
    this.currentNode = this.currentNode.previous;
    return this.currentNode.state;
  }
  /**
   * Performs a redo operation, moving to the next state
   * @returns The next state or null if can't redo
   */
  redo() {
    if (!this.canRedo) {
      return null;
    }
    this.currentNode = this.currentNode.next;
    return this.currentNode.state;
  }
  /**
   * Clears all history
   */
  clear() {
    this.currentNode = null;
    this.rootNode = null;
    this._size = 0;
  }
  /**
   * Removes all states after the specified node
   * @param node The node to truncate from
   * @returns The number of nodes removed
   */
  truncateForward(node) {
    if (!node.next) {
      return 0;
    }
    let removedCount = 0;
    let currentNext = node.next;
    while (currentNext) {
      const temp = currentNext.next;
      currentNext.previous = null;
      currentNext.next = null;
      currentNext = temp;
      removedCount++;
    }
    node.next = null;
    this._size -= removedCount;
    return removedCount;
  }
  /**
   * Ensures the stack doesn't exceed the maximum size by removing oldest nodes
   */
  enforceMaxSize() {
    if (this.maxSize <= 0 || this._size <= this.maxSize) {
      return;
    }
    let nodesToRemove = this._size - this.maxSize;
    let currentNode = this.rootNode;
    while (nodesToRemove > 0 && currentNode) {
      currentNode = currentNode.next;
      nodesToRemove--;
    }
    if (currentNode) {
      currentNode.previous = null;
      this.rootNode = currentNode;
      this._size = this.maxSize;
    }
  }
  /**
   * Gets all states in the stack as an array (from oldest to newest)
   */
  toArray() {
    const result = [];
    let node = this.rootNode;
    while (node) {
      result.push(node.state);
      node = node.next;
    }
    return result;
  }
  /**
   * Gets the history nodes as an array (useful for debugging)
   */
  getNodes() {
    const result = [];
    let node = this.rootNode;
    while (node) {
      result.push(node);
      node = node.next;
    }
    return result;
  }
};
var UndoRedoEvent = class extends PreventableEvent {
  /**
   * The event data of the original action that triggered the state change.
   */
  originalEvent;
  /**
   * The grid state and rendered data at the time of the action.
   */
  gridState;
  /**
   * @hidden
   */
  constructor({
    originalEvent,
    gridState
  }) {
    super();
    this.originalEvent = originalEvent;
    this.gridState = gridState;
  }
};
var UndoRedoService = class _UndoRedoService {
  originalEvent;
  onUndo = new Subject();
  onRedo = new Subject();
  stackEndReached = new Subject();
  setState = new Subject();
  static ɵfac = function UndoRedoService_Factory(t) {
    return new (t || _UndoRedoService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _UndoRedoService,
    factory: _UndoRedoService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UndoRedoService, [{
    type: Injectable
  }], null, null);
})();
var UndoRedoDirective = class _UndoRedoDirective {
  host;
  editService;
  undoRedoService;
  changeNotification;
  /**
   * Determines the maximum number of actions to keep in the undo-redo stack.
   * @default 10
   */
  maxStoredStates = 10;
  /**
   * Fires when undo action is performed. Exposes the state of the grid that will be applied.
   */
  onUndo = new EventEmitter();
  /**
   * Fires when undo action is performed. Exposes the state of the grid that will be applied.
   */
  onRedo = new EventEmitter();
  /**
   * Returns an array of all undo-redo actions that are currently in the stack.
   */
  get undoRedoItems() {
    return this.stack.toArray();
  }
  stack;
  subs = new Subscription();
  addToState = true;
  constructor(host, editService, undoRedoService, changeNotification) {
    this.host = host;
    this.editService = editService;
    this.undoRedoService = undoRedoService;
    this.changeNotification = changeNotification;
    this.host.undoRedoService = this.undoRedoService;
  }
  ngOnInit() {
    this.stack = new UndoRedoStack(this.maxStoredStates);
    this.stack.add({
      originalEvent: {
        skip: this.host.skip,
        take: this.host.pageSize,
        sort: this.host.sort,
        filter: this.host.filter,
        group: this.host.group
      },
      gridState: structuredClone(this.host.currentState)
    });
    this.subs = this.host.gridStateChange.subscribe((state2) => {
      if (this.addToState) {
        this.stack.add({
          originalEvent: {
            skip: state2.skip,
            take: state2.take,
            sort: state2.sort,
            filter: state2.filter,
            group: state2.group
          },
          gridState: structuredClone(state2)
        });
      }
      let stackEndPointReached;
      if (this.stack.canUndo) {
        stackEndPointReached = this.stack.canRedo ? false : "end";
      } else {
        stackEndPointReached = "start";
      }
      this.undoRedoService.stackEndReached.next(stackEndPointReached);
    });
    this.subs.add(this.editService.changes.pipe(filter((event2) => event2.action === "save" || event2.action === "remove"), tap((event2) => this.undoRedoService.originalEvent = event2)).subscribe((event2) => {
      this.stack.add({
        originalEvent: event2,
        gridState: structuredClone(this.host.currentState)
      });
      this.addToState = false;
      this.host.gridStateChange.emit(this.stack.current.gridState);
      this.addToState = true;
      this.updateUndoRedoDisabled();
    }));
    this.subs.add(this.changeNotification.changes.subscribe(() => this.stack.current.gridState = this.host.currentState));
    ["Undo", "Redo"].forEach((action) => {
      this.subs.add(this.undoRedoService[`on${action}`].subscribe(() => {
        if (!this.stack[`can${action}`]) {
          return;
        }
        this.stack[`${action.toLowerCase()}`]();
        if (hasObservers(this[`on${action}`])) {
          const event2 = new UndoRedoEvent(this.stack.current);
          this[`on${action}`].emit(event2);
          if (event2.isDefaultPrevented()) {
            return;
          }
        }
        this.updateUndoRedoDisabled();
        this.host.loadState(this.stack.current.gridState);
      }));
    });
    this.subs.add(this.undoRedoService.setState.subscribe((state2) => this.stack.add({
      originalEvent: "dataChange",
      gridState: state2
    })));
  }
  ngOnDestroy() {
    this.stack.clear();
    this.stack = null;
    this.subs.unsubscribe();
  }
  /**
   * Re-applies the last action, reverted by the `undo` method.
   */
  redo() {
    if (this.stack.canRedo) {
      this.stack.redo();
      this.host.loadState(this.stack.current.gridState);
      if (!this.stack.canRedo) {
        this.undoRedoService.stackEndReached.next("end");
      }
    }
  }
  /**
   * Reverts the last user action.
   */
  undo() {
    if (this.stack.canUndo) {
      this.stack.undo();
      this.host.loadState(this.stack.current.gridState);
      if (!this.stack.canUndo) {
        this.undoRedoService.stackEndReached.next("start");
      }
    }
  }
  updateUndoRedoDisabled() {
    if (!this.stack.canRedo) {
      this.undoRedoService.stackEndReached.next("end");
      return;
    }
    if (!this.stack.canUndo) {
      this.undoRedoService.stackEndReached.next("start");
      return;
    }
    this.undoRedoService.stackEndReached.next(false);
  }
  static ɵfac = function UndoRedoDirective_Factory(t) {
    return new (t || _UndoRedoDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(UndoRedoService), ɵɵdirectiveInject(ChangeNotificationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _UndoRedoDirective,
    selectors: [["", "kendoGridUndoRedo", ""]],
    inputs: {
      maxStoredStates: "maxStoredStates"
    },
    outputs: {
      onUndo: "undo",
      onRedo: "redo"
    },
    exportAs: ["kendoGridUndoRedo"],
    standalone: true,
    features: [ɵɵProvidersFeature([UndoRedoService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UndoRedoDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridUndoRedo]",
      standalone: true,
      exportAs: "kendoGridUndoRedo",
      providers: [UndoRedoService]
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: EditService
    }, {
      type: UndoRedoService
    }, {
      type: ChangeNotificationService
    }];
  }, {
    maxStoredStates: [{
      type: Input
    }],
    onUndo: [{
      type: Output,
      args: ["undo"]
    }],
    onRedo: [{
      type: Output,
      args: ["redo"]
    }]
  });
})();
var UndoCommandToolbarDirective = class _UndoCommandToolbarDirective {
  undoRedoService;
  host;
  subs = new Subscription();
  constructor(undoRedoService, host) {
    this.undoRedoService = undoRedoService;
    this.host = host;
  }
  ngOnInit() {
    this.subs = this.host.click.subscribe((e) => this.onClick(e));
    this.host.className = "k-grid-undo-command";
    this.host.svgIcon = undoIcon;
    this.host.icon = "undo";
    this.host.text = "Undo";
    this.host.disabled = true;
    this.subs.add(this.undoRedoService.stackEndReached.subscribe((stackEnd) => this.host.disabled = stackEnd === "start"));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.undoRedoService.onUndo.next();
  }
  static ɵfac = function UndoCommandToolbarDirective_Factory(t) {
    return new (t || _UndoCommandToolbarDirective)(ɵɵdirectiveInject(UndoRedoService), ɵɵdirectiveInject(ToolBarButtonComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _UndoCommandToolbarDirective,
    selectors: [["", "kendoGridUndoTool", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UndoCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridUndoTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: UndoRedoService
    }, {
      type: ToolBarButtonComponent
    }];
  }, null);
})();
var RedoCommandToolbarDirective = class _RedoCommandToolbarDirective {
  undoRedoService;
  host;
  subs = new Subscription();
  constructor(undoRedoService, host) {
    this.undoRedoService = undoRedoService;
    this.host = host;
  }
  ngOnInit() {
    this.subs = this.host.click.subscribe((e) => this.onClick(e));
    this.host.className = "k-grid-redo-command";
    this.host.svgIcon = redoIcon;
    this.host.icon = "redo";
    this.host.text = "Redo";
    this.host.disabled = true;
    this.subs.add(this.undoRedoService.stackEndReached.subscribe((stackEnd) => this.host.disabled = stackEnd === "end"));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.undoRedoService.onRedo.next();
  }
  static ɵfac = function RedoCommandToolbarDirective_Factory(t) {
    return new (t || _RedoCommandToolbarDirective)(ɵɵdirectiveInject(UndoRedoService), ɵɵdirectiveInject(ToolBarButtonComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RedoCommandToolbarDirective,
    selectors: [["", "kendoGridRedoTool", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RedoCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRedoTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: UndoRedoService
    }, {
      type: ToolBarButtonComponent
    }];
  }, null);
})();
var incrementingId$2 = 0;
var SortCommandToolbarDirective = class _SortCommandToolbarDirective {
  host;
  popupService;
  ctx;
  sortService;
  columnInfoService;
  ngZone;
  renderer;
  adaptiveGridService;
  popupRef;
  nextId = incrementingId$2++;
  toolSubs = new Subscription();
  popupSubs;
  actionSheetCloseSub;
  removeClickListener;
  /**
   * @hidden
   */
  isSortingApplied(sort) {
    return isPresent(sort) && sort.length > 0 && sort.filter((item) => item.dir !== void 0).length > 0;
  }
  constructor(host, popupService, ctx, sortService, columnInfoService, ngZone, renderer, adaptiveGridService) {
    this.host = host;
    this.popupService = popupService;
    this.ctx = ctx;
    this.sortService = sortService;
    this.columnInfoService = columnInfoService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.toolSubs = this.host.click.subscribe((e) => this.onClick(e));
    this.toolSubs.add(this.sortService.changes.subscribe((sort) => {
      this.host.showBadge = this.isSortingApplied(sort);
    }));
    this.host.hasBadgeContainer = true;
    this.host.showBadge = this.isSortingApplied(this.ctx.grid.sort);
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "arrows-swap";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = arrowsSwapIcon;
    }
  }
  ngAfterViewInit() {
    if (!isPresent(this.host.text)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.host.text = this.ctx.localization.get(`sortToolbarToolText`);
      });
    }
    this.buttonElement?.setAttribute("aria-haspopup", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.setAttribute("title", this.ctx.localization.get("sortToolbarToolText"));
  }
  ngOnDestroy() {
    if (this.toolSubs) {
      this.toolSubs.unsubscribe();
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  onClick(e) {
    e.preventDefault();
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "sortToolbarTool";
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      if (this.popupRef) {
        this.closePopup();
        return;
      }
      this.openPopup();
    }
  }
  openPopup() {
    const direction = this.ctx.localization.rtl ? "right" : "left";
    this.popupRef = this.popupService.open({
      anchor: this.buttonElement,
      content: SortToolbarToolComponent,
      popupClass: "k-grid-columnmenu-popup",
      positionMode: "absolute",
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      }
    });
    this.adaptiveGridService.popupRef = this.popupRef;
    this.setPopupAttributes();
    this.host.selected = true;
    this.ngZone.runOutsideAngular(() => {
      if (!isDocumentAvailable()) {
        return;
      }
      this.removeClickListener = this.renderer.listen("document", "click", (e) => {
        if (this.popupRef && !closest(e.target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
          this.ngZone.run(() => {
            this.closePopup();
          });
        }
      });
    });
    this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
      this.popupSubs?.unsubscribe();
      this.popupSubs = null;
      this.closePopup();
    });
    this.initPopupProperties();
  }
  setPopupAttributes() {
    const popupElement = this.popupRef.popupElement;
    const popupId = `k-sort-tool-${this.nextId}-popup`;
    const popupAriaElement = popupElement.querySelector(".k-popup");
    this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    this.renderer.setAttribute(popupAriaElement, "id", popupId);
    this.renderer.setAttribute(popupAriaElement, "role", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "true");
    this.buttonElement?.setAttribute("aria-controls", popupId);
  }
  initPopupProperties() {
    this.popupRef.content.instance.columnInfoService = this.columnInfoService;
    this.popupRef.content.instance.ctx = this.ctx;
    this.popupRef.content.instance.sortService = this.sortService;
    this.popupRef.content.instance.hostButton = this.host;
    this.popupSubs.add(this.popupRef.content.instance.sortClear.subscribe(() => {
      this.closePopup();
    }));
    this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
      this.closePopup();
    }));
  }
  closePopup() {
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
      this.popupSubs = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  get buttonElement() {
    return this.host.getButton();
  }
  static ɵfac = function SortCommandToolbarDirective_Factory(t) {
    return new (t || _SortCommandToolbarDirective)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SortCommandToolbarDirective,
    selectors: [["", "kendoGridSortTool", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SortCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSortTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ToolBarButtonComponent
    }, {
      type: PopupService
    }, {
      type: ContextService
    }, {
      type: SortService
    }, {
      type: ColumnInfoService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: AdaptiveGridService
    }];
  }, null);
})();
var FilterToolWrapperComponent = class _FilterToolWrapperComponent {
  injector;
  container;
  wrapperClasses = true;
  onEscKeyDown(event2) {
    event2.preventDefault();
    this.close.emit();
    this.hostButton?.focus(event2);
  }
  onClick(event2) {
    if (this.hostButton.location !== "toolbar") {
      event2.stopImmediatePropagation();
    }
  }
  close = new EventEmitter();
  hostButton;
  clearIcon = filterClearIcon;
  columnInfoService;
  set ctx(ctx) {
    this._ctx = ctx;
    this.filter = ctx.grid.filter;
    this.createPopup();
  }
  get ctx() {
    return this._ctx;
  }
  set filterService(filterService) {
    this._filterService = filterService;
    this.subscriptions = this._filterService.changes.subscribe((filter3) => {
      this.filter = filter3;
    });
    this.createPopup();
  }
  get filterService() {
    return this._filterService;
  }
  columnMenuService;
  popupRef;
  filter;
  subscriptions;
  _ctx;
  _filterService;
  constructor(injector) {
    this.injector = injector;
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.destroy();
      this.popupRef = null;
    }
  }
  clear() {
    if (!this.filter || this.filter.filters?.length === 0) {
      return;
    }
    this.filter = {
      logic: "and",
      filters: []
    };
    this.popupRef.instance.filter = cloneFilters(this.filter);
    this.filterService.filter(this.filter);
    this.close.emit();
  }
  createPopup() {
    if (this._ctx && this._filterService && this.container && !this.popupRef) {
      const customInjector = Injector.create({
        providers: [{
          provide: FilterService,
          useValue: this._filterService
        }, {
          provide: ContextService,
          useValue: this._ctx
        }, {
          provide: ColumnInfoService,
          useValue: this.columnInfoService
        }, AdaptiveGridService, SinglePopupService, ScrollSyncService2],
        parent: this.injector
      });
      this.popupRef = this.container.createComponent(FilterToolbarToolComponent, {
        injector: customInjector
      });
      this.subscriptions.add(this.popupRef.instance.close.subscribe(() => this.close.emit()));
    }
  }
  static ɵfac = function FilterToolWrapperComponent_Factory(t) {
    return new (t || _FilterToolWrapperComponent)(ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FilterToolWrapperComponent,
    selectors: [["kendo-filter-tool-wrapper"]],
    viewQuery: function FilterToolWrapperComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c46, 7, ViewContainerRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function FilterToolWrapperComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.escape", function FilterToolWrapperComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.onEscKeyDown($event);
        })("click", function FilterToolWrapperComponent_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassProp("k-column-menu", ctx.wrapperClasses)("k-column-menu-md", ctx.wrapperClasses);
      }
    },
    outputs: {
      close: "close"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 5,
    vars: 2,
    consts: [["container", ""], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-column-menu-footer"], ["kendoButton", "", "icon", "filter-clear", 3, "click", "svgIcon"]],
    template: function FilterToolWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, null, 0);
        ɵɵelementStart(2, "div", 1)(3, "button", 2);
        ɵɵlistener("click", function FilterToolWrapperComponent_Template_button_click_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.clear());
        });
        ɵɵtext(4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("svgIcon", ctx.clearIcon);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.ctx == null ? null : ctx.ctx.localization.get("filterClearAllButton"), " ");
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterToolWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-filter-tool-wrapper",
      template: `
        <ng-container #container></ng-container>
        <div class="k-actions k-actions-stretched k-actions-horizontal k-column-menu-footer">
            <button kendoButton
                    [svgIcon]="clearIcon"
                    icon="filter-clear"
                    (click)="clear()">
                    {{ctx?.localization.get('filterClearAllButton')}}
            </button>
        </div>
    `,
      standalone: true,
      imports: [KENDO_BUTTON]
    }]
  }], function() {
    return [{
      type: Injector
    }];
  }, {
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    wrapperClasses: [{
      type: HostBinding,
      args: ["class.k-column-menu"]
    }, {
      type: HostBinding,
      args: ["class.k-column-menu-md"]
    }],
    onEscKeyDown: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    close: [{
      type: Output
    }]
  });
})();
var incrementingId$1 = 0;
var FilterCommandToolbarDirective = class _FilterCommandToolbarDirective {
  host;
  popupService;
  ctx;
  filterService;
  columnInfoService;
  ngZone;
  renderer;
  adaptiveGridService;
  popupRef;
  nextId = incrementingId$1++;
  toolSubs = new Subscription();
  popupSubs;
  actionSheetCloseSub;
  removeClickListener;
  /**
   * @hidden
   */
  isFilterApplied(filter3) {
    return isPresent(filter3) && filter3.filters?.length > 0;
  }
  constructor(host, popupService, ctx, filterService, columnInfoService, ngZone, renderer, adaptiveGridService) {
    this.host = host;
    this.popupService = popupService;
    this.ctx = ctx;
    this.filterService = filterService;
    this.columnInfoService = columnInfoService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.toolSubs = this.host.click.subscribe((e) => this.onClick(e));
    this.toolSubs.add(this.filterService.changes.subscribe((filter3) => {
      this.host.showBadge = this.isFilterApplied(filter3);
    }));
    this.host.hasBadgeContainer = true;
    this.host.showBadge = this.isFilterApplied(this.ctx.grid.filter);
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "filter";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = filterIcon;
    }
  }
  ngAfterViewInit() {
    if (!isPresent(this.host.text)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.host.text = this.ctx.localization.get(`filterToolbarToolText`);
      });
    }
    this.buttonElement?.setAttribute("aria-haspopup", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.setAttribute("title", this.ctx.localization.get("filterToolbarToolText"));
  }
  ngOnDestroy() {
    if (this.toolSubs) {
      this.toolSubs.unsubscribe();
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  onClick(e) {
    e.preventDefault();
    if (this.popupRef) {
      this.closePopup();
      return;
    }
    this.openPopup();
  }
  openPopup() {
    const direction = this.ctx.localization.rtl ? "right" : "left";
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "filterToolbarTool";
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      this.popupRef = this.popupService.open({
        anchor: this.buttonElement,
        content: FilterToolWrapperComponent,
        popupClass: "k-grid-columnmenu-popup",
        positionMode: "absolute",
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        }
      });
      this.adaptiveGridService.popupRef = this.popupRef;
      this.setPopupAttributes();
      this.host.selected = true;
      this.ngZone.runOutsideAngular(() => {
        if (!isDocumentAvailable()) {
          return;
        }
        this.removeClickListener = this.renderer.listen("document", "click", (e) => {
          if (this.popupRef && !closest(e.target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
            this.ngZone.run(() => {
              this.closePopup();
            });
          }
        });
      });
      this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
        this.popupSubs?.unsubscribe();
        this.popupSubs = null;
        this.closePopup();
      });
      this.initPopupProperties();
    }
  }
  setPopupAttributes() {
    const popupElement = this.popupRef.popupElement;
    const popupId = `k-filter-tool-${this.nextId}-popup`;
    const popupAriaElement = popupElement.querySelector(".k-popup");
    this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    this.renderer.setAttribute(popupAriaElement, "id", popupId);
    this.renderer.setAttribute(popupAriaElement, "role", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "true");
    this.buttonElement?.setAttribute("aria-controls", popupId);
  }
  initPopupProperties() {
    this.popupRef.content.instance.columnInfoService = this.columnInfoService;
    this.popupRef.content.instance.ctx = this.ctx;
    this.popupRef.content.instance.filterService = this.filterService;
    this.popupRef.content.instance.hostButton = this.host;
    this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
      this.closePopup();
    }));
  }
  closePopup() {
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
      this.popupSubs = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  get buttonElement() {
    return this.host.getButton();
  }
  static ɵfac = function FilterCommandToolbarDirective_Factory(t) {
    return new (t || _FilterCommandToolbarDirective)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterCommandToolbarDirective,
    selectors: [["", "kendoGridFilterTool", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ToolBarButtonComponent
    }, {
      type: PopupService
    }, {
      type: ContextService
    }, {
      type: FilterService
    }, {
      type: ColumnInfoService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: AdaptiveGridService
    }];
  }, null);
})();
var EditCommandToolbarDirective = class _EditCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.edit, ctx, zone, cdr, editService, selection);
    this.editService = editService;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (!this.isSelectionPresent) {
      return;
    }
    this.editService.beginEdit(this.lastSelectionIndex);
  }
  static ɵfac = function EditCommandToolbarDirective_Factory(t) {
    return new (t || _EditCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _EditCommandToolbarDirective,
    selectors: [["", "kendoGridEditTool", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: SelectionService2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var SaveCommandToolbarDirective = class _SaveCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.save, ctx, zone, cdr, editService, selection);
    this.editService = editService;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.editService.hasNewItem) {
      this.editService.save();
    } else if (this.isSelectionPresent && this.editService.isEdited(this.lastSelectionIndex)) {
      this.editService.save(this.lastSelectionIndex);
    } else {
      this.editService.editedIndices.forEach((i) => this.editService.save(i.index));
    }
  }
  static ɵfac = function SaveCommandToolbarDirective_Factory(t) {
    return new (t || _SaveCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SaveCommandToolbarDirective,
    selectors: [["", "kendoGridSaveTool", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SaveCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSaveTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: SelectionService2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var RemoveCommandToolbarDirective = class _RemoveCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  selection;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.remove, ctx, zone, cdr, editService, selection);
    this.editService = editService;
    this.selection = selection;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isSelectionPresent) {
      this.editService.remove(this.lastSelectionIndex);
    }
  }
  static ɵfac = function RemoveCommandToolbarDirective_Factory(t) {
    return new (t || _RemoveCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RemoveCommandToolbarDirective,
    selectors: [["", "kendoGridRemoveTool", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RemoveCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRemoveTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: SelectionService2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var CancelCommandToolbarDirective = class _CancelCommandToolbarDirective extends ToolbarEditingToolBase {
  editService;
  constructor(editService, host, selection, ctx, zone, cdr) {
    super(host, ToolbarToolName.cancel, ctx, zone, cdr, editService, selection);
    this.editService = editService;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.editService.hasNewItem) {
      this.editService.endEdit();
    } else if (this.isSelectionPresent && this.editService.isEdited(this.lastSelectionIndex)) {
      this.editService.endEdit(this.lastSelectionIndex);
    } else {
      this.editService.editedIndices.forEach((i) => this.editService.endEdit(i.index));
    }
  }
  static ɵfac = function CancelCommandToolbarDirective_Factory(t) {
    return new (t || _CancelCommandToolbarDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CancelCommandToolbarDirective,
    selectors: [["", "kendoGridCancelTool", ""]],
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CancelCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCancelTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: ToolBarButtonComponent
    }, {
      type: SelectionService2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var incrementingId = 0;
var GroupCommandToolbarDirective = class _GroupCommandToolbarDirective {
  host;
  popupService;
  ctx;
  ngZone;
  renderer;
  adaptiveGridService;
  popupRef;
  nextId = incrementingId++;
  toolSubs = new Subscription();
  popupSubs;
  actionSheetCloseSub;
  removeClickListener;
  constructor(host, popupService, ctx, ngZone, renderer, adaptiveGridService) {
    this.host = host;
    this.popupService = popupService;
    this.ctx = ctx;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.adaptiveGridService = adaptiveGridService;
  }
  ngOnInit() {
    this.toolSubs = this.host.click.subscribe((e) => this.onClick(e));
    this.toolSubs.add(this.ctx.grid.groupChange.subscribe((group) => {
      this.host.showBadge = this.isGroupingApplied(group);
    }));
    this.host.hasBadgeContainer = true;
    this.host.showBadge = this.isGroupingApplied(this.ctx.grid.group);
    const hasToolbarIcon = isPresent(this.host.toolbarOptions.icon) && this.host.toolbarOptions.icon !== "";
    const hasOverflowIcon = isPresent(this.host.overflowOptions.icon) && this.host.overflowOptions.icon !== "";
    const hasIcon = hasToolbarIcon && hasOverflowIcon;
    const hasSvgIcon = isPresent(this.host.toolbarOptions.svgIcon) && isPresent(this.host.overflowOptions.svgIcon);
    if (!hasIcon) {
      this.host.icon = "group";
    }
    if (!hasSvgIcon) {
      this.host.svgIcon = groupIcon;
    }
  }
  ngAfterViewInit() {
    if (!isPresent(this.host.text)) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.host.text = this.ctx.localization.get(`groupToolbarToolText`);
      });
    }
    this.buttonElement?.setAttribute("aria-haspopup", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.setAttribute("title", this.ctx.localization.get("groupToolbarToolText"));
  }
  ngOnDestroy() {
    if (this.toolSubs) {
      this.toolSubs.unsubscribe();
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.actionSheetCloseSub) {
      this.actionSheetCloseSub.unsubscribe();
      this.actionSheetCloseSub = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  onClick(e) {
    e.preventDefault();
    if (this.ctx.grid.adaptiveMode === "auto" && this.adaptiveGridService.windowSize !== "large") {
      if (!this.ctx.grid.isActionSheetExpanded) {
        this.adaptiveGridService.viewType = "groupToolbarTool";
        this.ctx.grid.adaptiveRenderer.actionSheet.toggle(true);
        this.host.selected = true;
        this.actionSheetCloseSub = this.ctx.grid.adaptiveRenderer.actionSheet.collapse.subscribe(() => this.host.selected = false);
      }
    } else {
      if (this.popupRef) {
        this.closePopup();
        return;
      }
      this.openPopup();
    }
  }
  openPopup() {
    const direction = this.ctx.localization.rtl ? "right" : "left";
    this.popupRef = this.popupService.open({
      anchor: this.buttonElement,
      content: GroupToolbarToolComponent,
      popupClass: "k-grid-columnmenu-popup",
      positionMode: "absolute",
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      }
    });
    this.adaptiveGridService.popupRef = this.popupRef;
    this.setPopupAttributes();
    this.host.selected = true;
    this.ngZone.runOutsideAngular(() => {
      if (!isDocumentAvailable()) {
        return;
      }
      this.removeClickListener = this.renderer.listen("document", "click", (e) => {
        if (this.popupRef && !closest(e.target, (node) => node === this.popupRef.popupElement || node === this.buttonElement)) {
          this.ngZone.run(() => {
            this.closePopup();
          });
        }
      });
    });
    this.popupSubs = this.popupRef.popup.instance.anchorViewportLeave.subscribe(() => {
      this.popupSubs?.unsubscribe();
      this.popupSubs = null;
      this.closePopup();
    });
    this.initPopupProperties();
  }
  setPopupAttributes() {
    const popupElement = this.popupRef.popupElement;
    const popupId = `k-group-tool-${this.nextId}-popup`;
    const popupAriaElement = popupElement.querySelector(".k-popup");
    this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    this.renderer.setAttribute(popupAriaElement, "id", popupId);
    this.renderer.setAttribute(popupAriaElement, "role", "dialog");
    this.buttonElement?.setAttribute("aria-expanded", "true");
    this.buttonElement?.setAttribute("aria-controls", popupId);
  }
  initPopupProperties() {
    this.popupRef.content.instance.ctx = this.ctx;
    this.popupRef.content.instance.hostButton = this.host;
    this.popupSubs.add(this.popupRef.content.instance.groupClear.subscribe(() => {
      this.closePopup();
    }));
    this.popupSubs.add(this.popupRef.content.instance.close.subscribe(() => {
      this.closePopup();
    }));
  }
  closePopup() {
    this.buttonElement?.setAttribute("aria-expanded", "false");
    this.buttonElement?.removeAttribute("aria-controls");
    this.host.selected = false;
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
    if (this.popupSubs) {
      this.popupSubs.unsubscribe();
      this.popupSubs = null;
    }
    if (this.removeClickListener) {
      this.removeClickListener();
      this.removeClickListener = null;
    }
  }
  get buttonElement() {
    return this.host.getButton();
  }
  isGroupingApplied(group) {
    return isPresent(group) && group.length > 0;
  }
  static ɵfac = function GroupCommandToolbarDirective_Factory(t) {
    return new (t || _GroupCommandToolbarDirective)(ɵɵdirectiveInject(ToolBarButtonComponent), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AdaptiveGridService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupCommandToolbarDirective,
    selectors: [["", "kendoGridGroupTool", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupCommandToolbarDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupTool]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ToolBarButtonComponent
    }, {
      type: PopupService
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: AdaptiveGridService
    }];
  }, null);
})();
var KENDO_GRID_COLUMN_DRAGANDDROP = [DraggableColumnDirective, DropTargetDirective];
var KENDO_GRID_SHARED = [ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective];
var KENDO_GRID_GROUP_EXPORTS = [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent];
var KENDO_GRID_FILTER_OPERATORS = [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent];
var KENDO_GRID_FILTER_SHARED = [...KENDO_GRID_SHARED, ...KENDO_GRID_FILTER_OPERATORS, FilterInputDirective];
var KENDO_GRID_FILTER_MENU_EXPORTS = [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective];
var KENDO_GRID_FILTER_MENU = [...KENDO_GRID_FILTER_SHARED, ...KENDO_GRID_FILTER_MENU_EXPORTS];
var KENDO_GRID_FILTER_ROW_EXPORTS = [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent];
var KENDO_GRID_FILTER_ROW = [...KENDO_GRID_FILTER_ROW_EXPORTS, ...KENDO_GRID_FILTER_SHARED];
var KENDO_GRID_COLUMN_MENU_DECLARATIONS = [ColumnMenuChooserItemCheckedDirective, ColumnListComponent, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];
var KENDO_GRID_COLUMN_MENU_EXPORTS = [ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];
var KENDO_GRID_HEADER_EXPORTS = [HeaderComponent2, HeaderTemplateDirective2, ColumnHandleDirective, SelectAllCheckboxDirective];
var KENDO_GRID_FOOTER_EXPORTS = [FooterComponent2];
var KENDO_GRID_BODY_EXPORTS = [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective2, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, GroupCommandToolbarDirective];
var KENDO_GRID_DECLARATIONS = [GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective3, CustomMessagesComponent2, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective, FormComponent, DialogFormComponent, FormFormFieldComponent, UndoRedoDirective];
var KENDO_GRID_EXPORTS = [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, CustomMessagesComponent2, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, ...KENDO_GRID_GROUP_EXPORTS, ...KENDO_GRID_SHARED, ...KENDO_GRID_BODY_EXPORTS, ...KENDO_GRID_HEADER_EXPORTS, ...KENDO_GRID_FILTER_ROW_EXPORTS, ...KENDO_GRID_FILTER_OPERATORS, ...KENDO_GRID_FILTER_MENU_EXPORTS, ...KENDO_GRID_COLUMN_MENU_EXPORTS, GridClipboardDirective, UndoRedoDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective];
var KENDO_GRID_EXCEL_EXPORT = [ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective2, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective];
var KENDO_GRID_PDF_EXPORT = [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective];
var KENDO_GRID = [...KENDO_GRID_EXPORTS, ...KENDO_GRID_EXCEL_EXPORT, ...KENDO_GRID_PDF_EXPORT];
var GridModule = class _GridModule {
  static ɵfac = function GridModule_Factory(t) {
    return new (t || _GridModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _GridModule,
    imports: [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective2, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, GroupCommandToolbarDirective, HeaderComponent2, HeaderTemplateDirective2, ColumnHandleDirective, SelectAllCheckboxDirective, FooterComponent2, CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnMenuChooserItemCheckedDirective, ColumnListComponent, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective3, CustomMessagesComponent2, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective, FormComponent, DialogFormComponent, FormFormFieldComponent, UndoRedoDirective, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, TableDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective],
    exports: [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, CustomMessagesComponent2, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExternalEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent, ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective3, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, LoadingComponent, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective2, EditTemplateDirective, RowDragHandleTemplateDirective, RowDragHintTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, AddCommandToolbarDirective, EditCommandToolbarDirective, SaveCommandToolbarDirective, RemoveCommandToolbarDirective, CancelCommandToolbarDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, SortCommandToolbarDirective, FilterCommandToolbarDirective, GroupCommandToolbarDirective, HeaderComponent2, HeaderTemplateDirective2, ColumnHandleDirective, SelectAllCheckboxDirective, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, ColumnChooserComponent, ColumnChooserToolbarDirective, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridClipboardDirective, UndoRedoDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, ToolBarToolComponent, CustomMessagesComponent, PagerFocusableDirective, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerTemplateDirective, PagerComponent, PagerSpacerComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService],
    imports: [GroupHeaderComponent, GroupPanelComponent, TableBodyComponent, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, HeaderComponent2, CustomMessagesComponent, PagerInfoComponent, PagerInputComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerPageSizesComponent, PagerPrevButtonsComponent, PagerComponent, PagerSpacerComponent, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellWrapperComponent, DateFilterCellComponent, FilterCellOperatorsComponent, FilterCellOperatorsComponent, FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridComponent, ListComponent, FormComponent, DialogFormComponent, FormFormFieldComponent, ToolBarComponent, ToolbarCustomMessagesComponent, ToolBarButtonComponent, ToolBarButtonGroupComponent, ToolBarDropDownButtonComponent, ToolBarSeparatorComponent, ToolBarSpacerComponent, ToolBarSplitButtonComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_GRID_EXPORTS, ...KENDO_TOOLBAR, ...KENDO_PAGER],
      imports: [...KENDO_GRID_GROUP_EXPORTS, ...KENDO_GRID_SHARED, ...KENDO_GRID_BODY_EXPORTS, ...KENDO_GRID_HEADER_EXPORTS, ...KENDO_GRID_FOOTER_EXPORTS, ...KENDO_PAGER, ...KENDO_TOOLBAR, ...KENDO_GRID_FILTER_ROW, ...KENDO_GRID_FILTER_MENU, ...KENDO_GRID_COLUMN_MENU_DECLARATIONS, ...KENDO_GRID_DECLARATIONS, ...KENDO_TOOLBAR, TableDirective, UndoCommandToolbarDirective, RedoCommandToolbarDirective],
      providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService]
    }]
  }], null, null);
})();
var PDFModule = class _PDFModule {
  static ɵfac = function PDFModule_Factory(t) {
    return new (t || _PDFModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PDFModule,
    imports: [IconComponent, SVGIconComponent, PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective],
    exports: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective, PDFCommandToolbarDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [KENDO_ICONS, PDFCommandDirective]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_ICONS, ...KENDO_GRID_PDF_EXPORT],
      exports: [...KENDO_GRID_PDF_EXPORT],
      providers: [IconsService]
    }]
  }], null, null);
})();
var ExcelModule = class _ExcelModule {
  static ɵfac = function ExcelModule_Factory(t) {
    return new (t || _ExcelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ExcelModule,
    imports: [IconComponent, SVGIconComponent, ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective2, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective],
    exports: [ExcelComponent, ExcelCommandDirective, ExcelCommandToolbarDirective, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective2, GroupFooterTemplateDirective, GroupHeaderColumnTemplateDirective, GroupHeaderTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [KENDO_ICONS, ExcelCommandDirective, ColumnComponent, ColumnGroupComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_ICONS, ...KENDO_GRID_EXCEL_EXPORT],
      exports: [...KENDO_GRID_EXCEL_EXPORT],
      providers: [IconsService]
    }]
  }], null, null);
})();
export {
  AddCommandDirective,
  AddCommandToolbarDirective,
  AfterEqFilterOperatorComponent,
  AfterFilterOperatorComponent,
  AutoCompleteFilterCellComponent,
  BaseFilterCellComponent,
  BeforeEqFilterOperatorComponent,
  BeforeFilterOperatorComponent,
  BooleanFilterCellComponent,
  BooleanFilterComponent,
  BooleanFilterMenuComponent,
  BooleanFilterRadioButtonDirective,
  BrowserSupportService,
  CELL_CONTEXT,
  CancelCommandDirective,
  CancelCommandToolbarDirective,
  CellCloseEvent,
  CellComponent,
  CellLoadingTemplateDirective,
  CellSelectionAggregateService,
  CellSelectionService,
  CellTemplateDirective2 as CellTemplateDirective,
  ChangeNotificationService,
  CheckboxColumnComponent,
  ColGroupComponent,
  ColumnBase2 as ColumnBase,
  ColumnChooserComponent,
  ColumnChooserToolbarDirective,
  ColumnComponent2 as ColumnComponent,
  ColumnGroupComponent2 as ColumnGroupComponent,
  ColumnHandleDirective,
  ColumnInfoService,
  ColumnListComponent,
  ColumnLockedChangeEvent,
  ColumnMenuAutoSizeAllColumnsComponent,
  ColumnMenuAutoSizeColumnComponent,
  ColumnMenuChooserComponent,
  ColumnMenuComponent,
  ColumnMenuContainerComponent,
  ColumnMenuFilterComponent,
  ColumnMenuItemComponent,
  ColumnMenuItemContentTemplateDirective,
  ColumnMenuItemDirective,
  ColumnMenuLockComponent,
  ColumnMenuPositionComponent,
  ColumnMenuService,
  ColumnMenuSortComponent,
  ColumnMenuStickComponent,
  ColumnMenuTemplateDirective,
  ColumnReorderEvent,
  ColumnReorderService,
  ColumnResizingService,
  ColumnStickyChangeEvent,
  ColumnVisibilityChangeEvent,
  ColumnsContainer,
  CommandColumnComponent,
  ContainsFilterOperatorComponent,
  ContextService,
  CustomMessagesComponent2 as CustomMessagesComponent,
  DEFAULT_SCROLLER_FACTORY2 as DEFAULT_SCROLLER_FACTORY,
  DataBindingDirective,
  DateFilterCellComponent,
  DateFilterComponent,
  DateFilterMenuComponent,
  DateFilterMenuInputComponent,
  DetailCollapseEvent,
  DetailExpandEvent,
  DetailTemplateDirective,
  DetailsService,
  DoesNotContainFilterOperatorComponent,
  DomEventsService,
  DragAndDropService,
  DragHintService,
  DropCueService,
  EditCommandDirective,
  EditCommandToolbarDirective,
  EditService as EditServiceClass,
  EditTemplateDirective,
  EditingDirectiveBase,
  EndsWithFilterOperatorComponent,
  EqualFilterOperatorComponent,
  ExcelCommandDirective,
  ExcelCommandToolbarDirective,
  ExcelComponent,
  ExcelExportEvent,
  ExcelModule,
  ExcelService,
  ExpandDetailsDirective,
  ExpandGroupDirective,
  ExternalEditingDirective,
  FieldAccessorPipe,
  FilterCellComponent,
  FilterCellHostDirective,
  FilterCellOperatorsComponent,
  FilterCellTemplateDirective,
  FilterCellWrapperComponent,
  FilterCommandToolbarDirective,
  FilterInputDirective,
  FilterMenuComponent,
  FilterMenuContainerComponent,
  FilterMenuDropDownListDirective,
  FilterMenuHostDirective,
  FilterMenuInputWrapperComponent,
  FilterMenuTemplateDirective,
  FilterRowComponent,
  FilterService,
  FocusRoot,
  FocusableDirective,
  FooterComponent2 as FooterComponent,
  FooterTemplateDirective3 as FooterTemplateDirective,
  GreaterFilterOperatorComponent,
  GreaterOrEqualToFilterOperatorComponent,
  GridClipboardDirective,
  GridComponent,
  GridModule,
  GridSpacerComponent,
  GridTableDirective,
  GridToolbarFocusableDirective,
  GridToolbarNavigationService,
  GroupBindingDirective,
  GroupCommandToolbarDirective,
  GroupFooterTemplateDirective2 as GroupFooterTemplateDirective,
  GroupHeaderColumnTemplateDirective2 as GroupHeaderColumnTemplateDirective,
  GroupHeaderComponent,
  GroupHeaderTemplateDirective2 as GroupHeaderTemplateDirective,
  GroupInfoService,
  GroupPanelComponent,
  GroupsService,
  HeaderComponent2 as HeaderComponent,
  HeaderTemplateDirective2 as HeaderTemplateDirective,
  IdService,
  InCellEditingDirective,
  IsEmptyFilterOperatorComponent,
  IsNotEmptyFilterOperatorComponent,
  IsNotNullFilterOperatorComponent,
  IsNullFilterOperatorComponent,
  KENDO_GRID,
  KENDO_GRID_BODY_EXPORTS,
  KENDO_GRID_COLUMN_DRAGANDDROP,
  KENDO_GRID_COLUMN_MENU_DECLARATIONS,
  KENDO_GRID_COLUMN_MENU_EXPORTS,
  KENDO_GRID_DECLARATIONS,
  KENDO_GRID_EXCEL_EXPORT,
  KENDO_GRID_EXPORTS,
  KENDO_GRID_FILTER_MENU,
  KENDO_GRID_FILTER_MENU_EXPORTS,
  KENDO_GRID_FILTER_OPERATORS,
  KENDO_GRID_FILTER_ROW,
  KENDO_GRID_FILTER_ROW_EXPORTS,
  KENDO_GRID_FILTER_SHARED,
  KENDO_GRID_FOOTER_EXPORTS,
  KENDO_GRID_GROUP_EXPORTS,
  KENDO_GRID_HEADER_EXPORTS,
  KENDO_GRID_PDF_EXPORT,
  KENDO_GRID_SHARED,
  LessFilterOperatorComponent,
  LessOrEqualToFilterOperatorComponent,
  ListComponent,
  LoadingComponent,
  LoadingTemplateDirective,
  LocalDataChangesService,
  LogicalCellDirective,
  LogicalRowDirective,
  MenuTabbingService,
  NavigationService2 as NavigationService,
  NoRecordsTemplateDirective,
  NotEqualFilterOperatorComponent,
  NumericFilterCellComponent,
  NumericFilterComponent,
  NumericFilterMenuComponent,
  NumericFilterMenuInputComponent,
  PDFCommandDirective,
  PDFCommandToolbarDirective,
  PDFComponent,
  PDFMarginComponent,
  PDFModule,
  PDFService,
  PDFTemplateDirective,
  PopupCloseEvent,
  ReactiveEditingDirective,
  RedoCommandToolbarDirective,
  RemoveCommandDirective,
  RemoveCommandToolbarDirective,
  ResizableContainerDirective,
  ResizeService,
  ResponsiveService,
  RowDragHandleTemplateDirective,
  RowDragHintTemplateDirective,
  RowEditingDirectiveBase,
  RowReorderColumnComponent,
  RowReorderService,
  SaveCommandDirective,
  SaveCommandToolbarDirective,
  ScrollRequestService,
  ScrollSyncService2 as ScrollSyncService,
  SelectAllCheckboxDirective,
  SelectionCheckboxDirective,
  SelectionDirective,
  SelectionService2 as SelectionService,
  SinglePopupService,
  SizingOptionsService,
  Skip,
  SortCommandToolbarDirective,
  SortService,
  SpanColumnComponent,
  StartsWithFilterOperatorComponent,
  StatusBarTemplateDirective,
  StringFilterCellComponent,
  StringFilterComponent,
  StringFilterMenuComponent,
  StringFilterMenuInputComponent,
  SuspendService,
  TableBodyComponent,
  TableDirective,
  TemplateEditingDirective,
  ToolbarComponent,
  ToolbarTemplateDirective,
  UndoCommandToolbarDirective,
  UndoRedoDirective,
  UndoRedoEvent,
  count,
  defaultTrackBy,
  hasFilterMenu,
  hasFilterRow,
  isFilterable,
  slice
};
//# sourceMappingURL=@progress_kendo-angular-grid.js.map
