import {
  class_default,
  color_default,
  drawing_exports,
  geometry_exports,
  logToConsole,
  parseColor,
  support_default,
  throttle
} from "./chunk-ZJJ2SPTS.js";

// node_modules/@progress/kendo-charts/dist/es/common/is-function.js
function isFunction(fn) {
  return typeof fn === "function";
}

// node_modules/@progress/kendo-charts/dist/es/common/deep-extend.js
var OBJECT = "object";
var UNDEFINED = "undefined";
function deepExtendOne(destination, source) {
  for (let property in source) {
    if (property === "__proto__" || property === "constructor") {
      continue;
    }
    let propValue = source[property];
    let propType = typeof propValue;
    let propInit;
    if (propType === OBJECT && propValue !== null) {
      propInit = propValue.constructor;
    } else {
      propInit = null;
    }
    if (propInit && propInit !== Array) {
      if (propValue instanceof Date) {
        destination[property] = new Date(propValue.getTime());
      } else if (isFunction(propValue.clone)) {
        destination[property] = propValue.clone();
      } else {
        let destProp = destination[property];
        if (typeof destProp === OBJECT) {
          destination[property] = destProp || {};
        } else {
          destination[property] = {};
        }
        deepExtendOne(destination[property], propValue);
      }
    } else if (propType !== UNDEFINED) {
      destination[property] = propValue;
    }
  }
  return destination;
}
function deepExtend(destination) {
  const length = arguments.length;
  for (let i = 1; i < length; i++) {
    deepExtendOne(destination, arguments[i]);
  }
  return destination;
}

// node_modules/@progress/kendo-charts/dist/es/common/instance-observer.js
var TRIGGER = "trigger";
var InstanceObserver = class {
  constructor(observer, handlers) {
    this.observer = observer;
    this.handlerMap = deepExtend({}, this.handlerMap, handlers);
  }
  trigger(name, args) {
    const { observer, handlerMap } = this;
    let isDefaultPrevented2;
    if (handlerMap[name]) {
      isDefaultPrevented2 = this.callObserver(handlerMap[name], args);
    } else if (observer[TRIGGER]) {
      isDefaultPrevented2 = this.callObserver(TRIGGER, name, args);
    }
    return isDefaultPrevented2;
  }
  callObserver(fnName, ...args) {
    return this.observer[fnName].apply(this.observer, args);
  }
  requiresHandlers(names) {
    if (this.observer.requiresHandlers) {
      return this.observer.requiresHandlers(names);
    }
    for (let idx = 0; idx < names.length; idx++) {
      if (this.handlerMap[names[idx]]) {
        return true;
      }
    }
  }
};
var instance_observer_default = InstanceObserver;

// node_modules/@progress/kendo-charts/dist/es/common/is-array.js
function isArray(value2) {
  return Array.isArray(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/add-class.js
function addClass(element, classes) {
  const classArray = isArray(classes) ? classes : [classes];
  for (let idx = 0; idx < classArray.length; idx++) {
    const className = classArray[idx];
    if (element.className.indexOf(className) === -1) {
      element.className += " " + className;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/remove-class.js
var SPACE_REGEX = /\s+/g;
function removeClass(element, className) {
  if (element && element.className) {
    element.className = element.className.replace(className, "").replace(SPACE_REGEX, " ");
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/align-path-to-pixel.js
function alignPathToPixel(path) {
  let offset = 0.5;
  if (path.options.stroke && drawing_exports.util.defined(path.options.stroke.width)) {
    if (path.options.stroke.width % 2 === 0) {
      offset = 0;
    }
  }
  for (let i = 0; i < path.segments.length; i++) {
    path.segments[i].anchor().round(0).translate(offset, offset);
  }
  return path;
}

// node_modules/@progress/kendo-charts/dist/es/common/clockwise.js
function clockwise(angle1, angle2) {
  return -angle1.x * angle2.y + angle1.y * angle2.x < 0;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-number.js
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/constants.js
var ARC = "arc";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var TAB = "Tab";
var ARIA_ACTIVE_DESCENDANT = "aria-activedescendant";
var AXIS_LABEL_CLICK = "axisLabelClick";
var BLACK = "#000";
var BOTTOM = "bottom";
var CENTER = "center";
var CIRCLE = "circle";
var COORD_PRECISION = 3;
var CROSS = "cross";
var DATE = "date";
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_HEIGHT = 400;
var DEFAULT_PRECISION = 10;
var DEFAULT_WIDTH = 600;
var END = "end";
var ENTER = "Enter";
var ESCAPE = "Escape";
var FORMAT_REGEX = /\{\d+:?/;
var HEIGHT = "height";
var HIGHLIGHT_ZINDEX = 100;
var INSIDE = "inside";
var INHERIT = "inherit";
var LEFT = "left";
var MAX_VALUE = Number.MAX_VALUE;
var MIN_VALUE = -Number.MAX_VALUE;
var NONE = "none";
var NOTE_CLICK = "noteClick";
var NOTE_HOVER = "noteHover";
var NOTE_LEAVE = "noteLeave";
var OBJECT2 = "object";
var OUTSIDE = "outside";
var RIGHT = "right";
var ROUNDED_RECT = "roundedRect";
var START = "start";
var STRING = "string";
var TOP = "top";
var TRIANGLE = "triangle";
var SQUARE = "square";
var RECT = "rect";
var VALUE = "value";
var WHITE = "#fff";
var WIDTH = "width";
var X = "x";
var Y = "y";
var DEFAULT_SERIES_OPACITY = 1;
var POINTER = "pointer";
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";

// node_modules/@progress/kendo-charts/dist/es/common/is-string.js
function isString(value2) {
  return typeof value2 === STRING;
}

// node_modules/@progress/kendo-charts/dist/es/common/convertable-to-number.js
function convertableToNumber(value2) {
  return isNumber(value2) || isString(value2) && isFinite(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleUp.js
function cycleUp(index, count) {
  return (index + 1) % count;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleDown.js
function cycleDown(index, count) {
  let result = index - 1;
  return result < 0 ? count - 1 : result;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleIndex.js
function cycleIndex(index, length) {
  if (length === 1 || index % length === 0) {
    return 0;
  }
  if (index < 0) {
    return length + index % length;
  } else if (index >= length) {
    return index % length;
  }
  return index;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-object.js
function isObject(value2) {
  return typeof value2 === "object";
}

// node_modules/@progress/kendo-charts/dist/es/common/style-value.js
function styleValue(value2) {
  if (isNumber(value2)) {
    return value2 + "px";
  }
  return value2;
}

// node_modules/@progress/kendo-charts/dist/es/common/element-styles.js
var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;
function isSizeField(field) {
  return SIZE_STYLES_REGEX.test(field);
}
function elementStyles(element, styles) {
  const stylesArray = isString(styles) ? [styles] : styles;
  if (isArray(stylesArray)) {
    const result = {};
    const style = window.getComputedStyle(element);
    for (let idx = 0; idx < stylesArray.length; idx++) {
      let field = stylesArray[idx];
      result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];
    }
    return result;
  } else if (isObject(styles)) {
    for (let field in styles) {
      element.style[field] = styleValue(styles[field]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-spacing.js
function getSpacing(value2, defaultSpacing = 0) {
  const spacing = { top: 0, right: 0, bottom: 0, left: 0 };
  if (typeof value2 === "number") {
    spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value2;
  } else {
    spacing[TOP] = value2[TOP] || defaultSpacing;
    spacing[RIGHT] = value2[RIGHT] || defaultSpacing;
    spacing[BOTTOM] = value2[BOTTOM] || defaultSpacing;
    spacing[LEFT] = value2[LEFT] || defaultSpacing;
  }
  return spacing;
}

// node_modules/@progress/kendo-charts/dist/es/services/template-service.js
var current = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = class {
  static register(userImplementation) {
    current = userImplementation;
  }
  static compile(template, options) {
    return current.compile(template, options);
  }
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-charts/dist/es/common/get-template.js
function getTemplate(options = {}) {
  let template;
  if (options.template) {
    options.template = template = template_service_default.compile(options.template);
  } else if (isFunction(options.content)) {
    template = options.content;
  }
  return template;
}

// node_modules/@progress/kendo-charts/dist/es/common/get-aria-template.js
function getTemplate2(options = {}) {
  let ariaTemplate;
  if (options.ariaTemplate) {
    options.ariaTemplate = ariaTemplate = template_service_default.compile(options.ariaTemplate);
  } else if (isFunction(options.ariaContent)) {
    ariaTemplate = options.ariaContent;
  }
  return ariaTemplate;
}

// node_modules/@progress/kendo-charts/dist/es/common/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
getterCache["undefined"] = function(obj) {
  return obj;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  const fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(drawing_exports.util.defined(index) ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    let result = obj;
    for (let idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-charts/dist/es/common/grep.js
function grep(array, callback) {
  const length = array.length;
  const result = [];
  for (let idx = 0; idx < length; idx++) {
    if (callback(array[idx])) {
      result.push(array[idx]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/has-classes.js
function hasClasses(element, classNames) {
  if (element.className) {
    const names = classNames.split(" ");
    for (let idx = 0; idx < names.length; idx++) {
      if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/hash-map.js
var HashMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get(key) {
    return this._map.get(key);
  }
  set(key, value2) {
    this._map.set(key, value2);
  }
};

// node_modules/@progress/kendo-charts/dist/es/common/in-array.js
function inArray(value2, array) {
  if (array) {
    return array.indexOf(value2) !== -1;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/interpolate-value.js
function interpolateValue(start, end, progress) {
  return drawing_exports.util.round(start + (end - start) * progress, COORD_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-plain-object.js
function isPlainObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}

// node_modules/@progress/kendo-charts/dist/es/common/map.js
function map(array, callback) {
  const length = array.length;
  const result = [];
  for (let idx = 0; idx < length; idx++) {
    let value2 = callback(array[idx]);
    if (drawing_exports.util.defined(value2)) {
      result.push(value2);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/mousewheel-delta.js
var browser = support_default.browser || {};
function mousewheelDelta(e) {
  let delta = 0;
  if (e.wheelDelta) {
    delta = -e.wheelDelta / 120;
    if (browser.webkit) {
      delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));
    }
  } else if (e.detail) {
    delta = e.detail / 3;
  }
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  return delta;
}

// node_modules/@progress/kendo-charts/dist/es/drawing-utils.js
var {
  append,
  bindEvents,
  defined,
  deg,
  elementOffset,
  elementSize,
  eventCoordinates,
  eventElement,
  hashKey,
  last,
  limitValue,
  objectKey,
  rad,
  round,
  unbindEvents,
  valueOrDefault
} = drawing_exports.util;

// node_modules/@progress/kendo-charts/dist/es/common/font-loader.js
var FontLoader = class _FontLoader {
  static fetchFonts(options, fonts, state = { depth: 0 }) {
    const MAX_DEPTH = 5;
    if (!options || state.depth > MAX_DEPTH || !document.fonts) {
      return;
    }
    Object.keys(options).forEach(function(key) {
      const value2 = options[key];
      if (key === "dataSource" || key[0] === "$" || !value2) {
        return;
      }
      if (key === "font") {
        fonts.push(value2);
      } else if (typeof value2 === "object") {
        state.depth++;
        _FontLoader.fetchFonts(value2, fonts, state);
        state.depth--;
      }
    });
  }
  static loadFonts(fonts, callback) {
    let promises = [];
    if (fonts.length > 0 && document.fonts) {
      try {
        promises = fonts.map(function(font) {
          return document.fonts.load(font);
        });
      } catch (e) {
        logToConsole(e);
      }
      Promise.all(promises).then(callback, callback);
    } else {
      callback();
    }
  }
  static preloadFonts(options, callback) {
    const fonts = [];
    _FontLoader.fetchFonts(options, fonts);
    _FontLoader.loadFonts(fonts, callback);
  }
};
var font_loader_default = FontLoader;

// node_modules/@progress/kendo-charts/dist/es/common/set-default-options.js
function setDefaultOptions(type, options) {
  const proto = type.prototype;
  if (proto.options) {
    proto.options = deepExtend({}, proto.options, options);
  } else {
    proto.options = options;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/render-icon.js
var KICON = "k-icon";
var KI_PREFFIX = "k-i-";
var KFONTICON = "k-font-icon";
var KSVGICON = "k-svg-icon";
var KSVG_PREFFIX = "k-svg-i-";
var HTMLBaseIcon = class {
  constructor(element, options) {
    this.element = element;
    this.options = deepExtend({}, this.options, options);
    this.wrapper();
  }
  wrapper() {
    this.addClasses();
  }
  addClasses() {
  }
  html() {
    return this.element.outerHTML;
  }
};
setDefaultOptions(HTMLBaseIcon, {
  name: "",
  size: "none",
  themeColor: "none",
  flip: "default",
  iconClass: "",
  stylingOptions: ["size", "themeColor", "fill"]
});
var HTMLFontIcon = class extends HTMLBaseIcon {
  constructor(element, options) {
    super(element, options);
  }
  wrapper() {
    let currentIconClass = this.element.className.split(" ").find((x) => x.startsWith(KI_PREFFIX));
    let className = this.options.icon ? `${this.options.icon.startsWith(KI_PREFFIX) ? "" : KI_PREFFIX}${this.options.icon}` : "";
    this._className = className;
    addClass(this.element, KICON);
    addClass(this.element, KFONTICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, this.options.iconClass || "");
    super.wrapper();
  }
};
setDefaultOptions(HTMLFontIcon, {
  name: "HTMLFontIcon",
  icon: null
});
var HTMLSvgIcon = class extends HTMLBaseIcon {
  constructor(element, options) {
    element.innerHTML = "";
    super(element, options);
  }
  wrapper() {
    let icon = this.options.icon;
    let iconClass = this.options.iconClass;
    let currentIconClass = this.element.className.split(" ").find((x) => x.startsWith(KSVG_PREFFIX));
    if (!icon && iconClass) {
      const regex = /k-i-(\w+(?:-\w+)*)/;
      let iconNameMatch = iconClass.match(regex);
      if (iconNameMatch) {
        icon = iconNameMatch[1];
        iconClass = iconClass.replace(iconNameMatch[0], "");
      }
    }
    if (isString(icon)) {
      icon = icon.replace("k-i-", "").replace(/-./g, (x) => x[1].toUpperCase());
      icon = this.options.svgIcons[icon] || this.options.svgIcons[`${icon}Icon`];
    }
    let className = icon && icon.name ? `${KSVG_PREFFIX}${icon.name}` : "";
    this._className = className;
    addClass(this.element, KSVGICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, iconClass || "");
    this.element.setAttribute("aria-hidden", "true");
    if (icon && isPlainObject(icon)) {
      let svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgElement.setAttribute("viewBox", icon.viewBox || "");
      svgElement.setAttribute("focusable", "false");
      svgElement.innerHTML = icon.content || "";
      this.element.appendChild(svgElement);
    }
    super.wrapper();
  }
};
setDefaultOptions(HTMLSvgIcon, {
  name: "HTMLSvgIcon",
  icon: null,
  svgIcons: {}
});
var ICON_TYPES = {
  "svg": HTMLSvgIcon,
  "font": HTMLFontIcon
};
function renderIcon(iconElement, iconOptions) {
  let element = iconElement;
  let options = iconOptions;
  if (!element || isObject(element) && !(element instanceof HTMLElement) || isString(element)) {
    options = element;
    element = document.createElement("span");
  }
  if (isString(options)) {
    options = {
      icon: options
    };
  }
  if (!options.type) {
    options.type = "svg";
  }
  if (!ICON_TYPES[options.type]) {
    return null;
  }
  return new ICON_TYPES[options.type](element, options).html();
}

// node_modules/@progress/kendo-charts/dist/es/common/sparse-array-limits.js
function sparseArrayLimits(arr) {
  let min4 = MAX_VALUE;
  let max3 = MIN_VALUE;
  for (let idx = 0, length = arr.length; idx < length; idx++) {
    const value2 = arr[idx];
    if (value2 !== null && isFinite(value2)) {
      min4 = Math.min(min4, value2);
      max3 = Math.max(max3, value2);
    }
  }
  return {
    min: min4 === MAX_VALUE ? void 0 : min4,
    max: max3 === MIN_VALUE ? void 0 : max3
  };
}

// node_modules/@progress/kendo-charts/dist/es/common/find.js
function find(array, predicate) {
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    if (predicate(item, i, array)) {
      return item;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/element-scale.js
var Matrix = geometry_exports.Matrix;
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  const match = matrixString.match(matrixRegexp);
  if (match === null || match.length !== 2) {
    return Matrix.unit();
  }
  const members = match[1].split(",").map((x) => parseFloat(x));
  return new Matrix(...members);
}
function transformMatrix(element) {
  const transform = getComputedStyle(element).transform;
  if (transform === "none") {
    return Matrix.unit();
  }
  return parseMatrix(transform);
}
function elementScale(element) {
  if (!element) {
    return Matrix.unit();
  }
  let matrix = transformMatrix(element);
  let parent = element.parentElement;
  while (parent) {
    const parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-charts/dist/es/common/auto-text-color.js
function autoTextColor(color) {
  const isDark = new color_default(color).isDark();
  if (isDark) {
    return WHITE;
  }
  return BLACK;
}
var auto_text_color_default = autoTextColor;

// node_modules/@progress/kendo-charts/dist/es/common/create-hash-set.js
var DELETED = {};
var LegacySet = class {
  constructor(values) {
    this._index = {};
    this._values = values ? values.slice(0) : [];
    for (let i = 0; i < this._values.length; i++) {
      this._index[this._values[i]] = i;
    }
  }
  values() {
    return this._values.filter((item) => item !== DELETED);
  }
  has(value2) {
    return this._index[value2] !== void 0;
  }
  add(value2) {
    if (!this.has(value2)) {
      this._index[value2] = this._values.length;
      this._values.push(value2);
    }
  }
  delete(value2) {
    const index = this._index[value2];
    if (index !== void 0) {
      this._values[index] = DELETED;
      delete this._index[value2];
    }
  }
  clear() {
    this._index = {};
    this._values = [];
  }
  get size() {
    return this._values.length;
  }
};
var SetWrapper = class {
  constructor(values) {
    this._set = new Set(values);
  }
  values() {
    return Array.from(this._set);
  }
  has(value2) {
    return this._set.has(value2);
  }
  add(value2) {
    this._set.add(value2);
  }
  delete(value2) {
    this._set.delete(value2);
  }
  clear() {
    this._set.clear();
  }
  get size() {
    return this._set.size;
  }
};
var supportsSet = () => {
  let supported = false;
  if (typeof Set === "function") {
    const set = /* @__PURE__ */ new Set([1]);
    supported = set.has(1);
  }
  return supported;
};
function createHashSet(values) {
  if (supportsSet()) {
    return new SetWrapper(values);
  }
  return new LegacySet(values);
}

// node_modules/@progress/kendo-charts/dist/es/common/default-error-handler.js
function defaultErrorHandler(error) {
  throw error;
}

// node_modules/@progress/kendo-charts/dist/es/common/keys.js
var keys = {
  INSERT: 45,
  DELETE: 46,
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  END: 35,
  HOME: 36,
  SPACEBAR: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  F2: 113,
  F10: 121,
  F12: 123,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_DOT: 110
};
var keys_default = keys;

// node_modules/@progress/kendo-charts/dist/es/common/has-own-property.js
function hasOwnProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}

// node_modules/@progress/kendo-charts/dist/es/common/matrix.js
var Matrix2 = class _Matrix {
  constructor() {
    this.height = 0;
    this.width = 0;
    this.data = [];
  }
  clone() {
    const m = new _Matrix();
    m.height = this.height;
    m.width = this.width;
    m.data = this.data.map((row) => row.slice());
    return m;
  }
  get(row, col) {
    const line = this.data[row];
    const val = line ? line[col] : null;
    return val;
  }
  set(row, col, data) {
    let line = this.data[row];
    if (line == null) {
      line = this.data[row] = [];
    }
    line[col] = data;
    if (row >= this.height) {
      this.height = row + 1;
    }
    if (col >= this.width) {
      this.width = col + 1;
    }
  }
  each(f, includeEmpty) {
    for (let row = 0; row < this.height; ++row) {
      for (let col = 0; col < this.width; ++col) {
        let val = this.get(row, col);
        if (includeEmpty || val != null) {
          val = f(val, row, col);
          if (val !== void 0) {
            return val;
          }
        }
      }
    }
  }
  map(f, includeEmpty) {
    const m = new _Matrix();
    this.each(function(el, row, col) {
      m.set(row, col, f(el, row, col));
    }, includeEmpty);
    return m;
  }
  transpose() {
    const m = new _Matrix();
    this.each(function(el, row, col) {
      m.set(col, row, el);
    });
    return m;
  }
  unit(n) {
    this.width = this.height = n;
    const a = this.data = new Array(n);
    for (let i = n; --i >= 0; ) {
      const row = a[i] = new Array(n);
      for (let j = n; --j >= 0; ) {
        row[j] = i === j ? 1 : 0;
      }
    }
    return this;
  }
  multiply(b) {
    const a = this;
    const m = new _Matrix();
    for (let row = 0; row < a.height; ++row) {
      for (let col = 0; col < b.width; ++col) {
        let s = 0;
        for (let i = 0; i < a.width; ++i) {
          const va = a.get(row, i);
          const vb = b.get(i, col);
          if (typeof va === "number" && typeof vb === "number") {
            s += va * vb;
          }
        }
        m.set(row, col, s);
      }
    }
    return m;
  }
  inverse() {
    const n = this.width;
    const m = this.augment(new _Matrix().unit(n));
    const a = m.data;
    for (let k = 0; k < n; ++k) {
      const imax = argmax(k, n, function(i) {
        return a[i][k];
      });
      if (!a[imax][k]) {
        return null;
      }
      if (k !== imax) {
        let tmp = a[k];
        a[k] = a[imax];
        a[imax] = tmp;
      }
      for (let i = k + 1; i < n; ++i) {
        for (let j = k + 1; j < 2 * n; ++j) {
          a[i][j] -= a[k][j] * a[i][k] / a[k][k];
        }
        a[i][k] = 0;
      }
    }
    for (let i = 0; i < n; ++i) {
      for (let f = a[i][i], j = 0; j < 2 * n; ++j) {
        a[i][j] /= f;
      }
    }
    for (let k = n; --k >= 0; ) {
      for (let i = k; --i >= 0; ) {
        if (a[i][k]) {
          for (let j = 2 * n; --j >= n; ) {
            a[i][j] -= a[k][j] * a[i][k];
          }
        }
      }
    }
    return m.slice(0, n, n, n);
  }
  augment(m) {
    const ret = this.clone();
    const n = ret.width;
    m.each(function(val, row, col) {
      ret.set(row, col + n, val);
    });
    return ret;
  }
  slice(row, col, height, width) {
    const m = new _Matrix();
    for (let i = 0; i < height; ++i) {
      for (let j = 0; j < width; ++j) {
        m.set(i, j, this.get(row + i, col + j));
      }
    }
    return m;
  }
};
function argmax(start, end, f) {
  let max3 = f(start), pos = start;
  for (let i = start + 1; i < end; i++) {
    const v = f(start);
    if (v > max3) {
      max3 = v;
      pos = start;
    }
  }
  return pos;
}
var matrix_default = Matrix2;

// node_modules/@progress/kendo-charts/dist/es/common/event-map.js
var eventMap = {
  down: "pointerdown",
  move: "pointermove",
  up: "pointerup",
  cancel: "pointercancel pointerleave"
};
function queryEventMap(e) {
  return eventMap[e] || e;
}
var applyEventMap = (events) => {
  const eventRegEx = /([^ ]+)/g;
  const appliedEvents = events.replace(eventRegEx, queryEventMap);
  return appliedEvents;
};

// node_modules/@progress/kendo-charts/dist/es/core/utils/guid.js
function guid() {
  let id = "";
  let i;
  let random;
  for (i = 0; i < 32; i++) {
    random = Math.random() * 16 | 0;
    if (i === 8 || i === 12 || i === 16 || i === 20) {
      id += "-";
    }
    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
  }
  return id;
}

// node_modules/@progress/kendo-charts/dist/es/common/event-utils.js
var elementEventHandlers = /* @__PURE__ */ new WeakMap();
var ID = Symbol("id");
function on(element, events, filter, handler, useCapture) {
  addEventListeners(element, events, filter, handler, useCapture);
}
function off(element, events, filter, handler, useCapture) {
  removeEventListeners(element, events, filter, handler, useCapture);
}
function isString2(value2) {
  return typeof value2 === "string";
}
function addEventListeners(element, events, filter, handler, useCapture) {
  const eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    addEventListener(element, eventName, filter, handler, useCapture);
  });
}
function addEventListener(element, event, filter, handler, useCapture) {
  let eventHandler = handler;
  let eventFilter;
  if (filter && isFunction(filter) && !handler) {
    eventHandler = filter;
  } else if (filter && isString2(filter) && isFunction(eventHandler)) {
    eventFilter = filter;
  }
  const attachedHandler = function(e) {
    const closestMatchingTarget = e.target ? e.target.closest(eventFilter) : null;
    if (!eventFilter || eventFilter && e.target && closestMatchingTarget) {
      const currentTarget = eventFilter ? closestMatchingTarget : e.currentTarget;
      Object.defineProperty(e, "currentTarget", { value: currentTarget });
      Object.defineProperty(e, "delegateTarget", { value: element });
      eventHandler(e);
    }
  };
  if (!eventHandler[ID]) {
    eventHandler[ID] = guid();
  }
  let eventHandlers = elementEventHandlers.get(element);
  if (!eventHandlers) {
    eventHandlers = /* @__PURE__ */ new Map();
    elementEventHandlers.set(element, eventHandlers);
  }
  eventHandlers.set(event + eventHandler[ID], attachedHandler);
  element.addEventListener(event, attachedHandler, Boolean(useCapture));
}
function removeEventListeners(element, events, handler, useCapture) {
  const eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    removeEventListener(element, eventName, handler, useCapture);
  });
}
function removeEventListener(element, event, handler, useCapture) {
  const eventHandlers = elementEventHandlers.get(element);
  if (eventHandlers && handler && handler[ID]) {
    const handlerId = event + handler[ID];
    const attachedHandler = eventHandlers.get(handlerId);
    eventHandlers.delete(handlerId);
    if (attachedHandler) {
      element.removeEventListener(event, attachedHandler, Boolean(useCapture));
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-supported-features.js
function getSupportedFeatures() {
  const os = detectOS(navigator.userAgent);
  const support = {};
  support.mobileOS = os;
  return support;
}
function detectOS(ua) {
  let os = false;
  const agentRxs = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.?(\d+(\.\d+)?)?/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i
  }, osRxs = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i
  };
  for (let agent in agentRxs) {
    let match = ua.match(agentRxs[agent]);
    if (match) {
      if (agent === "windows" && "plugins" in navigator) {
        return false;
      }
      os = {};
      os.device = agent;
      os.name = testRegex(agent, osRxs);
      os[os.name] = true;
      break;
    }
  }
  return os;
}
function testRegex(agent, regexes, dflt) {
  for (let regex in regexes) {
    if (regexes[regex].test(agent)) {
      return regex;
    }
  }
  return dflt !== void 0 ? dflt : agent;
}

// node_modules/@progress/kendo-charts/dist/es/common/noop.js
function noop() {
}

// node_modules/@progress/kendo-charts/dist/es/common/now.js
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}

// node_modules/@progress/kendo-charts/dist/es/common/observable.js
var STRING2 = "string";
var FUNCTION = "function";
var preventDefault = function() {
  this._defaultPrevented = true;
};
var isDefaultPrevented = function() {
  return this._defaultPrevented === true;
};
var Observable = class extends class_default {
  constructor() {
    super();
    this._events = {};
  }
  destroy() {
    this.unbind();
  }
  bind(event, handlers, one) {
    let that = this, idx, eventNames = typeof event === STRING2 ? [event] : event || [], length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    if (handlers === void 0) {
      for (idx in event) {
        that.bind(idx, event[idx]);
      }
      return that;
    }
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      let eventName = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName];
      if (handler) {
        if (one) {
          original = handler;
          handler = function() {
            that.unbind(eventName, handler);
            original.apply(that, arguments);
          };
          handler.original = original;
        }
        events = that._events[eventName] = that._events[eventName] || [];
        events.push(handler);
      }
    }
    return that;
  }
  one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  }
  first(eventName, handlers) {
    let that = this, idx, eventNames = typeof eventName === STRING2 ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      let eventName2 = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName2];
      if (handler) {
        events = that._events[eventName2] = that._events[eventName2] || [];
        events.unshift(handler);
      }
    }
    return that;
  }
  trigger(eventName, eventArgs) {
    let that = this, events = that._events[eventName], idx, length;
    if (events) {
      let e = eventArgs || {};
      e.sender = that;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault;
      e.isDefaultPrevented = isDefaultPrevented;
      events = events.slice();
      for (idx = 0, length = events.length; idx < length; idx++) {
        events[idx].call(that, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  }
  unbind(eventName, handler) {
    let that = this, events = that._events[eventName], idx;
    if (eventName === void 0) {
      that._events = {};
    } else if (events) {
      if (handler) {
        for (idx = events.length - 1; idx >= 0; idx--) {
          if (events[idx] === handler || events[idx].original === handler) {
            events.splice(idx, 1);
          }
        }
      } else {
        that._events[eventName] = [];
      }
    }
    return that;
  }
  _setEvents(options) {
    const length = (this.events || []).length;
    for (let idx = 0; idx < length; idx++) {
      let e = this.events[idx];
      if (this.options[e] && options[e]) {
        this.unbind(e, this.options[e]);
        if (this._events && this._events[e]) {
          delete this._events[e];
        }
      }
    }
    this.bind(this.events, options);
  }
};

// node_modules/@progress/kendo-charts/dist/es/common/user-events.js
var extend = Object.assign;
var preventDefault2 = (e) => {
  e.preventDefault();
};
var DEFAULT_MIN_HOLD = 800;
var CLICK_DELAY = 300;
var DEFAULT_THRESHOLD = 0;
var PRESS = "press";
var HOLD = "hold";
var SELECT = "select";
var START2 = "start";
var MOVE = "move";
var END2 = "end";
var CANCEL = "cancel";
var TAP = "tap";
var DOUBLETAP = "doubleTap";
var RELEASE = "release";
var GESTURESTART = "gesturestart";
var GESTURECHANGE = "gesturechange";
var GESTUREEND = "gestureend";
var GESTURETAP = "gesturetap";
var THRESHOLD = {
  "api": 0,
  "touch": 0,
  "mouse": 9,
  "pointer": 9
};
function touchDelta(touch1, touch2) {
  let x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;
  return {
    center: {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    },
    distance: Math.sqrt(dx * dx + dy * dy)
  };
}
function getTouches(e) {
  let touches = [], originalEvent = e.originalEvent || e, currentTarget = e.currentTarget;
  if (e.api) {
    touches.push({
      id: 2,
      // hardcoded ID for API call
      event: e,
      target: e.target,
      currentTarget: e.target,
      location: e,
      type: "api"
    });
  } else {
    touches.push({
      location: originalEvent,
      event: e,
      target: e.target,
      currentTarget,
      id: originalEvent.pointerId,
      type: "pointer"
    });
  }
  return touches;
}
var TouchAxis = class extends class_default {
  constructor(axis, location) {
    super();
    let that = this;
    that.support = getSupportedFeatures();
    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;
    that.axis = axis;
    that._updateLocationData(location);
    that.startLocation = that.location;
    that.velocity = that.delta = 0;
    that.timeStamp = now();
  }
  move(location) {
    let that = this, offset = location["page" + that.axis], timeStamp = now(), timeDelta = timeStamp - that.timeStamp || 1;
    if (!offset && this.invalidZeroEvents) {
      return;
    }
    that.delta = offset - that.location;
    that._updateLocationData(location);
    that.initialDelta = offset - that.startLocation;
    that.velocity = that.delta / timeDelta;
    that.timeStamp = timeStamp;
  }
  _updateLocationData(location) {
    let that = this, axis = that.axis;
    that.location = location["page" + axis];
    that.client = location["client" + axis];
    that.screen = location["screen" + axis];
  }
};
var Touch = class extends class_default {
  constructor(userEvents, target, touchInfo) {
    super();
    extend(this, {
      x: new TouchAxis("X", touchInfo.location),
      y: new TouchAxis("Y", touchInfo.location),
      type: touchInfo.type,
      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
      userEvents,
      target,
      currentTarget: touchInfo.currentTarget,
      initialTouch: touchInfo.target,
      id: touchInfo.id,
      pressEvent: touchInfo,
      _clicks: userEvents._clicks,
      supportDoubleTap: userEvents.supportDoubleTap,
      _moved: false,
      _finished: false
    });
  }
  press() {
    this._holdTimeout = setTimeout(() => this._hold(), this.userEvents.minHold);
    this._trigger(PRESS, this.pressEvent);
  }
  _tap(touchInfo) {
    let that = this;
    that.userEvents._clicks++;
    if (that.userEvents._clicks === 1) {
      that._clickTimeout = setTimeout(function() {
        if (that.userEvents._clicks === 1) {
          that._trigger(TAP, touchInfo);
        } else {
          that._trigger(DOUBLETAP, touchInfo);
        }
        that.userEvents._clicks = 0;
      }, CLICK_DELAY);
    }
  }
  _hold() {
    this._trigger(HOLD, this.pressEvent);
  }
  /* eslint-disable consistent-return */
  move(touchInfo) {
    let that = this;
    let preventMove = touchInfo.type !== "api" && that.userEvents._shouldNotMove;
    if (that._finished || preventMove) {
      return;
    }
    that.x.move(touchInfo.location);
    that.y.move(touchInfo.location);
    if (!that._moved) {
      if (that._withinIgnoreThreshold()) {
        return;
      }
      if (!UserEvents.current || UserEvents.current === that.userEvents) {
        that._start(touchInfo);
      } else {
        return that.dispose();
      }
    }
    if (!that._finished) {
      that._trigger(MOVE, touchInfo);
    }
  }
  /* eslint-enable consistent-return */
  end(touchInfo) {
    this.endTime = now();
    if (this._finished) {
      return;
    }
    this._finished = true;
    this._trigger(RELEASE, touchInfo);
    if (this._moved) {
      this._trigger(END2, touchInfo);
    } else {
      if (this.supportDoubleTap) {
        this._tap(touchInfo);
      } else {
        this._trigger(TAP, touchInfo);
      }
    }
    clearTimeout(this._holdTimeout);
    this.dispose();
  }
  dispose() {
    let userEvents = this.userEvents, activeTouches = userEvents.touches || [];
    this._finished = true;
    this.pressEvent = null;
    clearTimeout(this._holdTimeout);
    const activeTouchIndex = activeTouches.indexOf(this);
    activeTouches.splice(activeTouchIndex, 1);
  }
  skip() {
    this.dispose();
  }
  cancel() {
    this.dispose();
  }
  isMoved() {
    return this._moved;
  }
  _start(touchInfo) {
    clearTimeout(this._holdTimeout);
    this.startTime = now();
    this._moved = true;
    this._trigger(START2, touchInfo);
  }
  _trigger(name, touchInfo) {
    const e = touchInfo.event;
    const data = {
      touch: this,
      x: this.x,
      y: this.y,
      target: this.target,
      event: e
    };
    if (this.userEvents.notify(name, data)) {
      e.preventDefault();
    }
  }
  _withinIgnoreThreshold() {
    let xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
  }
};
function withEachUpEvent(callback) {
  let downEvents = eventMap.up.split(" "), idx = 0, length = downEvents.length;
  for (; idx < length; idx++) {
    callback(downEvents[idx]);
  }
}
var UserEvents = class _UserEvents extends Observable {
  constructor(element, options) {
    super();
    let that = this;
    let filter;
    const support = getSupportedFeatures();
    this.support = support;
    options = options || {};
    this.options = options;
    filter = that.filter = options.filter;
    that.threshold = options.threshold || DEFAULT_THRESHOLD;
    that.minHold = options.minHold || DEFAULT_MIN_HOLD;
    that.touches = [];
    that._maxTouches = options.multiTouch ? 2 : 1;
    that.allowSelection = options.allowSelection;
    that.captureUpIfMoved = options.captureUpIfMoved;
    that._clicks = 0;
    that.supportDoubleTap = options.supportDoubleTap;
    extend(that, {
      element,
      surface: options.surface || element,
      stopPropagation: options.stopPropagation,
      pressed: false
    });
    this._surfaceMoveHandler = this._move.bind(this);
    on(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    this._surfaceEndHandler = this._end.bind(this);
    on(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    this._elementStartHandler = this._start.bind(this);
    on(element, applyEventMap("down"), filter, this._elementStartHandler);
    element.style["touch-action"] = options.touchAction || "none";
    if (options.preventDragEvent) {
      this._elementDragStartHandler = preventDefault2;
      on(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    this._elementSelectHandler = this._select.bind(this);
    on(element, applyEventMap("mousedown"), filter, this._elementSelectHandler);
    if (that.captureUpIfMoved) {
      let surfaceElement = that.surface;
      that._preventIfMovingProxy = that.preventIfMoving.bind(that);
      withEachUpEvent(function(eventName) {
        surfaceElement.addEventListener(eventName, that._preventIfMovingProxy, true);
      });
    }
    that.bind([
      PRESS,
      HOLD,
      TAP,
      DOUBLETAP,
      START2,
      MOVE,
      END2,
      RELEASE,
      CANCEL,
      GESTURESTART,
      GESTURECHANGE,
      GESTUREEND,
      GESTURETAP,
      SELECT
    ], options);
  }
  preventIfMoving(e) {
    if (this._isMoved()) {
      e.preventDefault();
    }
  }
  destroy() {
    let that = this;
    const options = this.options;
    const element = this.element;
    if (that._destroyed) {
      return;
    }
    that._destroyed = true;
    if (that.captureUpIfMoved) {
      let surfaceElement = that.surface;
      withEachUpEvent(function(eventName) {
        surfaceElement.removeEventListener(eventName, that._preventIfMovingProxy, true);
      });
    }
    off(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    off(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    off(element, applyEventMap("down"), this._elementStartHandler);
    if (options.preventDragEvent) {
      off(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    off(element, applyEventMap("mousedown"), this._elementSelectHandler);
    that._disposeAll();
    that.unbind();
    delete that.surface;
    delete that.element;
    delete that.currentTarget;
  }
  capture() {
    _UserEvents.current = this;
  }
  cancel() {
    this._disposeAll();
    this.trigger(CANCEL);
  }
  notify(event, data) {
    let that = this, touches = that.touches;
    let eventName = event;
    if (this._isMultiTouch()) {
      switch (eventName) {
        case MOVE:
          eventName = GESTURECHANGE;
          break;
        case END2:
          eventName = GESTUREEND;
          break;
        case TAP:
          eventName = GESTURETAP;
          break;
        default:
          break;
      }
      extend(data, {
        touches
      }, touchDelta(touches[0], touches[1]));
    }
    return this.trigger(eventName, extend(data, {
      type: eventName
    }));
  }
  press(x, y, target) {
    this._apiCall("_start", x, y, target);
  }
  move(x, y) {
    this._apiCall("_move", x, y);
  }
  end(x, y) {
    this._apiCall("_end", x, y);
  }
  _isMultiTouch() {
    return this.touches.length > 1;
  }
  _maxTouchesReached() {
    return this.touches.length >= this._maxTouches;
  }
  _disposeAll() {
    let touches = this.touches;
    while (touches.length > 0) {
      touches.pop().dispose();
    }
  }
  _isMoved() {
    return grep(this.touches, function(touch) {
      return touch.isMoved();
    }).length;
  }
  _select(e) {
    if (!this.allowSelection || this.trigger(SELECT, { event: e })) {
      e.preventDefault();
    }
  }
  _start(e) {
    if (e.which && e.which > 1 || this._maxTouchesReached()) {
      return;
    }
    _UserEvents.current = null;
    this.currentTarget = e.currentTarget;
    if (this.stopPropagation) {
      e.stopPropagation();
    }
    let target;
    const eventTouches = getTouches(e);
    for (let idx = 0; idx < eventTouches.length; idx++) {
      if (this._maxTouchesReached()) {
        break;
      }
      const eventTouch = eventTouches[idx];
      if (this.filter) {
        target = eventTouch.currentTarget;
      } else {
        target = this.element;
      }
      if (target && target.length === 0) {
        continue;
      }
      const touch = new Touch(this, target, eventTouch);
      this.touches.push(touch);
      touch.press();
      if (this._isMultiTouch()) {
        this.notify("gesturestart", {});
      }
    }
  }
  _move(e) {
    this._eachTouch("move", e);
  }
  _end(e) {
    this._eachTouch("end", e);
  }
  _eachTouch(methodName, e) {
    let that = this, dict = {}, touches = getTouches(e), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
    for (idx = 0; idx < activeTouches.length; idx++) {
      touch = activeTouches[idx];
      dict[touch.id] = touch;
    }
    for (idx = 0; idx < touches.length; idx++) {
      touchInfo = touches[idx];
      matchingTouch = dict[touchInfo.id];
      if (matchingTouch) {
        const shouldCapture = methodName === "move" && touchInfo.type === "pointer" && !this.surface.hasPointerCapture(touchInfo.id);
        if (shouldCapture) {
          this.surface.setPointerCapture(touchInfo.id);
        }
        matchingTouch[methodName](touchInfo);
      }
    }
  }
  _apiCall(type, x, y, target) {
    this[type]({
      api: true,
      pageX: x,
      pageY: y,
      clientX: x,
      clientY: y,
      target: target || this.element,
      stopPropagation: noop,
      preventDefault: noop
    });
  }
  static defaultThreshold(value2) {
    DEFAULT_THRESHOLD = value2;
  }
  static minHold(value2) {
    DEFAULT_MIN_HOLD = value2;
  }
};

// node_modules/@progress/kendo-charts/dist/es/core/chart-element.js
var ChartElement = class extends class_default {
  constructor(options) {
    super();
    this.children = [];
    this.options = deepExtend({}, this.options, this.initUserOptions(options));
  }
  initUserOptions(options) {
    return options;
  }
  reflow(targetBox) {
    const children = this.children;
    let box;
    for (let i = 0; i < children.length; i++) {
      let currentChild = children[i];
      currentChild.reflow(targetBox);
      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
    }
    this.box = box || targetBox;
  }
  destroy() {
    const children = this.children;
    if (this.animation) {
      this.animation.destroy();
    }
    for (let i = 0; i < children.length; i++) {
      children[i].destroy();
    }
  }
  getRoot() {
    const parent = this.parent;
    return parent ? parent.getRoot() : null;
  }
  getSender() {
    const service = this.getService();
    if (service) {
      return service.sender;
    }
  }
  getService() {
    let element = this;
    while (element) {
      if (element.chartService) {
        return element.chartService;
      }
      element = element.parent;
    }
  }
  translateChildren(dx, dy) {
    const children = this.children;
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      children[i].box.translate(dx, dy);
    }
  }
  append() {
    for (let i = 0; i < arguments.length; i++) {
      let item = arguments[i];
      this.children.push(item);
      item.parent = this;
    }
  }
  renderVisual() {
    if (this.options.visible === false) {
      return;
    }
    this.createVisual();
    this.addVisual();
    this.renderChildren();
    this.createAnimation();
    this.renderComplete();
  }
  addVisual() {
    if (this.visual) {
      this.visual.chartElement = this;
      if (this.parent) {
        this.parent.appendVisual(this.visual);
      }
    }
  }
  renderChildren() {
    const children = this.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      children[i].renderVisual();
    }
  }
  createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: this.options.zIndex,
      visible: valueOrDefault(this.options.visible, true)
    });
  }
  createAnimation() {
    if (this.visual && this.options.animation) {
      this.animation = drawing_exports.Animation.create(
        this.visual,
        this.options.animation
      );
    }
  }
  appendVisual(childVisual) {
    if (!childVisual.chartElement) {
      childVisual.chartElement = this;
    }
    if (childVisual.options.noclip) {
      this.clipRoot().visual.append(childVisual);
    } else if (defined(childVisual.options.zIndex)) {
      this.stackRoot().stackVisual(childVisual);
    } else if (this.isStackRoot) {
      this.stackVisual(childVisual);
    } else if (this.visual) {
      this.visual.append(childVisual);
    } else {
      this.parent.appendVisual(childVisual);
    }
  }
  clipRoot() {
    if (this.parent) {
      return this.parent.clipRoot();
    }
    return this;
  }
  stackRoot() {
    if (this.parent) {
      return this.parent.stackRoot();
    }
    return this;
  }
  stackVisual(childVisual) {
    const zIndex = childVisual.options.zIndex || 0;
    const visuals = this.visual.children;
    const length = visuals.length;
    let pos;
    for (pos = 0; pos < length; pos++) {
      let sibling = visuals[pos];
      let here = valueOrDefault(sibling.options.zIndex, 0);
      if (here > zIndex) {
        break;
      }
    }
    this.visual.insert(pos, childVisual);
  }
  traverse(callback) {
    const children = this.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      let child = children[i];
      callback(child);
      if (child.traverse) {
        child.traverse(callback);
      }
    }
  }
  closest(match) {
    let element = this;
    let matched = false;
    while (element && !matched) {
      matched = match(element);
      if (!matched) {
        element = element.parent;
      }
    }
    if (matched) {
      return element;
    }
  }
  renderComplete() {
  }
  hasHighlight() {
    const options = (this.options || {}).highlight;
    return !(!this.createHighlight || options && options.visible === false || this.visible === false);
  }
  toggleHighlight(show2, opacity) {
    const options = (this.options || {}).highlight || {};
    const customVisual = options.visual;
    let highlight = this._highlight;
    if (!highlight) {
      const highlightOptions2 = {
        fill: {
          color: WHITE,
          opacity: opacity || 0.2
        },
        stroke: {
          color: WHITE,
          width: 1,
          opacity: opacity || 0.2
        }
      };
      if (customVisual) {
        highlight = this._highlight = customVisual(
          Object.assign(this.highlightVisualArgs(), {
            createVisual: () => this.createHighlight(highlightOptions2),
            sender: this.getSender(),
            series: this.series,
            dataItem: this.dataItem,
            category: this.category,
            value: this.value,
            percentage: this.percentage,
            runningTotal: this.runningTotal,
            total: this.total
          })
        );
        if (!highlight) {
          return;
        }
      } else {
        highlight = this._highlight = this.createHighlight(highlightOptions2);
      }
      if (!defined(highlight.options.zIndex)) {
        highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);
      }
      this.appendVisual(highlight);
    }
    highlight.visible(show2);
  }
  toggleFocusHighlight(show2) {
    const options = (this.options || {}).focusHighlight || {};
    let focusHighlight = this._focusHighlight;
    if (!show2 && !focusHighlight) {
      return;
    }
    if (!focusHighlight) {
      const rootBackground = this.getRoot().options.background;
      const highlightColor = auto_text_color_default(rootBackground);
      const focusHighlightOptions = {
        fill: {
          opacity: options.opacity,
          color: options.color
        },
        stroke: Object.assign({}, { color: highlightColor }, options.border),
        zIndex: options.zIndex
      };
      focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);
      this.appendVisual(focusHighlight);
    }
    focusHighlight.visible(show2);
  }
  createGradientOverlay(element, options, gradientOptions) {
    const overlay = new drawing_exports.Path(Object.assign({
      stroke: {
        color: "none"
      },
      fill: this.createGradient(gradientOptions),
      closed: element.options.closed
    }, options));
    overlay.segments.elements(element.segments.elements());
    return overlay;
  }
  createGradient(options) {
    if (this.parent) {
      return this.parent.createGradient(options);
    }
  }
  supportsPointInactiveOpacity() {
    return true;
  }
};
ChartElement.prototype.options = {};
var chart_element_default = ChartElement;

// node_modules/@progress/kendo-charts/dist/es/core/point.js
var Point = class _Point extends class_default {
  constructor(x, y) {
    super();
    this.x = x || 0;
    this.y = y || 0;
  }
  clone() {
    return new _Point(this.x, this.y);
  }
  equals(point) {
    return point && this.x === point.x && this.y === point.y;
  }
  rotate(center, degrees) {
    const theta = rad(degrees);
    const cosT = Math.cos(theta);
    const sinT = Math.sin(theta);
    const { x: cx, y: cy } = center;
    const { x, y } = this;
    this.x = round(
      cx + (x - cx) * cosT + (y - cy) * sinT,
      COORD_PRECISION
    );
    this.y = round(
      cy + (y - cy) * cosT - (x - cx) * sinT,
      COORD_PRECISION
    );
    return this;
  }
  multiply(a) {
    this.x *= a;
    this.y *= a;
    return this;
  }
  distanceTo(point) {
    const dx = this.x - point.x;
    const dy = this.y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  static onCircle(center, angle, radius) {
    const radians = rad(angle);
    return new _Point(
      center.x - radius * Math.cos(radians),
      center.y - radius * Math.sin(radians)
    );
  }
};
var point_default = Point;

// node_modules/@progress/kendo-charts/dist/es/core/box.js
var Box = class _Box extends class_default {
  constructor(x1, y1, x2, y2) {
    super();
    this.x1 = x1 || 0;
    this.y1 = y1 || 0;
    this.x2 = x2 || 0;
    this.y2 = y2 || 0;
  }
  equals(box) {
    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;
  }
  width() {
    return this.x2 - this.x1;
  }
  height() {
    return this.y2 - this.y1;
  }
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  }
  move(x, y) {
    const height = this.height();
    const width = this.width();
    if (defined(x)) {
      this.x1 = x;
      this.x2 = this.x1 + width;
    }
    if (defined(y)) {
      this.y1 = y;
      this.y2 = this.y1 + height;
    }
    return this;
  }
  wrap(targetBox) {
    this.x1 = Math.min(this.x1, targetBox.x1);
    this.y1 = Math.min(this.y1, targetBox.y1);
    this.x2 = Math.max(this.x2, targetBox.x2);
    this.y2 = Math.max(this.y2, targetBox.y2);
    return this;
  }
  wrapPoint(point) {
    const arrayPoint = isArray(point);
    const x = arrayPoint ? point[0] : point.x;
    const y = arrayPoint ? point[1] : point.y;
    this.wrap(new _Box(x, y, x, y));
    return this;
  }
  snapTo(targetBox, axis) {
    if (axis === X || !axis) {
      this.x1 = targetBox.x1;
      this.x2 = targetBox.x2;
    }
    if (axis === Y || !axis) {
      this.y1 = targetBox.y1;
      this.y2 = targetBox.y2;
    }
    return this;
  }
  alignTo(targetBox, anchor) {
    const height = this.height();
    const width = this.width();
    const axis = anchor === TOP || anchor === BOTTOM ? Y : X;
    const offset = axis === Y ? height : width;
    if (anchor === CENTER) {
      const targetCenter = targetBox.center();
      const center = this.center();
      this.x1 += targetCenter.x - center.x;
      this.y1 += targetCenter.y - center.y;
    } else if (anchor === TOP || anchor === LEFT) {
      this[axis + 1] = targetBox[axis + 1] - offset;
    } else {
      this[axis + 1] = targetBox[axis + 2];
    }
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  }
  shrink(dw, dh) {
    this.x2 -= dw;
    this.y2 -= dh;
    return this;
  }
  expand(dw, dh) {
    this.shrink(-dw, -dh);
    return this;
  }
  pad(padding) {
    const spacing = getSpacing(padding);
    this.x1 -= spacing.left;
    this.x2 += spacing.right;
    this.y1 -= spacing.top;
    this.y2 += spacing.bottom;
    return this;
  }
  unpad(padding) {
    const spacing = getSpacing(padding);
    spacing.left = -spacing.left;
    spacing.top = -spacing.top;
    spacing.right = -spacing.right;
    spacing.bottom = -spacing.bottom;
    return this.pad(spacing);
  }
  clone() {
    return new _Box(this.x1, this.y1, this.x2, this.y2);
  }
  center() {
    return new point_default(
      this.x1 + this.width() / 2,
      this.y1 + this.height() / 2
    );
  }
  containsPoint(point) {
    return point.x >= this.x1 && point.x <= this.x2 && point.y >= this.y1 && point.y <= this.y2;
  }
  points() {
    return [
      new point_default(this.x1, this.y1),
      new point_default(this.x2, this.y1),
      new point_default(this.x2, this.y2),
      new point_default(this.x1, this.y2)
    ];
  }
  getHash() {
    return [this.x1, this.y1, this.x2, this.y2].join(",");
  }
  overlaps(box) {
    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);
  }
  rotate(rotation) {
    let width = this.width();
    let height = this.height();
    const { x: cx, y: cy } = this.center();
    const r1 = rotatePoint(0, 0, cx, cy, rotation);
    const r2 = rotatePoint(width, 0, cx, cy, rotation);
    const r3 = rotatePoint(width, height, cx, cy, rotation);
    const r4 = rotatePoint(0, height, cx, cy, rotation);
    width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);
    height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  }
  toRect() {
    return new geometry_exports.Rect([this.x1, this.y1], [this.width(), this.height()]);
  }
  hasSize() {
    return this.width() !== 0 && this.height() !== 0;
  }
  align(targetBox, axis, alignment) {
    const c1 = axis + 1;
    const c2 = axis + 2;
    const sizeFunc = axis === X ? WIDTH : HEIGHT;
    const size = this[sizeFunc]();
    if (inArray(alignment, [LEFT, TOP])) {
      this[c1] = targetBox[c1];
      this[c2] = this[c1] + size;
    } else if (inArray(alignment, [RIGHT, BOTTOM])) {
      this[c2] = targetBox[c2];
      this[c1] = this[c2] - size;
    } else if (alignment === CENTER) {
      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;
      this[c2] = this[c1] + size;
    }
  }
};
function rotatePoint(x, y, cx, cy, angle) {
  const theta = rad(angle);
  return new point_default(
    cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),
    cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)
  );
}
var box_default = Box;

// node_modules/@progress/kendo-charts/dist/es/core/pattern.js
var { dotsPattern, verticalStripesPattern, crosshatchPattern, diagonalStripesPattern, gridPattern } = drawing_exports;
var patternMap = {
  dots: dotsPattern,
  verticalStripes: verticalStripesPattern,
  crosshatch: crosshatchPattern,
  diagonalStripes: diagonalStripesPattern,
  grid: gridPattern
};
function evaluatePattern(options, point) {
  return isFunction(options) ? options(point) : options;
}
function createPatternFill(options, fill, point) {
  const patternOptions = evaluatePattern(options, point);
  const pattern = patternOptions && patternMap[patternOptions.type];
  return pattern ? pattern(Object.assign({}, fill, patternOptions)) : fill;
}

// node_modules/@progress/kendo-charts/dist/es/core/box-element.js
var BoxElement = class extends chart_element_default {
  constructor(options) {
    super(options);
    this.options.margin = getSpacing(this.options.margin);
    this.options.padding = getSpacing(this.options.padding);
  }
  reflow(targetBox) {
    const options = this.options;
    const { width, height, shrinkToFit } = options;
    const hasSetSize = width && height;
    const margin = options.margin;
    const padding = options.padding;
    const borderWidth = options.border.width;
    let box;
    const reflowPaddingBox = () => {
      this.align(targetBox, X, options.align);
      this.align(targetBox, Y, options.vAlign);
      this.paddingBox = box.clone().unpad(margin).unpad(borderWidth);
    };
    let contentBox = targetBox.clone();
    if (hasSetSize) {
      contentBox.x2 = contentBox.x1 + width;
      contentBox.y2 = contentBox.y1 + height;
    }
    if (shrinkToFit) {
      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);
    }
    super.reflow(contentBox);
    if (hasSetSize) {
      box = this.box = new box_default(0, 0, width, height);
    } else {
      box = this.box;
    }
    if (shrinkToFit && hasSetSize) {
      reflowPaddingBox();
      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);
    } else {
      contentBox = this.contentBox = box.clone();
      box.pad(padding).pad(borderWidth).pad(margin);
      reflowPaddingBox();
    }
    this.translateChildren(
      box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,
      box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top
    );
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      let item = children[i];
      item.reflow(item.box);
    }
  }
  align(targetBox, axis, alignment) {
    this.box.align(targetBox, axis, alignment);
  }
  hasBox() {
    const options = this.options;
    return options.border.width || options.background;
  }
  createVisual() {
    super.createVisual();
    const options = this.options;
    if (options.visible && this.hasBox()) {
      this.visual.append(drawing_exports.Path.fromRect(
        this.paddingBox.toRect(),
        this.visualStyle()
      ));
    }
  }
  visualStyle() {
    const options = this.options;
    const border = options.border || {};
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: createPatternFill(options.pattern, {
        color: options.background,
        opacity: options.opacity
      }, void 0),
      cursor: options.cursor
    };
  }
};
setDefaultOptions(BoxElement, {
  align: LEFT,
  vAlign: TOP,
  margin: {},
  padding: {},
  border: {
    color: BLACK,
    width: 0
  },
  background: "",
  shrinkToFit: false,
  width: 0,
  height: 0,
  visible: true
});
var box_element_default = BoxElement;

// node_modules/@progress/kendo-charts/dist/es/core/float-element.js
var FloatElement = class extends chart_element_default {
  constructor(options) {
    super(options);
    this._initDirection();
  }
  _initDirection() {
    const options = this.options;
    if (options.vertical) {
      this.groupAxis = X;
      this.elementAxis = Y;
      this.groupSizeField = WIDTH;
      this.elementSizeField = HEIGHT;
      this.groupSpacing = options.spacing;
      this.elementSpacing = options.vSpacing;
    } else {
      this.groupAxis = Y;
      this.elementAxis = X;
      this.groupSizeField = HEIGHT;
      this.elementSizeField = WIDTH;
      this.groupSpacing = options.vSpacing;
      this.elementSpacing = options.spacing;
    }
  }
  reflow(targetBox) {
    this.box = targetBox.clone();
    this.reflowChildren();
  }
  reflowChildren() {
    const { box, elementAxis, groupAxis, elementSizeField, groupSizeField } = this;
    const { groups, groupsSize, maxGroupElementsSize } = this.groupOptions();
    const groupsCount = groups.length;
    const groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());
    if (groupsCount) {
      let groupStart = groupsStart;
      for (let groupIdx = 0; groupIdx < groupsCount; groupIdx++) {
        let group = groups[groupIdx];
        let groupElements = group.groupElements;
        let elementStart = box[elementAxis + 1];
        let groupElementsCount = groupElements.length;
        for (let idx = 0; idx < groupElementsCount; idx++) {
          let element = groupElements[idx];
          let elementSize2 = this.elementSize(element);
          let groupElementStart = groupStart + this.alignStart(elementSize2[groupSizeField], group.groupSize);
          let elementBox = new box_default();
          elementBox[groupAxis + 1] = groupElementStart;
          elementBox[groupAxis + 2] = groupElementStart + elementSize2[groupSizeField];
          elementBox[elementAxis + 1] = elementStart;
          elementBox[elementAxis + 2] = elementStart + elementSize2[elementSizeField];
          element.reflow(elementBox);
          elementStart += elementSize2[elementSizeField] + this.elementSpacing;
        }
        groupStart += group.groupSize + this.groupSpacing;
      }
      box[groupAxis + 1] = groupsStart;
      box[groupAxis + 2] = groupsStart + groupsSize;
      box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;
    }
  }
  alignStart(size, maxSize) {
    let start = 0;
    const align = this.options.align;
    if (align === RIGHT || align === BOTTOM) {
      start = maxSize - size;
    } else if (align === CENTER) {
      start = (maxSize - size) / 2;
    }
    return start;
  }
  groupOptions() {
    const { box, children, elementSizeField, groupSizeField, elementSpacing, groupSpacing } = this;
    const maxSize = round(box[elementSizeField]());
    const childrenCount = children.length;
    const groups = [];
    let groupSize = 0;
    let groupElementsSize = 0;
    let groupsSize = 0;
    let maxGroupElementsSize = 0;
    let groupElements = [];
    for (let idx = 0; idx < childrenCount; idx++) {
      let element = children[idx];
      if (!element.box) {
        element.reflow(box);
      }
      let elementSize2 = this.elementSize(element);
      if (this.options.wrap && round(groupElementsSize + elementSpacing + elementSize2[elementSizeField]) > maxSize) {
        groups.push({
          groupElements,
          groupSize,
          groupElementsSize
        });
        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
        groupsSize += groupSpacing + groupSize;
        groupSize = 0;
        groupElementsSize = 0;
        groupElements = [];
      }
      groupSize = Math.max(groupSize, elementSize2[groupSizeField]);
      if (groupElementsSize > 0) {
        groupElementsSize += elementSpacing;
      }
      groupElementsSize += elementSize2[elementSizeField];
      groupElements.push(element);
    }
    groups.push({
      groupElements,
      groupSize,
      groupElementsSize
    });
    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
    groupsSize += groupSize;
    return {
      groups,
      groupsSize,
      maxGroupElementsSize
    };
  }
  elementSize(element) {
    return {
      width: element.box.width(),
      height: element.box.height()
    };
  }
  createVisual() {
  }
};
setDefaultOptions(FloatElement, {
  vertical: true,
  wrap: true,
  vSpacing: 0,
  spacing: 0
});
var float_element_default = FloatElement;

// node_modules/@progress/kendo-charts/dist/es/core/text.js
var DrawingText = drawing_exports.Text;
var Text = class extends chart_element_default {
  constructor(content, options) {
    super(options);
    this.content = content;
    this.reflow(new box_default());
  }
  reflow(targetBox) {
    const options = this.options;
    const size = options.size = drawing_exports.util.measureText(this.content, { font: options.font });
    this.baseline = size.baseline;
    this.box = new box_default(
      targetBox.x1,
      targetBox.y1,
      targetBox.x1 + size.width,
      targetBox.y1 + size.height
    );
  }
  createVisual() {
    const { font, color, opacity, cursor, stroke, paintOrder } = this.options;
    this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {
      font,
      fill: { color, opacity },
      cursor,
      stroke,
      paintOrder
    });
  }
};
setDefaultOptions(Text, {
  font: DEFAULT_FONT,
  color: BLACK
});
var text_default = Text;

// node_modules/@progress/kendo-charts/dist/es/core/utils/rect-to-box.js
function rectToBox(rect) {
  const origin = rect.origin;
  const bottomRight = rect.bottomRight();
  return new box_default(origin.x, origin.y, bottomRight.x, bottomRight.y);
}

// node_modules/@progress/kendo-charts/dist/es/core/text-box.js
var ROWS_SPLIT_REGEX = /\n/m;
var TextBox = class extends box_element_default {
  constructor(content, options, data) {
    super(options);
    this.content = content;
    this.data = data;
    this._initContainer();
    if (this.options._autoReflow !== false) {
      this.reflow(new box_default());
    }
  }
  _initContainer() {
    const options = this.options;
    const rows = String(this.content).split(ROWS_SPLIT_REGEX);
    const floatElement = new float_element_default({ vertical: true, align: options.align, wrap: false });
    const textOptions = deepExtend({}, options, { opacity: 1, animation: null });
    this.container = floatElement;
    this.append(floatElement);
    for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
      let text = new text_default(rows[rowIdx].trim(), textOptions);
      floatElement.append(text);
    }
  }
  reflow(targetBox) {
    const options = this.options;
    const visualFn = options.visual;
    this.container.options.align = options.align;
    if (visualFn && !this._boxReflow) {
      let visualBox = targetBox;
      if (!visualBox.hasSize()) {
        this._boxReflow = true;
        this.reflow(visualBox);
        this._boxReflow = false;
        visualBox = this.box;
      }
      const visual = this.visual = visualFn(this.visualContext(visualBox));
      if (visual) {
        visualBox = rectToBox(visual.clippedBBox() || new geometry_exports.Rect());
        visual.options.zIndex = options.zIndex;
      }
      this.box = this.contentBox = this.paddingBox = visualBox;
    } else {
      super.reflow(targetBox);
      if (options.rotation) {
        const margin = getSpacing(options.margin);
        let box = this.box.unpad(margin);
        this.targetBox = targetBox;
        this.normalBox = box.clone();
        box = this.rotate();
        box.translate(margin.left - margin.right, margin.top - margin.bottom);
        this.rotatedBox = box.clone();
        box.pad(margin);
      }
    }
  }
  createVisual() {
    const options = this.options;
    this.visual = new drawing_exports.Group({
      transform: this.rotationTransform(),
      zIndex: options.zIndex,
      noclip: options.noclip
    });
    if (this.hasBox()) {
      const box = drawing_exports.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());
      this.visual.append(box);
    }
  }
  renderVisual() {
    if (!this.options.visible) {
      return;
    }
    if (this.options.visual) {
      const visual = this.visual;
      if (visual && !defined(visual.options.noclip)) {
        visual.options.noclip = this.options.noclip;
      }
      this.addVisual();
      this.createAnimation();
    } else {
      super.renderVisual();
    }
  }
  visualContext(targetBox) {
    const context = {
      text: this.content,
      rect: targetBox.toRect(),
      sender: this.getSender(),
      options: this.options,
      createVisual: () => {
        this._boxReflow = true;
        this.reflow(targetBox);
        this._boxReflow = false;
        return this.getDefaultVisual();
      }
    };
    if (this.data) {
      Object.assign(context, this.data);
    }
    return context;
  }
  getDefaultVisual() {
    this.createVisual();
    this.renderChildren();
    const visual = this.visual;
    delete this.visual;
    return visual;
  }
  rotate() {
    const options = this.options;
    this.box.rotate(options.rotation);
    this.align(this.targetBox, X, options.align);
    this.align(this.targetBox, Y, options.vAlign);
    return this.box;
  }
  rotationTransform() {
    const rotation = this.options.rotation;
    if (!rotation) {
      return null;
    }
    const { x: cx, y: cy } = this.normalBox.center();
    const boxCenter = this.rotatedBox.center();
    return geometry_exports.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);
  }
};
var text_box_default = TextBox;

// node_modules/@progress/kendo-charts/dist/es/core/axis-label.js
var AxisLabel = class extends text_box_default {
  constructor(value2, text, index, dataItem, options) {
    super(text, options);
    this.text = text;
    this.value = value2;
    this.index = index;
    this.dataItem = dataItem;
    this.reflow(new box_default());
  }
  visualContext(targetBox) {
    const context = super.visualContext(targetBox);
    context.value = this.value;
    context.dataItem = this.dataItem;
    context.format = this.options.format;
    context.culture = this.options.culture;
    return context;
  }
  click(widget, e) {
    widget.trigger(AXIS_LABEL_CLICK, {
      element: eventElement(e),
      value: this.value,
      text: this.text,
      index: this.index,
      dataItem: this.dataItem,
      axis: this.parent.options
    });
  }
  rotate() {
    if (this.options.alignRotation !== CENTER) {
      const box = this.normalBox.toRect();
      const transform = this.rotationTransform();
      this.box = rectToBox(box.bbox(transform.matrix()));
    } else {
      super.rotate();
    }
    return this.box;
  }
  rotationTransform() {
    const options = this.options;
    const rotation = options.rotation;
    if (!rotation) {
      return null;
    }
    if (options.alignRotation === CENTER) {
      return super.rotationTransform();
    }
    const rotationMatrix = geometry_exports.transform().rotate(rotation).matrix();
    const box = this.normalBox.toRect();
    const rect = this.targetBox.toRect();
    const rotationOrigin = options.rotationOrigin || TOP;
    const alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;
    const distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;
    const axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();
    const topLeft = box.topLeft().transformCopy(rotationMatrix);
    const topRight = box.topRight().transformCopy(rotationMatrix);
    const bottomRight = box.bottomRight().transformCopy(rotationMatrix);
    const bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);
    const rotatedBox = geometry_exports.Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);
    const translate2 = {
      [distanceAxis]: rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis]
    };
    const distanceLeft = Math.abs(topLeft[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    const distanceRight = Math.abs(topRight[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    let alignStart, alignEnd;
    if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {
      alignStart = topLeft;
      alignEnd = topRight;
    } else if (distanceRight < distanceLeft) {
      alignStart = topRight;
      alignEnd = bottomRight;
    } else {
      alignStart = topLeft;
      alignEnd = bottomLeft;
    }
    const alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;
    translate2[alignAxis] = rect.center()[alignAxis] - alignCenter;
    return geometry_exports.transform().translate(translate2.x, translate2.y).rotate(rotation);
  }
};
setDefaultOptions(AxisLabel, {
  _autoReflow: false
});
var axis_label_default = AxisLabel;

// node_modules/@progress/kendo-charts/dist/es/core/utils/add-accessibility-attributes-to-visual.js
function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {
  if (accessibilityOptions) {
    visual.options.className = accessibilityOptions.className;
    visual.options.role = accessibilityOptions.role;
    visual.options.ariaLabel = accessibilityOptions.ariaLabel;
    visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;
    visual.options.ariaChecked = accessibilityOptions.ariaChecked;
  }
}

// node_modules/@progress/kendo-charts/dist/es/core/shape-element.js
var ShapeElement = class extends box_element_default {
  constructor(options, pointData) {
    super(options);
    this.pointData = pointData;
  }
  getElement() {
    const { options, paddingBox: box } = this;
    const { type, rotation } = options;
    const center = box.center();
    const halfWidth = box.width() / 2;
    const halfHeight = box.height() / 2;
    if (!options.visible || !this.hasBox()) {
      return null;
    }
    const style = this.visualStyle();
    let element;
    if (type === CIRCLE) {
      element = new drawing_exports.Circle(
        new geometry_exports.Circle([
          round(box.x1 + halfWidth, COORD_PRECISION),
          round(box.y1 + halfHeight, COORD_PRECISION)
        ], Math.min(halfWidth, halfHeight)),
        style
      );
    } else if (type === TRIANGLE) {
      element = drawing_exports.Path.fromPoints([
        [box.x1 + halfWidth, box.y1],
        [box.x1, box.y2],
        [box.x2, box.y2]
      ], style).close();
    } else if (type === CROSS) {
      element = new drawing_exports.MultiPath(style);
      element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);
      element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);
    } else {
      const rect = box.toRect();
      if (type === ROUNDED_RECT) {
        const borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);
        rect.setCornerRadius(borderRadius);
      }
      element = drawing_exports.Path.fromRect(rect, style);
    }
    if (rotation) {
      element.transform(
        geometry_exports.transform().rotate(-rotation, [center.x, center.y])
      );
    }
    element.options.zIndex = options.zIndex;
    return element;
  }
  createElement() {
    const customVisual = this.options.visual;
    const pointData = this.pointData || {};
    let visual;
    if (customVisual) {
      visual = customVisual({
        value: pointData.value,
        dataItem: pointData.dataItem,
        sender: this.getSender(),
        series: pointData.series,
        category: pointData.category,
        rect: this.paddingBox.toRect(),
        options: this.visualOptions(),
        createVisual: () => this.getElement()
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  }
  visualOptions() {
    const options = this.options;
    return {
      background: options.background,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      type: options.type,
      size: options.width,
      visible: options.visible
    };
  }
  createVisual() {
    this.visual = this.createElement();
    addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);
  }
};
setDefaultOptions(ShapeElement, {
  type: CIRCLE,
  align: CENTER,
  vAlign: CENTER
});
var shape_element_default = ShapeElement;

// node_modules/@progress/kendo-charts/dist/es/core/note.js
var DEFAULT_ICON_SIZE = 7;
var DEFAULT_LABEL_COLOR = "#fff";
var Note = class extends box_element_default {
  constructor(fields, options, chartService) {
    super(options);
    this.fields = fields;
    this.chartService = chartService;
    this.render();
  }
  hide() {
    this.options.visible = false;
  }
  show() {
    this.options.visible = true;
  }
  render() {
    const options = this.options;
    if (options.visible) {
      const { label, icon } = options;
      const box = new box_default();
      const childAlias = () => this;
      let size = icon.size;
      let text = this.fields.text;
      let width, height;
      if (defined(label) && label.visible) {
        const noteTemplate = getTemplate(label);
        if (noteTemplate) {
          text = noteTemplate(this.fields);
        } else if (label.format) {
          text = this.chartService.format.auto(label.format, text);
        }
        if (!label.color) {
          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;
        }
        this.label = new text_box_default(text, deepExtend({}, label));
        this.label.aliasFor = childAlias;
        if (label.position === INSIDE && !defined(size)) {
          if (icon.type === CIRCLE) {
            size = Math.max(this.label.box.width(), this.label.box.height());
          } else {
            width = this.label.box.width();
            height = this.label.box.height();
          }
          box.wrap(this.label.box);
        }
      }
      icon.width = width || size || DEFAULT_ICON_SIZE;
      icon.height = height || size || DEFAULT_ICON_SIZE;
      const marker = new shape_element_default(deepExtend({}, icon));
      marker.aliasFor = childAlias;
      this.marker = marker;
      this.append(marker);
      if (this.label) {
        this.append(this.label);
      }
      marker.reflow(new box_default());
      this.wrapperBox = box.wrap(marker.box);
    }
  }
  reflow(targetBox) {
    const { options, label, marker, wrapperBox } = this;
    const center = targetBox.center();
    const length = options.line.length;
    const position = options.position;
    if (options.visible) {
      let lineStart, box, contentBox;
      if (inArray(position, [LEFT, RIGHT])) {
        if (position === LEFT) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x1, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x2, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x2, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x1, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      } else {
        if (position === BOTTOM) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y2];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y1]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y1];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y2]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      }
      if (marker) {
        marker.reflow(contentBox);
      }
      if (label) {
        label.reflow(contentBox);
        if (marker) {
          if (options.label.position === OUTSIDE) {
            label.box.alignTo(marker.box, position);
          }
          label.reflow(label.box);
        }
      }
      this.contentBox = contentBox;
      this.targetBox = targetBox;
      this.box = box || contentBox;
    }
  }
  createVisual() {
    super.createVisual();
    this.visual.options.noclip = this.options.noclip;
    if (this.options.visible) {
      this.createLine();
    }
  }
  renderVisual() {
    const options = this.options;
    const customVisual = options.visual;
    if (options.visible && customVisual) {
      this.visual = customVisual(Object.assign(this.fields, {
        sender: this.getSender(),
        rect: this.targetBox.toRect(),
        options: {
          background: options.background,
          border: options.background,
          icon: options.icon,
          label: options.label,
          line: options.line,
          position: options.position,
          visible: options.visible
        },
        createVisual: () => {
          this.createVisual();
          this.renderChildren();
          const defaultVisual = this.visual;
          delete this.visual;
          return defaultVisual;
        }
      }));
      this.addVisual();
    } else {
      super.renderVisual();
    }
  }
  createLine() {
    const options = this.options.line;
    if (this.linePoints) {
      const path = drawing_exports.Path.fromPoints(this.linePoints, {
        stroke: {
          color: options.color,
          width: options.width,
          dashType: options.dashType
        }
      });
      alignPathToPixel(path);
      this.visual.append(path);
    }
  }
  click(widget, e) {
    const args = this.eventArgs(e);
    if (!widget.trigger(NOTE_CLICK, args)) {
      e.preventDefault();
    }
  }
  over(widget, e) {
    const args = this.eventArgs(e);
    if (!widget.trigger(NOTE_HOVER, args)) {
      e.preventDefault();
    }
  }
  out(widget, e) {
    const args = this.eventArgs(e);
    widget.trigger(NOTE_LEAVE, args);
  }
  eventArgs(e) {
    const options = this.options;
    return Object.assign(this.fields, {
      element: eventElement(e),
      text: defined(options.label) ? options.label.text : "",
      visual: this.visual
    });
  }
};
setDefaultOptions(Note, {
  icon: {
    visible: true,
    type: CIRCLE
  },
  label: {
    position: INSIDE,
    visible: true,
    align: CENTER,
    vAlign: CENTER
  },
  line: {
    visible: true
  },
  visible: true,
  position: TOP,
  zIndex: 2
});
var note_default = Note;

// node_modules/@progress/kendo-charts/dist/es/services/intl-service.js
var defaultImplementation = {
  format: (format, value2) => value2,
  toString: (value2) => value2,
  parseDate: (value2) => new Date(value2),
  firstDay: () => 0
};
var current2 = defaultImplementation;
var IntlService = class {
  static register(userImplementation) {
    current2 = userImplementation;
  }
  static get implementation() {
    return current2;
  }
};
var intl_service_default = IntlService;

// node_modules/@progress/kendo-charts/dist/es/services/format-service.js
var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;
var FormatService = class {
  constructor(intlService) {
    this._intlService = intlService;
  }
  get intl() {
    return this._intlService || intl_service_default.implementation;
  }
  set intl(value2) {
    this._intlService = value2;
  }
  auto(formatString, ...values) {
    const intl = this.intl;
    if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
      return intl.format(formatString, ...values);
    }
    return intl.toString(values[0], formatString);
  }
  localeAuto(formatString, values, locale) {
    const intl = this.intl;
    let result;
    if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
      result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {
        let value2 = values[parseInt(index, 10)];
        return intl.toString(value2, placeholderFormat ? placeholderFormat.substring(1) : "", locale);
      });
    } else {
      result = intl.toString(values[0], formatString, locale);
    }
    return result;
  }
};
var format_service_default = FormatService;

// node_modules/@progress/kendo-charts/dist/es/services/chart-service.js
var ChartService = class {
  constructor(chart, context = {}) {
    this._intlService = context.intlService;
    this.sender = context.sender || chart;
    this.format = new format_service_default(context.intlService);
    this.chart = chart;
    this.rtl = Boolean(context.rtl);
  }
  get intl() {
    return this._intlService || intl_service_default.implementation;
  }
  set intl(value2) {
    this._intlService = value2;
    this.format.intl = value2;
  }
  notify(name, args) {
    if (this.chart) {
      this.chart.trigger(name, args);
    }
  }
  isPannable(axis) {
    const pannable = ((this.chart || {}).options || {}).pannable;
    return pannable && pannable.lock !== axis;
  }
};
var chart_service_default = ChartService;

// node_modules/@progress/kendo-charts/dist/es/services/dom-events-builder.js
var current3;
var DomEventsBuilder = class {
  static register(userImplementation) {
    current3 = userImplementation;
  }
  static create(element, events) {
    let builder;
    if (current3) {
      builder = current3.create(element, events);
    } else {
      builder = new UserEvents(element, Object.assign(
        {},
        { multiTouch: true },
        events
      ));
    }
    return builder;
  }
};
var dom_events_builder_default = DomEventsBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-tick.js
function createAxisTick(options, tickOptions) {
  const { tickX, tickY, position } = options;
  const tick = new drawing_exports.Path({
    stroke: {
      width: tickOptions.width,
      color: tickOptions.color
    }
  });
  if (options.vertical) {
    tick.moveTo(tickX, position).lineTo(tickX + tickOptions.size, position);
  } else {
    tick.moveTo(position, tickY).lineTo(position, tickY + tickOptions.size);
  }
  alignPathToPixel(tick);
  return tick;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-grid-line.js
function createAxisGridLine(options, gridLine) {
  const { lineStart, lineEnd, position } = options;
  const line = new drawing_exports.Path({
    stroke: {
      width: gridLine.width,
      color: gridLine.color,
      dashType: gridLine.dashType
    }
  });
  if (options.vertical) {
    line.moveTo(lineStart, position).lineTo(lineEnd, position);
  } else {
    line.moveTo(position, lineStart).lineTo(position, lineEnd);
  }
  alignPathToPixel(line);
  return line;
}

// node_modules/@progress/kendo-charts/dist/es/core/axis.js
var Axis = class extends chart_element_default {
  constructor(options, chartService = new chart_service_default()) {
    super(options);
    this.chartService = chartService;
    if (!this.options.visible) {
      this.options = deepExtend({}, this.options, {
        labels: {
          visible: false
        },
        line: {
          visible: false
        },
        margin: 0,
        majorTickSize: 0,
        minorTickSize: 0
      });
    }
    this.options.minorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.minorTickType !== NONE
    }, this.options.minorTicks, {
      size: this.options.minorTickSize,
      align: this.options.minorTickType
    });
    this.options.majorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.majorTickType !== NONE
    }, this.options.majorTicks, {
      size: this.options.majorTickSize,
      align: this.options.majorTickType
    });
    this.initFields();
    if (!this.options._deferLabels) {
      this.createLabels();
    }
    this.createTitle();
    this.createNotes();
  }
  initFields() {
  }
  // abstract labelsCount(): Number
  // abstract createAxisLabel(index, options): AxisLabel
  labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.labelsCount()
    };
  }
  normalizeLabelRotation(labelOptions) {
    const rotation = labelOptions.rotation;
    if (isObject(rotation)) {
      labelOptions.alignRotation = rotation.align;
      labelOptions.rotation = rotation.angle;
    }
  }
  createLabels() {
    const options = this.options;
    const align = options.vertical ? RIGHT : CENTER;
    const labelOptions = deepExtend({}, options.labels, {
      align,
      zIndex: options.zIndex
    });
    const step = Math.max(1, labelOptions.step);
    this.clearLabels();
    if (labelOptions.visible) {
      this.normalizeLabelRotation(labelOptions);
      if (labelOptions.rotation === "auto") {
        labelOptions.rotation = 0;
        options.autoRotateLabels = true;
      }
      const range = this.labelsRange();
      for (let idx = range.min; idx < range.max; idx += step) {
        const labelContext = { index: idx, count: range.max };
        let label = this.createAxisLabel(idx, labelOptions, labelContext);
        if (label) {
          this.append(label);
          this.labels.push(label);
        }
      }
    }
  }
  clearLabels() {
    this.children = grep(this.children, (child) => !(child instanceof axis_label_default));
    this.labels = [];
  }
  clearTitle() {
    if (this.title) {
      this.children = grep(this.children, (child) => child !== this.title);
      this.title = void 0;
    }
  }
  clear() {
    this.clearLabels();
    this.clearTitle();
  }
  lineBox() {
    const { options, box } = this;
    const vertical = options.vertical;
    const mirror = options.labels.mirror;
    const axisX = mirror ? box.x1 : box.x2;
    const axisY = mirror ? box.y2 : box.y1;
    const lineWidth = options.line.width || 0;
    return vertical ? new box_default(axisX, box.y1, axisX, box.y2 - lineWidth) : new box_default(box.x1, axisY, box.x2 - lineWidth, axisY);
  }
  createTitle() {
    const options = this.options;
    const titleOptions = deepExtend({
      rotation: options.vertical ? -90 : 0,
      text: "",
      zIndex: 1,
      visualSize: true
    }, options.title);
    if (titleOptions.visible && titleOptions.text) {
      const title3 = new text_box_default(titleOptions.text, titleOptions);
      this.append(title3);
      this.title = title3;
    }
  }
  createNotes() {
    const options = this.options;
    const notes3 = options.notes;
    const items = notes3.data || [];
    this.notes = [];
    for (let i = 0; i < items.length; i++) {
      const item = deepExtend({}, notes3, items[i]);
      item.value = this.parseNoteValue(item.value);
      const note = new note_default({
        value: item.value,
        text: item.label.text,
        dataItem: item
      }, item, this.chartService);
      if (note.options.visible) {
        if (defined(note.options.position)) {
          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        } else {
          if (options.vertical) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        }
        this.append(note);
        this.notes.push(note);
      }
    }
  }
  parseNoteValue(value2) {
    return value2;
  }
  renderVisual() {
    super.renderVisual();
    this.createPlotBands();
  }
  createVisual() {
    super.createVisual();
    this.createBackground();
    this.createLine();
  }
  gridLinesVisual() {
    let gridLines = this._gridLines;
    if (!gridLines) {
      gridLines = this._gridLines = new drawing_exports.Group({
        zIndex: -2
      });
      this.appendVisual(this._gridLines);
    }
    return gridLines;
  }
  createTicks(lineGroup) {
    const options = this.options;
    const lineBox = this.lineBox();
    const mirror = options.labels.mirror;
    const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    const tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical: options.vertical
    };
    function render(tickPositions, tickOptions, skipUnit) {
      const count = tickPositions.length;
      const step = Math.max(1, tickOptions.step);
      if (tickOptions.visible) {
        for (let i = tickOptions.skip; i < count; i += step) {
          if (defined(skipUnit) && i % skipUnit === 0) {
            continue;
          }
          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
          tickLineOptions.position = tickPositions[i];
          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
        }
      }
    }
    render(this.getMajorTickPositions(), options.majorTicks);
    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);
  }
  createLine() {
    const options = this.options;
    const line = options.line;
    const lineBox = this.lineBox();
    if (line.width > 0 && line.visible) {
      const path = new drawing_exports.Path({
        stroke: {
          width: line.width,
          color: line.color,
          dashType: line.dashType
        }
        /* TODO
        zIndex: line.zIndex,
        */
      });
      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      if (options._alignLines) {
        alignPathToPixel(path);
      }
      const group = this._lineGroup = new drawing_exports.Group();
      group.append(path);
      this.visual.append(group);
      this.createTicks(group);
    }
  }
  getActualTickSize() {
    const options = this.options;
    let tickSize = 0;
    if (options.majorTicks.visible && options.minorTicks.visible) {
      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);
    } else if (options.majorTicks.visible) {
      tickSize = options.majorTicks.size;
    } else if (options.minorTicks.visible) {
      tickSize = options.minorTicks.size;
    }
    return tickSize;
  }
  createBackground() {
    const { options, box } = this;
    const background = options.background;
    if (background) {
      this._backgroundPath = drawing_exports.Path.fromRect(box.toRect(), {
        fill: {
          color: background
        },
        stroke: null
      });
      this.visual.append(this._backgroundPath);
    }
  }
  createPlotBands() {
    const options = this.options;
    const plotBands = options.plotBands || [];
    const vertical = options.vertical;
    const plotArea = this.plotArea;
    if (plotBands.length === 0) {
      return;
    }
    const group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    const altAxis = grep(this.pane.axes, (axis) => axis.options.vertical !== this.options.vertical)[0];
    for (let idx = 0; idx < plotBands.length; idx++) {
      let item = plotBands[idx];
      let slotX, slotY;
      let labelOptions = item.label;
      let label;
      if (vertical) {
        slotX = (altAxis || plotArea.axisX).lineBox();
        slotY = this.getSlot(item.from, item.to, true);
      } else {
        slotX = this.getSlot(item.from, item.to, true);
        slotY = (altAxis || plotArea.axisY).lineBox();
      }
      if (labelOptions) {
        labelOptions.vAlign = labelOptions.position || LEFT;
        label = this.createPlotBandLabel(
          labelOptions,
          item,
          new box_default(
            slotX.x1,
            slotY.y1,
            slotX.x2,
            slotY.y2
          )
        );
      }
      if (slotX.width() !== 0 && slotY.height() !== 0) {
        const bandRect = new geometry_exports.Rect(
          [slotX.x1, slotY.y1],
          [slotX.width(), slotY.height()]
        );
        const path = drawing_exports.Path.fromRect(bandRect, {
          fill: {
            color: item.color,
            opacity: item.opacity
          },
          stroke: null
        });
        group.append(path);
        if (label) {
          group.append(label);
        }
      }
    }
    this.appendVisual(group);
  }
  createPlotBandLabel(label, item, box) {
    if (label.visible === false) {
      return null;
    }
    let text = label.text;
    let textbox;
    if (defined(label) && label.visible) {
      const labelTemplate = getTemplate(label);
      if (labelTemplate) {
        text = labelTemplate({ text, item });
      } else if (label.format) {
        text = this.chartService.format.auto(label.format, text);
      }
      if (!label.color) {
        label.color = this.options.labels.color;
      }
    }
    textbox = new text_box_default(text, label);
    textbox.reflow(box);
    textbox.renderVisual();
    return textbox.visual;
  }
  createGridLines(altAxis) {
    const options = this.options;
    const { minorGridLines, majorGridLines, minorUnit, vertical } = options;
    const axisLineVisible = altAxis.options.line.visible;
    const majorUnit = majorGridLines.visible ? options.majorUnit : 0;
    const lineBox = altAxis.lineBox();
    const linePos = lineBox[vertical ? "y1" : "x1"];
    const lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    const majorTicks = [];
    const container = this.gridLinesVisual();
    function render(tickPositions, gridLine, skipUnit) {
      const count = tickPositions.length;
      const step = Math.max(1, gridLine.step);
      if (gridLine.visible) {
        for (let i = gridLine.skip; i < count; i += step) {
          let pos = round(tickPositions[i]);
          if (!inArray(pos, majorTicks)) {
            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
              lineOptions.position = pos;
              container.append(createAxisGridLine(lineOptions, gridLine));
              majorTicks.push(pos);
            }
          }
        }
      }
    }
    render(this.getMajorTickPositions(), majorGridLines);
    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);
    return container.children;
  }
  reflow(box) {
    const { options, labels, title: title3 } = this;
    const vertical = options.vertical;
    const count = labels.length;
    const sizeFn = vertical ? WIDTH : HEIGHT;
    const titleSize = title3 ? title3.box[sizeFn]() : 0;
    const space = this.getActualTickSize() + options.margin + titleSize;
    const rootBox = (this.getRoot() || {}).box || box;
    const boxSize = rootBox[sizeFn]();
    let maxLabelSize = 0;
    for (let i = 0; i < count; i++) {
      let labelSize = labels[i].box[sizeFn]();
      if (labelSize + space <= boxSize) {
        maxLabelSize = Math.max(maxLabelSize, labelSize);
      }
    }
    if (vertical) {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x1 + maxLabelSize + space,
        box.y2
      );
    } else {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x2,
        box.y1 + maxLabelSize + space
      );
    }
    this.arrangeTitle();
    this.arrangeLabels();
    this.arrangeNotes();
  }
  getLabelsTickPositions() {
    return this.getMajorTickPositions();
  }
  labelTickIndex(label) {
    return label.index;
  }
  arrangeLabels() {
    const { options, labels } = this;
    const labelsBetweenTicks = this.labelsBetweenTicks();
    const vertical = options.vertical;
    const mirror = options.labels.mirror;
    const tickPositions = this.getLabelsTickPositions();
    for (let idx = 0; idx < labels.length; idx++) {
      const label = labels[idx];
      const tickIx = this.labelTickIndex(label);
      const labelSize = vertical ? label.box.height() : label.box.width();
      const firstTickPosition = tickPositions[tickIx];
      const nextTickPosition = tickPositions[tickIx + 1];
      let positionStart, positionEnd;
      if (vertical) {
        if (labelsBetweenTicks) {
          const middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
          positionStart = middle - labelSize / 2;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
        }
        positionEnd = positionStart;
      } else {
        if (labelsBetweenTicks) {
          positionStart = firstTickPosition;
          positionEnd = nextTickPosition;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
          positionEnd = positionStart + labelSize;
        }
      }
      this.positionLabel(label, mirror, positionStart, positionEnd);
    }
  }
  positionLabel(label, mirror, positionStart, positionEnd = positionStart) {
    const options = this.options;
    const vertical = options.vertical;
    const lineBox = this.lineBox();
    const labelOffset = this.getActualTickSize() + options.margin;
    let labelBox;
    if (vertical) {
      let labelX = lineBox.x2;
      if (mirror) {
        labelX += labelOffset;
        label.options.rotationOrigin = LEFT;
      } else {
        labelX -= labelOffset + label.box.width();
        label.options.rotationOrigin = RIGHT;
      }
      labelBox = label.box.move(labelX, positionStart);
    } else {
      let labelY = lineBox.y1;
      if (mirror) {
        labelY -= labelOffset + label.box.height();
        label.options.rotationOrigin = BOTTOM;
      } else {
        labelY += labelOffset;
        label.options.rotationOrigin = TOP;
      }
      labelBox = new box_default(
        positionStart,
        labelY,
        positionEnd,
        labelY + label.box.height()
      );
    }
    label.reflow(labelBox);
  }
  autoRotateLabelAngle(labelBox, slotWidth) {
    if (labelBox.width() < slotWidth) {
      return 0;
    }
    if (labelBox.height() > slotWidth) {
      return -90;
    }
    return -45;
  }
  autoRotateLabels() {
    if (!this.options.autoRotateLabels || this.options.vertical) {
      return false;
    }
    const tickPositions = this.getMajorTickPositions();
    const labels = this.labels;
    const limit = Math.min(labels.length, tickPositions.length - 1);
    let angle = 0;
    for (let idx = 0; idx < limit; idx++) {
      const width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);
      const labelBox = labels[idx].box;
      const labelAngle = this.autoRotateLabelAngle(labelBox, width);
      if (labelAngle !== 0) {
        angle = labelAngle;
      }
      if (angle === -90) {
        break;
      }
    }
    if (angle !== 0) {
      for (let idx = 0; idx < labels.length; idx++) {
        labels[idx].options.rotation = angle;
        labels[idx].reflow(new box_default());
      }
      return true;
    }
  }
  arrangeTitle() {
    const { options, title: title3 } = this;
    const mirror = options.labels.mirror;
    const vertical = options.vertical;
    if (title3) {
      if (vertical) {
        title3.options.align = mirror ? RIGHT : LEFT;
        title3.options.vAlign = title3.options.position;
      } else {
        title3.options.align = title3.options.position;
        title3.options.vAlign = mirror ? TOP : BOTTOM;
      }
      title3.reflow(this.box);
    }
  }
  arrangeNotes() {
    for (let idx = 0; idx < this.notes.length; idx++) {
      const item = this.notes[idx];
      const value2 = item.options.value;
      let slot;
      if (defined(value2)) {
        if (this.shouldRenderNote(value2)) {
          item.show();
        } else {
          item.hide();
        }
        slot = this.noteSlot(value2);
      } else {
        item.hide();
      }
      item.reflow(slot || this.lineBox());
    }
  }
  noteSlot(value2) {
    return this.getSlot(value2);
  }
  alignTo(secondAxis) {
    const lineBox = secondAxis.lineBox();
    const vertical = this.options.vertical;
    const pos = vertical ? Y : X;
    this.box.snapTo(lineBox, pos);
    if (vertical) {
      this.box.shrink(0, this.lineBox().height() - lineBox.height());
    } else {
      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
    }
    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
  }
  axisLabelText(value2, options, context) {
    let text;
    const tmpl = getTemplate(options);
    const defaultText = () => {
      if (!options.format) {
        return value2;
      }
      return this.chartService.format.localeAuto(
        options.format,
        [value2],
        options.culture
      );
    };
    if (tmpl) {
      const templateContext = Object.assign({}, context, {
        get text() {
          return defaultText();
        },
        value: value2,
        format: options.format,
        culture: options.culture
      });
      text = tmpl(templateContext);
    } else {
      text = defaultText();
    }
    return text;
  }
  slot(from, to, limit) {
    const slot = this.getSlot(from, to, limit);
    if (slot) {
      return slot.toRect();
    }
  }
  contentBox() {
    const box = this.box.clone();
    const labels = this.labels;
    if (labels.length) {
      const axis = this.options.vertical ? Y : X;
      if (this.chartService.isPannable(axis)) {
        const offset = this.maxLabelOffset();
        box[axis + 1] -= offset.start;
        box[axis + 2] += offset.end;
      } else {
        if (labels[0].options.visible) {
          box.wrap(labels[0].box);
        }
        const lastLabel = labels[labels.length - 1];
        if (lastLabel.options.visible) {
          box.wrap(lastLabel.box);
        }
      }
    }
    return box;
  }
  maxLabelOffset() {
    const { vertical, reverse } = this.options;
    const labelsBetweenTicks = this.labelsBetweenTicks();
    const tickPositions = this.getLabelsTickPositions();
    const offsetField = vertical ? Y : X;
    const labels = this.labels;
    const startPosition = reverse ? 1 : 0;
    const endPosition = reverse ? 0 : 1;
    let maxStartOffset = 0;
    let maxEndOffset = 0;
    for (let idx = 0; idx < labels.length; idx++) {
      const label = labels[idx];
      const tickIx = this.labelTickIndex(label);
      let startTick, endTick;
      if (labelsBetweenTicks) {
        startTick = tickPositions[tickIx + startPosition];
        endTick = tickPositions[tickIx + endPosition];
      } else {
        startTick = endTick = tickPositions[tickIx];
      }
      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);
      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);
    }
    return {
      start: maxStartOffset,
      end: maxEndOffset
    };
  }
  limitRange(from, to, min4, max3, offset) {
    const options = this.options;
    if (from < min4 && offset < 0 && (!defined(options.min) || options.min <= min4) || max3 < to && offset > 0 && (!defined(options.max) || max3 <= options.max)) {
      return null;
    }
    if (to < min4 && offset > 0 || max3 < from && offset < 0) {
      return {
        min: from,
        max: to
      };
    }
    const rangeSize = to - from;
    let minValue = from;
    let maxValue = to;
    if (from < min4 && offset < 0) {
      minValue = limitValue(from, min4, max3);
      maxValue = limitValue(from + rangeSize, min4 + rangeSize, max3);
    } else if (to > max3 && offset > 0) {
      maxValue = limitValue(to, min4, max3);
      minValue = limitValue(to - rangeSize, min4, max3 - rangeSize);
    }
    return {
      min: minValue,
      max: maxValue
    };
  }
  valueRange() {
    return {
      min: this.seriesMin,
      max: this.seriesMax
    };
  }
  lineDir() {
    const { vertical, reverse } = this.options;
    return (vertical ? -1 : 1) * (reverse ? -1 : 1);
  }
  lineInfo() {
    const { vertical } = this.options;
    const lineBox = this.lineBox();
    const lineSize = vertical ? lineBox.height() : lineBox.width();
    const axis = vertical ? Y : X;
    const axisDir = this.lineDir();
    const startEdge = axisDir === 1 ? 1 : 2;
    const axisOrigin = axis + startEdge.toString();
    const lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  }
  pointOffset(point) {
    const { axis, axisDir, axisOrigin, lineBox, lineSize } = this.lineInfo();
    const relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];
    const offset = relative / lineSize;
    return offset;
  }
  // Computes the axis range change (delta) for a given scale factor.
  // The delta is subtracted from the axis range:
  //   * delta > 0 reduces the axis range (zoom-in)
  //   * delta < 0 expands the axis range (zoom-out)
  scaleToDelta(rawScale, range) {
    const MAX_SCALE = 0.999;
    const scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);
    let delta;
    if (scale > 0) {
      delta = range * Math.min(1, scale);
    } else {
      delta = range - range / (1 + scale);
    }
    return delta;
  }
  labelsBetweenTicks() {
    return !this.options.justified;
  }
  //add legacy fields to the options that are no longer generated by default
  prepareUserOptions() {
  }
};
setDefaultOptions(Axis, {
  labels: {
    visible: true,
    rotation: 0,
    mirror: false,
    step: 1,
    skip: 0
  },
  line: {
    width: 1,
    color: BLACK,
    visible: true
  },
  title: {
    visible: true,
    position: CENTER
  },
  majorTicks: {
    align: OUTSIDE,
    size: 4,
    skip: 0,
    step: 1
  },
  minorTicks: {
    align: OUTSIDE,
    size: 3,
    skip: 0,
    step: 1
  },
  axisCrossingValue: 0,
  majorTickType: OUTSIDE,
  minorTickType: NONE,
  majorGridLines: {
    skip: 0,
    step: 1
  },
  minorGridLines: {
    visible: false,
    width: 1,
    color: BLACK,
    skip: 0,
    step: 1
  },
  // TODO: Move to line or labels options
  margin: 5,
  visible: true,
  reverse: false,
  justified: true,
  notes: {
    label: {
      text: ""
    }
  },
  _alignLines: true,
  _deferLabels: false
});
var axis_default = Axis;

// node_modules/@progress/kendo-charts/dist/es/date-utils/constants.js
var MILLISECONDS = "milliseconds";
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var DAYS = "days";
var WEEKS = "weeks";
var MONTHS = "months";
var YEARS = "years";
var TIME_PER_MILLISECOND = 1;
var TIME_PER_SECOND = 1e3;
var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;
var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;
var TIME_PER_DAY = 24 * TIME_PER_HOUR;
var TIME_PER_WEEK = 7 * TIME_PER_DAY;
var TIME_PER_MONTH = 31 * TIME_PER_DAY;
var TIME_PER_YEAR = 365 * TIME_PER_DAY;
var TIME_PER_UNIT = {
  "years": TIME_PER_YEAR,
  "months": TIME_PER_MONTH,
  "weeks": TIME_PER_WEEK,
  "days": TIME_PER_DAY,
  "hours": TIME_PER_HOUR,
  "minutes": TIME_PER_MINUTE,
  "seconds": TIME_PER_SECOND,
  "milliseconds": TIME_PER_MILLISECOND
};

// node_modules/@progress/kendo-charts/dist/es/date-utils/absolute-date-diff.js
function absoluteDateDiff(a, b) {
  const diff = a.getTime() - b;
  const offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();
  return diff - offsetDiff * TIME_PER_MINUTE;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-ticks.js
function addTicks(date, ticks) {
  return new Date(date.getTime() + ticks);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-date.js
function toDate(value2) {
  let result;
  if (value2 instanceof Date) {
    result = value2;
  } else if (value2) {
    result = new Date(value2);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/start-of-week.js
function startOfWeek(date, weekStartDay = 0) {
  let daysToSubtract = 0;
  let day = date.getDay();
  if (!isNaN(day)) {
    while (day !== weekStartDay) {
      if (day === 0) {
        day = 6;
      } else {
        day--;
      }
      daysToSubtract++;
    }
  }
  return addTicks(date, -daysToSubtract * TIME_PER_DAY);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-duration.js
function adjustDST(date, hours) {
  if (hours === 0 && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
    return true;
  }
  return false;
}
function addHours(date, hours) {
  const roundedDate = new Date(date);
  roundedDate.setMinutes(0, 0, 0);
  const tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;
  return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);
}
function addDuration(dateValue, value2, unit, weekStartDay) {
  let result = dateValue;
  if (dateValue) {
    let date = toDate(dateValue);
    const hours = date.getHours();
    if (unit === YEARS) {
      result = new Date(date.getFullYear() + value2, 0, 1);
      adjustDST(result, 0);
    } else if (unit === MONTHS) {
      result = new Date(date.getFullYear(), date.getMonth() + value2, 1);
      adjustDST(result, hours);
    } else if (unit === WEEKS) {
      result = addDuration(startOfWeek(date, weekStartDay), value2 * 7, DAYS);
      adjustDST(result, hours);
    } else if (unit === DAYS) {
      result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value2);
      adjustDST(result, hours);
    } else if (unit === HOURS) {
      result = addHours(date, value2);
    } else if (unit === MINUTES) {
      result = addTicks(date, value2 * TIME_PER_MINUTE);
      if (result.getSeconds() > 0) {
        result.setSeconds(0);
      }
    } else if (unit === SECONDS) {
      result = addTicks(date, value2 * TIME_PER_SECOND);
    } else if (unit === MILLISECONDS) {
      result = addTicks(date, value2);
    }
    if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {
      result.setMilliseconds(0);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/floor-date.js
function floorDate(date, unit, weekStartDay) {
  return addDuration(toDate(date), 0, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/ceil-date.js
function ceilDate(dateValue, unit, weekStartDay) {
  const date = toDate(dateValue);
  if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {
    return date;
  }
  return addDuration(date, 1, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-comparer.js
function dateComparer(a, b) {
  if (a && b) {
    return a.getTime() - b.getTime();
  }
  return -1;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-diff.js
function dateDiff(a, b) {
  return a.getTime() - b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-time.js
function toTime(value2) {
  if (isArray(value2)) {
    let result = [];
    for (let idx = 0; idx < value2.length; idx++) {
      result.push(toTime(value2[idx]));
    }
    return result;
  } else if (value2) {
    return toDate(value2).getTime();
  }
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-equals.js
function dateEquals(a, b) {
  if (a && b) {
    return toTime(a) === toTime(b);
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-index.js
function timeIndex(date, start, baseUnit) {
  return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];
}
function dateIndex(value2, start, baseUnit, baseUnitStep) {
  const date = toDate(value2);
  const startDate = toDate(start);
  let index;
  if (baseUnit === MONTHS) {
    index = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  } else if (baseUnit === YEARS) {
    index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;
  } else if (baseUnit === DAYS || baseUnit === WEEKS) {
    index = timeIndex(date, startDate, baseUnit);
  } else {
    index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];
  }
  return index / baseUnitStep;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/duration.js
function duration(a, b, unit) {
  let diff;
  if (unit === YEARS) {
    diff = b.getFullYear() - a.getFullYear();
  } else if (unit === MONTHS) {
    diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();
  } else if (unit === DAYS) {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);
  } else {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);
  }
  return diff;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-date.js
function parseDate(intlService, date) {
  let result;
  if (isString(date)) {
    result = intlService.parseDate(date) || toDate(date);
  } else {
    result = toDate(date);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-dates.js
function parseDates(intlService, dates) {
  if (isArray(dates)) {
    const result = [];
    for (let idx = 0; idx < dates.length; idx++) {
      result.push(parseDate(intlService, dates[idx]));
    }
    return result;
  }
  return parseDate(intlService, dates);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/first-day.js
function firstDay(options, intlService) {
  if (isNumber(options.weekStartDay)) {
    return options.weekStartDay;
  }
  if (intlService && intlService.firstDay) {
    return intlService.firstDay();
  }
  return 0;
}

// node_modules/@progress/kendo-charts/dist/es/core/category-axis.js
var MIN_CATEGORY_POINTS_RANGE = 0.01;
var MIN_CATEGORY_RANGE = 0.1;
function indexOf(value2, arr) {
  if (value2 instanceof Date) {
    const length = arr.length;
    for (let idx = 0; idx < length; idx++) {
      if (dateEquals(arr[idx], value2)) {
        return idx;
      }
    }
    return -1;
  }
  return arr.indexOf(value2);
}
var CategoryAxis = class _CategoryAxis extends axis_default {
  initFields() {
    this._ticks = {};
  }
  categoriesHash() {
    return "";
  }
  clone() {
    const copy = new _CategoryAxis(Object.assign({}, this.options, {
      categories: this.options.srcCategories
    }), this.chartService);
    copy.createLabels();
    return copy;
  }
  initUserOptions(options) {
    const categories = options.categories || [];
    const definedMin = defined(options.min);
    const definedMax = defined(options.max);
    options.srcCategories = options.categories = categories;
    if ((definedMin || definedMax) && categories.length) {
      const min4 = definedMin ? Math.floor(options.min) : 0;
      let max3;
      if (definedMax) {
        max3 = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);
      } else {
        max3 = categories.length;
      }
      options.categories = options.categories.slice(min4, max3);
    }
    return options;
  }
  rangeIndices() {
    const options = this.options;
    const length = options.categories.length || 1;
    const min4 = isNumber(options.min) ? options.min % 1 : 0;
    let max3;
    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {
      max3 = length - (1 - options.max % 1);
    } else {
      max3 = length - (options.justified ? 1 : 0);
    }
    return {
      min: min4,
      max: max3
    };
  }
  range() {
    const options = this.options;
    const min4 = isNumber(options.min) ? options.min : 0;
    const max3 = isNumber(options.max) ? options.max : this.totalRange().max;
    return {
      min: min4,
      max: max3
    };
  }
  roundedRange() {
    return this.range();
  }
  totalRange() {
    const options = this.options;
    return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };
  }
  scaleOptions() {
    const { min: min4, max: max3 } = this.rangeIndices();
    const lineBox = this.lineBox();
    const size = this.options.vertical ? lineBox.height() : lineBox.width();
    const scale = size / (max3 - min4 || 1);
    return {
      scale: scale * (this.options.reverse ? -1 : 1),
      box: lineBox,
      min: min4,
      max: max3
    };
  }
  arrangeLabels() {
    super.arrangeLabels();
    this.hideOutOfRangeLabels();
  }
  hideOutOfRangeLabels() {
    const { box, labels } = this;
    if (labels.length > 0) {
      const valueAxis = this.options.vertical ? Y : X;
      const start = box[valueAxis + 1];
      const end = box[valueAxis + 2];
      const firstLabel = labels[0];
      const lastLabel = last(labels);
      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
        firstLabel.options.visible = false;
      }
      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
        lastLabel.options.visible = false;
      }
    }
  }
  getMajorTickPositions() {
    return this.getTicks().majorTicks;
  }
  getMinorTickPositions() {
    return this.getTicks().minorTicks;
  }
  getLabelsTickPositions() {
    return this.getTicks().labelTicks;
  }
  tickIndices(stepSize) {
    const { min: min4, max: max3 } = this.rangeIndices();
    const limit = Math.ceil(max3);
    let current4 = Math.floor(min4);
    const indices = [];
    while (current4 <= limit) {
      indices.push(current4);
      current4 += stepSize;
    }
    return indices;
  }
  getTickPositions(stepSize) {
    const { vertical, reverse } = this.options;
    const { scale, box, min: min4 } = this.scaleOptions();
    const pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];
    const indices = this.tickIndices(stepSize);
    const positions = [];
    for (let idx = 0; idx < indices.length; idx++) {
      positions.push(pos + round(scale * (indices[idx] - min4), COORD_PRECISION));
    }
    return positions;
  }
  getTicks() {
    const options = this.options;
    const cache2 = this._ticks;
    const range = this.rangeIndices();
    const lineBox = this.lineBox();
    const hash = lineBox.getHash() + range.min + "," + range.max + options.reverse + options.justified;
    if (cache2._hash !== hash) {
      const hasMinor = options.minorTicks.visible || options.minorGridLines.visible;
      cache2._hash = hash;
      cache2.labelTicks = this.getTickPositions(1);
      cache2.majorTicks = this.filterOutOfRangePositions(cache2.labelTicks, lineBox);
      cache2.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];
    }
    return cache2;
  }
  filterOutOfRangePositions(positions, lineBox) {
    if (!positions.length) {
      return positions;
    }
    const axis = this.options.vertical ? Y : X;
    const inRange = (position) => lineBox[axis + 1] <= position && position <= lineBox[axis + 2];
    const end = positions.length - 1;
    let startIndex = 0;
    while (!inRange(positions[startIndex]) && startIndex <= end) {
      startIndex++;
    }
    let endIndex = end;
    while (!inRange(positions[endIndex]) && endIndex >= 0) {
      endIndex--;
    }
    return positions.slice(startIndex, endIndex + 1);
  }
  lineInfo() {
    const { vertical, reverse } = this.options;
    const lineBox = this.lineBox();
    const lineSize = vertical ? lineBox.height() : lineBox.width();
    const axis = vertical ? Y : X;
    const axisDir = reverse ? -1 : 1;
    const startEdge = axisDir === 1 ? 1 : 2;
    const axisOrigin = axis + startEdge.toString();
    const lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  }
  lineDir() {
    const { reverse } = this.options;
    return reverse ? -1 : 1;
  }
  // TODO: Rename to slotBox, valueSlot, slotByIndex?
  getSlot(from, to, limit) {
    const options = this.options;
    const { reverse, justified } = options;
    const { scale, box, min: min4 } = this.scaleOptions();
    const { axis: valueAxis, lineStart } = this.lineInfo();
    const slotBox = box.clone();
    const singleSlot = !defined(to);
    const start = valueOrDefault(from, 0);
    let end = valueOrDefault(to, start);
    end = Math.max(end - 1, start);
    end = Math.max(start, end);
    let p1 = lineStart + (start - min4) * scale;
    let p2 = lineStart + (end + 1 - min4) * scale;
    if (singleSlot && justified) {
      p2 = p1;
    }
    if (limit) {
      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);
      p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);
    }
    slotBox[valueAxis + 1] = reverse ? p2 : p1;
    slotBox[valueAxis + 2] = reverse ? p1 : p2;
    return slotBox;
  }
  limitSlot(slot) {
    const vertical = this.options.vertical;
    const valueAxis = vertical ? Y : X;
    const lineBox = this.lineBox();
    const limittedSlot = slot.clone();
    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    return limittedSlot;
  }
  slot(from, to, limit) {
    const min4 = Math.floor(this.options.min || 0);
    let start = from;
    let end = to;
    if (typeof start === "string") {
      start = this.categoryIndex(start);
    } else if (isNumber(start)) {
      start -= min4;
    }
    if (typeof end === "string") {
      end = this.categoryIndex(end);
    } else if (isNumber(end)) {
      end -= min4;
    }
    return super.slot(start, end, limit);
  }
  pointCategoryIndex(point) {
    const { reverse, justified, vertical } = this.options;
    const valueAxis = vertical ? Y : X;
    const { scale, box, min: min4, max: max3 } = this.scaleOptions();
    const startValue = reverse ? max3 : min4;
    const lineStart = box[valueAxis + 1];
    const lineEnd = box[valueAxis + 2];
    const pos = point[valueAxis];
    if (pos < lineStart || pos > lineEnd) {
      return null;
    }
    let value2 = startValue + (pos - lineStart) / scale;
    const diff = value2 % 1;
    if (justified) {
      value2 = Math.round(value2);
    } else if (diff === 0 && value2 > 0) {
      value2--;
    }
    return Math.floor(value2);
  }
  getCategory(point) {
    const index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.options.categories[index];
  }
  categoryIndex(value2) {
    return this.totalIndex(value2) - Math.floor(this.options.min || 0);
  }
  categoryAt(index, total) {
    const options = this.options;
    return (total ? options.srcCategories : options.categories)[index];
  }
  categoriesCount() {
    return (this.options.categories || []).length;
  }
  translateRange(delta) {
    const options = this.options;
    const lineBox = this.lineBox();
    const size = options.vertical ? lineBox.height() : lineBox.width();
    const range = options.categories.length;
    const scale = size / range;
    const offset = round(delta / scale, DEFAULT_PRECISION);
    return {
      min: offset,
      max: range + offset
    };
  }
  scaleRange(scale, cursor) {
    const position = Math.abs(this.pointOffset(cursor));
    const rangeIndices = this.limitedRangeIndices();
    const range = rangeIndices.max - rangeIndices.min;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = position * delta;
    const maxDelta = (1 - position) * delta;
    const min4 = rangeIndices.min + minDelta;
    let max3 = rangeIndices.max - maxDelta;
    if (max3 - min4 < MIN_CATEGORY_RANGE) {
      max3 = min4 + MIN_CATEGORY_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const { min: totalMin, max: totalMax } = this.totalRange();
    const range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  }
  labelsCount() {
    const labelsRange = this.labelsRange();
    return labelsRange.max - labelsRange.min;
  }
  labelsRange() {
    const options = this.options;
    const { justified, labels: labelOptions } = options;
    let { min: min4, max: max3 } = this.limitedRangeIndices(true);
    const start = Math.floor(min4);
    if (!justified) {
      min4 = Math.floor(min4);
      max3 = Math.ceil(max3);
    } else {
      min4 = Math.ceil(min4);
      max3 = Math.floor(max3);
    }
    let skip;
    if (min4 > labelOptions.skip) {
      skip = labelOptions.skip + labelOptions.step * Math.ceil((min4 - labelOptions.skip) / labelOptions.step);
    } else {
      skip = labelOptions.skip;
    }
    return {
      min: skip - start,
      max: (options.categories.length ? max3 + (justified ? 1 : 0) : 0) - start
    };
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const options = this.options;
    const dataItem = options.dataItems ? options.dataItems[index] : null;
    const category = valueOrDefault(options.categories[index], "");
    labelContext.dataItem = dataItem;
    const text = this.axisLabelText(category, labelOptions, labelContext);
    return new axis_label_default(category, text, index, dataItem, labelOptions);
  }
  shouldRenderNote(value2) {
    const range = this.limitedRangeIndices();
    return Math.floor(range.min) <= value2 && value2 <= Math.ceil(range.max);
  }
  noteSlot(value2) {
    const options = this.options;
    const index = value2 - Math.floor(options.min || 0);
    return this.getSlot(index);
  }
  arrangeNotes() {
    super.arrangeNotes();
    this.hideOutOfRangeNotes();
  }
  hideOutOfRangeNotes() {
    const { notes: notes3, box } = this;
    if (notes3 && notes3.length) {
      const valueAxis = this.options.vertical ? Y : X;
      const start = box[valueAxis + 1];
      const end = box[valueAxis + 2];
      for (let idx = 0; idx < notes3.length; idx++) {
        const note = notes3[idx];
        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {
          note.hide();
        }
      }
    }
  }
  pan(delta) {
    const range = this.limitedRangeIndices(true);
    const { scale } = this.scaleOptions();
    const offset = round(delta / scale, DEFAULT_PRECISION);
    const totalRange = this.totalRange();
    const min4 = range.min + offset;
    const max3 = range.max + offset;
    return this.limitRange(min4, max3, 0, totalRange.max, offset);
  }
  pointsRange(start, end) {
    const { reverse, vertical } = this.options;
    const valueAxis = vertical ? Y : X;
    const range = this.limitedRangeIndices(true);
    const { scale, box } = this.scaleOptions();
    const lineStart = box[valueAxis + (reverse ? 2 : 1)];
    const diffStart = start[valueAxis] - lineStart;
    const diffEnd = end[valueAxis] - lineStart;
    const min4 = range.min + diffStart / scale;
    const max3 = range.min + diffEnd / scale;
    const rangeMin = Math.min(min4, max3);
    const rangeMax = Math.max(min4, max3);
    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {
      return {
        min: rangeMin,
        max: rangeMax
      };
    }
  }
  valueRange() {
    return this.range();
  }
  totalIndex(value2) {
    const options = this.options;
    const index = this._categoriesMap ? this._categoriesMap.get(value2) : indexOf(value2, options.srcCategories);
    return index;
  }
  currentRangeIndices() {
    const options = this.options;
    let min4 = 0;
    if (isNumber(options.min)) {
      min4 = Math.floor(options.min);
    }
    let max3;
    if (isNumber(options.max)) {
      max3 = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;
    } else {
      max3 = this.totalCount() - 1;
    }
    return {
      min: min4,
      max: max3
    };
  }
  limitedRangeIndices(totalLimit) {
    const options = this.options;
    let min4 = isNumber(options.min) ? options.min : 0;
    let max3;
    if (isNumber(options.max)) {
      max3 = options.max;
    } else if (isNumber(options.min)) {
      max3 = min4 + options.categories.length;
    } else {
      max3 = this.totalRange().max || 1;
    }
    if (totalLimit) {
      const totalRange = this.totalRange();
      min4 = limitValue(min4, 0, totalRange.max);
      max3 = limitValue(max3, 0, totalRange.max);
    }
    return {
      min: min4,
      max: max3
    };
  }
  totalRangeIndices() {
    return {
      min: 0,
      max: this.totalRange().max || 1
    };
  }
  indexCategories() {
    if (!this._categoriesMap) {
      const map2 = this._categoriesMap = new HashMap();
      const srcCategories = this.options.srcCategories;
      for (let idx = 0; idx < srcCategories.length; idx++) {
        map2.set(srcCategories[idx], idx);
      }
    }
  }
  totalCount() {
    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);
  }
};
setDefaultOptions(CategoryAxis, {
  type: "category",
  vertical: false,
  majorGridLines: {
    visible: false,
    width: 1,
    color: BLACK
  },
  labels: {
    zIndex: 1
  },
  justified: false,
  _deferLabels: true
});
var category_axis_default = CategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/constants.js
var COORDINATE_LIMIT = 3e5;
var DateLabelFormats = {
  milliseconds: "HH:mm:ss.fff",
  seconds: "HH:mm:ss",
  minutes: "HH:mm",
  hours: "HH:mm",
  days: "M/d",
  weeks: "M/d",
  months: "MMM 'yy",
  years: "yyyy"
};
var ZERO_THRESHOLD = 0.2;

// node_modules/@progress/kendo-charts/dist/es/core/date-category-axis.js
var AUTO = "auto";
var BASE_UNITS = [
  MILLISECONDS,
  SECONDS,
  MINUTES,
  HOURS,
  DAYS,
  WEEKS,
  MONTHS,
  YEARS
];
var FIT = "fit";
function categoryRange(categories, clearCache) {
  if (clearCache) {
    categories._range = void 0;
  }
  let range = categories._range;
  if (!range) {
    range = categories._range = sparseArrayLimits(categories);
    range.min = toDate(range.min);
    range.max = toDate(range.max);
  }
  return range;
}
var EmptyDateRange = class {
  constructor(options) {
    this.options = options;
  }
  displayIndices() {
    return {
      min: 0,
      max: 1
    };
  }
  displayRange() {
    return {};
  }
  total() {
    return {};
  }
  valueRange() {
    return {};
  }
  valueIndex() {
    return -1;
  }
  values() {
    return [];
  }
  totalIndex() {
    return -1;
  }
  valuesCount() {
    return 0;
  }
  totalCount() {
    return 0;
  }
  dateAt() {
    return null;
  }
};
var DateRange = class {
  constructor(start, end, options) {
    this.options = options;
    options.baseUnitStep = options.baseUnitStep || 1;
    const { roundToBaseUnit, justified } = options;
    this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);
    const lowerEnd = this.roundToTotalStep(end);
    const expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;
    this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);
    const min4 = options.min || start;
    this.valueStart = this.roundToTotalStep(min4);
    this.displayStart = roundToBaseUnit ? this.valueStart : min4;
    const max3 = options.max;
    if (!max3) {
      this.valueEnd = lowerEnd;
      this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;
    } else {
      const next = !justified && dateEquals(max3, this.roundToTotalStep(max3)) ? -1 : 0;
      this.valueEnd = this.roundToTotalStep(max3, false, next);
      this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max3, !justified) : options.max;
    }
    if (this.valueEnd < this.valueStart) {
      this.valueEnd = this.valueStart;
    }
    if (this.displayEnd <= this.displayStart) {
      this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);
    }
  }
  displayRange() {
    return {
      min: this.displayStart,
      max: this.displayEnd
    };
  }
  displayIndices() {
    if (!this._indices) {
      const options = this.options;
      const { baseUnit, baseUnitStep } = options;
      const minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);
      const maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);
      this._indices = { min: minIdx, max: maxIdx };
    }
    return this._indices;
  }
  total() {
    return {
      min: this.start,
      max: this.end
    };
  }
  totalCount() {
    const last2 = this.totalIndex(this.end);
    return last2 + (this.options.justified ? 1 : 0);
  }
  valueRange() {
    return {
      min: this.valueStart,
      max: this.valueEnd
    };
  }
  valueIndex(value2) {
    const options = this.options;
    return Math.floor(dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep));
  }
  totalIndex(value2) {
    const options = this.options;
    return Math.floor(dateIndex(value2, this.start, options.baseUnit, options.baseUnitStep));
  }
  dateIndex(value2) {
    const options = this.options;
    return dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep);
  }
  valuesCount() {
    const maxIdx = this.valueIndex(this.valueEnd);
    return maxIdx + 1;
  }
  values() {
    let values = this._values;
    if (!values) {
      const options = this.options;
      const range = this.valueRange();
      this._values = values = [];
      for (let date = range.min; date <= range.max; ) {
        values.push(date);
        date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);
      }
    }
    return values;
  }
  dateAt(index, total) {
    const options = this.options;
    return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);
  }
  roundToTotalStep(value2, upper, next) {
    const { baseUnit, baseUnitStep, weekStartDay } = this.options;
    const start = this.start;
    const step = dateIndex(value2, start, baseUnit, baseUnitStep);
    let roundedStep = upper ? Math.ceil(step) : Math.floor(step);
    if (next) {
      roundedStep += next;
    }
    return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);
  }
};
function autoBaseUnit(options, startUnit, startStep) {
  const categoryLimits = categoryRange(options.categories);
  const span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);
  const { autoBaseUnitSteps, maxDateGroups } = options;
  const autoUnit = options.baseUnit === FIT;
  let autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;
  let baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;
  let units = span / TIME_PER_UNIT[baseUnit];
  let totalUnits = units;
  let unitSteps, step, nextStep;
  while (!step || units >= maxDateGroups) {
    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
    do {
      nextStep = unitSteps.shift();
    } while (nextStep && startUnit === baseUnit && nextStep < startStep);
    if (nextStep) {
      step = nextStep;
      units = totalUnits / step;
    } else if (baseUnit === last(BASE_UNITS)) {
      step = Math.ceil(totalUnits / maxDateGroups);
      break;
    } else if (autoUnit) {
      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);
      totalUnits = span / TIME_PER_UNIT[baseUnit];
      unitSteps = null;
    } else {
      if (units > maxDateGroups) {
        step = Math.ceil(totalUnits / maxDateGroups);
      }
      break;
    }
  }
  options.baseUnitStep = step;
  options.baseUnit = baseUnit;
}
function defaultBaseUnit(options) {
  const categories = options.categories;
  const count = defined(categories) ? categories.length : 0;
  let minDiff = MAX_VALUE;
  let lastCategory, unit;
  for (let categoryIx = 0; categoryIx < count; categoryIx++) {
    const category = categories[categoryIx];
    if (category && lastCategory) {
      let diff = Math.abs(absoluteDateDiff(category, lastCategory));
      if (diff !== 0) {
        minDiff = Math.min(minDiff, diff);
        if (minDiff >= TIME_PER_YEAR) {
          unit = YEARS;
        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {
          unit = MONTHS;
        } else if (minDiff >= TIME_PER_WEEK) {
          unit = WEEKS;
        } else if (minDiff >= TIME_PER_DAY) {
          unit = DAYS;
        } else if (minDiff >= TIME_PER_HOUR) {
          unit = HOURS;
        } else if (minDiff >= TIME_PER_MINUTE) {
          unit = MINUTES;
        } else {
          unit = SECONDS;
        }
      }
    }
    lastCategory = category;
  }
  options.baseUnit = unit || DAYS;
}
function initUnit(options) {
  const baseUnit = (options.baseUnit || "").toLowerCase();
  const useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);
  if (useDefault) {
    defaultBaseUnit(options);
  }
  if (baseUnit === FIT || options.baseUnitStep === AUTO) {
    autoBaseUnit(options);
  }
  return options;
}
var DateCategoryAxis = class _DateCategoryAxis extends category_axis_default {
  clone() {
    const copy = new _DateCategoryAxis(Object.assign({}, this.options), this.chartService);
    copy.createLabels();
    return copy;
  }
  categoriesHash() {
    const start = this.dataRange.total().min;
    return this.options.baseUnit + this.options.baseUnitStep + start;
  }
  initUserOptions(options) {
    return options;
  }
  initFields() {
    super.initFields();
    const chartService = this.chartService;
    const intlService = chartService.intl;
    let options = this.options;
    let categories = options.categories || [];
    if (!categories._parsed) {
      categories = parseDates(intlService, categories);
      categories._parsed = true;
    }
    options = deepExtend({
      roundToBaseUnit: true
    }, options, {
      categories,
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      weekStartDay: firstDay(options, intlService)
    });
    if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {
      options.roundToBaseUnit = false;
    }
    options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;
    options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;
    this.options = options;
    options.srcCategories = categories;
    if (categories.length > 0) {
      const range = categoryRange(categories, true);
      const maxDivisions = options.maxDivisions;
      const safeOptions = initUnit(options);
      const forecast = options._forecast;
      if (forecast) {
        if (forecast.before > 0) {
          range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
        if (forecast.after > 0) {
          range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
      }
      this.dataRange = new DateRange(range.min, range.max, safeOptions);
      if (maxDivisions) {
        const dataRange = this.dataRange.displayRange();
        const divisionOptions = Object.assign({}, options, {
          justified: true,
          roundToBaseUnit: false,
          baseUnit: "fit",
          min: dataRange.min,
          max: dataRange.max,
          maxDateGroups: maxDivisions
        });
        const dataRangeOptions = this.dataRange.options;
        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);
        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);
      } else {
        this.divisionRange = this.dataRange;
      }
    } else {
      options.baseUnit = options.baseUnit || DAYS;
      this.dataRange = this.divisionRange = new EmptyDateRange(options);
    }
    this.rangeLabels = [];
  }
  tickIndices(stepSize) {
    const { dataRange, divisionRange } = this;
    const valuesCount = divisionRange.valuesCount();
    if (!this.options.maxDivisions || !valuesCount) {
      return super.tickIndices(stepSize);
    }
    const indices = [];
    let values = divisionRange.values();
    let offset = 0;
    if (!this.options.justified) {
      values = values.concat(divisionRange.dateAt(valuesCount));
      offset = 0.5;
    }
    for (let idx = 0; idx < values.length; idx++) {
      indices.push(dataRange.dateIndex(values[idx]) + offset);
      if (stepSize !== 1 && idx >= 1) {
        const last2 = indices.length - 1;
        indices.splice(idx, 0, indices[last2 - 1] + (indices[last2] - indices[last2 - 1]) * stepSize);
      }
    }
    return indices;
  }
  shouldRenderNote(value2) {
    const range = this.range();
    const categories = this.options.categories || [];
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0 && categories.length;
  }
  parseNoteValue(value2) {
    return parseDate(this.chartService.intl, value2);
  }
  noteSlot(value2) {
    return this.getSlot(value2);
  }
  translateRange(delta) {
    const options = this.options;
    const { baseUnit, weekStartDay, vertical } = options;
    const lineBox = this.lineBox();
    const size = vertical ? lineBox.height() : lineBox.width();
    let range = this.range();
    const scale = size / (range.max - range.min);
    const offset = round(delta / scale, DEFAULT_PRECISION);
    if (range.min && range.max) {
      const from = addTicks(options.min || range.min, offset);
      const to = addTicks(options.max || range.max, offset);
      range = {
        min: addDuration(from, 0, baseUnit, weekStartDay),
        max: addDuration(to, 0, baseUnit, weekStartDay)
      };
    }
    return range;
  }
  labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.divisionRange.valuesCount()
    };
  }
  pan(delta) {
    if (this.isEmpty()) {
      return null;
    }
    const options = this.options;
    const lineBox = this.lineBox();
    const size = options.vertical ? lineBox.height() : lineBox.width();
    const { min: min4, max: max3 } = this.dataRange.displayRange();
    const totalLimits = this.dataRange.total();
    const scale = size / (max3 - min4);
    const offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);
    const from = addTicks(min4, offset);
    const to = addTicks(max3, offset);
    const panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);
    if (panRange) {
      panRange.min = toDate(panRange.min);
      panRange.max = toDate(panRange.max);
      panRange.baseUnit = options.baseUnit;
      panRange.baseUnitStep = options.baseUnitStep || 1;
      panRange.userSetBaseUnit = options.userSetBaseUnit;
      panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;
      return panRange;
    }
  }
  pointsRange(start, end) {
    if (this.isEmpty()) {
      return null;
    }
    const pointsRange = super.pointsRange(start, end);
    const datesRange = this.dataRange.displayRange();
    const indicesRange = this.dataRange.displayIndices();
    const scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
    const options = this.options;
    const min4 = addTicks(datesRange.min, pointsRange.min * scale);
    const max3 = addTicks(datesRange.min, pointsRange.max * scale);
    return {
      min: min4,
      max: max3,
      baseUnit: options.userSetBaseUnit || options.baseUnit,
      baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
    };
  }
  scaleRange(scale, cursor) {
    if (this.isEmpty()) {
      return {};
    }
    const options = this.options;
    const fit = options.userSetBaseUnit === FIT;
    const totalLimits = this.dataRange.total();
    const { min: rangeMin, max: rangeMax } = this.dataRange.displayRange();
    const position = Math.abs(this.pointOffset(cursor));
    const range = rangeMax - rangeMin;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = Math.round(position * delta);
    const maxDelta = Math.round((1 - position) * delta);
    let { baseUnit } = this.dataRange.options;
    let min4 = new Date(rangeMin.getTime() + minDelta);
    let max3 = new Date(rangeMax.getTime() - maxDelta);
    if (fit) {
      const { autoBaseUnitSteps, maxDateGroups } = options;
      const maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];
      const rangeDiff = dateDiff(rangeMax, rangeMin);
      const diff = dateDiff(max3, min4);
      let baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
      let autoBaseUnitStep, ticks;
      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {
        baseUnit = BASE_UNITS[baseUnitIndex - 1];
        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);
        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;
        min4 = addTicks(rangeMin, ticks);
        max3 = addTicks(rangeMax, -ticks);
      } else if (diff > maxDiff && baseUnit !== YEARS) {
        let stepIndex = 0;
        do {
          baseUnitIndex++;
          baseUnit = BASE_UNITS[baseUnitIndex];
          stepIndex = 0;
          ticks = 2 * TIME_PER_UNIT[baseUnit];
          do {
            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
            stepIndex++;
          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);
        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
        if (ticks > 0) {
          min4 = addTicks(rangeMin, -ticks);
          max3 = addTicks(rangeMax, ticks);
          min4 = addTicks(min4, limitValue(max3, totalLimits.min, totalLimits.max) - max3);
          max3 = addTicks(max3, limitValue(min4, totalLimits.min, totalLimits.max) - min4);
        }
      }
    }
    if (min4 && max3 && dateDiff(max3, min4) > 0) {
      return {
        min: min4,
        max: max3,
        baseUnit: options.userSetBaseUnit || options.baseUnit,
        baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
      };
    }
  }
  zoomRange(scale, cursor) {
    const totalLimits = this.dataRange.total();
    const range = this.scaleRange(scale, cursor);
    if (range) {
      if (range.min < totalLimits.min) {
        range.min = totalLimits.min;
      }
      if (range.max > totalLimits.max) {
        range.max = totalLimits.max;
      }
    }
    return range;
  }
  range() {
    return this.dataRange.displayRange();
  }
  createLabels() {
    super.createLabels();
    this.createRangeLabels();
  }
  clearLabels() {
    super.clearLabels();
    this.rangeLabels = [];
  }
  arrangeLabels() {
    this.arrangeRangeLabels();
    super.arrangeLabels();
  }
  arrangeRangeLabels() {
    const { options, rangeLabels } = this;
    if (rangeLabels.length === 0) {
      return;
    }
    const lineBox = this.lineBox();
    const vertical = options.vertical;
    const mirror = options.rangeLabels.mirror || options.labels.mirror;
    const firstLabel = rangeLabels[0];
    if (firstLabel) {
      const position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;
      this.positionLabel(firstLabel, mirror, position);
    }
    const lastLabel = rangeLabels[1];
    if (lastLabel) {
      const position = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;
      this.positionLabel(lastLabel, mirror, position);
    }
  }
  autoRotateLabels() {
    super.autoRotateLabels();
    this.autoRotateRangeLabels();
  }
  hideOutOfRangeLabels() {
    super.hideOutOfRangeLabels();
    this.hideOverlappingLabels();
  }
  hideOverlappingLabels() {
    const { rangeLabels, labels } = this;
    if (rangeLabels.length === 0) {
      return;
    }
    function clip(rangeLabel, label) {
      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {
        label.options.visible = false;
        return true;
      }
      return false;
    }
    const firstRangeLabel = rangeLabels[0];
    if (firstRangeLabel && firstRangeLabel.options.visible) {
      for (let i = 0; i < labels.length; i++) {
        const overlaps = clip(firstRangeLabel, labels[i]);
        if (!overlaps) {
          break;
        }
      }
    }
    const lastRangeLabel = rangeLabels[1];
    if (lastRangeLabel && lastRangeLabel.options.visible) {
      for (let i = labels.length - 1; i > 0; --i) {
        const overlaps = clip(lastRangeLabel, labels[i]);
        if (!overlaps) {
          break;
        }
      }
    }
  }
  contentBox() {
    const box = super.contentBox();
    const rangeLabels = this.rangeLabels;
    for (let i = 0; i < rangeLabels.length; i++) {
      const label = rangeLabels[i];
      if (label.options.visible) {
        box.wrap(label.box);
      }
    }
    return box;
  }
  createAxisLabel(index, labelOptions, labelContext = {}) {
    const options = this.options;
    const dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;
    const date = this.divisionRange.dateAt(index);
    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    labelContext.dataItem = dataItem;
    const text = this.axisLabelText(date, labelOptions, labelContext);
    if (text) {
      return new axis_label_default(date, text, index, dataItem, labelOptions);
    }
  }
  createRangeLabels() {
    const { displayStart, displayEnd } = this.divisionRange;
    const options = this.options;
    const labelOptions = Object.assign({}, options.labels, options.rangeLabels, {
      align: CENTER,
      zIndex: options.zIndex
    });
    if (labelOptions.visible !== true) {
      return;
    }
    this.normalizeLabelRotation(labelOptions);
    labelOptions.alignRotation = CENTER;
    if (labelOptions.rotation === "auto") {
      labelOptions.rotation = 0;
      options.autoRotateRangeLabels = true;
    }
    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    const createLabel = (index, date, text) => {
      if (text) {
        const label = new axis_label_default(date, text, index, null, labelOptions);
        this.append(label);
        this.rangeLabels.push(label);
      }
    };
    const startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });
    createLabel(0, displayStart, startText);
    const endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });
    createLabel(1, displayEnd, endText);
  }
  autoRotateRangeLabels() {
    const labels = this.rangeLabels;
    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {
      return;
    }
    const rotateLabel = (label, tickPositions2, index) => {
      const width = Math.abs(tickPositions2[index + 1] - tickPositions2[index]) * 2;
      const angle = this.autoRotateLabelAngle(label.box, width);
      if (angle !== 0) {
        label.options.rotation = angle;
        label.reflow(new box_default());
      }
    };
    const tickPositions = this.getMajorTickPositions();
    rotateLabel(labels[0], tickPositions, 0);
    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);
  }
  categoryIndex(value2) {
    return this.dataRange.valueIndex(value2);
  }
  slot(from, to, limit) {
    const dateRange = this.dataRange;
    let start = from;
    let end = to;
    if (start instanceof Date) {
      start = dateRange.dateIndex(start);
    }
    if (end instanceof Date) {
      end = dateRange.dateIndex(end);
    }
    const slot = this.getSlot(start, end, limit);
    if (slot) {
      return slot.toRect();
    }
  }
  getSlot(a, b, limit) {
    let start = a;
    let end = b;
    if (typeof start === OBJECT2) {
      start = this.categoryIndex(start);
    }
    if (typeof end === OBJECT2) {
      end = this.categoryIndex(end);
    }
    return super.getSlot(start, end, limit);
  }
  valueRange() {
    const options = this.options;
    const range = categoryRange(options.srcCategories);
    return {
      min: toDate(range.min),
      max: toDate(range.max)
    };
  }
  categoryAt(index, total) {
    return this.dataRange.dateAt(index, total);
  }
  categoriesCount() {
    return this.dataRange.valuesCount();
  }
  rangeIndices() {
    return this.dataRange.displayIndices();
  }
  labelsBetweenTicks() {
    return !this.divisionRange.options.justified;
  }
  prepareUserOptions() {
    if (this.isEmpty()) {
      return;
    }
    this.options.categories = this.dataRange.values();
  }
  getCategory(point) {
    const index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.dataRange.dateAt(index);
  }
  totalIndex(value2) {
    return this.dataRange.totalIndex(value2);
  }
  currentRangeIndices() {
    const range = this.dataRange.valueRange();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  }
  totalRange() {
    return this.dataRange.total();
  }
  totalRangeIndices() {
    const range = this.dataRange.total();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  }
  totalCount() {
    return this.dataRange.totalCount();
  }
  isEmpty() {
    return !this.options.srcCategories.length;
  }
  roundedRange() {
    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {
      return this.range();
    }
    const options = this.options;
    const datesRange = categoryRange(options.srcCategories);
    const dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {
      justified: false,
      roundToBaseUnit: true,
      justifyEnd: false
    }));
    return dateRange.displayRange();
  }
};
setDefaultOptions(DateCategoryAxis, {
  type: DATE,
  labels: {
    dateFormats: DateLabelFormats
  },
  rangeLabels: {
    visible: false
  },
  autoBaseUnitSteps: {
    milliseconds: [1, 10, 100],
    seconds: [1, 2, 5, 15, 30],
    minutes: [1, 2, 5, 15, 30],
    hours: [1, 2, 3],
    days: [1, 2, 3],
    weeks: [1, 2],
    months: [1, 2, 3, 6],
    years: [1, 2, 3, 5, 10, 25, 50]
  },
  maxDateGroups: 10
});
var date_category_axis_default = DateCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-major-unit.js
function autoMajorUnit(min4, max3) {
  let diff = round(max3 - min4, DEFAULT_PRECISION - 1);
  if (diff === 0) {
    if (max3 === 0) {
      return 0.1;
    }
    diff = Math.abs(max3);
  }
  const scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));
  const relativeValue = round(diff / scale, DEFAULT_PRECISION);
  let scaleMultiplier = 1;
  if (relativeValue < 1.904762) {
    scaleMultiplier = 0.2;
  } else if (relativeValue < 4.761904) {
    scaleMultiplier = 0.5;
  } else if (relativeValue < 9.523809) {
    scaleMultiplier = 1;
  } else {
    scaleMultiplier = 2;
  }
  return round(scale * scaleMultiplier, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-min.js
function autoAxisMin(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 0;
  }
  let axisMin;
  if (min4 >= 0 && max3 >= 0) {
    const minValue = min4 === max3 ? 0 : min4;
    let diff = (max3 - minValue) / max3;
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMin = Math.max(0, minValue - (max3 - minValue) / 2);
  } else {
    axisMin = min4;
  }
  return axisMin;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-max.js
function autoAxisMax(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 1;
  }
  let axisMax;
  if (min4 <= 0 && max3 <= 0) {
    const maxValue = min4 === max3 ? 0 : max3;
    let diff = Math.abs((maxValue - min4) / maxValue);
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMax = Math.min(0, maxValue - (min4 - maxValue) / 2);
  } else {
    axisMax = max3;
  }
  return axisMax;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/floor.js
function floor(value2, step) {
  return round(Math.floor(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/ceil.js
function ceil(value2, step) {
  return round(Math.ceil(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/limit-coordinate.js
function limitCoordinate(value2) {
  return Math.max(Math.min(value2, COORDINATE_LIMIT), -COORDINATE_LIMIT);
}

// node_modules/@progress/kendo-charts/dist/es/core/numeric-axis.js
var MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);
var NumericAxis = class _NumericAxis extends axis_default {
  constructor(seriesMin, seriesMax, options, chartService) {
    super(Object.assign({}, options, {
      seriesMin,
      seriesMax
    }), chartService);
  }
  initUserOptions(options) {
    const autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);
    this.totalOptions = totalAxisOptions(autoOptions, options);
    return axisOptions(autoOptions, options);
  }
  initFields() {
    this.totalMin = this.totalOptions.min;
    this.totalMax = this.totalOptions.max;
    this.totalMajorUnit = this.totalOptions.majorUnit;
    this.seriesMin = this.options.seriesMin;
    this.seriesMax = this.options.seriesMax;
  }
  clone() {
    return new _NumericAxis(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  }
  startValue() {
    return 0;
  }
  range() {
    const options = this.options;
    return { min: options.min, max: options.max };
  }
  getDivisions(stepValue) {
    if (stepValue === 0) {
      return 1;
    }
    const options = this.options;
    const range = options.max - options.min;
    return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;
  }
  getTickPositions(unit, skipUnit) {
    const options = this.options;
    const { axisDir, axisOrigin, lineBox, lineSize } = this.lineInfo();
    const range = options.max - options.min;
    const scale = lineSize / range;
    const step = unit * scale;
    const divisions = this.getDivisions(unit);
    const positions = [];
    let pos = lineBox[axisOrigin];
    let skipStep = 0;
    if (skipUnit) {
      skipStep = skipUnit / unit;
    }
    for (let idx = 0; idx < divisions; idx++) {
      if (idx % skipStep !== 0) {
        positions.push(round(pos, COORD_PRECISION));
      }
      pos = pos + step * axisDir;
    }
    return positions;
  }
  getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  }
  getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  }
  getSlot(a, b, limit = false) {
    const options = this.options;
    const { axis, axisDir, lineBox, lineSize, lineStart } = this.lineInfo();
    const step = axisDir * (lineSize / (options.max - options.min));
    let start = valueOrDefault(a, b || 0);
    let end = valueOrDefault(b, a || 0);
    if (limit) {
      start = limitValue(start, options.min, options.max);
      end = limitValue(end, options.min, options.max);
    }
    const p1 = Math.min(start, end) - options.min;
    const p2 = Math.max(start, end) - options.min;
    const slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  }
  getValue(point) {
    const options = this.options;
    const max3 = Number(options.max);
    const min4 = Number(options.min);
    const offset = this.pointOffset(point);
    const valueOffset = offset * (max3 - min4);
    if (offset < 0 || offset > 1) {
      return null;
    }
    const value2 = min4 + valueOffset;
    return round(value2, DEFAULT_PRECISION);
  }
  translateRange(delta) {
    const options = this.options;
    const { vertical, reverse, max: max3, min: min4 } = options;
    const { lineSize } = this.lineInfo();
    const range = max3 - min4;
    const scale = lineSize / range;
    let offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: min4 + offset,
      max: max3 + offset,
      offset
    };
  }
  labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const options = this.options;
    const value2 = round(options.min + index * options.majorUnit, DEFAULT_PRECISION);
    const text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  }
  shouldRenderNote(value2) {
    const range = this.range();
    return range.min <= value2 && value2 <= range.max;
  }
  pan(delta) {
    const range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  }
  pointsRange(start, end) {
    const startValue = this.getValue(start);
    const endValue = this.getValue(end);
    const min4 = Math.min(startValue, endValue);
    const max3 = Math.max(startValue, endValue);
    if (this.isValidRange(min4, max3)) {
      return {
        min: min4,
        max: max3
      };
    }
  }
  scaleRange(scale, cursor) {
    const position = Math.abs(this.pointOffset(cursor));
    const range = this.options.max - this.options.min;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = position * delta;
    const maxDelta = (1 - position) * delta;
    const min4 = round(this.options.min + minDelta, DEFAULT_PRECISION);
    let max3 = round(this.options.max - maxDelta, DEFAULT_PRECISION);
    if (max3 - min4 < MIN_VALUE_RANGE) {
      max3 = min4 + MIN_VALUE_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const { totalMin, totalMax } = this;
    const range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax),
      narrowRange: false
    };
  }
  isValidRange(min4, max3) {
    return max3 - min4 > MIN_VALUE_RANGE;
  }
};
function autoAxisOptions(seriesMin, seriesMax, options) {
  const narrowRange = options.narrowRange;
  let autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);
  let autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);
  const majorUnit = autoMajorUnit(autoMin, autoMax);
  const autoOptions = {
    majorUnit
  };
  if (options.roundToMajorUnit !== false) {
    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
      autoMin -= majorUnit;
    }
    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
      autoMax += majorUnit;
    }
  }
  autoOptions.min = floor(autoMin, majorUnit);
  autoOptions.max = ceil(autoMax, majorUnit);
  return autoOptions;
}
function totalAxisOptions(autoOptions, options) {
  return {
    min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,
    max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,
    majorUnit: autoOptions.majorUnit
  };
}
function clearNullValues(options, fields) {
  for (let idx = 0; idx < fields.length; idx++) {
    const field = fields[idx];
    if (options[field] === null) {
      options[field] = void 0;
    }
  }
}
function axisOptions(autoOptions, userOptions) {
  let options = userOptions;
  let userSetMin, userSetMax;
  if (userOptions) {
    clearNullValues(userOptions, ["min", "max"]);
    userSetMin = defined(userOptions.min);
    userSetMax = defined(userOptions.max);
    const userSetLimits = userSetMin || userSetMax;
    if (userSetLimits) {
      if (userOptions.min === userOptions.max) {
        if (userOptions.min > 0) {
          userOptions.min = 0;
        } else {
          userOptions.max = 1;
        }
      }
    }
    if (userOptions.majorUnit) {
      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);
      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);
    } else if (userSetLimits) {
      options = deepExtend(autoOptions, userOptions);
      autoOptions.majorUnit = autoMajorUnit(options.min, options.max);
    }
  }
  autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;
  const result = deepExtend(autoOptions, options);
  if (result.min >= result.max) {
    if (userSetMin && !userSetMax) {
      result.max = result.min + result.majorUnit;
    } else if (!userSetMin && userSetMax) {
      result.min = result.max - result.majorUnit;
    }
  }
  return result;
}
function remainderClose(value2, divisor, ratio) {
  const remainder = round(Math.abs(value2 % divisor), DEFAULT_PRECISION);
  const threshold = divisor * (1 - ratio);
  return remainder === 0 || remainder > threshold;
}
setDefaultOptions(NumericAxis, {
  type: "numeric",
  min: 0,
  max: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    format: "#.####################"
  },
  zIndex: 1
});
var numeric_axis_default = NumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/date-value-axis.js
var MIN_VALUE_RANGE2 = 1e3;
var DateValueAxis = class _DateValueAxis extends axis_default {
  constructor(seriesMin, seriesMax, axisOptions2, chartService) {
    const min4 = toDate(seriesMin);
    const max3 = toDate(seriesMax);
    const intlService = chartService.intl;
    let options = axisOptions2 || {};
    options = deepExtend(options || {}, {
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),
      weekStartDay: firstDay(options, intlService)
    });
    options = applyDefaults(min4, max3, options);
    super(options, chartService);
    this.intlService = intlService;
    this.seriesMin = min4;
    this.seriesMax = max3;
    const weekStartDay = options.weekStartDay || 0;
    this.totalMin = toTime(floorDate(toTime(min4) - 1, options.baseUnit, weekStartDay));
    this.totalMax = toTime(ceilDate(toTime(max3) + 1, options.baseUnit, weekStartDay));
  }
  clone() {
    return new _DateValueAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  }
  range() {
    const options = this.options;
    return { min: options.min, max: options.max };
  }
  getDivisions(stepValue) {
    const options = this.options;
    return Math.floor(
      duration(options.min, options.max, options.baseUnit) / stepValue + 1
    );
  }
  getTickPositions(step) {
    const options = this.options;
    const { axisDir: dir, lineSize, lineStart: start } = this.lineInfo();
    const divisions = this.getDivisions(step);
    const timeRange = dateDiff(options.max, options.min);
    const scale = lineSize / timeRange;
    const weekStartDay = options.weekStartDay || 0;
    const positions = [start];
    for (let i = 1; i < divisions; i++) {
      const date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);
      const pos = start + dateDiff(date, options.min) * scale * dir;
      positions.push(round(pos, COORD_PRECISION));
    }
    return positions;
  }
  getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  }
  getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  }
  getSlot(a, b, limit) {
    return numeric_axis_default.prototype.getSlot.call(
      this,
      parseDate(this.intlService, a),
      parseDate(this.intlService, b),
      limit
    );
  }
  getValue(point) {
    const value2 = numeric_axis_default.prototype.getValue.call(this, point);
    return value2 !== null ? toDate(value2) : null;
  }
  labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const options = this.options;
    const offset = index * options.majorUnit;
    const weekStartDay = options.weekStartDay || 0;
    let date = options.min;
    if (offset > 0) {
      date = addDuration(date, offset, options.baseUnit, weekStartDay);
    }
    const unitFormat = labelOptions.dateFormats[options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    const text = this.axisLabelText(date, labelOptions, labelContext);
    return new axis_label_default(date, text, index, null, labelOptions);
  }
  translateRange(delta) {
    const options = this.options;
    const lineBox = this.lineBox();
    const { vertical, reverse } = options;
    const size = vertical ? lineBox.height() : lineBox.width();
    const range = this.range();
    const scale = size / dateDiff(range.max, range.min);
    let offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    let from = addTicks(options.min, offset);
    let to = addTicks(options.max, offset);
    return {
      min: from,
      max: to,
      offset
    };
  }
  shouldRenderNote(value2) {
    const range = this.range();
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0;
  }
  pan(delta) {
    const range = this.translateRange(delta, true);
    const limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);
    if (limittedRange) {
      return {
        min: toDate(limittedRange.min),
        max: toDate(limittedRange.max)
      };
    }
  }
  pointsRange(start, end) {
    const startValue = this.getValue(start);
    const endValue = this.getValue(end);
    const min4 = Math.min(startValue, endValue);
    const max3 = Math.max(startValue, endValue);
    return {
      min: toDate(min4),
      max: toDate(max3)
    };
  }
  scaleRange(scale, cursor) {
    const position = Math.abs(this.pointOffset(cursor));
    const range = this.options.max - this.options.min;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = position * delta;
    const maxDelta = (1 - position) * delta;
    const min4 = toDate(toTime(this.options.min) + minDelta);
    let max3 = toDate(toTime(this.options.max) - maxDelta);
    if (max3 - min4 < MIN_VALUE_RANGE2) {
      max3 = toDate(toTime(min4) + MIN_VALUE_RANGE2);
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const range = this.scaleRange(scale, cursor);
    const min4 = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));
    const max3 = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));
    return {
      min: min4,
      max: max3
    };
  }
};
function timeUnits(delta) {
  let unit = HOURS;
  if (delta >= TIME_PER_YEAR) {
    unit = YEARS;
  } else if (delta >= TIME_PER_MONTH) {
    unit = MONTHS;
  } else if (delta >= TIME_PER_WEEK) {
    unit = WEEKS;
  } else if (delta >= TIME_PER_DAY) {
    unit = DAYS;
  }
  return unit;
}
function applyDefaults(seriesMin, seriesMax, options) {
  const min4 = options.min || seriesMin;
  const max3 = options.max || seriesMax;
  const baseUnit = options.baseUnit || (max3 && min4 ? timeUnits(absoluteDateDiff(max3, min4)) : HOURS);
  const baseUnitTime = TIME_PER_UNIT[baseUnit];
  const weekStartDay = options.weekStartDay || 0;
  const autoMin = floorDate(toTime(min4) - 1, baseUnit, weekStartDay) || toDate(max3);
  const autoMax = ceilDate(toTime(max3) + 1, baseUnit, weekStartDay);
  const userMajorUnit = options.majorUnit ? options.majorUnit : void 0;
  const majorUnit = userMajorUnit || ceil(
    autoMajorUnit(autoMin.getTime(), autoMax.getTime()),
    baseUnitTime
  ) / baseUnitTime;
  const actualUnits = duration(autoMin, autoMax, baseUnit);
  const totalUnits = ceil(actualUnits, majorUnit);
  const unitsToAdd = totalUnits - actualUnits;
  const head = Math.floor(unitsToAdd / 2);
  const tail = unitsToAdd - head;
  if (!options.baseUnit) {
    delete options.baseUnit;
  }
  options.baseUnit = options.baseUnit || baseUnit;
  options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);
  options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);
  options.minorUnit = options.minorUnit || majorUnit / 5;
  options.majorUnit = majorUnit;
  return options;
}
setDefaultOptions(DateValueAxis, {
  type: DATE,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    dateFormats: DateLabelFormats
  }
});
var date_value_axis_default = DateValueAxis;

// node_modules/@progress/kendo-charts/dist/es/core/ring.js
var Ring = class _Ring extends class_default {
  constructor(center, innerRadius, radius, startAngle, angle) {
    super();
    this.center = center;
    this.innerRadius = innerRadius;
    this.radius = radius;
    this.startAngle = startAngle;
    this.angle = angle;
  }
  clone() {
    return new _Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
  }
  middle() {
    return this.startAngle + this.angle / 2;
  }
  setRadius(newRadius, innerRadius) {
    if (innerRadius) {
      this.innerRadius = newRadius;
    } else {
      this.radius = newRadius;
    }
    return this;
  }
  // TODO: Remove and replace with Point.onCircle
  point(angle, innerRadius) {
    const radianAngle = rad(angle);
    const ax = Math.cos(radianAngle);
    const ay = Math.sin(radianAngle);
    const radius = innerRadius ? this.innerRadius : this.radius;
    const x = round(this.center.x - ax * radius, COORD_PRECISION);
    const y = round(this.center.y - ay * radius, COORD_PRECISION);
    return new point_default(x, y);
  }
  adjacentBox(distance, width, height) {
    const sector = this.clone().expand(distance);
    const midAndle = sector.middle();
    const midPoint = sector.point(midAndle);
    const hw = width / 2;
    const hh = height / 2;
    const sa = Math.sin(rad(midAndle));
    const ca = Math.cos(rad(midAndle));
    let x = midPoint.x - hw;
    let y = midPoint.y - hh;
    if (Math.abs(sa) < 0.9) {
      x += hw * -ca / Math.abs(ca);
    }
    if (Math.abs(ca) < 0.9) {
      y += hh * -sa / Math.abs(sa);
    }
    return new box_default(x, y, x + width, y + height);
  }
  containsPoint(p) {
    const center = this.center;
    const innerRadius = this.innerRadius;
    const radius = this.radius;
    const startAngle = this.startAngle;
    const endAngle = this.startAngle + this.angle;
    const dx = p.x - center.x;
    const dy = p.y - center.y;
    const vector = new point_default(dx, dy);
    const startPoint = this.point(startAngle);
    const startVector = new point_default(startPoint.x - center.x, startPoint.y - center.y);
    const endPoint = this.point(endAngle);
    const endVector = new point_default(endPoint.x - center.x, endPoint.y - center.y);
    const dist = round(dx * dx + dy * dy, COORD_PRECISION);
    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
  }
  getBBox() {
    const box = new box_default(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);
    const startAngle = round(this.startAngle % 360);
    const endAngle = round((startAngle + this.angle) % 360);
    const innerRadius = this.innerRadius;
    const allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
    const startAngleIndex = allAngles.indexOf(startAngle);
    const endAngleIndex = allAngles.indexOf(endAngle);
    let angles;
    if (startAngle === endAngle) {
      angles = allAngles;
    } else {
      if (startAngleIndex < endAngleIndex) {
        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
      } else {
        angles = [].concat(
          allAngles.slice(0, endAngleIndex + 1),
          allAngles.slice(startAngleIndex, allAngles.length)
        );
      }
    }
    for (let i = 0; i < angles.length; i++) {
      let point = this.point(angles[i]);
      box.wrapPoint(point);
      box.wrapPoint(point, innerRadius);
    }
    if (!innerRadius) {
      box.wrapPoint(this.center);
    }
    return box;
  }
  expand(value2) {
    this.radius += value2;
    return this;
  }
};
function numericComparer(a, b) {
  return a - b;
}
var ring_default = Ring;

// node_modules/@progress/kendo-charts/dist/es/core/shape-builder.js
var DIRECTION_ANGLE = 1e-3;
var ShapeBuilder = class extends class_default {
  createRing(sector, options) {
    const startAngle = sector.startAngle + 180;
    let endAngle = sector.angle + startAngle;
    if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {
      endAngle += DIRECTION_ANGLE;
    }
    const center = new geometry_exports.Point(sector.center.x, sector.center.y);
    const radius = Math.max(sector.radius, 0);
    const innerRadius = Math.max(sector.innerRadius, 0);
    const arc = new geometry_exports.Arc(center, {
      startAngle,
      endAngle,
      radiusX: radius,
      radiusY: radius
    });
    const path = drawing_exports.Path.fromArc(arc, options).close();
    if (innerRadius) {
      arc.radiusX = arc.radiusY = innerRadius;
      const innerEnd = arc.pointAt(endAngle);
      path.lineTo(innerEnd.x, innerEnd.y);
      path.arc(endAngle, startAngle, innerRadius, innerRadius, true);
    } else {
      path.lineTo(center.x, center.y);
    }
    return path;
  }
};
ShapeBuilder.current = new ShapeBuilder();
var shape_builder_default = ShapeBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/gradients.js
var LINEAR = "linear";
var RADIAL = "radial";
var GRADIENTS = {
  glass: {
    type: LINEAR,
    rotation: 0,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.25,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 1,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpBevel: {
    type: RADIAL,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.55
    }, {
      offset: 0.65,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0.25
    }]
  },
  roundedBevel: {
    type: RADIAL,
    stops: [{
      offset: 0.33,
      color: WHITE,
      opacity: 0.06
    }, {
      offset: 0.83,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0
    }]
  },
  roundedGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.5,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.15,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.17,
      color: WHITE,
      opacity: 0.35
    }, {
      offset: 0.85,
      color: WHITE,
      opacity: 0.05
    }, {
      offset: 0.87,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  bubbleShadow: {
    type: RADIAL,
    center: [0.5, 0.5],
    radius: 0.5
  }
};
var gradients_default = GRADIENTS;

// node_modules/@progress/kendo-charts/dist/es/core/utils/box-diff.js
function boxDiff(r, s) {
  if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {
    return s;
  }
  const a = Math.min(r.x1, s.x1);
  const b = Math.max(r.x1, s.x1);
  const c = Math.min(r.x2, s.x2);
  const d = Math.max(r.x2, s.x2);
  const e = Math.min(r.y1, s.y1);
  const f = Math.max(r.y1, s.y1);
  const g = Math.min(r.y2, s.y2);
  const h = Math.max(r.y2, s.y2);
  const boxes = [];
  boxes[0] = new box_default(b, e, c, f);
  boxes[1] = new box_default(a, f, b, g);
  boxes[2] = new box_default(c, f, d, g);
  boxes[3] = new box_default(b, g, c, h);
  if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) {
    boxes[4] = new box_default(a, e, b, f);
    boxes[5] = new box_default(c, g, d, h);
  } else {
    boxes[4] = new box_default(c, e, d, f);
    boxes[5] = new box_default(a, g, b, h);
  }
  return grep(boxes, function(box) {
    return box.height() > 0 && box.width() > 0;
  })[0];
}

// node_modules/@progress/kendo-charts/dist/es/core/root-element.js
var RootElement = class extends chart_element_default {
  constructor(options) {
    super(options);
    const rootOptions = this.options;
    rootOptions.width = parseInt(rootOptions.width, 10);
    rootOptions.height = parseInt(rootOptions.height, 10);
    this.gradients = {};
  }
  reflow() {
    const { options, children } = this;
    let currentBox = new box_default(0, 0, options.width, options.height);
    this.box = currentBox.unpad(options.margin);
    for (let i = 0; i < children.length; i++) {
      children[i].reflow(currentBox);
      currentBox = boxDiff(currentBox, children[i].box) || new box_default();
    }
  }
  createVisual() {
    this.visual = new drawing_exports.Group();
    this.createBackground();
  }
  createBackground() {
    const options = this.options;
    const border = options.border || {};
    const box = this.box.clone().pad(options.margin).unpad(border.width);
    const background = drawing_exports.Path.fromRect(box.toRect(), {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      zIndex: -10
    });
    this.visual.append(background);
  }
  getRoot() {
    return this;
  }
  createGradient(options) {
    const gradients = this.gradients;
    const hashCode = objectKey(options);
    const gradient = gradients_default[options.gradient];
    let drawingGradient;
    if (gradients[hashCode]) {
      drawingGradient = gradients[hashCode];
    } else {
      const gradientOptions = Object.assign({}, gradient, options);
      if (gradient.type === "linear") {
        drawingGradient = new drawing_exports.LinearGradient(gradientOptions);
      } else {
        if (options.innerRadius) {
          gradientOptions.stops = innerRadialStops(gradientOptions);
        }
        drawingGradient = new drawing_exports.RadialGradient(gradientOptions);
        drawingGradient.supportVML = gradient.supportVML !== false;
      }
      gradients[hashCode] = drawingGradient;
    }
    return drawingGradient;
  }
  cleanGradients() {
    const gradients = this.gradients;
    for (let hashCode in gradients) {
      gradients[hashCode]._observers = [];
    }
  }
  size() {
    const options = this.options;
    return new box_default(0, 0, options.width, options.height);
  }
};
setDefaultOptions(RootElement, {
  width: DEFAULT_WIDTH,
  height: DEFAULT_HEIGHT,
  background: WHITE,
  border: {
    color: BLACK,
    width: 0
  },
  margin: getSpacing(5),
  zIndex: -2
});
function innerRadialStops(options) {
  const stops = options.stops;
  const usedSpace = options.innerRadius / options.radius * 100;
  const length = stops.length;
  const currentStops = [];
  for (let i = 0; i < length; i++) {
    let currentStop = Object.assign({}, stops[i]);
    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;
    currentStops.push(currentStop);
  }
  return currentStops;
}
var root_element_default = RootElement;

// node_modules/@progress/kendo-charts/dist/es/core/title.js
var Title = class _Title extends chart_element_default {
  constructor(options) {
    super(options);
    this._textBox = new text_box_default(this.options.text, Object.assign({}, this.options, {
      vAlign: this.options.position
    }));
    this.append(this._textBox);
  }
  reflow(targetBox) {
    super.reflow(targetBox);
    this.box.snapTo(targetBox, X);
  }
  static buildTitle(options, defaultOptions) {
    let titleOptions = options;
    if (typeof options === "string") {
      titleOptions = { text: options };
    }
    titleOptions = Object.assign({ visible: true }, defaultOptions, titleOptions);
    let title3;
    if (titleOptions && titleOptions.visible && titleOptions.text) {
      title3 = new _Title(titleOptions);
    }
    return title3;
  }
  static orderTitles(titles) {
    const items = [].concat(titles);
    const top = items.filter((item) => item && item.options.position !== BOTTOM);
    const bottom = items.filter((item) => item && item.options.position === BOTTOM);
    collapseVerticalMargins(top);
    collapseVerticalMargins(bottom);
    bottom.reverse();
    return top.concat(bottom);
  }
};
function collapseVerticalMargins(items) {
  for (let i = 1; i < items.length; i++) {
    const box = items[i]._textBox;
    const prevBox = items[i - 1]._textBox;
    prevBox.options.margin = Object.assign(getSpacing(prevBox.options.margin), { bottom: 0 });
    box.options.margin = Object.assign(getSpacing(box.options.margin), { top: 0 });
  }
}
setDefaultOptions(Title, {
  color: BLACK,
  position: TOP,
  align: CENTER,
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var title_default = Title;

// node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js
var DEFAULT_MAJOR_UNIT = 10;
var MIN_VALUE_RANGE3 = 1e-6;
var LogarithmicAxis = class _LogarithmicAxis extends axis_default {
  constructor(seriesMin, seriesMax, options, chartService) {
    const axisOptions2 = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);
    const base = axisOptions2.majorUnit;
    const autoMax = autoAxisMax2(seriesMax, base);
    const autoMin = autoAxisMin2(seriesMin, seriesMax, axisOptions2);
    const range = initRange(autoMin, autoMax, axisOptions2, options);
    axisOptions2.max = range.max;
    axisOptions2.min = range.min;
    axisOptions2.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);
    super(axisOptions2, chartService);
    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;
    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;
    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);
    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);
    this.seriesMin = seriesMin;
    this.seriesMax = seriesMax;
    this.createLabels();
  }
  clone() {
    return new _LogarithmicAxis(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  }
  startValue() {
    return this.options.min;
  }
  getSlot(a, b, limit) {
    const { options, logMin, logMax } = this;
    const { majorUnit: base, min: min4, max: max3 } = options;
    const { axis, axisDir, lineBox, lineSize, lineStart } = this.lineInfo();
    const step = axisDir * (lineSize / (logMax - logMin));
    let start = valueOrDefault(a, b || 1);
    let end = valueOrDefault(b, a || 1);
    if (start <= 0 || end <= 0) {
      return null;
    }
    if (limit) {
      start = limitValue(start, min4, max3);
      end = limitValue(end, min4, max3);
    }
    start = log(start, base);
    end = log(end, base);
    const p1 = Math.min(start, end) - logMin;
    const p2 = Math.max(start, end) - logMin;
    const slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  }
  getValue(point) {
    const { options, logMin, logMax } = this;
    const { majorUnit: base } = options;
    const { axis, axisDir, lineStart, lineSize } = this.lineInfo();
    const step = (logMax - logMin) / lineSize;
    const offset = axisDir * (point[axis] - lineStart);
    const valueOffset = offset * step;
    if (offset < 0 || offset > lineSize) {
      return null;
    }
    const value2 = logMin + valueOffset;
    return round(Math.pow(base, value2), DEFAULT_PRECISION);
  }
  range() {
    const options = this.options;
    return { min: options.min, max: options.max };
  }
  translateRange(delta) {
    const { options, logMin, logMax } = this;
    const { reverse, vertical, majorUnit: base } = options;
    const lineBox = this.lineBox();
    const size = vertical ? lineBox.height() : lineBox.width();
    const scale = size / (logMax - logMin);
    let offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: Math.pow(base, logMin + offset),
      max: Math.pow(base, logMax + offset),
      offset
    };
  }
  labelsCount() {
    const floorMax = Math.floor(this.logMax);
    const count = Math.floor(floorMax - this.logMin) + 1;
    return count;
  }
  getMajorTickPositions() {
    const ticks = [];
    this.traverseMajorTicksPositions((position) => {
      ticks.push(position);
    }, { step: 1, skip: 0 });
    return ticks;
  }
  createTicks(lineGroup) {
    const options = this.options;
    const { majorTicks, minorTicks, vertical } = options;
    const mirror = options.labels.mirror;
    const lineBox = this.lineBox();
    const ticks = [];
    const tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical
    };
    function render(tickPosition, tickOptions) {
      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickLineOptions.position = tickPosition;
      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
    }
    if (majorTicks.visible) {
      this.traverseMajorTicksPositions(render, majorTicks);
    }
    if (minorTicks.visible) {
      this.traverseMinorTicksPositions(render, minorTicks);
    }
    return ticks;
  }
  createGridLines(altAxis) {
    const options = this.options;
    const { minorGridLines, majorGridLines, vertical } = options;
    const lineBox = altAxis.lineBox();
    const lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    const majorTicks = [];
    const container = this.gridLinesVisual();
    function render(tickPosition, gridLine) {
      if (!inArray(tickPosition, majorTicks)) {
        lineOptions.position = tickPosition;
        container.append(createAxisGridLine(lineOptions, gridLine));
        majorTicks.push(tickPosition);
      }
    }
    if (majorGridLines.visible) {
      this.traverseMajorTicksPositions(render, majorGridLines);
    }
    if (minorGridLines.visible) {
      this.traverseMinorTicksPositions(render, minorGridLines);
    }
    return container.children;
  }
  traverseMajorTicksPositions(callback, tickOptions) {
    const { lineStart, step } = this.lineInfo();
    const { logMin, logMax } = this;
    for (let power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
      let position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);
      callback(position, tickOptions);
    }
  }
  traverseMinorTicksPositions(callback, tickOptions) {
    const { min: min4, max: max3, minorUnit, majorUnit: base } = this.options;
    const { lineStart, step } = this.lineInfo();
    const { logMin, logMax } = this;
    const start = Math.floor(logMin);
    for (let power = start; power < logMax; power++) {
      const minorOptions = this._minorIntervalOptions(power);
      for (let idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
        const value2 = minorOptions.value + idx * minorOptions.minorStep;
        if (value2 > max3) {
          break;
        }
        if (value2 >= min4) {
          const position = round(lineStart + step * (log(value2, base) - logMin), DEFAULT_PRECISION);
          callback(position, tickOptions);
        }
      }
    }
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const power = Math.ceil(this.logMin + index);
    const value2 = Math.pow(this.options.majorUnit, power);
    const text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  }
  shouldRenderNote(value2) {
    const range = this.range();
    return range.min <= value2 && value2 <= range.max;
  }
  pan(delta) {
    const range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  }
  pointsRange(start, end) {
    const startValue = this.getValue(start);
    const endValue = this.getValue(end);
    const min4 = Math.min(startValue, endValue);
    const max3 = Math.max(startValue, endValue);
    return {
      min: min4,
      max: max3
    };
  }
  scaleRange(scale, cursor) {
    const { majorUnit: base } = this.options;
    const logMin = log(this.options.min, base);
    const logMax = log(this.options.max, base);
    const position = Math.abs(this.pointOffset(cursor));
    const range = logMax - logMin;
    const delta = this.scaleToDelta(scale, range);
    const min4 = Math.pow(base, logMin + position * delta);
    let max3 = Math.pow(base, logMax - (1 - position) * delta);
    if (max3 - min4 < MIN_VALUE_RANGE3) {
      max3 = min4 + MIN_VALUE_RANGE3;
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const range = this.scaleRange(scale, cursor);
    const { totalMin, totalMax } = this;
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  }
  _minorIntervalOptions(power) {
    const { minorUnit, majorUnit: base } = this.options;
    const value2 = Math.pow(base, power);
    const nextValue = Math.pow(base, power + 1);
    const difference = nextValue - value2;
    const minorStep = difference / minorUnit;
    return {
      value: value2,
      minorStep
    };
  }
  lineInfo() {
    const info = super.lineInfo();
    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));
    return info;
  }
};
function initRange(autoMin, autoMax, axisOptions2, options) {
  let { min: min4, max: max3 } = axisOptions2;
  if (defined(axisOptions2.axisCrossingValue) && axisOptions2.axisCrossingValue <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.max)) {
    max3 = autoMax;
  } else if (options.max <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.min)) {
    min4 = autoMin;
  } else if (options.min <= 0) {
    throwNegativeValuesError();
  }
  return {
    min: min4,
    max: max3
  };
}
function autoAxisMin2(min4, max3, options) {
  const base = options.majorUnit;
  let autoMin = min4;
  if (min4 <= 0) {
    autoMin = max3 <= 1 ? Math.pow(base, -2) : 1;
  } else if (!options.narrowRange) {
    autoMin = Math.pow(base, Math.floor(log(min4, base)));
  }
  return autoMin;
}
function autoAxisMax2(max3, base) {
  const logMaxRemainder = round(log(max3, base), DEFAULT_PRECISION) % 1;
  let autoMax;
  if (max3 <= 0) {
    autoMax = base;
  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
    autoMax = Math.pow(base, log(max3, base) + 0.2);
  } else {
    autoMax = Math.pow(base, Math.ceil(log(max3, base)));
  }
  return autoMax;
}
function throwNegativeValuesError() {
  throw new Error("Non positive values cannot be used for a logarithmic axis");
}
function log(x, base) {
  return Math.log(x) / Math.log(base);
}
setDefaultOptions(LogarithmicAxis, {
  type: "log",
  majorUnit: DEFAULT_MAJOR_UNIT,
  minorUnit: 1,
  axisCrossingValue: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  zIndex: 1,
  _deferLabels: true
});
var logarithmic_axis_default = LogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/grid-lines-mixin.js
var GridLinesMixin = {
  createGridLines: function(altAxis) {
    const options = this.options;
    const radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);
    let gridLines = [];
    let skipMajor = false;
    let majorAngles, minorAngles;
    if (options.majorGridLines.visible) {
      majorAngles = this.majorGridLineAngles(altAxis);
      skipMajor = true;
      gridLines = this.renderMajorGridLines(
        majorAngles,
        radius,
        options.majorGridLines
      );
    }
    if (options.minorGridLines.visible) {
      minorAngles = this.minorGridLineAngles(altAxis, skipMajor);
      append(gridLines, this.renderMinorGridLines(
        minorAngles,
        radius,
        options.minorGridLines,
        altAxis,
        skipMajor
      ));
    }
    return gridLines;
  },
  renderMajorGridLines: function(angles, radius, options) {
    return this.renderGridLines(angles, radius, options);
  },
  renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {
    const radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);
    return this.renderGridLines(angles, radius, options, radiusCallback);
  },
  renderGridLines: function(angles, radius, options, radiusCallback) {
    const style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    const center = this.box.center();
    const circle = new geometry_exports.Circle([center.x, center.y], radius);
    const container = this.gridLinesVisual();
    for (let i = 0; i < angles.length; i++) {
      const line = new drawing_exports.Path(style);
      if (radiusCallback) {
        circle.radius = radiusCallback(angles[i]);
      }
      line.moveTo(circle.center).lineTo(circle.pointAt(angles[i] + 180));
      container.append(line);
    }
    return container.children;
  },
  gridLineAngles: function(altAxis, size, skip, step, skipAngles) {
    const divs = this.intervals(size, skip, step, skipAngles);
    const options = altAxis.options;
    const altAxisVisible = options.visible && (options.line || {}).visible !== false;
    return map(divs, (d) => {
      const alpha = this.intervalAngle(d);
      if (!altAxisVisible || alpha !== 90) {
        return alpha;
      }
    });
  }
};
var grid_lines_mixin_default = GridLinesMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-category-axis.js
var RadarCategoryAxis = class extends category_axis_default {
  range() {
    return { min: 0, max: this.options.categories.length };
  }
  reflow(box) {
    this.box = box;
    this.reflowLabels();
  }
  lineBox() {
    return this.box;
  }
  reflowLabels() {
    const { labels, options: { labels: labelOptions } } = this;
    const skip = labelOptions.skip || 0;
    const step = labelOptions.step || 1;
    const measureBox = new box_default();
    for (let i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      const labelBox = labels[i].box;
      labels[i].reflow(this.getSlot(skip + i * step).adjacentBox(
        0,
        labelBox.width(),
        labelBox.height()
      ));
    }
  }
  intervals(size, skipOption, stepOption, skipAngles = false) {
    const options = this.options;
    const categories = options.categories.length;
    const divCount = categories / size || 1;
    const divAngle = 360 / divCount;
    const skip = skipOption || 0;
    const step = stepOption || 1;
    const divs = [];
    let angle = 0;
    for (let i = skip; i < divCount; i += step) {
      if (options.reverse) {
        angle = 360 - i * divAngle;
      } else {
        angle = i * divAngle;
      }
      angle = round(angle, COORD_PRECISION) % 360;
      if (!(skipAngles && inArray(angle, skipAngles))) {
        divs.push(angle);
      }
    }
    return divs;
  }
  majorIntervals() {
    return this.intervals(1);
  }
  minorIntervals() {
    return this.intervals(0.5);
  }
  intervalAngle(interval) {
    return (360 + interval + this.options.startAngle) % 360;
  }
  majorAngles() {
    return map(this.majorIntervals(), (interval) => this.intervalAngle(interval));
  }
  createLine() {
    return [];
  }
  majorGridLineAngles(altAxis) {
    const majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);
  }
  minorGridLineAngles(altAxis, skipMajor) {
    const { minorGridLines, majorGridLines } = this.options;
    const majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  }
  radiusCallback(radius, altAxis, skipMajor) {
    if (altAxis.options.type !== ARC) {
      const minorAngle = rad(360 / (this.options.categories.length * 2));
      const minorRadius = Math.cos(minorAngle) * radius;
      const majorAngles = this.majorAngles();
      const radiusCallback = function(angle) {
        if (!skipMajor && inArray(angle, majorAngles)) {
          return radius;
        }
        return minorRadius;
      };
      return radiusCallback;
    }
  }
  createPlotBands() {
    const plotBands = this.options.plotBands || [];
    const group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (let i = 0; i < plotBands.length; i++) {
      const band = plotBands[i];
      const slot = this.plotBandSlot(band);
      const singleSlot = this.getSlot(band.from);
      const head = band.from - Math.floor(band.from);
      slot.startAngle += head * singleSlot.angle;
      const tail = Math.ceil(band.to) - band.to;
      slot.angle -= (tail + head) * singleSlot.angle;
      const ring = shape_builder_default.current.createRing(slot, {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      });
      group.append(ring);
    }
    this.appendVisual(group);
  }
  plotBandSlot(band) {
    return this.getSlot(band.from, band.to - 1);
  }
  getSlot(from, to) {
    const options = this.options;
    const justified = options.justified;
    const box = this.box;
    const divs = this.majorAngles();
    const totalDivs = divs.length;
    const slotAngle = 360 / totalDivs;
    let fromValue = from;
    if (options.reverse && !justified) {
      fromValue = (fromValue + 1) % totalDivs;
    }
    fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);
    let slotStart = divs[fromValue];
    if (justified) {
      slotStart = slotStart - slotAngle / 2;
      if (slotStart < 0) {
        slotStart += 360;
      }
    }
    const toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);
    const slots = toValue - fromValue + 1;
    const angle = slotAngle * slots;
    return new ring_default(box.center(), 0, box.height() / 2, slotStart, angle);
  }
  slot(from, to) {
    const slot = this.getSlot(from, to);
    const startAngle = slot.startAngle + 180;
    const endAngle = startAngle + slot.angle;
    return new geometry_exports.Arc([slot.center.x, slot.center.y], {
      startAngle,
      endAngle,
      radiusX: slot.radius,
      radiusY: slot.radius
    });
  }
  pointCategoryIndex(point) {
    const length = this.options.categories.length;
    let index = null;
    for (let i = 0; i < length; i++) {
      const slot = this.getSlot(i);
      if (slot.containsPoint(point)) {
        index = i;
        break;
      }
    }
    return index;
  }
};
setDefaultOptions(RadarCategoryAxis, {
  startAngle: 90,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    visible: true
  },
  justified: true
});
deepExtend(RadarCategoryAxis.prototype, grid_lines_mixin_default);
var radar_category_axis_default = RadarCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/polar-axis.js
var PolarAxis = class extends axis_default {
  constructor(options, chartService) {
    super(options, chartService);
    const instanceOptions = this.options;
    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;
  }
  getDivisions(stepValue) {
    return numeric_axis_default.prototype.getDivisions.call(this, stepValue) - 1;
  }
  reflow(box) {
    this.box = box;
    this.reflowLabels();
  }
  reflowLabels() {
    const { options, labels, options: { labels: labelOptions } } = this;
    const skip = labelOptions.skip || 0;
    const step = labelOptions.step || 1;
    const measureBox = new box_default();
    const divs = this.intervals(options.majorUnit, skip, step);
    for (let i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      const labelBox = labels[i].box;
      labels[i].reflow(this.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  }
  lineBox() {
    return this.box;
  }
  intervals(size, skipOption, stepOption, skipAngles = false) {
    const min4 = this.options.min;
    const divisions = this.getDivisions(size);
    const divs = [];
    const skip = skipOption || 0;
    const step = stepOption || 1;
    for (let i = skip; i < divisions; i += step) {
      const current4 = (360 + min4 + i * size) % 360;
      if (!(skipAngles && inArray(current4, skipAngles))) {
        divs.push(current4);
      }
    }
    return divs;
  }
  majorIntervals() {
    return this.intervals(this.options.majorUnit);
  }
  minorIntervals() {
    return this.intervals(this.options.minorUnit);
  }
  intervalAngle(i) {
    return (540 - i - this.options.startAngle) % 360;
  }
  createLine() {
    return [];
  }
  majorGridLineAngles(altAxis) {
    const majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);
  }
  minorGridLineAngles(altAxis, skipMajor) {
    const options = this.options;
    const { minorGridLines, majorGridLines } = options;
    const majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  }
  plotBandSlot(band) {
    return this.getSlot(band.from, band.to);
  }
  getSlot(a, b) {
    const { options, box } = this;
    const startAngle = options.startAngle;
    let start = limitValue(a, options.min, options.max);
    let end = limitValue(b || start, start, options.max);
    if (options.reverse) {
      start *= -1;
      end *= -1;
    }
    start = (540 - start - startAngle) % 360;
    end = (540 - end - startAngle) % 360;
    if (end < start) {
      const tmp = start;
      start = end;
      end = tmp;
    }
    return new ring_default(box.center(), 0, box.height() / 2, start, end - start);
  }
  slot(from, to = from) {
    const options = this.options;
    const start = 360 - options.startAngle;
    const slot = this.getSlot(from, to);
    const min4 = Math.min(from, to);
    const max3 = Math.max(from, to);
    let startAngle, endAngle;
    if (options.reverse) {
      startAngle = min4;
      endAngle = max3;
    } else {
      startAngle = 360 - max3;
      endAngle = 360 - min4;
    }
    startAngle = (startAngle + start) % 360;
    endAngle = (endAngle + start) % 360;
    return new geometry_exports.Arc([slot.center.x, slot.center.y], {
      startAngle,
      endAngle,
      radiusX: slot.radius,
      radiusY: slot.radius
    });
  }
  getValue(point) {
    const options = this.options;
    const center = this.box.center();
    const dx = point.x - center.x;
    const dy = point.y - center.y;
    let theta = Math.round(deg(Math.atan2(dy, dx)));
    let start = options.startAngle;
    if (!options.reverse) {
      theta *= -1;
      start *= -1;
    }
    return (theta + start + 360) % 360;
  }
  valueRange() {
    return {
      min: 0,
      max: Math.PI * 2
    };
  }
};
setDefaultOptions(PolarAxis, {
  type: "polar",
  startAngle: 0,
  reverse: false,
  majorUnit: 60,
  min: 0,
  max: 360,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    color: BLACK,
    visible: true,
    width: 1
  },
  minorGridLines: {
    color: "#aaa"
  }
});
deepExtend(PolarAxis.prototype, grid_lines_mixin_default, {
  createPlotBands: radar_category_axis_default.prototype.createPlotBands,
  majorAngles: radar_category_axis_default.prototype.majorAngles,
  range: numeric_axis_default.prototype.range,
  labelsCount: numeric_axis_default.prototype.labelsCount,
  createAxisLabel: numeric_axis_default.prototype.createAxisLabel
});
var polar_axis_default = PolarAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/radar-numeric-axis-mixin.js
var RadarNumericAxisMixin = {
  options: {
    majorGridLines: {
      visible: true
    }
  },
  createPlotBands: function() {
    const { majorGridLines: { type }, plotBands = [] } = this.options;
    const altAxis = this.plotArea.polarAxis;
    const majorAngles = altAxis.majorAngles();
    const center = altAxis.box.center();
    const group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (let i = 0; i < plotBands.length; i++) {
      const band = plotBands[i];
      const bandStyle = {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      };
      const slot = this.getSlot(band.from, band.to, true);
      const ring = new ring_default(center, center.y - slot.y2, center.y - slot.y1, 0, 360);
      let shape;
      if (type === ARC) {
        shape = shape_builder_default.current.createRing(ring, bandStyle);
      } else {
        shape = drawing_exports.Path.fromPoints(this.plotBandPoints(ring, majorAngles), bandStyle).close();
      }
      group.append(shape);
    }
    this.appendVisual(group);
  },
  plotBandPoints: function(ring, angles) {
    const innerPoints = [];
    const outerPoints = [];
    const center = [ring.center.x, ring.center.y];
    const innerCircle = new geometry_exports.Circle(center, ring.innerRadius);
    const outerCircle = new geometry_exports.Circle(center, ring.radius);
    for (let i = 0; i < angles.length; i++) {
      innerPoints.push(innerCircle.pointAt(angles[i] + 180));
      outerPoints.push(outerCircle.pointAt(angles[i] + 180));
    }
    innerPoints.reverse();
    innerPoints.push(innerPoints[0]);
    outerPoints.push(outerPoints[0]);
    return outerPoints.concat(innerPoints);
  },
  createGridLines: function(altAxis) {
    const options = this.options;
    const majorTicks = this.radarMajorGridLinePositions();
    const majorAngles = altAxis.majorAngles();
    const center = altAxis.box.center();
    let gridLines = [];
    if (options.majorGridLines.visible) {
      gridLines = this.renderGridLines(
        center,
        majorTicks,
        majorAngles,
        options.majorGridLines
      );
    }
    if (options.minorGridLines.visible) {
      const minorTicks = this.radarMinorGridLinePositions();
      append(gridLines, this.renderGridLines(
        center,
        minorTicks,
        majorAngles,
        options.minorGridLines
      ));
    }
    return gridLines;
  },
  renderGridLines: function(center, ticks, angles, options) {
    const style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    const { skip = 0, step = 0 } = options;
    const container = this.gridLinesVisual();
    for (let tickIx = skip; tickIx < ticks.length; tickIx += step) {
      const tickRadius = center.y - ticks[tickIx];
      if (tickRadius > 0) {
        const circle = new geometry_exports.Circle([center.x, center.y], tickRadius);
        if (options.type === ARC) {
          container.append(new drawing_exports.Circle(circle, style));
        } else {
          const line = new drawing_exports.Path(style);
          for (let angleIx = 0; angleIx < angles.length; angleIx++) {
            line.lineTo(circle.pointAt(angles[angleIx] + 180));
          }
          line.close();
          container.append(line);
        }
      }
    }
    return container.children;
  },
  getValue: function(point) {
    const lineBox = this.lineBox();
    const altAxis = this.plotArea.polarAxis;
    const majorAngles = altAxis.majorAngles();
    const center = altAxis.box.center();
    const radius = point.distanceTo(center);
    let distance = radius;
    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {
      const dx = point.x - center.x;
      const dy = point.y - center.y;
      const theta = (deg(Math.atan2(dy, dx)) + 540) % 360;
      majorAngles.sort(function(a, b) {
        return angularDistance(a, theta) - angularDistance(b, theta);
      });
      const midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;
      const alpha = angularDistance(theta, majorAngles[0]);
      const gamma = 90 - midAngle;
      const beta = 180 - alpha - gamma;
      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));
    }
    return this.axisType().prototype.getValue.call(
      this,
      new point_default(lineBox.x1, lineBox.y2 - distance)
    );
  }
};
function angularDistance(a, b) {
  return 180 - Math.abs(Math.abs(a - b) - 180);
}
var radar_numeric_axis_mixin_default = RadarNumericAxisMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-numeric-axis.js
var RadarNumericAxis = class extends numeric_axis_default {
  radarMajorGridLinePositions() {
    return this.getTickPositions(this.options.majorUnit);
  }
  radarMinorGridLinePositions() {
    const options = this.options;
    let minorSkipStep = 0;
    if (options.majorGridLines.visible) {
      minorSkipStep = options.majorUnit;
    }
    return this.getTickPositions(options.minorUnit, minorSkipStep);
  }
  axisType() {
    return numeric_axis_default;
  }
};
deepExtend(RadarNumericAxis.prototype, radar_numeric_axis_mixin_default);
var radar_numeric_axis_default = RadarNumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/radar-logarithmic-axis.js
var RadarLogarithmicAxis = class extends logarithmic_axis_default {
  radarMajorGridLinePositions() {
    const positions = [];
    this.traverseMajorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.majorGridLines);
    return positions;
  }
  radarMinorGridLinePositions() {
    const positions = [];
    this.traverseMinorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.minorGridLines);
    return positions;
  }
  axisType() {
    return logarithmic_axis_default;
  }
};
deepExtend(RadarLogarithmicAxis.prototype, radar_numeric_axis_mixin_default);
var radar_logarithmic_axis_default = RadarLogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var CurveProcessor = class extends class_default {
  constructor(closed) {
    super();
    this.closed = closed;
  }
  process(dataPoints) {
    const points = dataPoints.slice(0);
    const segments = [];
    let closed = this.closed;
    let length = points.length;
    if (length > 2) {
      this.removeDuplicates(0, points);
      length = points.length;
    }
    if (length < 2 || length === 2 && points[0].equals(points[1])) {
      return segments;
    }
    let p0 = points[0];
    let p1 = points[1];
    let p2 = points[2];
    segments.push(new geometry_exports.Segment(p0));
    while (p0.equals(points[length - 1])) {
      closed = true;
      points.pop();
      length--;
    }
    if (length === 2) {
      const tangent = this.tangent(p0, p1, X, Y);
      last(segments).controlOut(
        this.firstControlPoint(tangent, p0, p1, X, Y)
      );
      segments.push(new geometry_exports.Segment(
        p1,
        this.secondControlPoint(tangent, p0, p1, X, Y)
      ));
      return segments;
    }
    let initialControlPoint, lastControlPoint;
    if (closed) {
      p0 = points[length - 1];
      p1 = points[0];
      p2 = points[1];
      const controlPoints = this.controlPoints(p0, p1, p2);
      initialControlPoint = controlPoints[1];
      lastControlPoint = controlPoints[0];
    } else {
      const tangent = this.tangent(p0, p1, X, Y);
      initialControlPoint = this.firstControlPoint(tangent, p0, p1, X, Y);
    }
    let cp0 = initialControlPoint;
    for (let idx = 0; idx <= length - 3; idx++) {
      this.removeDuplicates(idx, points);
      length = points.length;
      if (idx + 3 <= length) {
        p0 = points[idx];
        p1 = points[idx + 1];
        p2 = points[idx + 2];
        const controlPoints = this.controlPoints(p0, p1, p2);
        last(segments).controlOut(cp0);
        cp0 = controlPoints[1];
        const cp1 = controlPoints[0];
        segments.push(new geometry_exports.Segment(p1, cp1));
      }
    }
    if (closed) {
      p0 = points[length - 2];
      p1 = points[length - 1];
      p2 = points[0];
      const controlPoints = this.controlPoints(p0, p1, p2);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p1,
        controlPoints[0]
      ));
      last(segments).controlOut(controlPoints[1]);
      segments.push(new geometry_exports.Segment(
        p2,
        lastControlPoint
      ));
    } else {
      const tangent = this.tangent(p1, p2, X, Y);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p2,
        this.secondControlPoint(tangent, p1, p2, X, Y)
      ));
    }
    return segments;
  }
  removeDuplicates(idx, points) {
    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {
      points.splice(idx + 1, 1);
    }
  }
  invertAxis(p0, p1, p2) {
    let invertAxis = false;
    if (p0.x === p1.x) {
      invertAxis = true;
    } else if (p1.x === p2.x) {
      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
        invertAxis = true;
      }
    } else {
      const fn = this.lineFunction(p0, p1);
      const y2 = this.calculateFunction(fn, p2.x);
      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
        invertAxis = true;
      }
    }
    return invertAxis;
  }
  isLine(p0, p1, p2) {
    const fn = this.lineFunction(p0, p1);
    const y2 = this.calculateFunction(fn, p2.x);
    return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);
  }
  lineFunction(p1, p2) {
    const a = (p2.y - p1.y) / (p2.x - p1.x);
    const b = p1.y - a * p1.x;
    return [b, a];
  }
  controlPoints(p0, p1, p2) {
    let xField = X;
    let yField = Y;
    let restrict = false;
    let switchOrientation = false;
    let tangent;
    if (this.isLine(p0, p1, p2)) {
      tangent = this.tangent(p0, p1, X, Y);
    } else {
      const monotonic = {
        x: this.isMonotonicByField(p0, p1, p2, X),
        y: this.isMonotonicByField(p0, p1, p2, Y)
      };
      if (monotonic.x && monotonic.y) {
        tangent = this.tangent(p0, p2, X, Y);
        restrict = true;
      } else {
        if (this.invertAxis(p0, p1, p2)) {
          xField = Y;
          yField = X;
        }
        if (monotonic[xField]) {
          tangent = 0;
        } else {
          let sign;
          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
          } else {
            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
          }
          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
          switchOrientation = true;
        }
      }
    }
    const secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);
    if (switchOrientation) {
      const oldXField = xField;
      xField = yField;
      yField = oldXField;
    }
    const firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);
    if (restrict) {
      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);
      this.restrictControlPoint(p1, p2, firstControlPoint, tangent);
    }
    return [secondControlPoint, firstControlPoint];
  }
  restrictControlPoint(p1, p2, cp, tangent) {
    if (p1.y < p2.y) {
      if (p2.y < cp.y) {
        cp.x = p1.x + (p2.y - p1.y) / tangent;
        cp.y = p2.y;
      } else if (cp.y < p1.y) {
        cp.x = p2.x - (p2.y - p1.y) / tangent;
        cp.y = p1.y;
      }
    } else {
      if (cp.y < p2.y) {
        cp.x = p1.x - (p1.y - p2.y) / tangent;
        cp.y = p2.y;
      } else if (p1.y < cp.y) {
        cp.x = p2.x + (p1.y - p2.y) / tangent;
        cp.y = p1.y;
      }
    }
  }
  tangent(p0, p1, xField, yField) {
    const x = p1[xField] - p0[xField];
    const y = p1[yField] - p0[yField];
    let tangent;
    if (x === 0) {
      tangent = 0;
    } else {
      tangent = y / x;
    }
    return tangent;
  }
  isMonotonicByField(p0, p1, p2, field) {
    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
  }
  firstControlPoint(tangent, p0, p3, xField, yField) {
    const t1 = p0[xField];
    const t2 = p3[xField];
    const distance = (t2 - t1) * WEIGHT;
    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
  }
  secondControlPoint(tangent, p0, p3, xField, yField) {
    const t1 = p0[xField];
    const t2 = p3[xField];
    const distance = (t2 - t1) * WEIGHT;
    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
  }
  point(xValue, yValue, xField, yField) {
    const controlPoint = new geometry_exports.Point();
    controlPoint[xField] = xValue;
    controlPoint[yField] = yValue;
    return controlPoint;
  }
  calculateFunction(fn, x) {
    const length = fn.length;
    let result = 0;
    for (let i = 0; i < length; i++) {
      result += Math.pow(x, i) * fn[i];
    }
    return result;
  }
};
function numberSign(value2) {
  return value2 <= 0 ? -1 : 1;
}
var curve_processor_default = CurveProcessor;

// node_modules/@progress/kendo-charts/dist/es/chart/highlight.js
var Highlight = class extends class_default {
  constructor() {
    super();
    this._points = [];
  }
  destroy() {
    this._points = [];
  }
  show(points, opacity) {
    const arrayPoints = [].concat(points);
    this.hide();
    for (let i = 0; i < arrayPoints.length; i++) {
      const point = arrayPoints[i];
      if (point && point.toggleHighlight && point.hasHighlight()) {
        this.togglePointHighlight(point, true, opacity);
        this._points.push(point);
      }
    }
  }
  togglePointHighlight(point, show2, opacity) {
    const toggleHandler = (point.options.highlight || {}).toggle;
    if (toggleHandler) {
      const eventArgs = {
        category: point.category,
        series: point.series,
        dataItem: point.dataItem,
        value: point.value,
        stackValue: point.stackValue,
        preventDefault: preventDefault3,
        visual: point.highlightVisual(),
        show: show2
      };
      toggleHandler(eventArgs);
      if (!eventArgs._defaultPrevented) {
        point.toggleHighlight(show2, opacity);
      }
    } else {
      point.toggleHighlight(show2, opacity);
    }
  }
  hide() {
    const points = this._points;
    while (points.length) {
      this.togglePointHighlight(points.pop(), false);
    }
  }
  isHighlighted(element) {
    const points = this._points;
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      if (element === point) {
        return true;
      }
    }
    return false;
  }
};
function preventDefault3() {
  this._defaultPrevented = true;
}
var highlight_default = Highlight;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/accept-key.js
function acceptKey(e, mouseKey) {
  const key = (mouseKey || "").toLowerCase();
  const event = e.event;
  const accept = key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + "Key"];
  return accept;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/to-chart-axis-ranges.js
function toChartAxisRanges(axisRanges2) {
  const ranges = {};
  for (let idx = 0; idx < axisRanges2.length; idx++) {
    const axisRange = axisRanges2[idx];
    if (axisRange.axis.options.name) {
      ranges[axisRange.axis.options.name] = {
        min: axisRange.range.min,
        max: axisRange.range.max
      };
    }
  }
  return ranges;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/pannable.js
var Pannable = class extends class_default {
  constructor(plotArea, options) {
    super();
    this.plotArea = plotArea;
    this.options = deepExtend({}, this.options, options);
  }
  start(e) {
    this._active = acceptKey(e, this.options.key);
    return this._active;
  }
  move(e) {
    if (this._active) {
      const axisRanges2 = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));
      if (axisRanges2.length) {
        this.axisRanges = axisRanges2;
        return toChartAxisRanges(axisRanges2);
      }
    }
  }
  end() {
    const active = this._active;
    this._active = false;
    return active;
  }
  pan() {
    const { plotArea, axisRanges: axisRanges2 } = this;
    if (axisRanges2.length) {
      for (let idx = 0; idx < axisRanges2.length; idx++) {
        const range = axisRanges2[idx];
        plotArea.updateAxisOptions(range.axis, range.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  }
  destroy() {
    delete this.plotArea;
  }
  _panAxes(e, position) {
    const plotArea = this.plotArea;
    const delta = -e[position].delta;
    const lock = (this.options.lock || "").toLowerCase();
    const updatedAxes = [];
    if (delta !== 0 && (lock || "").toLowerCase() !== position) {
      const axes = plotArea.axes;
      for (let idx = 0; idx < axes.length; idx++) {
        const axis = axes[idx];
        if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {
          const range = axis.pan(delta);
          if (range) {
            range.limitRange = true;
            updatedAxes.push({
              axis,
              range
            });
          }
        }
      }
    }
    return updatedAxes;
  }
};
Pannable.prototype.options = {
  key: "none",
  lock: "none"
};
var pannable_default = Pannable;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/zoom-selection.js
var ZoomSelection = class extends class_default {
  constructor(chart, options) {
    super();
    this.chart = chart;
    this.options = deepExtend({}, this.options, options);
    this.createElement();
  }
  createElement() {
    const marquee = this._marquee = document.createElement("div");
    marquee.className = "k-marquee";
    const marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
  }
  removeElement() {
    if (this._marquee.parentNode) {
      this._marquee.parentNode.removeChild(this._marquee);
    }
  }
  setStyles(styles) {
    elementStyles(this._marquee, styles);
  }
  start(e) {
    if (acceptKey(e, this.options.key)) {
      const chart = this.chart;
      const point = chart._eventCoordinates(e);
      const zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);
      const clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;
      if (zoomPane && clipBox) {
        const offset = this._elementOffset();
        clipBox.translate(offset.left, offset.top);
        this._zoomPaneClipBox = clipBox;
        document.body.appendChild(this._marquee);
        this.setStyles({
          left: e.pageX + 1,
          top: e.pageY + 1,
          width: 0,
          height: 0
        });
        return true;
      }
    }
    return false;
  }
  _elementOffset() {
    const chartElement = this.chart.element;
    const { paddingLeft, paddingTop } = elementStyles(chartElement, ["paddingLeft", "paddingTop"]);
    const offset = elementOffset(chartElement);
    return {
      left: paddingLeft + offset.left,
      top: paddingTop + offset.top
    };
  }
  move(e) {
    const zoomPane = this._zoomPane;
    if (zoomPane) {
      this.setStyles(this._selectionPosition(e));
    }
  }
  end(e) {
    const zoomPane = this._zoomPane;
    if (zoomPane) {
      const elementOffset2 = this._elementOffset();
      const selectionPosition = this._selectionPosition(e);
      selectionPosition.left -= elementOffset2.left;
      selectionPosition.top -= elementOffset2.top;
      const start = { x: selectionPosition.left, y: selectionPosition.top };
      const end = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };
      this._updateAxisRanges(start, end);
      this.removeElement();
      delete this._zoomPane;
      return toChartAxisRanges(this.axisRanges);
    }
  }
  zoom() {
    const axisRanges2 = this.axisRanges;
    if (axisRanges2 && axisRanges2.length) {
      const plotArea = this.chart._plotArea;
      for (let idx = 0; idx < axisRanges2.length; idx++) {
        const axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  }
  destroy() {
    this.removeElement();
    delete this._marquee;
    delete this.chart;
  }
  _updateAxisRanges(start, end) {
    const lock = (this.options.lock || "").toLowerCase();
    const axisRanges2 = [];
    const axes = this._zoomPane.axes;
    for (let idx = 0; idx < axes.length; idx++) {
      const axis = axes[idx];
      const vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {
        const range = axis.pointsRange(start, end);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
  }
  _selectionPosition(e) {
    const clipBox = this._zoomPaneClipBox;
    const startLocation = {
      x: e.x.startLocation,
      y: e.y.startLocation
    };
    const { x: { location: pageX }, y: { location: pageY } } = e;
    const lock = (this.options.lock || "").toLowerCase();
    let left = Math.min(startLocation.x, pageX);
    let top = Math.min(startLocation.y, pageY);
    let width = Math.abs(startLocation.x - pageX);
    let height = Math.abs(startLocation.y - pageY);
    if (lock === X) {
      left = clipBox.x1;
      width = clipBox.width();
    }
    if (lock === Y) {
      top = clipBox.y1;
      height = clipBox.height();
    }
    if (pageX > clipBox.x2) {
      width = clipBox.x2 - startLocation.x;
    }
    if (pageX < clipBox.x1) {
      width = startLocation.x - clipBox.x1;
    }
    if (pageY > clipBox.y2) {
      height = clipBox.y2 - startLocation.y;
    }
    if (pageY < clipBox.y1) {
      height = startLocation.y - clipBox.y1;
    }
    return {
      left: Math.max(left, clipBox.x1),
      top: Math.max(top, clipBox.y1),
      width,
      height
    };
  }
};
ZoomSelection.prototype.options = {
  key: "shift",
  lock: "none"
};
var zoom_selection_default = ZoomSelection;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/mousewheel-zoom.js
var MIN_RATE = 0.01;
var MAX_RATE = 0.9;
var DEFAULT_RATE = 0.3;
var MousewheelZoom = class extends class_default {
  constructor(chart, options) {
    super();
    this.chart = chart;
    this.options = deepExtend({
      rate: DEFAULT_RATE
    }, this.options, options);
  }
  updateRanges(delta, coords) {
    const lock = (this.options.lock || "").toLowerCase();
    const axisRanges2 = [];
    const axes = this.chart._plotArea.axes;
    for (let idx = 0; idx < axes.length; idx++) {
      const axis = axes[idx];
      const vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {
        const rate = limitValue(this.options.rate, MIN_RATE, MAX_RATE);
        const range = axis.zoomRange(-delta * rate, coords);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
    return toChartAxisRanges(axisRanges2);
  }
  zoom() {
    const axisRanges2 = this.axisRanges;
    const plotArea = this.chart._plotArea;
    if (axisRanges2 && axisRanges2.length && plotArea.updateAxisOptions) {
      for (let idx = 0; idx < axisRanges2.length; idx++) {
        const axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  }
  destroy() {
    delete this.chart;
  }
};
var mousewheel_zoom_default = MousewheelZoom;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-layout.js
var alignItems = (rtl) => rtl ? END : START;
var LegendLayout = class extends chart_element_default {
  constructor(options, chartService) {
    super(options);
    this.chartService = chartService;
  }
  render() {
    const { children, options } = this;
    const vertical = options.vertical;
    this.visual = new drawing_exports.Layout(null, {
      spacing: vertical ? 0 : options.spacing,
      lineSpacing: vertical ? options.spacing : 0,
      orientation: vertical ? VERTICAL : HORIZONTAL,
      reverse: options.rtl,
      alignItems: vertical ? alignItems(options.rtl) : CENTER
    });
    for (let idx = 0; idx < children.length; idx++) {
      let legendItem = children[idx];
      legendItem.reflow(new box_default());
      legendItem.renderVisual();
    }
  }
  reflow(box) {
    this.visual.rect(box.toRect());
    this.visual.reflow();
    const bbox = this.visual.clippedBBox();
    if (bbox) {
      this.box = rectToBox(bbox);
    } else {
      this.box = new box_default();
    }
  }
  renderVisual() {
    this.addVisual();
  }
  createVisual() {
  }
};
var legend_layout_default = LegendLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/constants.js
var browser2 = support_default.browser || {};
var INITIAL_ANIMATION_DURATION = 600;
var FADEIN = "fadeIn";
var BORDER_BRIGHTNESS = 0.8;
var TOOLTIP_OFFSET = 5;
var START_SCALE = browser2.msie ? 1e-3 : 0;
var ERROR_LOW_FIELD = "errorLow";
var ERROR_HIGH_FIELD = "errorHigh";
var X_ERROR_LOW_FIELD = "xErrorLow";
var X_ERROR_HIGH_FIELD = "xErrorHigh";
var Y_ERROR_LOW_FIELD = "yErrorLow";
var Y_ERROR_HIGH_FIELD = "yErrorHigh";
var LINE_MARKER_SIZE = 8;
var ZERO = "zero";
var INTERPOLATE = "interpolate";
var GAP = "gap";
var ABOVE = "above";
var BELOW = "below";
var SMOOTH = "smooth";
var STEP = "step";
var AREA = "area";
var BAR = "bar";
var BOX_PLOT = "boxPlot";
var BUBBLE = "bubble";
var BULLET = "bullet";
var CANDLESTICK = "candlestick";
var COLUMN = "column";
var DONUT = "donut";
var FUNNEL = "funnel";
var PYRAMID = "pyramid";
var HEATMAP = "heatmap";
var HORIZONTAL_WATERFALL = "horizontalWaterfall";
var LINE = "line";
var OHLC = "ohlc";
var PIE = "pie";
var POLAR_AREA = "polarArea";
var POLAR_LINE = "polarLine";
var POLAR_SCATTER = "polarScatter";
var RADAR_AREA = "radarArea";
var RADAR_COLUMN = "radarColumn";
var RADAR_LINE = "radarLine";
var RANGE_AREA = "rangeArea";
var RANGE_BAR = "rangeBar";
var RANGE_COLUMN = "rangeColumn";
var SCATTER = "scatter";
var SCATTER_LINE = "scatterLine";
var VERTICAL_AREA = "verticalArea";
var VERTICAL_BOX_PLOT = "verticalBoxPlot";
var VERTICAL_BULLET = "verticalBullet";
var VERTICAL_LINE = "verticalLine";
var VERTICAL_RANGE_AREA = "verticalRangeArea";
var WATERFALL = "waterfall";
var EQUALLY_SPACED_SERIES = [
  BAR,
  COLUMN,
  OHLC,
  CANDLESTICK,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  BULLET,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL
];
var TRENDLINE_EXPONENTIAL = "exponentialTrendline";
var TRENDLINE_LINEAR = "linearTrendline";
var TRENDLINE_LOGARITHMIC = "logarithmicTrendline";
var TRENDLINE_MOVING_AVERAGE = "movingAverageTrendline";
var TRENDLINE_POLYNOMIAL = "polynomialTrendline";
var TRENDLINE_POWER = "powerTrendline";
var TRENDLINE_SERIES = [
  TRENDLINE_EXPONENTIAL,
  TRENDLINE_LINEAR,
  TRENDLINE_LOGARITHMIC,
  TRENDLINE_MOVING_AVERAGE,
  TRENDLINE_POLYNOMIAL,
  TRENDLINE_POWER
];
var LEGEND_ITEM_CLICK = "legendItemClick";
var LEGEND_ITEM_HOVER = "legendItemHover";
var LEGEND_ITEM_LEAVE = "legendItemLeave";
var SERIES_CLICK = "seriesClick";
var SERIES_HOVER = "seriesHover";
var SERIES_OVER = "seriesOver";
var SERIES_LEAVE = "seriesLeave";
var PLOT_AREA_CLICK = "plotAreaClick";
var PLOT_AREA_HOVER = "plotAreaHover";
var PLOT_AREA_LEAVE = "plotAreaLeave";
var DRAG = "drag";
var DRAG_END = "dragEnd";
var DRAG_START = "dragStart";
var ZOOM_START = "zoomStart";
var ZOOM = "zoom";
var ZOOM_END = "zoomEnd";
var SELECT_START = "selectStart";
var SELECT2 = "select";
var SELECT_END = "selectEnd";
var RENDER = "render";
var SHOW_TOOLTIP = "showTooltip";
var HIDE_TOOLTIP = "hideTooltip";
var PANE_RENDER = "paneRender";
var CHART_POINT_ROLE = "graphics-symbol";
var CHART_POINT_CLASSNAME = "k-chart-point";
var CHART_POINT_ROLE_DESCRIPTION = "Point";
var LEGEND_ITEM_ROLE = "checkbox";
var LEGEND_ITEM_CLASSNAME = "k-chart-legend-item";
var LEGEND_ITEM_ARIA_ROLE_DESCRIPTION = "Legend item";
var LOGARITHMIC = "log";
var CATEGORY = "category";
var INSIDE_END = "insideEnd";
var INSIDE_BASE = "insideBase";
var OUTSIDE_END = "outsideEnd";
var MOUSEWHEEL = "wheel";
var MOUSEWHEEL_DELAY = 150;
var MOUSEWHEEL_ZOOM_RATE = 0.3;
var DRILLDOWN = "drilldown";
var DRILLDOWN_FIELD = "drilldown";
var PATTERN_FIELD = "pattern";
var MIN_MOVING_AVERAGE_PERIOD = 2;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-marker.js
var DEFAULT_MARKER_SIZE = 10;
var DEFAULT_MARKER_BORDER_WIDTH = 2;
var LegendItemMarker = class extends shape_element_default {
  visualStyle() {
    const options = this.markerOptions();
    const border = options.border;
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      cursor: options.cursor
    };
  }
  markerOptions() {
    return this.options;
  }
  markerHighlightOptions() {
    const options = this.markerOptions();
    const borderWidth = options.highlight.border.width;
    return deepExtend(
      {},
      options,
      { background: options.border.color },
      options.highlight,
      options.type === CROSS ? {
        background: options.highlight.border.color,
        border: { color: options.highlight.background, width: borderWidth / 2 },
        width: options.width,
        height: options.height,
        margin: { top: 0, left: 0 }
      } : {}
    );
  }
  createHighlight() {
    const highlight = new shape_element_default(this.markerHighlightOptions());
    const box = this.paddingBox.clone();
    highlight.reflow(box.pad(highlight.options.border.width));
    this.highlight = [highlight.getElement()];
    return this.highlight;
  }
};
setDefaultOptions(LegendItemMarker, {
  border: {
    width: DEFAULT_MARKER_BORDER_WIDTH
  },
  width: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  height: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  background: WHITE,
  margin: {
    top: -1,
    left: -1
  },
  vAlign: TOP,
  align: LEFT,
  highlight: {
    width: DEFAULT_MARKER_SIZE,
    height: DEFAULT_MARKER_SIZE,
    border: {
      color: WHITE,
      width: DEFAULT_MARKER_BORDER_WIDTH
    }
  }
});
var legend_item_marker_default = LegendItemMarker;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line-area.js
var MarkerLineArea = class extends shape_element_default {
  getElement() {
    const group = new drawing_exports.Group();
    const element = new drawing_exports.MultiPath(this.visualStyle());
    const { paddingBox: box } = this;
    const halfHeight = box.height() / 2;
    element.moveTo(box.x1, box.y1 + halfHeight).lineTo(box.x1, box.y2).lineTo(box.x2, box.y2);
    group.append(element);
    return group;
  }
};
setDefaultOptions(MarkerLineArea, {
  width: 15,
  height: 15,
  align: RIGHT,
  vAlign: BOTTOM,
  margin: {
    right: -2,
    bottom: 2
  }
});
var legend_item_line_area_default = MarkerLineArea;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line.js
var LegendItemLine = class extends shape_element_default {
  getElement() {
    const group = new drawing_exports.Group();
    const element = new drawing_exports.MultiPath({
      stroke: {
        color: this.options.border.color,
        opacity: this.options.opacity,
        width: this.options.height,
        dashType: this.options.dashType
      }
    });
    const box = this.paddingBox;
    const centerY = box.center().y;
    element.moveTo(box.x1, centerY).lineTo(box.x2, centerY);
    group.append(element);
    return group;
  }
  createHighlight() {
    this.highlight = [this.createHighlightLine(), this.createHighlightMarker()];
    return this.highlight;
  }
  createHighlightLine() {
    const options = deepExtend({}, {
      border: {
        color: this.options.border.color,
        opacity: this.options.border.opacity,
        dashType: this.options.border.dashType
      }
    }, this.options.highlight);
    const highlightLine = new legend_item_line_area_default(options);
    highlightLine.reflow(this.parent.paddingBox.clone());
    this.highlightLine = highlightLine.getElement();
    return this.highlightLine;
  }
  createHighlightMarker() {
    const options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    const highlightMarker = new shape_element_default(options);
    const paddingBox = this.parent.paddingBox;
    const borderWidth = options.border.width;
    const box = this.parent.box.clone();
    box.pad({
      left: borderWidth - paddingBox.x1,
      top: borderWidth - paddingBox.y1
    });
    highlightMarker.reflow(box);
    this.highlightMarker = highlightMarker.getElement();
    return this.highlightMarker;
  }
};
setDefaultOptions(LegendItemLine, {
  border: {
    width: 0
  },
  type: RECT,
  align: LEFT,
  vAlign: CENTER,
  highlight: {
    border: {
      width: DEFAULT_MARKER_BORDER_WIDTH
    },
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      align: LEFT,
      vAlign: TOP
    }
  }
});
var legend_item_line_default = LegendItemLine;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-square.js
var LegendItemSquare = class extends shape_element_default {
  createHighlight() {
    const options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    const highlight = new shape_element_default(options);
    const box = this.paddingBox.clone();
    const targetBox = this.parent.box.clone();
    box.align(targetBox, X, LEFT);
    box.align(targetBox, Y, TOP);
    highlight.reflow(box);
    this.highlight = [highlight.getElement()];
    return this.highlight;
  }
};
setDefaultOptions(LegendItemSquare, {
  highlight: {
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      margin: {
        top: -3,
        left: -3
      }
    }
  }
});
var legend_item_square_default = LegendItemSquare;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item.js
var LegendItem = class extends box_element_default {
  constructor(options) {
    super(options);
    this.createContainer();
    if (!options.rtl) {
      this.createMarker();
      this.createLabel();
    } else {
      this.createLabel();
      this.createMarker();
    }
    this._id = guid();
    this.options.accessibility.ariaChecked = options.active;
  }
  createContainer() {
    this.container = new float_element_default({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });
    this.append(this.container);
  }
  createMarker() {
    this.markerWrap = new box_element_default({ vertical: false, shrinkToFit: true, wrap: false, margin: 1, width: 22, height: 22 });
    this.container.append(this.markerWrap);
    this.createMarkerArea();
    if (this.options.markers.visible) {
      this._marker = this._createMarker();
      this.markerWrap.append(this._marker);
    }
  }
  createMarkerArea() {
    const options = this.options;
    const { markerColor, line = {} } = options;
    const lineOptions = {
      border: {
        color: line.color || markerColor,
        opacity: line.opacity,
        dashType: line.dashType
      }
    };
    return this._createLine(lineOptions) || this._createMarkerLine(lineOptions, line) || this._createSquare();
  }
  markerOptions() {
    const options = this.options;
    const { markers = {}, markerColor } = options;
    const { border = {} } = markers;
    markers.zIndex = void 0;
    return deepExtend({}, markers, {
      border: { color: border.color || markerColor },
      highlight: options.highlight.markers
    });
  }
  _highlightOptions() {
    const options = this.options;
    return deepExtend(
      { markers: { type: options.markers.type } },
      options.highlight
    );
  }
  _createLine(lineOptions) {
    const options = this.options;
    if (options.type === LINE && !options.markers.visible) {
      this._line = new legend_item_line_default(deepExtend({}, {
        background: options.markerColor,
        highlight: this._highlightOptions()
      }, lineOptions, options.line));
      this.markerWrap.append(this._line);
    }
    return this._line;
  }
  _createMarkerLine(lineOptions, line) {
    const options = this.options;
    if (options.type === LINE) {
      this._markerLineArea = new legend_item_line_area_default(deepExtend({}, {
        border: {
          width: line.height
        }
      }, lineOptions));
      this.markerWrap.append(this._markerLineArea);
    }
    return this._markerLineArea;
  }
  _reduceSize(object, prop, factor = 0.6) {
    if (typeof object[prop] === "number") {
      object[prop] = object[prop] * factor;
    }
  }
  _createSquare() {
    const options = this.options;
    if (options.type === AREA) {
      let pattern = options.pattern || (options.series || {}).pattern;
      if (pattern) {
        if (typeof pattern === "function") {
          pattern = pattern(options.series);
        }
        pattern = Object.assign({}, pattern);
        this._reduceSize(pattern, "gap");
        this._reduceSize(pattern, "width");
        this._reduceSize(pattern, "radius");
      }
      this._square = new legend_item_square_default(Object.assign(
        {},
        {
          border: options.border,
          vAlign: options.markers.visible ? BOTTOM : CENTER,
          highlight: this._highlightOptions()
        },
        options.area,
        {
          pattern,
          background: options.area.background || options.markerColor
        }
      ));
      this.markerWrap.append(this._square);
    }
    return this._square;
  }
  _createMarker() {
    return new legend_item_marker_default(this.markerOptions());
  }
  _highlightMarkers() {
    if (this.options.active) {
      this._toggleHighlight(true);
    }
  }
  _restoreMarkers() {
    this._toggleHighlight(false);
  }
  _toggleHighlight(show2) {
    if (!this.options.highlight.visible) {
      return;
    }
    const element = this._marker || this._square || this._line;
    if (element && element === this._line) {
      this._line.visual.visible(!show2);
    }
    if (element) {
      let highlight = element.highlight;
      if (!highlight) {
        highlight = element.createHighlight();
        highlight.forEach((h) => h && this.markerWrap.appendVisual(h));
      }
      highlight.forEach((h) => h && h.visible(show2));
    }
  }
  createLabel() {
    const options = this.options;
    const labelOptions = deepExtend({}, options.labels);
    this.container.append(new text_box_default(options.text, labelOptions));
  }
  getAriaLabelText() {
    return this.options.text;
  }
  focusVisual() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
    this._highlightMarkers();
  }
  clearFocusFromVisual() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
    this._restoreMarkers();
  }
  renderComplete() {
    super.renderComplete();
    const cursor = this.options.cursor || {};
    const eventSink = this._itemOverlay = drawing_exports.Path.fromRect(this.container.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null,
      cursor: cursor.style || cursor
    });
    this.appendVisual(eventSink);
  }
  click(widget, e) {
    const args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === "contextmenu") {
      e.preventDefault();
    }
  }
  over(widget, e) {
    const args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {
      widget._legendItemHover(args.seriesIndex, args.pointIndex);
      this._highlightMarkers();
    }
    return true;
  }
  out(widget, e) {
    widget._unsetActivePoint();
    this._restoreMarkers();
    widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));
  }
  eventArgs(e) {
    const options = this.options;
    return {
      element: eventElement(e),
      text: options.text,
      series: options.series,
      seriesIndex: options.series.index,
      pointIndex: options.pointIndex
    };
  }
  createVisual() {
    super.createVisual();
    const options = this.options;
    if (this.options.visible) {
      const accessibilityOptions = deepExtend({
        ariaLabel: options.accessibility.ariaLabel !== void 0 ? options.accessibility.ariaLabel : options.text
      }, options.accessibility);
      addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
    }
  }
  renderVisual() {
    const options = this.options;
    const customVisual = options.visual;
    if (customVisual) {
      this.visual = customVisual({
        active: options.active,
        series: options.series,
        sender: this.getSender(),
        pointIndex: options.pointIndex,
        options: {
          type: options.type,
          // Passing the markerColor as a background option for backwards compatibility.
          // Example in jq docs - https://docs.telerik.com/kendo-ui/api/javascript/dataviz/ui/chart/configuration/legend.item#legenditemvisual
          markers: deepExtend({ background: this.options.markerColor }, this.markerOptions()),
          labels: options.labels
        },
        createVisual: () => {
          this.createVisual();
          this.renderChildren();
          this.renderComplete();
          const defaultVisual = this.visual;
          delete this.visual;
          return defaultVisual;
        }
      });
      this._marker = this._markerLineArea = this._square = this._line = null;
      this.addVisual();
    } else {
      super.renderVisual();
    }
  }
  createFocusHighlight(style) {
    const borderWidth = style.stroke.width;
    return drawing_exports.Path.fromRect(this.container.box.pad(borderWidth / 2).toRect(), style);
  }
};
setDefaultOptions(LegendItem, {
  accessibility: {
    role: LEGEND_ITEM_ROLE,
    className: LEGEND_ITEM_CLASSNAME,
    ariaRoleDescription: LEGEND_ITEM_ARIA_ROLE_DESCRIPTION
  },
  markers: {},
  highlight: {
    visible: true,
    markers: {}
  }
});
var legend_item_default = LegendItem;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend.js
var CUSTOM = "custom";
var Legend = class extends chart_element_default {
  constructor(options, chartService = {}) {
    super(options);
    this.chartService = chartService;
    if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {
      this.options.position = RIGHT;
    }
    this.createContainers();
    this.createLegendTitle(options.title);
    this.createItems();
  }
  createContainers() {
    const options = this.options;
    const { position, align: userAlign } = options;
    let align = position;
    let vAlign = CENTER;
    if (position === CUSTOM) {
      align = LEFT;
    } else if (inArray(position, [TOP, BOTTOM])) {
      if (userAlign === START) {
        align = LEFT;
      } else if (userAlign === END) {
        align = RIGHT;
      } else {
        align = CENTER;
      }
      vAlign = position;
    } else if (userAlign) {
      if (userAlign === START) {
        vAlign = TOP;
      } else if (userAlign === END) {
        vAlign = BOTTOM;
      }
    }
    this.container = new box_element_default({
      margin: options.margin,
      padding: options.padding,
      background: options.background,
      border: options.border,
      vAlign,
      align,
      zIndex: options.zIndex,
      shrinkToFit: true
    });
    if (this.hasTitle()) {
      this.itemsContainer = new box_element_default({
        vAlign,
        align,
        zIndex: options.zIndex,
        shrinkToFit: true
      });
    } else {
      this.itemsContainer = this.container;
    }
    this.append(this.container);
  }
  createItems() {
    const chartService = this.getService();
    const options = this.options;
    const vertical = this.isVertical();
    const innerElement = new legend_layout_default({
      vertical,
      spacing: options.spacing,
      rtl: chartService.rtl
    }, chartService);
    let data = options.data;
    if (options.reverse) {
      data = data.slice(0).reverse();
    }
    const count = data.length;
    for (let i = 0; i < count; i++) {
      let dataItem = data[i];
      const { markers = {}, dashType, legendItem, opacity } = dataItem.series || {};
      const markersOptions = deepExtend({ visible: markers.visible !== false, type: CIRCLE }, markers);
      delete markersOptions.size;
      const itemOptions = deepExtend(
        {},
        {
          markers: markersOptions,
          labels: options.labels,
          rtl: chartService.rtl,
          line: Object.assign(
            {},
            { dashType },
            options.line
          ),
          area: Object.assign(
            {},
            { opacity },
            options.area
          ),
          opacity,
          accessibility: options.accessibility,
          focusHighlight: options.focusHighlight
        },
        options.item,
        legendItem,
        dataItem,
        { markers: options.markers }
      );
      innerElement.append(new legend_item_default(itemOptions));
    }
    innerElement.render();
    this.itemsContainer.append(innerElement);
  }
  isVertical() {
    const { orientation, position } = this.options;
    const vertical = position === CUSTOM && orientation !== HORIZONTAL || (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [LEFT, RIGHT]));
    return vertical;
  }
  hasItems() {
    return this.container.children[0].children.length > 0;
  }
  getItems() {
    return this.itemsContainer.children[0].children;
  }
  reflow(targetBox) {
    const options = this.options;
    const legendBox = targetBox.clone();
    if (!this.hasItems()) {
      this.box = legendBox;
      return;
    }
    if (options.position === CUSTOM) {
      this.containerCustomReflow(legendBox);
      this.box = legendBox;
    } else {
      this.containerReflow(legendBox);
    }
    if (this.hasTitle()) {
      this.title.reflow(new box_default(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));
    }
  }
  containerReflow(targetBox) {
    const { options, container } = this;
    const { position, width, height } = options;
    const pos = position === TOP || position === BOTTOM ? X : Y;
    const vertical = this.isVertical();
    const alignTarget = targetBox.clone();
    let containerBox = targetBox.clone();
    if (position === LEFT || position === RIGHT) {
      containerBox.y1 = alignTarget.y1 = 0;
    }
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
      containerBox.align(alignTarget, Y, container.options.vAlign);
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
      containerBox.align(alignTarget, X, container.options.align);
    }
    container.reflow(containerBox);
    containerBox = container.box;
    const box = containerBox.clone();
    if (options.offsetX || options.offsetY) {
      containerBox.translate(options.offsetX, options.offsetY);
      container.reflow(containerBox);
    }
    box[pos + 1] = targetBox[pos + 1];
    box[pos + 2] = targetBox[pos + 2];
    this.box = box;
  }
  containerCustomReflow(targetBox) {
    const { options, container } = this;
    const { offsetX, offsetY, width, height } = options;
    const vertical = this.isVertical();
    let containerBox = targetBox.clone();
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
    }
    container.reflow(containerBox);
    containerBox = container.box;
    container.reflow(new box_default(
      offsetX,
      offsetY,
      offsetX + containerBox.width(),
      offsetY + containerBox.height()
    ));
  }
  renderVisual() {
    if (this.hasItems()) {
      super.renderVisual();
    }
  }
  createLegendTitle(title3) {
    let titleOptions = deepExtend({}, {
      color: BLACK,
      position: TOP,
      align: CENTER
    }, title3);
    let text = titleOptions.text;
    if (!title3 || title3.visible === false || !title3.text) {
      return;
    }
    if (defined(titleOptions) && titleOptions.visible) {
      const labelTemplate = getTemplate(titleOptions);
      if (labelTemplate) {
        text = labelTemplate({ text });
      } else if (titleOptions.format) {
        text = this.chartService.format.auto(titleOptions.format, text);
      }
    }
    this.title = new text_box_default(text, titleOptions);
    this.createTitleLayout();
    this.appendTitleLayoutContent();
  }
  createTitleLayout() {
    this.layout = new float_element_default({
      vertical: true,
      wrap: false
    });
    this.container.append(this.layout);
  }
  hasTitle() {
    return Boolean(this.options.title && this.options.title.visible !== false && this.options.title.text);
  }
  appendTitleLayoutContent() {
    const options = this.options;
    if (options.title.position === BOTTOM) {
      this.layout.append(this.itemsContainer);
      this.layout.append(this.title);
    } else {
      this.layout.append(this.title);
      this.layout.append(this.itemsContainer);
    }
  }
};
setDefaultOptions(Legend, {
  position: RIGHT,
  data: [],
  offsetX: 0,
  offsetY: 0,
  margin: getSpacing(2),
  padding: getSpacing(5),
  border: {
    color: BLACK,
    width: 0
  },
  item: {
    cursor: POINTER,
    spacing: 6
  },
  spacing: 6,
  background: "",
  zIndex: 1,
  markers: {},
  line: {
    width: 20,
    height: 2,
    cursor: POINTER,
    opacity: 1
  },
  area: {
    type: SQUARE,
    align: RIGHT,
    width: 15,
    height: 15
  }
});
var legend_default = Legend;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/filter-series-by-type.js
function filterSeriesByType(series, types) {
  const result = [];
  const seriesTypes = [].concat(types);
  for (let idx = 0; idx < series.length; idx++) {
    const currentSeries = series[idx];
    if (inArray(currentSeries.type, seriesTypes)) {
      result.push(currentSeries);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-factory.js
var PlotAreaFactory = class extends class_default {
  constructor() {
    super();
    this._registry = [];
  }
  register(type, seriesTypes) {
    this._registry.push({
      type,
      seriesTypes
    });
  }
  create(srcSeries, options, chartService) {
    const registry2 = this._registry;
    let match = registry2[0];
    let series;
    for (let idx = 0; idx < registry2.length; idx++) {
      const entry = registry2[idx];
      series = filterSeriesByType(srcSeries, entry.seriesTypes);
      const trendlines = filterSeriesByType(srcSeries, TRENDLINE_SERIES);
      if (series.length - trendlines.length > 0) {
        match = entry;
        break;
      }
    }
    return new match.type(series, options, chartService);
  }
};
PlotAreaFactory.current = new PlotAreaFactory();
var plotarea_factory_default = PlotAreaFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/selection.js
var ZOOM_ACCELERATION = 3;
var SELECTOR_HEIGHT_ADJUST = 0.1;
function createDiv(classNames) {
  const element = document.createElement("div");
  if (classNames) {
    element.className = classNames;
  }
  return element;
}
function closestHandle(element) {
  let current4 = element;
  while (current4 && !hasClasses(current4, "k-handle")) {
    current4 = current4.parentNode;
  }
  return current4;
}
var Selection = class extends class_default {
  constructor(chart, categoryAxis, options, observer) {
    super();
    const chartElement = chart.element;
    this.options = deepExtend({}, this.options, options);
    this.chart = chart;
    this.observer = observer;
    this.chartElement = chartElement;
    this.categoryAxis = categoryAxis;
    this._dateAxis = this.categoryAxis instanceof date_category_axis_default;
    this.initOptions();
    this.visible = this.options.visible && chartElement.offsetHeight;
    if (this.visible) {
      this.createElements();
      this.set(this._index(this.options.from), this._index(this.options.to));
      this.bindEvents();
    }
  }
  onPane(pane) {
    return this.categoryAxis.pane === pane;
  }
  createElements() {
    const options = this.options;
    const wrapper = this.wrapper = createDiv("k-selector k-pointer-events-none");
    elementStyles(wrapper, {
      top: options.offset.top,
      left: options.offset.left,
      width: options.width,
      height: options.height,
      direction: "ltr"
    });
    const selection = this.selection = createDiv("k-selection k-pointer-events-none");
    this.leftMask = createDiv("k-mask k-pointer-events-none");
    this.rightMask = createDiv("k-mask k-pointer-events-none");
    wrapper.appendChild(this.leftMask);
    wrapper.appendChild(this.rightMask);
    wrapper.appendChild(selection);
    const body = this.body = createDiv("k-selection-bg k-pointer-events-none");
    selection.appendChild(body);
    const leftHandle = this.leftHandle = createDiv("k-handle k-left-handle k-pointer-events-auto");
    const rightHandle = this.rightHandle = createDiv("k-handle k-right-handle k-pointer-events-auto");
    leftHandle.appendChild(createDiv());
    rightHandle.appendChild(createDiv());
    selection.appendChild(leftHandle);
    selection.appendChild(rightHandle);
    this.chartElement.appendChild(wrapper);
    const selectionStyles = elementStyles(selection, ["borderLeftWidth", "borderRightWidth", "height"]);
    const leftHandleHeight = elementStyles(leftHandle, "height").height;
    const rightHandleHeight = elementStyles(rightHandle, "height").height;
    options.selection = {
      border: {
        left: selectionStyles.borderLeftWidth,
        right: selectionStyles.borderRightWidth
      }
    };
    elementStyles(leftHandle, {
      top: (selectionStyles.height - leftHandleHeight) / 2
    });
    elementStyles(rightHandle, {
      top: (selectionStyles.height - rightHandleHeight) / 2
    });
    wrapper.style.cssText = wrapper.style.cssText;
  }
  bindEvents() {
    if (this.options.mousewheel !== false) {
      this._mousewheelHandler = this._mousewheel.bind(this);
      bindEvents(this.chartElement, {
        [MOUSEWHEEL]: this._mousewheelHandler
      });
    }
    this._domEvents = dom_events_builder_default.create(this.chartElement, {
      stopPropagation: true,
      // applicable for the jQuery UserEvents
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      press: this._press.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
  }
  initOptions() {
    const { options, categoryAxis } = this;
    const box = categoryAxis.pane.chartsBox();
    const intlService = this.chart.chartService.intl;
    if (this._dateAxis) {
      deepExtend(options, {
        min: parseDate(intlService, options.min),
        max: parseDate(intlService, options.max),
        from: parseDate(intlService, options.from),
        to: parseDate(intlService, options.to)
      });
    }
    const { paddingLeft, paddingTop } = elementStyles(this.chartElement, ["paddingLeft", "paddingTop"]);
    this.options = deepExtend({}, {
      width: box.width(),
      height: box.height() + SELECTOR_HEIGHT_ADJUST,
      //workaround for sub-pixel hover on the paths in chrome
      padding: {
        left: paddingLeft,
        top: paddingTop
      },
      offset: {
        left: box.x1 + paddingLeft,
        top: box.y1 + paddingTop
      },
      from: options.min,
      to: options.max
    }, options);
  }
  destroy() {
    if (this._domEvents) {
      this._domEvents.destroy();
      delete this._domEvents;
    }
    clearTimeout(this._mwTimeout);
    this._state = null;
    if (this.wrapper) {
      if (this._mousewheelHandler) {
        unbindEvents(this.chartElement, {
          [MOUSEWHEEL]: this._mousewheelHandler
        });
        this._mousewheelHandler = null;
      }
      this.chartElement.removeChild(this.wrapper);
      this.wrapper = null;
    }
  }
  _rangeEventArgs(range) {
    return {
      axis: this.categoryAxis.options,
      from: this._value(range.from),
      to: this._value(range.to)
    };
  }
  _pointInPane(x, y) {
    const paneBox = this.categoryAxis.pane.box;
    const modelCoords = this.chart._toModelCoordinates(x, y);
    return paneBox.containsPoint(modelCoords);
  }
  _start(e) {
    const options = this.options;
    const target = eventElement(e);
    if (this._state || !target) {
      return;
    }
    const coords = eventCoordinates(e);
    const inPane = this._pointInPane(coords.x, coords.y);
    if (!inPane) {
      return;
    }
    const handle = closestHandle(target);
    const bodyRect = this.body.getBoundingClientRect();
    const inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;
    this.chart._unsetActivePoint();
    this._state = {
      moveTarget: handle,
      startLocation: e.x ? e.x.location : 0,
      inBody,
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    const args = this._rangeEventArgs({
      from: this._index(options.from),
      to: this._index(options.to)
    });
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    }
  }
  _press(e) {
    let handle;
    if (this._state) {
      handle = this._state.moveTarget;
    } else {
      handle = closestHandle(eventElement(e));
    }
    if (handle) {
      addClass(handle, "k-handle-active");
    }
  }
  _move(e) {
    if (!this._state) {
      return;
    }
    const { _state: state, options, categoryAxis } = this;
    const { range, moveTarget: target } = state;
    const reverse = categoryAxis.options.reverse;
    const from = this._index(options.from);
    const to = this._index(options.to);
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const delta = state.startLocation - e.x.location;
    const oldRange = { from: range.from, to: range.to };
    const span = range.to - range.from;
    const scale = elementStyles(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);
    const offset = Math.round(delta / scale) * (reverse ? -1 : 1);
    if (!target && !state.inBody) {
      return;
    }
    const leftHandle = target && hasClasses(target, "k-left-handle");
    const rightHandle = target && hasClasses(target, "k-right-handle");
    if (state.inBody) {
      range.from = Math.min(
        Math.max(min4, from - offset),
        max3 - span
      );
      range.to = Math.min(
        range.from + span,
        max3
      );
    } else if (leftHandle && !reverse || rightHandle && reverse) {
      range.from = Math.min(
        Math.max(min4, from - offset),
        max3 - 1
      );
      range.to = Math.max(range.from + 1, range.to);
    } else if (leftHandle && reverse || rightHandle && !reverse) {
      range.to = Math.min(
        Math.max(min4 + 1, to - offset),
        max3
      );
      range.from = Math.min(range.to - 1, range.from);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.move(range.from, range.to);
      this.trigger(SELECT2, this._rangeEventArgs(range));
    }
  }
  _end() {
    if (this._state) {
      const moveTarget = this._state.moveTarget;
      if (moveTarget) {
        removeClass(moveTarget, "k-handle-active");
      }
      const range = this._state.range;
      this.set(range.from, range.to);
      this.trigger(SELECT_END, this._rangeEventArgs(range));
      delete this._state;
    }
  }
  _tap(e) {
    const { options, categoryAxis } = this;
    const coords = this.chart._eventCoordinates(e);
    const categoryIx = categoryAxis.pointCategoryIndex(new point_default(coords.x, categoryAxis.box.y1));
    const from = this._index(options.from);
    const to = this._index(options.to);
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const span = to - from;
    const mid = from + span / 2;
    const range = {};
    const rightClick = e.event.which === 3;
    let offset = Math.round(mid - categoryIx);
    if (this._state || rightClick) {
      return;
    }
    this.chart._unsetActivePoint();
    if (!categoryAxis.options.justified) {
      offset--;
    }
    range.from = Math.min(
      Math.max(min4, from - offset),
      max3 - span
    );
    range.to = Math.min(range.from + span, max3);
    this._start(e);
    if (this._state) {
      this._state.range = range;
      this.trigger(SELECT2, this._rangeEventArgs(range));
      this._end();
    }
  }
  _mousewheel(e) {
    let delta = mousewheelDelta(e);
    this._start(e);
    if (this._state) {
      const range = this._state.range;
      e.preventDefault();
      e.stopPropagation();
      if (Math.abs(delta) > 1) {
        delta *= ZOOM_ACCELERATION;
      }
      if (this.options.mousewheel.reverse) {
        delta *= -1;
      }
      if (this.expand(delta)) {
        this.trigger(SELECT2, {
          axis: this.categoryAxis.options,
          delta,
          originalEvent: e,
          from: this._value(range.from),
          to: this._value(range.to)
        });
      }
      if (this._mwTimeout) {
        clearTimeout(this._mwTimeout);
      }
      this._mwTimeout = setTimeout(() => {
        this._end();
      }, MOUSEWHEEL_DELAY);
    }
  }
  _gesturestart(e) {
    const options = this.options;
    const touch = e.touches[0];
    const inPane = this._pointInPane(touch.pageX, touch.pageY);
    if (!inPane) {
      return;
    }
    this._state = {
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    const args = this._rangeEventArgs(this._state.range);
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    } else {
      e.preventDefault();
    }
  }
  _gestureend() {
    if (this._state) {
      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));
      delete this._state;
    }
  }
  _gesturechange(e) {
    if (!this._state) {
      return;
    }
    const { chart, _state: state, options, categoryAxis } = this;
    const range = state.range;
    const p0 = chart._toModelCoordinates(e.touches[0].x.location).x;
    const p1 = chart._toModelCoordinates(e.touches[1].x.location).x;
    const left = Math.min(p0, p1);
    const right = Math.max(p0, p1);
    e.preventDefault();
    range.from = categoryAxis.pointCategoryIndex(new point_default(left)) || options.min;
    range.to = categoryAxis.pointCategoryIndex(new point_default(right)) || options.max;
    this.move(range.from, range.to);
    this.trigger(SELECT2, this._rangeEventArgs(range));
  }
  _index(value2) {
    let index = value2;
    if (value2 instanceof Date) {
      index = this.categoryAxis.categoryIndex(value2);
    }
    return index;
  }
  _value(index) {
    let value2 = index;
    if (this._dateAxis) {
      value2 = this.categoryAxis.categoryAt(index);
      if (value2 > this.options.max) {
        value2 = this.options.max;
      }
    }
    return value2;
  }
  _slot(value2) {
    const categoryAxis = this.categoryAxis;
    const index = this._index(value2);
    return categoryAxis.getSlot(index, index, true);
  }
  move(from, to) {
    const options = this.options;
    const reverse = this.categoryAxis.options.reverse;
    const { offset, padding, selection: { border } } = options;
    const left = reverse ? to : from;
    const right = reverse ? from : to;
    const edge = "x" + (reverse ? 2 : 1);
    let box = this._slot(left);
    const leftMaskWidth = round(box[edge] - offset.left + padding.left);
    elementStyles(this.leftMask, {
      width: leftMaskWidth
    });
    elementStyles(this.selection, {
      left: leftMaskWidth
    });
    box = this._slot(right);
    const rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));
    elementStyles(this.rightMask, {
      width: rightMaskWidth
    });
    let distance = options.width - rightMaskWidth;
    if (distance !== options.width) {
      distance += border.right;
    }
    elementStyles(this.rightMask, {
      left: distance
    });
    elementStyles(this.selection, {
      width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)
    });
  }
  set(from, to) {
    const options = this.options;
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const fromValue = limitValue(this._index(from), min4, max3);
    const toValue = limitValue(this._index(to), fromValue + 1, max3);
    if (options.visible) {
      this.move(fromValue, toValue);
    }
    options.from = this._value(fromValue);
    options.to = this._value(toValue);
  }
  expand(delta) {
    const options = this.options;
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const zDir = options.mousewheel.zoom;
    const from = this._index(options.from);
    const to = this._index(options.to);
    let range = { from, to };
    const oldRange = deepExtend({}, range);
    if (this._state) {
      range = this._state.range;
    }
    if (zDir !== RIGHT) {
      range.from = limitValue(
        limitValue(from - delta, 0, to - 1),
        min4,
        max3
      );
    }
    if (zDir !== LEFT) {
      range.to = limitValue(
        limitValue(to + delta, range.from + 1, max3),
        min4,
        max3
      );
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  }
  zoom(delta, coords) {
    const options = this.options;
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const from = this._index(options.from);
    const to = this._index(options.to);
    let range = { from, to };
    const oldRange = deepExtend({}, range);
    const { reverse } = this.categoryAxis.options;
    const origin = X + (reverse ? "2" : "1");
    const lineBox = this.categoryAxis.lineBox();
    const relative = Math.abs(lineBox[origin] - coords[X]);
    const size = lineBox.width();
    const position = round(relative / size, 2);
    const minDelta = round(position * delta);
    const maxDelta = round((1 - position) * delta);
    if (this._state) {
      range = this._state.range;
    }
    range.from = limitValue(
      limitValue(from - minDelta, 0, to - 1),
      min4,
      max3
    );
    range.to = limitValue(
      limitValue(to + maxDelta, range.from + 1, max3),
      min4,
      max3
    );
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  }
  trigger(name, args) {
    return (this.observer || this.chart).trigger(name, args);
  }
};
setDefaultOptions(Selection, {
  visible: true,
  mousewheel: {
    zoom: "both"
  },
  min: MIN_VALUE,
  max: MAX_VALUE
});
var selection_default = Selection;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-field.js
function getField(field, row) {
  if (row === null) {
    return row;
  }
  const get = getter(field, true);
  return get(row);
}

// node_modules/@progress/kendo-charts/dist/es/chart/series-binder.js
var SeriesBinder = class extends class_default {
  constructor() {
    super();
    this._valueFields = {};
    this._otherFields = {};
    this._nullValue = {};
    this._undefinedValue = {};
  }
  register(seriesTypes, valueFields = [VALUE], otherFields = {}) {
    for (let i = 0; i < seriesTypes.length; i++) {
      const type = seriesTypes[i];
      this._valueFields[type] = valueFields;
      this._otherFields[type] = otherFields;
      this._nullValue[type] = this._makeValue(valueFields, null);
      this._undefinedValue[type] = this._makeValue(valueFields, void 0);
    }
  }
  canonicalFields(series) {
    return this.valueFields(series).concat(this.otherFields(series));
  }
  valueFields(series) {
    return this._valueFields[series.type] || [VALUE];
  }
  otherFields(series) {
    return this._otherFields[series.type] || [VALUE];
  }
  bindPoint(series, pointIx, item) {
    const data = series.data;
    const pointData = defined(item) ? item : data[pointIx];
    const result = { valueFields: { value: pointData } };
    const valueFields = this.valueFields(series);
    const otherFields = this._otherFields[series.type];
    let fields, value2;
    if (pointData === null) {
      value2 = this._nullValue[series.type];
    } else if (!defined(pointData)) {
      value2 = this._undefinedValue[series.type];
    } else if (Array.isArray(pointData)) {
      const fieldData = pointData.slice(valueFields.length);
      value2 = this._bindFromArray(pointData, valueFields);
      fields = this._bindFromArray(fieldData, otherFields);
    } else if (typeof pointData === "object") {
      const srcValueFields = this.sourceFields(series, valueFields);
      const srcPointFields = this.sourceFields(series, otherFields);
      value2 = this._bindFromObject(pointData, valueFields, srcValueFields);
      fields = this._bindFromObject(pointData, otherFields, srcPointFields);
    }
    if (defined(value2)) {
      if (valueFields.length === 1) {
        result.valueFields.value = value2[valueFields[0]];
      } else {
        result.valueFields = value2;
      }
    }
    result.fields = fields || {};
    return result;
  }
  _makeValue(fields, initialValue) {
    const value2 = {};
    const length = fields.length;
    for (let i = 0; i < length; i++) {
      const fieldName = fields[i];
      value2[fieldName] = initialValue;
    }
    return value2;
  }
  _bindFromArray(array, fields) {
    const value2 = {};
    if (fields) {
      const length = Math.min(fields.length, array.length);
      for (let i = 0; i < length; i++) {
        value2[fields[i]] = array[i];
      }
    }
    return value2;
  }
  _bindFromObject(object, fields, srcFields = fields) {
    const value2 = {};
    if (fields) {
      const length = fields.length;
      for (let i = 0; i < length; i++) {
        const fieldName = fields[i];
        const srcFieldName = srcFields[i];
        if (srcFieldName !== null) {
          value2[fieldName] = getField(srcFieldName, object);
        }
      }
    }
    return value2;
  }
  sourceFields(series, canonicalFields) {
    const sourceFields = [];
    if (canonicalFields) {
      const length = canonicalFields.length;
      for (let i = 0; i < length; i++) {
        const fieldName = canonicalFields[i];
        const sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";
        sourceFields.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);
      }
    }
    return sourceFields;
  }
};
SeriesBinder.current = new SeriesBinder();
var series_binder_default = SeriesBinder;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/base-tooltip.js
var BaseTooltip = class extends class_default {
  constructor(chartService, options) {
    super();
    this.chartService = chartService;
    this.options = deepExtend({}, this.options, options);
  }
  getStyle(options, point) {
    let { background, border: { color: border } } = options;
    if (point) {
      const pointColor = point.color || point.options.color;
      background = valueOrDefault(background, pointColor);
      border = valueOrDefault(border, pointColor);
    }
    const padding = options.padding !== void 0 ? getSpacing(options.padding) : {};
    if (typeof options.padding === "object") {
      padding.top = options.padding.top !== void 0 ? padding.top : void 0;
      padding.right = options.padding.right !== void 0 ? padding.right : void 0;
      padding.bottom = options.padding.bottom !== void 0 ? padding.bottom : void 0;
      padding.left = options.padding.left !== void 0 ? padding.left : void 0;
    }
    return {
      backgroundColor: background,
      borderColor: border,
      font: options.font,
      color: options.color,
      opacity: options.opacity,
      borderWidth: styleValue(options.border.width),
      paddingTop: styleValue(padding.top),
      paddingBottom: styleValue(padding.bottom),
      paddingLeft: styleValue(padding.left),
      paddingRight: styleValue(padding.right)
    };
  }
  show(options, tooltipOptions, point) {
    if (!this.chartService) {
      return;
    }
    options.format = tooltipOptions.format;
    const style = this.getStyle(tooltipOptions, point);
    options.style = style;
    const background = new color_default(style.backgroundColor);
    if (!defined(tooltipOptions.color) && !background.isDark()) {
      options.className = "k-chart-tooltip-inverse";
    }
    this.chartService.notify(SHOW_TOOLTIP, options);
    this.visible = true;
  }
  hide() {
    if (this.chartService) {
      this.chartService.notify(HIDE_TOOLTIP);
    }
    this.visible = false;
  }
  destroy() {
    delete this.chartService;
  }
};
setDefaultOptions(BaseTooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var base_tooltip_default = BaseTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/tooltip.js
var Tooltip = class extends base_tooltip_default {
  show(point) {
    if (!point || !point.tooltipAnchor || this._current && this._current === point) {
      return;
    }
    const options = deepExtend({}, this.options, point.options.tooltip);
    const anchor = point.tooltipAnchor();
    if (anchor) {
      this._current = point;
      super.show({
        point,
        anchor
      }, options, point);
    } else {
      this.hide();
    }
  }
  hide() {
    delete this._current;
    super.hide();
  }
};
var tooltip_default = Tooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/shared-tooltip.js
var SharedTooltip = class extends base_tooltip_default {
  constructor(plotArea, options) {
    super(plotArea.chartService, options);
    this.plotArea = plotArea;
    this.formatService = plotArea.chartService.format;
  }
  showAt(points, coords) {
    const tooltipPoints = grep(points, function(point) {
      const tooltip = point.series.tooltip;
      const excluded = tooltip && tooltip.visible === false;
      return !excluded;
    });
    if (tooltipPoints.length > 0) {
      const point = tooltipPoints[0];
      const slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);
      const anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);
      this.show({
        anchor,
        shared: true,
        points,
        category: point.category,
        categoryText: this.formatService.auto(this.options.categoryFormat, point.category),
        series: this.plotArea.series
      }, this.options);
    }
  }
  _slotAnchor(point, slot) {
    const axis = this.plotArea.categoryAxis;
    const align = {
      horizontal: "left",
      vertical: "center"
    };
    if (!axis.options.vertical) {
      point.x = slot.center().x;
    }
    return {
      point,
      align
    };
  }
  _defaultAnchor(point, slot) {
    const box = point.owner.pane.chartsBox();
    const vertical = this.plotArea.categoryAxis.options.vertical;
    const center = box.center();
    const slotCenter = slot.center();
    const align = {
      horizontal: "center",
      vertical: "center"
    };
    let centerPoint;
    if (vertical) {
      centerPoint = new point_default(center.x, slotCenter.y);
    } else {
      centerPoint = new point_default(slotCenter.x, center.y);
    }
    return {
      point: centerPoint,
      align
    };
  }
};
setDefaultOptions(SharedTooltip, {
  categoryFormat: "{0:d}"
});
var shared_tooltip_default = SharedTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair-tooltip.js
var CrosshairTooltip = class extends base_tooltip_default {
  constructor(chartService, crosshair, options) {
    super(chartService, options);
    this.crosshair = crosshair;
    this.formatService = chartService.format;
    this.initAxisName();
  }
  initAxisName() {
    const axis = this.crosshair.axis;
    const plotArea = axis.plotArea;
    let name;
    if (plotArea.categoryAxis) {
      name = axis.getCategory ? "categoryAxis" : "valueAxis";
    } else {
      name = axis.options.vertical ? "yAxis" : "xAxis";
    }
    this.axisName = name;
  }
  showAt(point) {
    const { crosshair: { axis }, options } = this;
    let value2 = axis[options.stickyMode ? "getCategory" : "getValue"](point);
    let formattedValue = value2;
    if (options.format) {
      formattedValue = this.formatService.auto(options.format, value2);
    } else if (axis.options.type === DATE) {
      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value2);
    }
    this.show({
      point,
      anchor: this.getAnchor(),
      crosshair: this.crosshair,
      value: formattedValue,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    }, this.options);
  }
  hide() {
    this.chartService.notify(HIDE_TOOLTIP, {
      crosshair: this.crosshair,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    });
  }
  getAnchor() {
    const { crosshair, options: { position, padding } } = this;
    const vertical = !crosshair.axis.options.vertical;
    const lineBox = crosshair.line.bbox();
    let horizontalAlign, verticalAlign, point;
    if (vertical) {
      horizontalAlign = CENTER;
      if (position === BOTTOM) {
        verticalAlign = TOP;
        point = lineBox.bottomLeft().translate(0, padding);
      } else {
        verticalAlign = BOTTOM;
        point = lineBox.topLeft().translate(0, -padding);
      }
    } else {
      verticalAlign = CENTER;
      if (position === LEFT) {
        horizontalAlign = RIGHT;
        point = lineBox.topLeft().translate(-padding, 0);
      } else {
        horizontalAlign = LEFT;
        point = lineBox.topRight().translate(padding, 0);
      }
    }
    return {
      point,
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  }
};
setDefaultOptions(CrosshairTooltip, {
  padding: 10
});
var crosshair_tooltip_default = CrosshairTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair.js
var Crosshair = class extends chart_element_default {
  constructor(chartService, axis, options) {
    super(options);
    this.axis = axis;
    this.stickyMode = axis instanceof category_axis_default;
    const tooltipOptions = this.options.tooltip;
    if (tooltipOptions.visible) {
      this.tooltip = new crosshair_tooltip_default(
        chartService,
        this,
        deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })
      );
    }
  }
  showAt(point) {
    this.point = point;
    this.moveLine();
    this.line.visible(true);
    if (this.tooltip) {
      this.tooltip.showAt(point);
    }
  }
  hide() {
    this.line.visible(false);
    if (this.tooltip) {
      this.tooltip.hide();
    }
  }
  moveLine() {
    const { axis, point } = this;
    const vertical = axis.options.vertical;
    const box = this.getBox();
    const dim = vertical ? Y : X;
    const lineStart = new geometry_exports.Point(box.x1, box.y1);
    let lineEnd;
    if (vertical) {
      lineEnd = new geometry_exports.Point(box.x2, box.y1);
    } else {
      lineEnd = new geometry_exports.Point(box.x1, box.y2);
    }
    if (point) {
      if (this.stickyMode) {
        const slot = axis.getSlot(axis.pointCategoryIndex(point));
        lineStart[dim] = lineEnd[dim] = slot.center()[dim];
      } else {
        lineStart[dim] = lineEnd[dim] = point[dim];
      }
    }
    this.box = box;
    this.line.moveTo(lineStart).lineTo(lineEnd);
  }
  getBox() {
    const axis = this.axis;
    const axes = axis.pane.axes;
    const length = axes.length;
    const vertical = axis.options.vertical;
    const box = axis.lineBox().clone();
    const dim = vertical ? X : Y;
    let axisLineBox;
    for (let i = 0; i < length; i++) {
      const currentAxis = axes[i];
      if (currentAxis.options.vertical !== vertical) {
        if (!axisLineBox) {
          axisLineBox = currentAxis.lineBox().clone();
        } else {
          axisLineBox.wrap(currentAxis.lineBox());
        }
      }
    }
    box[dim + 1] = axisLineBox[dim + 1];
    box[dim + 2] = axisLineBox[dim + 2];
    return box;
  }
  createVisual() {
    super.createVisual();
    const options = this.options;
    this.line = new drawing_exports.Path({
      stroke: {
        color: options.color,
        width: options.width,
        opacity: options.opacity,
        dashType: options.dashType
      },
      visible: false
    });
    this.moveLine();
    this.visual.append(this.line);
  }
  destroy() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    super.destroy();
  }
};
setDefaultOptions(Crosshair, {
  color: BLACK,
  width: 2,
  zIndex: -1,
  tooltip: {
    visible: false
  }
});
var crosshair_default = Crosshair;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-axis.js
var ChartAxis = class extends class_default {
  constructor(axis) {
    super();
    this._axis = axis;
    this.options = axis.options;
  }
  value(point) {
    const axis = this._axis;
    const value2 = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);
    return value2;
  }
  slot(from, to, limit = true) {
    return this._axis.slot(from, to, limit);
  }
  range() {
    return this._axis.range();
  }
  valueRange() {
    return this._axis.valueRange();
  }
};
var chart_axis_default = ChartAxis;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/find-axis-by-name.js
function findAxisByName(name, axes) {
  for (let idx = 0; idx < axes.length; idx++) {
    if (axes[idx].options.name === name) {
      axes[idx].prepareUserOptions();
      return new chart_axis_default(axes[idx]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-pane.js
var ChartPane = class {
  constructor(pane) {
    this.visual = pane.visual;
    this.chartsVisual = pane.chartContainer.visual;
    this._pane = pane;
  }
  findAxisByName(name) {
    return findAxisByName(name, this._pane.axes);
  }
};
var chart_pane_default = ChartPane;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-plotarea.js
var ChartPlotArea = class extends class_default {
  constructor(plotArea) {
    super();
    this._plotArea = plotArea;
    this.visual = plotArea.visual;
    this.backgroundVisual = plotArea._bgVisual;
  }
};
var chart_plotarea_default = ChartPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/chart-container.js
var ChartContainer = class extends chart_element_default {
  constructor(options, pane) {
    super(options);
    this.pane = pane;
  }
  shouldClip() {
    const children = this.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      if (children[i].options.clip === true) {
        return true;
      }
    }
    return false;
  }
  _clipBox() {
    return this.pane.chartsBox();
  }
  createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: 0
    });
    if (this.shouldClip()) {
      const clipBox = this.clipBox = this._clipBox();
      const clipRect = clipBox.toRect();
      const clipPath = drawing_exports.Path.fromRect(clipRect);
      alignPathToPixel(clipPath);
      this.visual.clip(clipPath);
      this.unclipLabels();
    }
  }
  stackRoot() {
    return this;
  }
  unclipLabels() {
    const { children: charts, clipBox } = this;
    for (let i = 0; i < charts.length; i++) {
      const points = charts[i].points || {};
      const length = points.length;
      for (let j = 0; j < length; j++) {
        const point = points[j];
        if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {
          if (point.unclipElements) {
            point.unclipElements();
          } else {
            const { label, note } = point;
            if (label && label.options.visible) {
              if (label.alignToClipBox) {
                label.alignToClipBox(clipBox);
              }
              label.options.noclip = true;
            }
            if (note && note.options.visible) {
              note.options.noclip = true;
            }
          }
        }
      }
    }
  }
  destroy() {
    super.destroy();
    delete this.parent;
  }
};
ChartContainer.prototype.isStackRoot = true;
var chart_container_default = ChartContainer;

// node_modules/@progress/kendo-charts/dist/es/chart/pane.js
var Pane = class _Pane extends box_element_default {
  constructor(options) {
    super(options);
    this.id = paneID();
    this.createTitle();
    this.content = new chart_element_default();
    this.chartContainer = new chart_container_default({}, this);
    this.append(this.content);
    this.axes = [];
    this.charts = [];
  }
  createTitle() {
    let titleOptions = this.options.title;
    if (isObject(titleOptions)) {
      titleOptions = deepExtend({}, titleOptions, {
        align: titleOptions.position,
        position: TOP
      });
    }
    this.title = title_default.buildTitle(titleOptions, _Pane.prototype.options.title);
    if (this.title) {
      this.append(this.title);
    }
  }
  appendAxis(axis) {
    this.content.append(axis);
    this.axes.push(axis);
    axis.pane = this;
  }
  appendAxisAt(axis, pos) {
    this.content.append(axis);
    this.axes.splice(pos, 0, axis);
    axis.pane = this;
  }
  appendChart(chart) {
    if (this.chartContainer.parent !== this.content) {
      this.content.append(this.chartContainer);
    }
    this.charts.push(chart);
    this.chartContainer.append(chart);
    chart.pane = this;
  }
  empty() {
    const plotArea = this.parent;
    if (plotArea) {
      for (let i = 0; i < this.axes.length; i++) {
        plotArea.removeAxis(this.axes[i]);
      }
      for (let i = 0; i < this.charts.length; i++) {
        plotArea.removeChart(this.charts[i]);
      }
    }
    this.axes = [];
    this.charts = [];
    this.content.destroy();
    this.content.children = [];
    this.chartContainer.children = [];
  }
  reflow(targetBox) {
    let content;
    if (last(this.children) === this.content) {
      content = this.children.pop();
    }
    super.reflow(targetBox);
    if (content) {
      this.children.push(content);
    }
    if (this.title) {
      this.contentBox.y1 += this.title.box.height();
    }
  }
  visualStyle() {
    const style = super.visualStyle();
    style.zIndex = -10;
    return style;
  }
  renderComplete() {
    if (this.options.visible) {
      this.createGridLines();
    }
  }
  stackRoot() {
    return this;
  }
  clipRoot() {
    return this;
  }
  createGridLines() {
    const axes = this.axes;
    const allAxes = axes.concat(this.parent.axes);
    const vGridLines = [];
    const hGridLines = [];
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      const vertical = axis.options.vertical;
      const gridLines = vertical ? vGridLines : hGridLines;
      for (let j = 0; j < allAxes.length; j++) {
        if (gridLines.length === 0) {
          const altAxis = allAxes[j];
          if (vertical !== altAxis.options.vertical) {
            append(gridLines, axis.createGridLines(altAxis));
          }
        }
      }
    }
  }
  refresh() {
    this.visual.clear();
    this.content.parent = null;
    this.content.createGradient = this.createGradient.bind(this);
    this.content.renderVisual();
    this.content.parent = this;
    if (this.title) {
      this.visual.append(this.title.visual);
    }
    this.visual.append(this.content.visual);
    this.renderComplete();
    this.notifyRender();
  }
  chartsBox() {
    const axes = this.axes;
    const length = axes.length;
    const chartsBox = new box_default();
    for (let idx = 0; idx < length; idx++) {
      const axis = axes[idx];
      const axisValueField = axis.options.vertical ? Y : X;
      const lineBox = axis.lineBox();
      chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];
      chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];
    }
    if (chartsBox.x2 === 0) {
      const allAxes = this.parent.axes;
      const length2 = allAxes.length;
      for (let idx = 0; idx < length2; idx++) {
        const axis = allAxes[idx];
        if (!axis.options.vertical) {
          const lineBox = axis.lineBox();
          chartsBox.x1 = lineBox.x1;
          chartsBox.x2 = lineBox.x2;
        }
      }
    }
    return chartsBox;
  }
  clipBox() {
    return this.chartContainer.clipBox;
  }
  notifyRender() {
    const service = this.getService();
    if (service) {
      service.notify(PANE_RENDER, {
        pane: new chart_pane_default(this),
        index: this.paneIndex,
        name: this.options.name
      });
    }
  }
};
var ID2 = 1;
function paneID() {
  return "pane" + ID2++;
}
Pane.prototype.isStackRoot = true;
setDefaultOptions(Pane, {
  zIndex: -1,
  shrinkToFit: true,
  title: {
    align: LEFT
  },
  visible: true
});
var pane_default = Pane;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/any-has-z-index.js
function anyHasZIndex(elements) {
  for (let idx = 0; idx < elements.length; idx++) {
    if (defined(elements[idx].zIndex)) {
      return true;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/append-if-not-null.js
function appendIfNotNull(array, element) {
  if (element !== null) {
    array.push(element);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/count-numbers.js
function countNumbers(values) {
  const length = values.length;
  let count = 0;
  for (let i = 0; i < length; i++) {
    const num = values[i];
    if (isNumber(num)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/are-numbers.js
function areNumbers(values) {
  return countNumbers(values) === values.length;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/segment-visible.js
function segmentVisible(series, fields, index) {
  const visible = fields.visible;
  if (defined(visible)) {
    return visible;
  }
  const pointVisibility = series.pointVisibility;
  if (pointVisibility) {
    return pointVisibility[index];
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/bind-segments.js
function bindSegments(series) {
  const data = series.data;
  const points = [];
  let sum2 = 0;
  let count = 0;
  for (let idx = 0; idx < data.length; idx++) {
    const pointData = series_binder_default.current.bindPoint(series, idx);
    let value2 = pointData.valueFields.value;
    if (isString(value2)) {
      value2 = parseFloat(value2);
    }
    if (isNumber(value2)) {
      pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;
      pointData.value = Math.abs(value2);
      points.push(pointData);
      if (pointData.visible) {
        sum2 += pointData.value;
      }
      if (value2 !== 0) {
        count++;
      }
    } else {
      points.push(null);
    }
  }
  return {
    total: sum2,
    points,
    count
  };
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/categories-count.js
function categoriesCount(series) {
  const seriesCount = series.length;
  let categories = 0;
  for (let i = 0; i < seriesCount; i++) {
    categories = Math.max(categories, series[i].data.length);
  }
  return categories;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/equals-ignore-case.js
function equalsIgnoreCase(a, b) {
  if (a && b) {
    return a.toLowerCase() === b.toLowerCase();
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/eval-options.js
var MAX_EXPAND_DEPTH = 5;
function evalOptions(options, context, state = {}, dryRun = false) {
  const defaults = state.defaults = state.defaults || {};
  const depth = state.depth = state.depth || 0;
  let needsEval = false;
  state.excluded = state.excluded || [];
  if (depth > MAX_EXPAND_DEPTH) {
    return null;
  }
  for (let property in options) {
    if (!inArray(property, state.excluded) && hasOwnProperty(options, property)) {
      const propValue = options[property];
      if (isFunction(propValue)) {
        needsEval = true;
        if (!dryRun) {
          options[property] = valueOrDefault(propValue(context), defaults[property]);
        }
      } else if (isObject(propValue)) {
        if (!dryRun) {
          state.defaults = defaults[property];
        }
        state.depth++;
        needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;
        state.depth--;
      }
    }
  }
  return needsEval;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/parse-date-category.js
var dateCache = /* @__PURE__ */ new WeakMap();
function parseDateCategory(category, row, intlService) {
  if (row === null || typeof row !== "object") {
    return parseDate(intlService, category);
  }
  let date = dateCache.get(row);
  if (!date) {
    date = parseDate(intlService, category);
    dateCache.set(row, date);
  }
  return date;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-gradient-overlay.js
function hasGradientOverlay(options) {
  const overlay = options.overlay;
  return overlay && overlay.gradient && overlay.gradient !== "none";
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-value.js
function hasValue(value2) {
  return defined(value2) && value2 !== null;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/is-date-axis.js
function isDateAxis(axisOptions2, sampleCategory) {
  const type = axisOptions2.type;
  const dateCategory = sampleCategory instanceof Date;
  return !type && dateCategory || equalsIgnoreCase(type, DATE);
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/single-item-or-array.js
function singleItemOrArray(array) {
  return array.length === 1 ? array[0] : array;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js
var AREA_REGEX = /area/i;
function seriesMissingValues(series) {
  if (series.missingValues) {
    return series.missingValues;
  }
  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;
}
function hasValue2(series, item) {
  const fields = series_binder_default.current.bindPoint(series, null, item);
  const valueFields = fields.valueFields;
  for (let field in valueFields) {
    if (convertableToNumber(valueFields[field])) {
      return true;
    }
  }
}
function findNext({ start, dir, min: min4, max: max3, getter: getter2, hasItem, series }) {
  let pointHasValue, outPoint;
  let idx = start;
  do {
    idx += dir;
    if (hasItem(idx)) {
      outPoint = getter2(idx);
      pointHasValue = hasValue2(series, outPoint.item);
    }
  } while (min4 <= idx && idx <= max3 && !pointHasValue);
  if (pointHasValue) {
    return outPoint;
  }
}
function createOutOfRangePoints(series, range, count, getter2, hasItem) {
  const { min: min4, max: max3 } = range;
  const hasMinPoint = min4 > 0 && min4 < count;
  const hasMaxPoint = max3 + 1 < count;
  if (hasMinPoint || hasMaxPoint) {
    const missingValues = seriesMissingValues(series);
    let minPoint, maxPoint;
    if (missingValues !== INTERPOLATE) {
      if (hasMinPoint) {
        minPoint = getter2(min4 - 1);
      }
      if (hasMaxPoint) {
        maxPoint = getter2(max3 + 1);
      }
    } else {
      let outPoint, pointHasValue;
      if (hasMinPoint) {
        outPoint = getter2(min4 - 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          minPoint = findNext({
            start: min4,
            dir: -1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          minPoint = outPoint;
        }
      }
      if (hasMaxPoint) {
        outPoint = getter2(max3 + 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          maxPoint = findNext({
            start: max3,
            dir: 1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          maxPoint = outPoint;
        }
      }
    }
    if (minPoint) {
      series._outOfRangeMinPoint = minPoint;
    }
    if (maxPoint) {
      series._outOfRangeMaxPoint = maxPoint;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-base.js
var visiblePoint = (point) => point.options.visible !== false;
var PlotAreaBase = class extends chart_element_default {
  constructor(series, options, chartService) {
    super(options);
    this.initFields(series, options);
    this.series = series;
    this.initSeries();
    this.charts = [];
    this.options.legend = this.options.legend || {};
    this.options.legend.data = [];
    this.axes = [];
    this.crosshairs = [];
    this.chartService = chartService;
    this.originalOptions = options;
    this.originalSeries = series;
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.createPanes();
    this.render();
    this.createCrosshairs();
  }
  initFields() {
  }
  initSeries() {
    const series = this.series;
    for (let i = 0; i < series.length; i++) {
      series[i].index = i;
    }
  }
  bindPoint(series, pointIx, item) {
    let cached = this._bindCache.get(series);
    if (!cached) {
      cached = [];
      this._bindCache.set(series, cached);
    }
    let data = cached[pointIx];
    if (!data) {
      data = cached[pointIx] = series_binder_default.current.bindPoint(series, pointIx, item);
    }
    return data;
  }
  createPanes() {
    const titleOptions = this.options.title || {};
    const paneDefaults = this.options.paneDefaults;
    const paneOptions = this.options.panes || [];
    const panesLength = Math.max(paneOptions.length, 1);
    const panes = [];
    const defaults = deepExtend({
      title: {
        color: titleOptions.color
      }
    }, paneDefaults);
    for (let i = 0; i < panesLength; i++) {
      const options = deepExtend({}, defaults, paneOptions[i]);
      if (isString(options.title)) {
        options.title = deepExtend({ text: options.title }, defaults.title);
      }
      const currentPane = new pane_default(options);
      currentPane.paneIndex = i;
      panes.push(currentPane);
      this.append(currentPane);
    }
    this.panes = panes;
  }
  crosshairOptions(axis) {
    return axis.options.crosshair;
  }
  createCrosshairs(panes = this.panes) {
    for (let i = 0; i < panes.length; i++) {
      const pane = panes[i];
      for (let j = 0; j < pane.axes.length; j++) {
        const axis = pane.axes[j];
        const options = this.crosshairOptions(axis);
        if (options && options.visible) {
          const currentCrosshair = new crosshair_default(this.chartService, axis, options);
          this.crosshairs.push(currentCrosshair);
          pane.content.append(currentCrosshair);
        }
      }
    }
  }
  removeCrosshairs(pane) {
    const crosshairs = this.crosshairs;
    const axes = pane.axes;
    for (let i = crosshairs.length - 1; i >= 0; i--) {
      for (let j = 0; j < axes.length; j++) {
        if (crosshairs[i].axis === axes[j]) {
          crosshairs.splice(i, 1);
          break;
        }
      }
    }
  }
  hideCrosshairs() {
    const crosshairs = this.crosshairs;
    for (let idx = 0; idx < crosshairs.length; idx++) {
      crosshairs[idx].hide();
    }
  }
  findPane(name) {
    const panes = this.panes;
    let matchingPane;
    for (let i = 0; i < panes.length; i++) {
      if (panes[i].options.name === name) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane || panes[0];
  }
  findPointPane(point) {
    const panes = this.panes;
    let matchingPane;
    for (let i = 0; i < panes.length; i++) {
      if (panes[i].box.containsPoint(point)) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane;
  }
  appendAxis(axis) {
    const pane = this.findPane(axis.options.pane);
    pane.appendAxis(axis);
    this.axes.push(axis);
    axis.plotArea = this;
  }
  removeAxis(axisToRemove) {
    const filteredAxes = [];
    for (let i = 0; i < this.axes.length; i++) {
      const axis = this.axes[i];
      if (axisToRemove !== axis) {
        filteredAxes.push(axis);
      } else {
        axis.destroy();
      }
    }
    this.axes = filteredAxes;
  }
  appendChart(chart, pane) {
    this.charts.push(chart);
    if (pane) {
      pane.appendChart(chart);
    } else {
      this.append(chart);
    }
  }
  removeChart(chartToRemove) {
    const filteredCharts = [];
    for (let i = 0; i < this.charts.length; i++) {
      const chart = this.charts[i];
      if (chart !== chartToRemove) {
        filteredCharts.push(chart);
      } else {
        chart.destroy();
      }
    }
    this.charts = filteredCharts;
  }
  addToLegend(series) {
    const count = series.length;
    const legend2 = this.options.legend;
    const labels = legend2.labels || {};
    const inactiveItems = legend2.inactiveItems || {};
    const inactiveItemsLabels = inactiveItems.labels || {};
    const data = [];
    for (let i = 0; i < count; i++) {
      const currentSeries = series[i];
      const seriesVisible = currentSeries.visible !== false;
      if (currentSeries.visibleInLegend === false) {
        continue;
      }
      let text = currentSeries.name;
      const labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);
      if (labelTemplate) {
        text = labelTemplate({
          text: hasValue(text) ? text : "",
          series: currentSeries
        });
      }
      const defaults = currentSeries._defaults;
      let color = currentSeries.color;
      if (isFunction(color) && defaults) {
        color = defaults.color;
      }
      let itemLabelOptions, markerColor;
      if (seriesVisible) {
        itemLabelOptions = {};
        markerColor = color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = inactiveItems.markers.color;
      }
      if (hasValue(text) && text !== "") {
        data.push({
          text,
          labels: itemLabelOptions,
          markerColor,
          series: currentSeries,
          active: seriesVisible
        });
      }
    }
    append(legend2.data, data);
  }
  groupAxes(panes) {
    const xAxes = [];
    const yAxes = [];
    for (let paneIx = 0; paneIx < panes.length; paneIx++) {
      const paneAxes = panes[paneIx].axes;
      for (let axisIx = 0; axisIx < paneAxes.length; axisIx++) {
        const axis = paneAxes[axisIx];
        if (axis.options.vertical) {
          yAxes.push(axis);
        } else {
          xAxes.push(axis);
        }
      }
    }
    return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };
  }
  groupSeriesByPane() {
    const series = this.series;
    const seriesByPane = {};
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      const pane = this.seriesPaneName(currentSeries);
      if (seriesByPane[pane]) {
        seriesByPane[pane].push(currentSeries);
      } else {
        seriesByPane[pane] = [currentSeries];
      }
    }
    return seriesByPane;
  }
  filterVisibleSeries(series) {
    const result = [];
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      if (currentSeries.visible !== false) {
        result.push(currentSeries);
      }
    }
    return result;
  }
  reflow(targetBox) {
    const options = this.options.plotArea;
    const panes = this.panes;
    const margin = getSpacing(options.margin);
    this.box = targetBox.clone().unpad(margin);
    this.reflowPanes();
    this.detachLabels();
    this.reflowAxes(panes);
    this.reflowCharts(panes);
  }
  redraw(panes) {
    const panesArray = [].concat(panes);
    this.initSeries();
    const root = this.getRoot();
    if (root) {
      root.cleanGradients();
    }
    for (let i = 0; i < panesArray.length; i++) {
      this.removeCrosshairs(panesArray[i]);
      panesArray[i].empty();
    }
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.render(panesArray);
    this.detachLabels();
    this.reflowAxes(this.panes);
    this.reflowCharts(panesArray);
    this.createCrosshairs(panesArray);
    for (let i = 0; i < panesArray.length; i++) {
      panesArray[i].refresh();
    }
  }
  axisCrossingValues(axis, crossingAxes) {
    const options = axis.options;
    const crossingValues = [].concat(
      options.axisCrossingValues || options.axisCrossingValue
    );
    const valuesToAdd = crossingAxes.length - crossingValues.length;
    const defaultValue = crossingValues[0] || 0;
    for (let i = 0; i < valuesToAdd; i++) {
      crossingValues.push(defaultValue);
    }
    return crossingValues;
  }
  alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
    const slot = axis.getSlot(crossingValue, crossingValue, true);
    const slotEdge = axis.options.reverse ? 2 : 1;
    const targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
    const targetEdge = targetAxis.options.reverse ? 2 : 1;
    const axisBox = axis.box.translate(
      targetSlot[X + targetEdge] - slot[X + slotEdge],
      targetSlot[Y + targetEdge] - slot[Y + slotEdge]
    );
    if (axis.pane !== targetAxis.pane) {
      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
    }
    axis.reflow(axisBox);
  }
  alignAxes(xAxes, yAxes) {
    const xAnchor = xAxes[0];
    const yAnchor = yAxes[0];
    const xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
    const yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
    const leftAnchors = {};
    const rightAnchors = {};
    const topAnchors = {};
    const bottomAnchors = {};
    for (let i = 0; i < yAxes.length; i++) {
      const axis = yAxes[i];
      const pane = axis.pane;
      const paneId = pane.id;
      const visible = axis.options.visible !== false;
      const anchor = paneAnchor(xAxes, pane) || xAnchor;
      let anchorCrossings = xAnchorCrossings;
      if (anchor !== xAnchor) {
        anchorCrossings = this.axisCrossingValues(anchor, yAxes);
      }
      this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
      if (axis.options._overlap) {
        continue;
      }
      if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {
        if (leftAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0)
          );
        }
        if (visible) {
          leftAnchors[paneId] = axis;
        }
      }
      if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
        if (rightAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0)
          );
        }
        if (visible) {
          rightAnchors[paneId] = axis;
        }
      }
      const paneYAnchor = paneAnchor(yAxes, pane) || yAnchor;
      if (paneYAnchor !== axis) {
        axis.alignTo(paneYAnchor);
        axis.reflow(axis.box);
      }
    }
    for (let i = 0; i < xAxes.length; i++) {
      const axis = xAxes[i];
      const pane = axis.pane;
      const paneId = pane.id;
      const visible = axis.options.visible !== false;
      const anchor = paneAnchor(yAxes, pane) || yAnchor;
      let anchorCrossings = yAnchorCrossings;
      if (anchor !== yAnchor) {
        anchorCrossings = this.axisCrossingValues(anchor, xAxes);
      }
      this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);
      if (axis.options._overlap) {
        continue;
      }
      if (round(axis.lineBox().y1) === round(anchor.lineBox().y1)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);
        if (topAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(topAnchors[paneId].box, TOP).translate(0, -axis.options.margin)
          );
        }
        if (visible) {
          topAnchors[paneId] = axis;
        }
      }
      if (round(axis.lineBox().y2, COORD_PRECISION) === round(anchor.lineBox().y2, COORD_PRECISION)) {
        if (bottomAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(bottomAnchors[paneId].box, BOTTOM).translate(0, axis.options.margin)
          );
        }
        if (visible) {
          bottomAnchors[paneId] = axis;
        }
      }
      if (i !== 0) {
        axis.alignTo(xAnchor);
        axis.reflow(axis.box);
      }
    }
  }
  shrinkAxisWidth(panes) {
    const axes = this.groupAxes(panes).any;
    const axisBox = axisGroupBox(axes);
    let overflowX = 0;
    for (let i = 0; i < panes.length; i++) {
      const currentPane = panes[i];
      if (currentPane.axes.length > 0) {
        overflowX = Math.max(
          overflowX,
          axisBox.width() - currentPane.contentBox.width()
        );
      }
    }
    if (overflowX !== 0) {
      for (let i = 0; i < axes.length; i++) {
        const currentAxis = axes[i];
        if (!currentAxis.options.vertical) {
          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
        }
      }
    }
  }
  shrinkAxisHeight(panes) {
    let shrinked;
    for (let i = 0; i < panes.length; i++) {
      const currentPane = panes[i];
      const axes = currentPane.axes;
      const overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());
      if (overflowY !== 0) {
        for (let j = 0; j < axes.length; j++) {
          const currentAxis = axes[j];
          if (currentAxis.options.vertical) {
            currentAxis.reflow(
              currentAxis.box.shrink(0, overflowY)
            );
          }
        }
        shrinked = true;
      }
    }
    return shrinked;
  }
  fitAxes(panes) {
    const axes = this.groupAxes(panes).any;
    let offsetX = 0;
    for (let i = 0; i < panes.length; i++) {
      const currentPane = panes[i];
      const paneAxes = currentPane.axes;
      const paneBox = currentPane.contentBox;
      if (paneAxes.length > 0) {
        const axisBox = axisGroupBox(paneAxes);
        const offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);
        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);
        for (let j = 0; j < paneAxes.length; j++) {
          const currentAxis = paneAxes[j];
          currentAxis.reflow(
            currentAxis.box.translate(0, offsetY)
          );
        }
      }
    }
    for (let i = 0; i < axes.length; i++) {
      const currentAxis = axes[i];
      currentAxis.reflow(
        currentAxis.box.translate(offsetX, 0)
      );
    }
  }
  reflowAxes(panes) {
    const axes = this.groupAxes(panes);
    for (let i = 0; i < panes.length; i++) {
      this.reflowPaneAxes(panes[i]);
    }
    if (axes.x.length > 0 && axes.y.length > 0) {
      this.alignAxes(axes.x, axes.y);
      this.shrinkAxisWidth(panes);
      this.autoRotateAxisLabels(axes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisWidth(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.shrinkAxisHeight(panes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisHeight(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.fitAxes(panes);
    }
  }
  autoRotateAxisLabels(groupedAxes) {
    const { panes } = this;
    const axes = allPaneAxes(panes);
    let rotated;
    for (let idx = 0; idx < axes.length; idx++) {
      const axis = axes[idx];
      if (axis.autoRotateLabels()) {
        rotated = true;
      }
    }
    if (rotated) {
      for (let idx = 0; idx < panes.length; idx++) {
        this.reflowPaneAxes(panes[idx]);
      }
      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
        this.alignAxes(groupedAxes.x, groupedAxes.y);
        this.shrinkAxisWidth(panes);
      }
    }
  }
  reflowPaneAxes(pane) {
    const axes = pane.axes;
    const length = axes.length;
    if (length > 0) {
      for (let i = 0; i < length; i++) {
        axes[i].reflow(pane.contentBox);
      }
    }
  }
  reflowCharts(panes) {
    const charts = this.charts;
    const count = charts.length;
    const box = this.box;
    for (let i = 0; i < count; i++) {
      const chartPane = charts[i].pane;
      if (!chartPane || inArray(chartPane, panes)) {
        charts[i].reflow(box);
      }
    }
  }
  reflowPanes() {
    const { box, panes } = this;
    const panesLength = panes.length;
    let remainingHeight = box.height();
    let autoHeightPanes = 0;
    let top = box.y1;
    for (let i = 0; i < panesLength; i++) {
      const currentPane = panes[i];
      const height = currentPane.options.height;
      currentPane.options.width = box.width();
      if (!currentPane.options.height) {
        autoHeightPanes++;
      } else {
        if (height.indexOf && height.indexOf("%")) {
          const percents = parseInt(height, 10) / 100;
          currentPane.options.height = percents * box.height();
        }
        currentPane.reflow(box.clone());
        remainingHeight -= currentPane.options.height;
      }
    }
    for (let i = 0; i < panesLength; i++) {
      const currentPane = panes[i];
      if (!currentPane.options.height) {
        currentPane.options.height = remainingHeight / autoHeightPanes;
      }
    }
    for (let i = 0; i < panesLength; i++) {
      const currentPane = panes[i];
      const paneBox = box.clone().move(box.x1, top);
      currentPane.reflow(paneBox);
      top += currentPane.options.height;
    }
  }
  backgroundBox() {
    const axes = this.axes;
    const axesCount = axes.length;
    let box;
    for (let i = 0; i < axesCount; i++) {
      const axisA = axes[i];
      for (let j = 0; j < axesCount; j++) {
        const axisB = axes[j];
        if (axisA.options.vertical !== axisB.options.vertical) {
          const lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());
          if (!box) {
            box = lineBox;
          } else {
            box = box.wrap(lineBox);
          }
        }
      }
    }
    return box || this.box;
  }
  chartsBoxes() {
    const panes = this.panes;
    const boxes = [];
    for (let idx = 0; idx < panes.length; idx++) {
      boxes.push(panes[idx].chartsBox());
    }
    return boxes;
  }
  addBackgroundPaths(multipath) {
    const boxes = this.chartsBoxes();
    for (let idx = 0; idx < boxes.length; idx++) {
      multipath.paths.push(drawing_exports.Path.fromRect(boxes[idx].toRect()));
    }
  }
  backgroundContainsPoint(point) {
    const boxes = this.chartsBoxes();
    for (let idx = 0; idx < boxes.length; idx++) {
      if (boxes[idx].containsPoint(point)) {
        return true;
      }
    }
  }
  createVisual() {
    super.createVisual();
    const options = this.options.plotArea;
    let { opacity, background, border = {} } = options;
    if (isTransparent(background)) {
      background = WHITE;
      opacity = 0;
    }
    const bg = this._bgVisual = new drawing_exports.MultiPath({
      fill: {
        color: background,
        opacity
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      zIndex: -1
    });
    this.addBackgroundPaths(bg);
    this.appendVisual(bg);
  }
  pointsByCategoryIndex(categoryIndex) {
    const charts = this.charts;
    const result = [];
    if (categoryIndex !== null) {
      for (let i = 0; i < charts.length; i++) {
        const chart = charts[i];
        if (chart.pane.options.name === "_navigator") {
          continue;
        }
        const points = charts[i].categoryPoints[categoryIndex];
        if (points && points.length) {
          for (let j = 0; j < points.length; j++) {
            const point = points[j];
            if (point && defined(point.value) && point.value !== null) {
              result.push(point);
            }
          }
        }
      }
    }
    return result;
  }
  pointsBySeriesIndex(seriesIndex) {
    return this.filterPoints(function(point) {
      return point.series.index === seriesIndex;
    });
  }
  pointsByPointIndex(pointIndex) {
    return this.filterPoints(function(point) {
      return point.getIndex() === pointIndex;
    });
  }
  pointsBySeriesName(name) {
    return this.filterPoints(function(point) {
      return point.series.name === name;
    });
  }
  filterPoints(callback) {
    const charts = this.charts;
    const result = [];
    for (let i = 0; i < charts.length; i++) {
      const chart = charts[i];
      const points = chart.points;
      for (let j = 0; j < points.length; j++) {
        const point = points[j];
        if (point && point.visible !== false && callback(point)) {
          result.push(point);
        }
      }
    }
    return result;
  }
  findPoint(callback) {
    const charts = this.charts;
    for (let i = 0; i < charts.length; i++) {
      const chart = charts[i];
      const points = chart.points;
      for (let j = 0; j < points.length; j++) {
        const point = points[j];
        if (point && point.visible !== false && callback(point)) {
          return point;
        }
      }
    }
  }
  paneByPoint(point) {
    const panes = this.panes;
    for (let i = 0; i < panes.length; i++) {
      const pane = panes[i];
      if (pane.box.containsPoint(point)) {
        return pane;
      }
    }
  }
  detachLabels() {
    const axes = this.groupAxes(this.panes);
    const xAxes = axes.x;
    const yAxes = axes.y;
    this.detachAxisGroupLabels(yAxes, xAxes);
    this.detachAxisGroupLabels(xAxes, yAxes);
  }
  detachAxisGroupLabels(axes, crossingAxes) {
    let labelAxisCount = 0;
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      const pane = axis.pane;
      const anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];
      const axisIndex = i + labelAxisCount;
      const labelAxis = this.createLabelAxis(axis, axisIndex, anchor);
      if (labelAxis) {
        labelAxisCount++;
        const pos = pane.axes.indexOf(axis) + labelAxisCount;
        pane.appendAxisAt(labelAxis, pos);
      }
    }
  }
  createLabelAxis(axis, axisIndex, anchor) {
    const labelOptions = axis.options.labels;
    const position = labelOptions.position;
    const onAxis = position !== END && position !== START;
    const visible = labelOptions.visible;
    if (onAxis || visible === false) {
      return null;
    }
    const allAxes = this.groupAxes(this.panes);
    const crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;
    const anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);
    const end = position === END;
    const range = anchor.range();
    const edge = end ? range.max : range.min;
    const crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);
    if (crossingValue - edge === 0) {
      return null;
    }
    anchorCrossings.splice(axisIndex + 1, 0, edge);
    anchor.options.axisCrossingValues = anchorCrossings;
    const labelAxis = axis.clone();
    axis.clear();
    labelAxis.options.name = void 0;
    labelAxis.options.line.visible = false;
    labelAxis.options.crosshair = void 0;
    labelAxis.options.notes = void 0;
    labelAxis.options.plotBands = void 0;
    return labelAxis;
  }
  isTrendline(series) {
    return series && inArray(series.type, TRENDLINE_SERIES);
  }
  trendlineFactory() {
  }
  createTrendlineSeries() {
    const modifiedSeries = [];
    this.series = this.series.map((series) => {
      if (!this.isTrendline(series)) {
        return series;
      }
      const forSeries = this.seriesByName(series.for);
      if (!forSeries) {
        throw new Error(`Invalid Configuration: Unable to locate linked series "${series.for}" for trendline "${series.name}".`);
      }
      const valueFields = series_binder_default.current.valueFields(forSeries);
      const field = last(valueFields);
      const trendlineSeries = this.trendlineFactory(Object.assign({}, { field }, series), forSeries);
      if (trendlineSeries) {
        if (forSeries.visible === false) {
          trendlineSeries.visible = false;
        }
        if (trendlineSeries.color === INHERIT) {
          trendlineSeries.color = forSeries.color;
        }
        modifiedSeries.push(trendlineSeries);
      }
      return trendlineSeries;
    }).filter((series) => series !== null);
    return modifiedSeries;
  }
  seriesByName(name) {
    return this.series.find((series) => series.name === name);
  }
  getFirstPoint() {
    for (let i = 0; i < this.series.length; i++) {
      const points = this.pointsBySeriesIndex(i);
      const point = points.find(visiblePoint);
      if (point) {
        return point;
      }
    }
  }
  getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  }
  getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  }
  getPointToTheRight(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, 1);
  }
  getPointToTheLeft(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, -1);
  }
  _getNextPoint(point, getPointsFunc, increment) {
    let points = getPointsFunc.call(this, point).filter(visiblePoint);
    const pointIndex = points.indexOf(point);
    let nextIndex = pointIndex + increment;
    const loopPoints = (direction) => {
      let result;
      let offset = 0;
      do {
        offset += direction;
        result = getPointsFunc.call(this, point, offset).filter(visiblePoint);
      } while (result.length === 0);
      return result;
    };
    if (nextIndex < 0) {
      points = loopPoints(-1);
      return points.at(-1);
    } else if (nextIndex >= points.length) {
      points = loopPoints(1);
      return points.at(0);
    }
    return points[nextIndex];
  }
  _pointsByVertical(basePoint) {
    return this.pointsByPointIndex(basePoint.getIndex());
  }
  _pointsByHorizontal(basePoint, offset = 0) {
    let index = cycleIndex(basePoint.series.index + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  }
};
function isSingleAxis(axis) {
  return !axis.pane.axes.some(
    (a) => a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false
  );
}
function axisGroupBox(axes) {
  const length = axes.length;
  let box;
  for (let i = 0; i < length; i++) {
    const axis = axes[i];
    const visible = axis.options.visible !== false;
    if (visible || isSingleAxis(axis)) {
      const axisBox = visible ? axis.contentBox() : axis.lineBox();
      if (!box) {
        box = axisBox.clone();
      } else {
        box.wrap(axisBox);
      }
    }
  }
  return box || new box_default();
}
function paneAnchor(axes, pane) {
  for (let i = 0; i < axes.length; i++) {
    const anchor = axes[i];
    if (anchor && anchor.pane === pane) {
      return anchor;
    }
  }
}
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}
var allPaneAxes = (panes) => panes.reduce((acc, pane) => acc.concat(pane.axes), []);
setDefaultOptions(PlotAreaBase, {
  series: [],
  plotArea: {
    margin: {}
  },
  background: "",
  border: {
    color: BLACK,
    width: 0
  },
  paneDefaults: {
    title: {}
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "#919191"
      },
      markers: {
        color: "#919191"
      }
    }
  }
});
var plotarea_base_default = PlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/axis-group-range-tracker.js
var AxisGroupRangeTracker = class extends class_default {
  constructor() {
    super();
    this.axisRanges = {};
  }
  update(chartAxisRanges) {
    const axisRanges2 = this.axisRanges;
    for (let axisName in chartAxisRanges) {
      const chartRange = chartAxisRanges[axisName];
      let range = axisRanges2[axisName];
      axisRanges2[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };
      range.min = Math.min(range.min, chartRange.min);
      range.max = Math.max(range.max, chartRange.max);
    }
  }
  reset(axisName) {
    this.axisRanges[axisName] = void 0;
  }
  query(axisName) {
    return this.axisRanges[axisName];
  }
};
var axis_group_range_tracker_default = AxisGroupRangeTracker;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/plotarea-events-mixin.js
var PlotAreaEventsMixin = {
  hover: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_HOVER);
  },
  click: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_CLICK);
  }
};
var plotarea_events_mixin_default = PlotAreaEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/aggregates.js
var Aggregates = {
  min: function(values) {
    const length = values.length;
    let min4 = MAX_VALUE;
    for (let i = 0; i < length; i++) {
      const value2 = values[i];
      if (isNumber(value2)) {
        min4 = Math.min(min4, value2);
      }
    }
    return min4 === MAX_VALUE ? values[0] : min4;
  },
  max: function(values) {
    const length = values.length;
    let max3 = MIN_VALUE;
    for (let i = 0; i < length; i++) {
      const value2 = values[i];
      if (isNumber(value2)) {
        max3 = Math.max(max3, value2);
      }
    }
    return max3 === MIN_VALUE ? values[0] : max3;
  },
  sum: function(values) {
    const length = values.length;
    let sum2 = 0;
    for (let i = 0; i < length; i++) {
      const value2 = values[i];
      if (isNumber(value2)) {
        sum2 += value2;
      }
    }
    return sum2;
  },
  sumOrNull: function(values) {
    let result = null;
    if (countNumbers(values)) {
      result = Aggregates.sum(values);
    }
    return result;
  },
  count: function(values) {
    const length = values.length;
    let count = 0;
    for (let i = 0; i < length; i++) {
      const value2 = values[i];
      if (value2 !== null && defined(value2)) {
        count++;
      }
    }
    return count;
  },
  avg: function(values) {
    const count = countNumbers(values);
    let result = values[0];
    if (count > 0) {
      result = Aggregates.sum(values) / count;
    }
    return result;
  },
  first: function(values) {
    const length = values.length;
    for (let i = 0; i < length; i++) {
      const value2 = values[i];
      if (value2 !== null && defined(value2)) {
        return value2;
      }
    }
    return values[0];
  }
};
var aggregates_default = Aggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/series-aggregator.js
var SeriesAggregator = class extends class_default {
  constructor(series, binder, defaultAggregates) {
    super();
    const canonicalFields = binder.canonicalFields(series);
    const valueFields = binder.valueFields(series);
    const sourceFields = binder.sourceFields(series, canonicalFields);
    const seriesFields = this._seriesFields = [];
    const defaults = defaultAggregates.query(series.type);
    const rootAggregate = series.aggregate || defaults;
    this._series = series;
    this._binder = binder;
    for (let i = 0; i < canonicalFields.length; i++) {
      const field = canonicalFields[i];
      let fieldAggregate;
      if (isObject(rootAggregate)) {
        fieldAggregate = rootAggregate[field];
      } else if (i === 0 || inArray(field, valueFields)) {
        fieldAggregate = rootAggregate;
      } else {
        break;
      }
      if (fieldAggregate) {
        seriesFields.push({
          canonicalName: field,
          name: sourceFields[i],
          transform: isFunction(fieldAggregate) ? fieldAggregate : aggregates_default[fieldAggregate]
        });
      }
    }
  }
  aggregatePoints(srcPoints, group) {
    const { _series: series, _seriesFields: seriesFields } = this;
    const data = this._bindPoints(srcPoints || []);
    const firstDataItem = data.dataItems[0];
    let result = {};
    if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {
      const fn = function() {
      };
      fn.prototype = firstDataItem;
      result = new fn();
    }
    for (let i = 0; i < seriesFields.length; i++) {
      const field = seriesFields[i];
      const srcValues = this._bindField(data.values, field.canonicalName);
      const value2 = field.transform(srcValues, series, data.dataItems, group);
      if (value2 !== null && isObject(value2) && !defined(value2.length) && !(value2 instanceof Date)) {
        result = value2;
        break;
      } else {
        if (defined(value2)) {
          setValue(field.name, result, value2);
        }
      }
    }
    return result;
  }
  _bindPoints(points) {
    const { _binder: binder, _series: series } = this;
    const values = [];
    const dataItems = [];
    for (let i = 0; i < points.length; i++) {
      const pointIx = points[i];
      values.push(binder.bindPoint(series, pointIx));
      dataItems.push(series.data[pointIx]);
    }
    return {
      values,
      dataItems
    };
  }
  _bindField(data, field) {
    const values = [];
    const count = data.length;
    for (let i = 0; i < count; i++) {
      const item = data[i];
      const valueFields = item.valueFields;
      let value2;
      if (defined(valueFields[field])) {
        value2 = valueFields[field];
      } else {
        value2 = item.fields[field];
      }
      values.push(value2);
    }
    return values;
  }
};
function setValue(fieldName, target, value2) {
  let parentObj = target;
  let field = fieldName;
  if (fieldName.indexOf(".") > -1) {
    const parts = fieldName.split(".");
    while (parts.length > 1) {
      field = parts.shift();
      if (!defined(parentObj[field])) {
        parentObj[field] = {};
      }
      parentObj = parentObj[field];
    }
    field = parts.shift();
  }
  parentObj[field] = value2;
}
var series_aggregator_default = SeriesAggregator;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/default-aggregates.js
var DefaultAggregates = class extends class_default {
  constructor() {
    super();
    this._defaults = {};
  }
  register(seriesTypes, aggregates) {
    for (let i = 0; i < seriesTypes.length; i++) {
      this._defaults[seriesTypes[i]] = aggregates;
    }
  }
  query(seriesType) {
    return this._defaults[seriesType];
  }
};
DefaultAggregates.current = new DefaultAggregates();
var default_aggregates_default = DefaultAggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-label.js
var BarLabel = class extends chart_element_default {
  constructor(content, options, pointData) {
    super(options);
    this.textBox = new text_box_default(content, this.options, pointData);
    this.append(this.textBox);
  }
  createVisual() {
    this.textBox.options.noclip = this.options.noclip;
  }
  reflow(targetBox) {
    const options = this.options;
    const { vertical, aboveAxis } = options;
    const text = this.children[0];
    const textOptions = text.options;
    const box = text.box;
    const padding = text.options.padding;
    let labelBox = targetBox;
    textOptions.align = vertical ? CENTER : LEFT;
    textOptions.vAlign = vertical ? TOP : CENTER;
    if (options.position === INSIDE_END) {
      if (vertical) {
        textOptions.vAlign = TOP;
        if (!aboveAxis && box.height() < targetBox.height()) {
          textOptions.vAlign = BOTTOM;
        }
      } else {
        textOptions.align = aboveAxis ? RIGHT : LEFT;
      }
    } else if (options.position === CENTER) {
      textOptions.vAlign = CENTER;
      textOptions.align = CENTER;
    } else if (options.position === INSIDE_BASE) {
      if (vertical) {
        textOptions.vAlign = aboveAxis ? BOTTOM : TOP;
      } else {
        textOptions.align = aboveAxis ? LEFT : RIGHT;
      }
    } else if (options.position === OUTSIDE_END) {
      if (vertical) {
        if (aboveAxis) {
          const boxesDiff = (box.width() - targetBox.width() - padding.left - padding.right) / 2;
          labelBox = new box_default(
            targetBox.x1 - boxesDiff,
            targetBox.y1 - box.height(),
            targetBox.x2 + boxesDiff,
            targetBox.y1
          );
        } else {
          labelBox = new box_default(
            targetBox.x1,
            targetBox.y2,
            targetBox.x2,
            targetBox.y2 + box.height()
          );
        }
      } else {
        textOptions.align = CENTER;
        if (aboveAxis) {
          labelBox = new box_default(
            targetBox.x2,
            targetBox.y1,
            targetBox.x2 + box.width(),
            targetBox.y2
          );
        } else {
          labelBox = new box_default(
            targetBox.x1 - box.width(),
            targetBox.y1,
            targetBox.x1,
            targetBox.y2
          );
        }
      }
    }
    if (!options.rotation) {
      if (vertical) {
        padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;
      } else {
        padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;
      }
    }
    text.reflow(labelBox);
  }
  alignToClipBox(clipBox) {
    const vertical = this.options.vertical;
    const field = vertical ? Y : X;
    const start = field + "1";
    const end = field + "2";
    const text = this.children[0];
    const parentBox = this.parent.box;
    if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {
      const targetBox = text.paddingBox.clone();
      targetBox[start] = Math.max(parentBox[start], clipBox[start]);
      targetBox[end] = Math.min(parentBox[end], clipBox[end]);
      this.reflow(targetBox);
    }
  }
};
setDefaultOptions(BarLabel, {
  position: OUTSIDE_END,
  margin: getSpacing(3),
  padding: getSpacing(4),
  color: BLACK,
  background: "",
  border: {
    width: 1,
    color: ""
  },
  aboveAxis: true,
  vertical: false,
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  zIndex: 2
});
var bar_label_default = BarLabel;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/point-events-mixin.js
var PointEventsMixin = {
  click: function(chart, e) {
    return chart.trigger(
      SERIES_CLICK,
      this.eventArgs(e)
    );
  },
  hover: function(chart, e) {
    return chart.trigger(
      SERIES_HOVER,
      this.eventArgs(e)
    );
  },
  over: function(chart, e) {
    return chart.trigger(
      SERIES_OVER,
      this.eventArgs(e)
    );
  },
  out: function(chart, e) {
    return chart.trigger(
      SERIES_LEAVE,
      this.eventArgs(e)
    );
  },
  eventArgs: function(e) {
    return {
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      category: this.category,
      series: this.series,
      dataItem: this.dataItem,
      runningTotal: this.runningTotal,
      total: this.total,
      element: eventElement(e),
      originalEvent: e,
      point: this
    };
  }
};
var point_events_mixin_default = PointEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/note-mixin.js
var NoteMixin = {
  createNote: function() {
    const options = this.options.notes;
    const text = this.noteText || options.label.text;
    if (options.visible !== false && defined(text) && text !== null) {
      this.note = new note_default({
        value: this.value,
        text,
        dataItem: this.dataItem,
        category: this.category,
        series: this.series
      }, this.options.notes, this.owner.chartService);
      this.append(this.note);
    }
  }
};
var note_mixin_default = NoteMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/accessibility-attributes-mixin.js
var AccessibilityAttributesMixin = {
  addAccessibilityAttributesToVisual: function() {
    this._id = this._id || guid();
    const accessibilityOptions = deepExtend({
      ariaLabel: this.getAriaLabelText()
    }, this.options.accessibility);
    addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
  },
  getAriaLabelText() {
    const labels = this.options.labels;
    const ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  },
  focusVisual() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
  },
  clearFocusFromVisual() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
  }
};
var accessibility_attributes_mixin_default = AccessibilityAttributesMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar.js
var BAR_ALIGN_MIN_WIDTH = 6;
var Bar = class extends chart_element_default {
  constructor(value2, options) {
    super();
    this.options = options;
    this.color = options.color || WHITE;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.value = value2;
  }
  render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    return new bar_label_default(
      this.getLabelText(options),
      deepExtend(
        {
          vertical: this.options.vertical
        },
        options
      ),
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  reflow(targetBox) {
    this.render();
    const label = this.label;
    this.box = targetBox;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    if (this.errorBars) {
      for (let i = 0; i < this.errorBars.length; i++) {
        this.errorBars[i].reflow(targetBox);
      }
    }
  }
  createVisual() {
    const { box, options } = this;
    const customVisual = options.visual;
    if (this.visible !== false) {
      super.createVisual();
      this.addAccessibilityAttributesToVisual();
      if (customVisual) {
        const visual = this.rectVisual = customVisual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          sender: this.getSender(),
          series: this.series,
          percentage: this.percentage,
          stackValue: this.stackValue,
          runningTotal: this.runningTotal,
          total: this.total,
          rect: box.toRect(),
          createVisual: () => {
            const group = new drawing_exports.Group();
            this.createRect(group);
            return group;
          },
          options
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else if (box.width() > 0 && box.height() > 0) {
        this.createRect(this.visual);
      }
    }
  }
  createRect(visual) {
    const options = this.options;
    const border = options.border;
    const strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;
    const rect = this.box.toRect();
    rect.size.width = Math.round(rect.size.width);
    const path = this.rectVisual = drawing_exports.Path.fromRect(rect, {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: {
        color: this.getBorderColor(),
        width: border.width,
        opacity: strokeOpacity,
        dashType: border.dashType
      }
    });
    const width = this.box.width();
    const height = this.box.height();
    const size = options.vertical ? width : height;
    if (size > BAR_ALIGN_MIN_WIDTH) {
      alignPathToPixel(path);
      if (width < 1 || height < 1) {
        path.options.stroke.lineJoin = "round";
      }
    }
    visual.append(path);
    if (hasGradientOverlay(options)) {
      const overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay));
      visual.append(overlay);
    }
  }
  createHighlight(style) {
    const highlight = drawing_exports.Path.fromRect(this.box.toRect(), style);
    return alignPathToPixel(highlight);
  }
  highlightVisual() {
    return this.rectVisual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  }
  createFocusHighlight(style) {
    const borderWidth = this.options.focusHighlight.border.width;
    const highlight = drawing_exports.Path.fromRect(this.box.pad(borderWidth / 2).toRect(), style);
    return alignPathToPixel(highlight);
  }
  getBorderColor() {
    const color = this.color;
    const border = this.options.border;
    const brightness = border._brightness || BORDER_BRIGHTNESS;
    let borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(color).brightness(brightness).toHex();
    }
    return borderColor;
  }
  tooltipAnchor() {
    const { options, box, aboveAxis } = this;
    const clipBox = this.owner.pane.clipBox() || box;
    let horizontalAlign = LEFT;
    let verticalAlign = TOP;
    let x, y;
    if (options.vertical) {
      x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;
      if (aboveAxis) {
        y = Math.max(box.y1, clipBox.y1);
      } else {
        y = Math.min(box.y2, clipBox.y2);
        verticalAlign = BOTTOM;
      }
    } else {
      const x1 = Math.max(box.x1, clipBox.x1);
      const x2 = Math.min(box.x2, clipBox.x2);
      if (options.isStacked) {
        verticalAlign = BOTTOM;
        if (aboveAxis) {
          horizontalAlign = RIGHT;
          x = x2;
        } else {
          x = x1;
        }
        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;
      } else {
        if (aboveAxis) {
          x = x2 + TOOLTIP_OFFSET;
        } else {
          x = x1 - TOOLTIP_OFFSET;
          horizontalAlign = RIGHT;
        }
        y = Math.max(box.y1, clipBox.y1);
      }
    }
    return {
      point: new point_default(x, y),
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      runningTotal: this.runningTotal,
      total: this.total,
      series: this.series
    };
  }
  getIndex() {
    return this.categoryIx;
  }
};
deepExtend(Bar.prototype, point_events_mixin_default);
deepExtend(Bar.prototype, note_mixin_default);
deepExtend(Bar.prototype, accessibility_attributes_mixin_default);
Bar.prototype.defaults = {
  border: {
    width: 1
  },
  vertical: true,
  overlay: {
    gradient: "glass"
  },
  labels: {
    visible: false,
    format: "{0}"
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var bar_default = Bar;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-range-calculator.js
var STD_ERR = "stderr";
var STD_DEV = "stddev";
var percentRegex = /percent(?:\w*)\((\d+)\)/;
var standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\((\\d+(?:\\.\\d+)?)\\))?$");
var ErrorRangeCalculator = class extends class_default {
  constructor(errorValue, series, field) {
    super();
    this.initGlobalRanges(errorValue, series, field);
  }
  initGlobalRanges(errorValue, series, field) {
    const data = series.data;
    const deviationMatch = standardDeviationRegex.exec(errorValue);
    if (deviationMatch) {
      this.valueGetter = this.createValueGetter(series, field);
      const average = this.getAverage(data);
      const deviation = this.getStandardDeviation(data, average, false);
      const multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;
      const errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };
      this.globalRange = function() {
        return errorRange;
      };
    } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {
      this.valueGetter = this.createValueGetter(series, field);
      const standardError = this.getStandardError(data, this.getAverage(data));
      this.globalRange = function(value2) {
        return { low: value2 - standardError, high: value2 + standardError };
      };
    }
  }
  createValueGetter(series, field) {
    const data = series.data;
    const binder = series_binder_default.current;
    const valueFields = binder.valueFields(series);
    const item = defined(data[0]) ? data[0] : {};
    let valueGetter10;
    if (isArray(item)) {
      const index = field ? valueFields.indexOf(field) : 0;
      valueGetter10 = getter("[" + index + "]");
    } else if (isNumber(item)) {
      valueGetter10 = getter();
    } else if (typeof item === OBJECT2) {
      const srcValueFields = binder.sourceFields(series, valueFields);
      valueGetter10 = getter(srcValueFields[valueFields.indexOf(field)]);
    }
    return valueGetter10;
  }
  getErrorRange(pointValue, errorValue) {
    let low, high, value2;
    if (!defined(errorValue)) {
      return null;
    }
    if (this.globalRange) {
      return this.globalRange(pointValue);
    }
    if (isArray(errorValue)) {
      low = pointValue - errorValue[0];
      high = pointValue + errorValue[1];
    } else if (isNumber(value2 = parseFloat(errorValue))) {
      low = pointValue - value2;
      high = pointValue + value2;
    } else if (value2 = percentRegex.exec(errorValue)) {
      const percentValue = pointValue * (parseFloat(value2[1]) / 100);
      low = pointValue - Math.abs(percentValue);
      high = pointValue + Math.abs(percentValue);
    } else {
      throw new Error("Invalid ErrorBar value: " + errorValue);
    }
    return { low, high };
  }
  getStandardError(data, average) {
    return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);
  }
  getStandardDeviation(data, average, isSample) {
    const length = data.length;
    const total = isSample ? average.count - 1 : average.count;
    let squareDifferenceSum = 0;
    for (let idx = 0; idx < length; idx++) {
      const value2 = this.valueGetter(data[idx]);
      if (isNumber(value2)) {
        squareDifferenceSum += Math.pow(value2 - average.value, 2);
      }
    }
    return Math.sqrt(squareDifferenceSum / total);
  }
  getAverage(data) {
    const length = data.length;
    let sum2 = 0;
    let count = 0;
    for (let idx = 0; idx < length; idx++) {
      const value2 = this.valueGetter(data[idx]);
      if (isNumber(value2)) {
        sum2 += value2;
        count++;
      }
    }
    return {
      value: sum2 / count,
      count
    };
  }
};
var error_range_calculator_default = ErrorRangeCalculator;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-bar-base.js
var DEFAULT_ERROR_BAR_WIDTH = 4;
var ErrorBarBase = class extends chart_element_default {
  constructor(low, high, isVertical, chart, series, options) {
    super(options);
    this.low = low;
    this.high = high;
    this.isVertical = isVertical;
    this.chart = chart;
    this.series = series;
  }
  reflow(targetBox) {
    const endCaps = this.options.endCaps;
    const isVertical = this.isVertical;
    const axis = this.getAxis();
    const valueBox = axis.getSlot(this.low, this.high);
    const centerBox = targetBox.center();
    const capsWidth = this.getCapsWidth(targetBox, isVertical);
    const capValue = isVertical ? centerBox.x : centerBox.y;
    const capStart = capValue - capsWidth;
    const capEnd = capValue + capsWidth;
    let linePoints;
    if (isVertical) {
      linePoints = [
        new point_default(centerBox.x, valueBox.y1),
        new point_default(centerBox.x, valueBox.y2)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default(capStart, valueBox.y1),
          new point_default(capEnd, valueBox.y1),
          new point_default(capStart, valueBox.y2),
          new point_default(capEnd, valueBox.y2)
        );
      }
      this.box = new box_default(capStart, valueBox.y1, capEnd, valueBox.y2);
    } else {
      linePoints = [
        new point_default(valueBox.x1, centerBox.y),
        new point_default(valueBox.x2, centerBox.y)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default(valueBox.x1, capStart),
          new point_default(valueBox.x1, capEnd),
          new point_default(valueBox.x2, capStart),
          new point_default(valueBox.x2, capEnd)
        );
      }
      this.box = new box_default(valueBox.x1, capStart, valueBox.x2, capEnd);
    }
    this.linePoints = linePoints;
  }
  getCapsWidth(box, isVertical) {
    const boxSize = isVertical ? box.width() : box.height();
    const capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;
    return capsWidth;
  }
  createVisual() {
    const options = this.options;
    const visual = options.visual;
    if (visual) {
      this.visual = visual({
        low: this.low,
        high: this.high,
        rect: this.box.toRect(),
        sender: this.getSender(),
        options: {
          endCaps: options.endCaps,
          color: options.color,
          line: options.line
        },
        createVisual: () => {
          this.createDefaultVisual();
          const defaultVisual = this.visual;
          delete this.visual;
          return defaultVisual;
        }
      });
    } else {
      this.createDefaultVisual();
    }
  }
  createDefaultVisual() {
    const { options, linePoints } = this;
    const lineOptions = {
      stroke: {
        color: options.color,
        width: options.line.width,
        dashType: options.line.dashType
      }
    };
    super.createVisual();
    for (let idx = 0; idx < linePoints.length; idx += 2) {
      const line = new drawing_exports.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);
      alignPathToPixel(line);
      this.visual.append(line);
    }
  }
};
setDefaultOptions(ErrorBarBase, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  endCaps: true,
  line: {
    width: 2
  },
  zIndex: 1
});
var error_bar_base_default = ErrorBarBase;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/categorical-error-bar.js
var CategoricalErrorBar = class extends error_bar_base_default {
  getAxis() {
    const axis = this.chart.seriesValueAxis(this.series);
    return axis;
  }
};
var categorical_error_bar_default = CategoricalErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js
var CategoricalChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);
    this.valueAxisRanges = {};
    this.points = [];
    this.categoryPoints = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
    this.render();
  }
  render() {
    this.traverseDataPoints(this.addValue.bind(this));
  }
  pointOptions(series, seriesIx) {
    let options = this.seriesOptions[seriesIx];
    if (!options) {
      const defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        vertical: !this.options.invertAxes
      }, series);
    }
    return options;
  }
  plotValue(point) {
    if (!point) {
      return 0;
    }
    if (this.options.isStacked100 && isNumber(point.value)) {
      const categoryIx = point.categoryIx;
      const categoryPoints = this.categoryPoints[categoryIx];
      const otherValues = [];
      let categorySum = 0;
      for (let i = 0; i < categoryPoints.length; i++) {
        const other = categoryPoints[i];
        if (other) {
          const stack = point.series.stack;
          const otherStack = other.series.stack;
          if (stack && otherStack && stack.group !== otherStack.group) {
            continue;
          }
          if (isNumber(other.value)) {
            categorySum += Math.abs(other.value);
            otherValues.push(Math.abs(other.value));
          }
        }
      }
      if (categorySum > 0) {
        return point.value / categorySum;
      }
    }
    return point.value;
  }
  plotRange(point, startValue = 0) {
    const categoryPoints = this.categoryPoints[point.categoryIx];
    if (this.options.isStacked) {
      let plotValue = this.plotValue(point);
      const positive = plotValue >= 0;
      let prevValue = startValue;
      let isStackedBar = false;
      const stack = defined(point.series.stack) ? point.series.stack : this.options.defaultStack;
      const isNonGroupStack = (stack2) => stack2 === true || typeof stack2 === OBJECT2 && !stack2.group;
      if (stack) {
        for (let i = 0; i < categoryPoints.length; i++) {
          const other = categoryPoints[i];
          if (point === other) {
            break;
          }
          const otherStack = defined(other.series.stack) ? other.series.stack : this.options.defaultStack;
          if (!otherStack) {
            continue;
          }
          if (typeof stack === STRING && stack !== otherStack) {
            continue;
          }
          if (isNonGroupStack(stack) && !isNonGroupStack(otherStack)) {
            continue;
          }
          if (stack.group && stack.group !== otherStack.group) {
            continue;
          }
          const otherValue = this.plotValue(other);
          if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
            if (startValue === 0 || otherValue !== 0) {
              prevValue += otherValue;
              plotValue += otherValue;
              isStackedBar = true;
              if (this.options.isStacked100) {
                plotValue = Math.min(plotValue, 1);
              }
            }
          }
        }
      }
      if (isStackedBar) {
        prevValue -= startValue;
      }
      return [prevValue, plotValue];
    }
    const series = point.series;
    const valueAxis = this.seriesValueAxis(series);
    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];
  }
  stackLimits(axisName, stackName) {
    let min4 = MAX_VALUE;
    let max3 = MIN_VALUE;
    for (let i = 0; i < this.categoryPoints.length; i++) {
      const categoryPoints = this.categoryPoints[i];
      if (!categoryPoints) {
        continue;
      }
      for (let pIx = 0; pIx < categoryPoints.length; pIx++) {
        const point = categoryPoints[pIx];
        if (point) {
          if (point.series.stack === stackName || point.series.axis === axisName) {
            const to = this.plotRange(point, 0)[1];
            if (defined(to) && isFinite(to)) {
              max3 = Math.max(max3, to);
              min4 = Math.min(min4, to);
            }
          }
        }
      }
    }
    return { min: min4, max: max3 };
  }
  updateStackRange() {
    const { isStacked, series: chartSeries } = this.options;
    const limitsCache = {};
    if (isStacked) {
      for (let i = 0; i < chartSeries.length; i++) {
        const series = chartSeries[i];
        const axisName = series.axis;
        const key = axisName + series.stack;
        let limits = limitsCache[key];
        if (!limits) {
          limits = this.stackLimits(axisName, series.stack);
          const errorTotals = this.errorTotals;
          if (errorTotals) {
            if (errorTotals.negative.length) {
              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);
            }
            if (errorTotals.positive.length) {
              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);
            }
          }
          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {
            limitsCache[key] = limits;
          } else {
            limits = null;
          }
        }
        if (limits) {
          this.valueAxisRanges[axisName] = limits;
        }
      }
    }
  }
  addErrorBar(point, data, categoryIx) {
    const { value: value2, series, seriesIx } = point;
    const errorBars = point.options.errorBars;
    const lowValue = data.fields[ERROR_LOW_FIELD];
    const highValue = data.fields[ERROR_HIGH_FIELD];
    let errorRange;
    if (isNumber(lowValue) && isNumber(highValue)) {
      errorRange = { low: lowValue, high: highValue };
    } else if (errorBars && defined(errorBars.value)) {
      this.seriesErrorRanges = this.seriesErrorRanges || [];
      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new error_range_calculator_default(errorBars.value, series, VALUE);
      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value2, errorBars.value);
    }
    if (errorRange) {
      point.low = errorRange.low;
      point.high = errorRange.high;
      this.addPointErrorBar(point, categoryIx);
    }
  }
  addPointErrorBar(point, categoryIx) {
    const isVertical = !this.options.invertAxes;
    const options = point.options.errorBars;
    let { series, low, high } = point;
    if (this.options.isStacked) {
      const stackedErrorRange = this.stackedErrorRange(point, categoryIx);
      low = stackedErrorRange.low;
      high = stackedErrorRange.high;
    } else {
      const fields = { categoryIx, series };
      this.updateRange({ value: low }, fields);
      this.updateRange({ value: high }, fields);
    }
    const errorBar = new categorical_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars = [errorBar];
    point.append(errorBar);
  }
  stackedErrorRange(point, categoryIx) {
    const plotValue = this.plotRange(point, 0)[1] - point.value;
    const low = point.low + plotValue;
    const high = point.high + plotValue;
    this.errorTotals = this.errorTotals || { positive: [], negative: [] };
    if (low < 0) {
      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
    }
    if (high > 0) {
      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
    }
    return { low, high };
  }
  addValue(data, fields) {
    const { categoryIx, series, seriesIx } = fields;
    let categoryPoints = this.categoryPoints[categoryIx];
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    let seriesPoints = this.seriesPoints[seriesIx];
    if (!seriesPoints) {
      this.seriesPoints[seriesIx] = seriesPoints = [];
    }
    const point = this.createPoint(data, fields);
    if (point) {
      Object.assign(point, fields);
      point.owner = this;
      point.noteText = data.fields.noteText;
      if (!defined(point.dataItem)) {
        point.dataItem = series.data[categoryIx];
      }
      this.addErrorBar(point, data, categoryIx);
    }
    this.points.push(point);
    seriesPoints.push(point);
    categoryPoints.push(point);
    this.updateRange(data.valueFields, fields);
  }
  evalPointOptions(options, value2, fields) {
    const categoryIx = fields.categoryIx;
    const category = fields.category;
    const series = fields.series;
    const seriesIx = fields.seriesIx;
    const state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "aggregate",
        "_events",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    let doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    let pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, pointOptions);
      evalOptions(pointOptions, {
        value: value2,
        category,
        index: categoryIx,
        series,
        dataItem: series.data[categoryIx]
      }, state);
    }
    return pointOptions;
  }
  updateRange(data, fields) {
    const axisName = fields.series.axis;
    const value2 = data.value;
    let axisRange = this.valueAxisRanges[axisName];
    if (isFinite(value2) && value2 !== null) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, value2);
      axisRange.max = Math.max(axisRange.max, value2);
    }
  }
  seriesValueAxis(series) {
    const plotArea = this.plotArea;
    const axisName = series.axis;
    const axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;
    if (!axis) {
      throw new Error("Unable to locate value axis with name " + axisName);
    }
    return axis;
  }
  reflow(targetBox) {
    const categorySlots = this.categorySlots = [];
    const chartPoints = this.points;
    const categoryAxis = this.categoryAxis;
    let pointIx = 0;
    this.traverseDataPoints((data, fields) => {
      const { categoryIx, series: currentSeries } = fields;
      const valueAxis = this.seriesValueAxis(currentSeries);
      const point = chartPoints[pointIx++];
      let categorySlot = categorySlots[categoryIx];
      if (!categorySlot) {
        categorySlots[categoryIx] = categorySlot = this.categorySlot(categoryAxis, categoryIx, valueAxis);
      }
      if (point) {
        const plotRange = this.plotRange(point, valueAxis.startValue());
        const valueSlot = this.valueSlot(valueAxis, plotRange);
        if (valueSlot) {
          const pointSlot = this.pointSlot(categorySlot, valueSlot);
          point.aboveAxis = this.aboveAxis(point, valueAxis);
          point.stackValue = plotRange[1];
          if (this.options.isStacked100) {
            point.percentage = this.plotValue(point);
          }
          this.reflowPoint(point, pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.reflowCategories(categorySlots);
    if (!this.options.clip && this.options.limitPoints && this.points.length) {
      this.limitPoints();
    }
    this.box = targetBox;
  }
  valueSlot(valueAxis, plotRange) {
    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);
  }
  limitPoints() {
    const categoryPoints = this.categoryPoints;
    const points = categoryPoints[0].concat(last(categoryPoints));
    for (let idx = 0; idx < points.length; idx++) {
      if (points[idx]) {
        this.limitPoint(points[idx]);
      }
    }
  }
  limitPoint(point) {
    const limitedSlot = this.categoryAxis.limitSlot(point.box);
    if (!limitedSlot.equals(point.box)) {
      point.reflow(limitedSlot);
    }
  }
  aboveAxis(point, valueAxis) {
    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    const value2 = point.value;
    return valueAxis.options.reverse ? value2 < axisCrossingValue : value2 >= axisCrossingValue;
  }
  categoryAxisCrossingValue(valueAxis) {
    const categoryAxis = this.categoryAxis;
    const options = valueAxis.options;
    const crossingValues = [].concat(
      options.axisCrossingValues || options.axisCrossingValue
    );
    return crossingValues[categoryAxis.axisIndex || 0] || 0;
  }
  reflowPoint(point, pointSlot) {
    point.reflow(pointSlot);
  }
  reflowCategories() {
  }
  pointSlot(categorySlot, valueSlot) {
    const options = this.options;
    const invertAxes = options.invertAxes;
    const slotX = invertAxes ? valueSlot : categorySlot;
    const slotY = invertAxes ? categorySlot : valueSlot;
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  }
  categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  }
  traverseDataPoints(callback) {
    const series = this.options.series;
    const count = categoriesCount(series);
    const seriesCount = series.length;
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
    }
    for (let categoryIx = 0; categoryIx < count; categoryIx++) {
      for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
        const currentSeries = series[seriesIx];
        const currentCategory = this.categoryAxis.categoryAt(categoryIx);
        const pointData = this.plotArea.bindPoint(currentSeries, categoryIx);
        callback(pointData, {
          category: currentCategory,
          categoryIx,
          categoriesCount: count,
          series: currentSeries,
          seriesIx
        });
      }
    }
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this._outOfRangeCallback(series[seriesIx], "_outOfRangeMaxPoint", seriesIx, callback);
    }
  }
  _outOfRangeCallback(series, field, seriesIx, callback) {
    const outOfRangePoint = series[field];
    if (outOfRangePoint) {
      const categoryIx = outOfRangePoint.categoryIx;
      const pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);
      callback(pointData, {
        category: outOfRangePoint.category,
        categoryIx,
        series,
        seriesIx,
        dataItem: outOfRangePoint.item
      });
    }
  }
  formatPointValue(point, format) {
    if (point.value === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value);
  }
  pointValue(data) {
    return data.valueFields.value;
  }
};
setDefaultOptions(CategoricalChart, {
  series: [],
  invertAxes: false,
  isStacked: false,
  clip: true,
  limitPoints: true
});
var categorical_chart_default = CategoricalChart;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/utils.js
function forEach(elements, callback) {
  elements.forEach(callback);
}
function forEachReverse(elements, callback) {
  const length = elements.length;
  for (let idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx - length - 1);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/layout/cluster-layout.js
var ClusterLayout = class extends chart_element_default {
  constructor(options) {
    super(options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  reflow(box) {
    const { vertical, gap, spacing } = this.options;
    const children = this.children;
    const count = children.length;
    const axis = vertical ? Y : X;
    const slots = count + gap + spacing * (count - 1);
    const slotSize = (vertical ? box.height() : box.width()) / slots;
    let position = box[axis + 1] + slotSize * (gap / 2);
    this.forEach(children, (child, idx) => {
      const childBox = (child.box || box).clone();
      childBox[axis + 1] = position;
      childBox[axis + 2] = position + slotSize;
      child.reflow(childBox);
      if (idx < count - 1) {
        position += slotSize * spacing;
      }
      position += slotSize;
    });
  }
};
setDefaultOptions(ClusterLayout, {
  vertical: false,
  gap: 0,
  spacing: 0
});
var cluster_layout_default = ClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/stack-wrap.js
var StackWrap = class extends chart_element_default {
  reflow(targetBox) {
    const positionAxis = this.options.vertical ? X : Y;
    const children = this.children;
    const childrenCount = children.length;
    let box = this.box = new box_default();
    for (let i = 0; i < childrenCount; i++) {
      const currentChild = children[i];
      if (currentChild.visible !== false) {
        const childBox = currentChild.box.clone();
        childBox.snapTo(targetBox, positionAxis);
        if (i === 0) {
          box = this.box = childBox.clone();
        }
        currentChild.reflow(childBox);
        box.wrap(childBox);
      }
    }
  }
};
setDefaultOptions(StackWrap, {
  vertical: true
});
var stack_wrap_default = StackWrap;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-chart.js
var BarChart = class extends categorical_chart_default {
  render() {
    super.render();
    this.updateStackRange();
  }
  pointType() {
    return bar_default;
  }
  clusterType() {
    return cluster_layout_default;
  }
  stackType() {
    return stack_wrap_default;
  }
  stackLimits(axisName, stackName) {
    const limits = super.stackLimits(axisName, stackName);
    return limits;
  }
  createPoint(data, fields) {
    const { categoryIx, series, seriesIx } = fields;
    const { options, children } = this;
    const stackOrDefault = defined(series.stack) ? series.stack : options.defaultStack;
    const value2 = this.pointValue(data);
    let pointOptions = this.pointOptions(series, seriesIx);
    const labelOptions = pointOptions.labels;
    if (stackOrDefault) {
      if (labelOptions.position === OUTSIDE_END) {
        labelOptions.position = INSIDE_END;
      }
    }
    pointOptions.isStacked = stackOrDefault;
    let color = data.fields.color || series.color;
    if (value2 < 0 && pointOptions.negativeColor) {
      color = pointOptions.negativeColor;
    }
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const pointType = this.pointType();
    const point = new pointType(value2, pointOptions);
    point.color = color;
    let cluster = children[categoryIx];
    if (!cluster) {
      const clusterType = this.clusterType();
      cluster = new clusterType({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (options.isStacked) {
      const stackWrap = this.getStackWrap(stackOrDefault, cluster);
      stackWrap.append(point);
    } else {
      cluster.append(point);
    }
    return point;
  }
  getStackWrap(stack, cluster) {
    const stackGroup = typeof stack === OBJECT2 ? stack.group || true : stack;
    const wraps = cluster.children;
    let stackWrap;
    if (typeof stackGroup === STRING || stackGroup === true) {
      for (let i = 0; i < wraps.length; i++) {
        if (wraps[i]._stackGroup === stackGroup) {
          stackWrap = wraps[i];
          break;
        }
      }
    }
    if (!stackWrap) {
      const stackType = this.stackType();
      stackWrap = new stackType({
        vertical: !this.options.invertAxes
      });
      stackWrap._stackGroup = stackGroup;
      cluster.append(stackWrap);
    }
    return stackWrap;
  }
  categorySlot(categoryAxis, categoryIx, valueAxis) {
    const options = this.options;
    const categorySlot = categoryAxis.getSlot(categoryIx);
    const startValue = valueAxis.startValue();
    if (options.isStacked) {
      const zeroSlot = valueAxis.getSlot(startValue, startValue, true);
      const stackAxis = options.invertAxes ? X : Y;
      categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];
    }
    return categorySlot;
  }
  reflowCategories(categorySlots) {
    const children = this.children;
    const childrenLength = children.length;
    for (let i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  }
  createAnimation() {
    this._setAnimationOptions();
    super.createAnimation();
    if (anyHasZIndex(this.options.series)) {
      this._setChildrenAnimation();
    }
  }
  _setChildrenAnimation() {
    const points = this.points;
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      const pointVisual = point.visual;
      if (pointVisual && defined(pointVisual.options.zIndex)) {
        point.options.animation = this.options.animation;
        point.createAnimation();
      }
    }
  }
  _setAnimationOptions() {
    const options = this.options;
    const animation = options.animation || {};
    let origin;
    if (options.isStacked) {
      const valueAxis = this.seriesValueAxis(options.series[0]);
      origin = valueAxis.getSlot(valueAxis.startValue());
    } else {
      origin = this.categoryAxis.getSlot(0);
    }
    animation.origin = new geometry_exports.Point(origin.x1, origin.y1);
    animation.vertical = !options.invertAxes;
  }
};
setDefaultOptions(BarChart, {
  animation: {
    type: BAR
  }
});
var bar_chart_default = BarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar.js
var RangeBar = class extends bar_default {
  createLabel() {
    const labels = this.options.labels;
    const fromOptions = deepExtend({}, labels, labels.from);
    const toOptions = deepExtend({}, labels, labels.to);
    if (fromOptions.visible) {
      this.labelFrom = this.createLabelElement(fromOptions);
      this.append(this.labelFrom);
    }
    if (toOptions.visible) {
      this.labelTo = this.createLabelElement(toOptions);
      this.append(this.labelTo);
    }
  }
  reflow(targetBox) {
    this.render();
    const { labelFrom, labelTo, value: value2 } = this;
    this.box = targetBox;
    if (labelFrom) {
      labelFrom.options.aboveAxis = value2.from > value2.to;
      labelFrom.reflow(targetBox);
    }
    if (labelTo) {
      labelTo.options.aboveAxis = value2.to > value2.from;
      labelTo.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
  }
};
RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {
  labels: {
    format: "{0} - {1}"
  },
  tooltip: {
    format: "{1}"
  }
});
var range_bar_default = RangeBar;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar-chart.js
var RangeBarChart = class extends bar_chart_default {
  pointType() {
    return range_bar_default;
  }
  pointValue(data) {
    return data.valueFields;
  }
  formatPointValue(point, format) {
    if (point.value.from === null && point.value.to === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value.from, point.value.to);
  }
  plotRange(point) {
    if (!point) {
      return 0;
    }
    return [point.value.from, point.value.to];
  }
  updateRange(value2, fields) {
    const axisName = fields.series.axis;
    const { from, to } = value2;
    let axisRange = this.valueAxisRanges[axisName];
    if (value2 !== null && isNumber(from) && isNumber(to)) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, from);
      axisRange.max = Math.max(axisRange.max, from);
      axisRange.min = Math.min(axisRange.min, to);
      axisRange.max = Math.max(axisRange.max, to);
    }
  }
  aboveAxis(point) {
    const value2 = point.value;
    return value2.from < value2.to;
  }
};
RangeBarChart.prototype.plotLimits = categorical_chart_default.prototype.plotLimits;
var range_bar_chart_default = RangeBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/target.js
var Target = class extends shape_element_default {
};
deepExtend(Target.prototype, point_events_mixin_default);
var target_default = Target;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet.js
var Bullet = class extends chart_element_default {
  constructor(value2, options) {
    super(options);
    this.aboveAxis = this.options.aboveAxis;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  render() {
    const options = this.options;
    if (!this._rendered) {
      this._rendered = true;
      if (defined(this.value.target)) {
        this.target = new target_default({
          type: options.target.shape,
          background: options.target.color || this.color,
          opacity: options.opacity,
          zIndex: options.zIndex,
          border: options.target.border,
          vAlign: TOP,
          align: RIGHT
        });
        this.target.value = this.value;
        this.target.dataItem = this.dataItem;
        this.target.series = this.series;
        this.append(this.target);
      }
      this.createLabel();
      this.createNote();
    }
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    return new bar_label_default(
      this.getLabelText(options),
      options,
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  }
  reflow(box) {
    this.render();
    const { options, target, owner: chart } = this;
    const invertAxes = options.invertAxes;
    const valueAxis = chart.seriesValueAxis(this.options);
    const categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);
    const targetValueSlot = valueAxis.getSlot(this.value.target);
    const targetSlotX = invertAxes ? targetValueSlot : categorySlot;
    const targetSlotY = invertAxes ? categorySlot : targetValueSlot;
    if (target) {
      const targetSlot = new box_default(
        targetSlotX.x1,
        targetSlotY.y1,
        targetSlotX.x2,
        targetSlotY.y2
      );
      target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;
      target.options.width = invertAxes ? options.target.line.width : targetSlot.width();
      target.reflow(targetSlot);
    }
    const label = this.label;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(box);
    }
    if (this.note) {
      this.note.reflow(box);
    }
    this.box = box;
  }
  createVisual() {
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    const options = this.options;
    const body = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: options.border.color || this.color,
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    this.bodyVisual = body;
    alignPathToPixel(body);
    this.visual.append(body);
  }
  createAnimation() {
    if (this.bodyVisual) {
      this.animation = drawing_exports.Animation.create(
        this.bodyVisual,
        this.options.animation
      );
    }
  }
  createHighlight(style) {
    return drawing_exports.Path.fromRect(this.box.toRect(), style);
  }
  highlightVisual() {
    return this.bodyVisual;
  }
  highlightVisualArgs() {
    return {
      rect: this.box.toRect(),
      visual: this.bodyVisual,
      options: this.options
    };
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series
    };
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  getIndex() {
    return this.categoryIx;
  }
};
Bullet.prototype.tooltipAnchor = bar_default.prototype.tooltipAnchor;
Bullet.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Bullet, {
  border: {
    width: 1
  },
  vertical: false,
  opacity: 1,
  target: {
    shape: "",
    border: {
      width: 0,
      color: "green"
    },
    line: {
      width: 2
    }
  },
  labels: {
    visible: false
  },
  tooltip: {
    format: "Current: {0}<br />Target: {1}"
  },
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Bullet.prototype, point_events_mixin_default);
deepExtend(Bullet.prototype, note_mixin_default);
deepExtend(Bullet.prototype, accessibility_attributes_mixin_default);
var bullet_default = Bullet;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet-chart.js
var BulletChart = class extends categorical_chart_default {
  constructor(plotArea, options) {
    wrapData(options);
    super(plotArea, options);
  }
  reflowCategories(categorySlots) {
    const children = this.children;
    const childrenLength = children.length;
    for (let i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  }
  plotRange(point) {
    const series = point.series;
    const valueAxis = this.seriesValueAxis(series);
    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, point.value.current || axisCrossingValue];
  }
  createPoint(data, fields) {
    const { categoryIx, series } = fields;
    const { options, children } = this;
    const value2 = data.valueFields;
    let bulletOptions = deepExtend({
      vertical: !options.invertAxes,
      overlay: series.overlay,
      categoryIx,
      invertAxes: options.invertAxes
    }, series);
    let color = data.fields.color || series.color;
    bulletOptions = this.evalPointOptions(bulletOptions, value2, fields);
    if (isFunction(series.color)) {
      color = bulletOptions.color;
    }
    const bullet = new bullet_default(value2, bulletOptions);
    bullet.color = color;
    let cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    cluster.append(bullet);
    return bullet;
  }
  updateRange(value2, fields) {
    const { current: current4, target } = value2;
    const axisName = fields.series.axis;
    let axisRange = this.valueAxisRanges[axisName];
    if (defined(current4) && !isNaN(current4) && defined(target && !isNaN(target))) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, current4, target);
      axisRange.max = Math.max(axisRange.max, current4, target);
    }
  }
  formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value.current, point.value.target);
  }
  pointValue(data) {
    return data.valueFields.current;
  }
  aboveAxis(point) {
    const value2 = point.value.current;
    return value2 > 0;
  }
  createAnimation() {
    const points = this.points;
    this._setAnimationOptions();
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      point.options.animation = this.options.animation;
      point.createAnimation();
    }
  }
};
BulletChart.prototype._setAnimationOptions = bar_chart_default.prototype._setAnimationOptions;
setDefaultOptions(BulletChart, {
  animation: {
    type: BAR
  }
});
function wrapData(options) {
  const series = options.series;
  for (let i = 0; i < series.length; i++) {
    const seriesItem = series[i];
    const data = seriesItem.data;
    if (data && !isArray(data[0]) && !isObject(data[0])) {
      seriesItem.data = [data];
    }
  }
}
var bullet_chart_default = BulletChart;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-point.js
var LinePoint = class extends chart_element_default {
  constructor(value2, options) {
    super();
    this.value = value2;
    this.options = options;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
  }
  render() {
    const { markers } = this.options;
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    if (markers.visible && markers.size) {
      this.marker = this.createMarker();
      this.append(this.marker);
    }
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    return new text_box_default(
      this.getLabelText(options),
      deepExtend({
        align: CENTER,
        vAlign: CENTER,
        margin: {
          left: 5,
          right: 5
        },
        zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
      }, options),
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  }
  getAriaLabelText() {
    const labels = this.options.labels;
    const ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  }
  markerBorder() {
    const options = this.options.markers;
    const background = options.background;
    const border = deepExtend({ color: this.color }, options.border);
    if (!defined(border.color)) {
      border.color = new color_default(background).brightness(BORDER_BRIGHTNESS).toHex();
    }
    return border;
  }
  createVisual() {
  }
  createMarker() {
    const options = this.options.markers;
    const marker = new shape_element_default({
      type: options.type,
      width: options.size,
      height: options.size,
      rotation: options.rotation,
      background: options.background,
      border: this.markerBorder(),
      opacity: options.opacity,
      pattern: this.options.pattern,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual,
      accessibilityOptions: deepExtend({
        ariaLabel: this.getAriaLabelText(this.options.labels)
      }, this.options.accessibility)
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    return marker;
  }
  markerBox() {
    if (!this.marker) {
      this.marker = this.createMarker();
      this.marker.reflow(this._childBox);
    }
    return this.marker.box;
  }
  reflow(targetBox) {
    const { options, aboveAxis } = this;
    const vertical = options.vertical;
    this.render();
    this.box = targetBox;
    const childBox = targetBox.clone();
    if (vertical) {
      if (aboveAxis) {
        childBox.y1 -= childBox.height();
      } else {
        childBox.y2 += childBox.height();
      }
    } else {
      if (aboveAxis) {
        childBox.x1 += childBox.width();
      } else {
        childBox.x2 -= childBox.width();
      }
    }
    this._childBox = childBox;
    if (this.marker) {
      this.marker.reflow(childBox);
    }
    this.reflowLabel(childBox);
    if (this.errorBars) {
      for (let i = 0; i < this.errorBars.length; i++) {
        this.errorBars[i].reflow(childBox);
      }
    }
    if (this.note) {
      let noteTargetBox = this.markerBox();
      if (!(options.markers.visible && options.markers.size)) {
        const center = noteTargetBox.center();
        noteTargetBox = new box_default(center.x, center.y, center.x, center.y);
      }
      this.note.reflow(noteTargetBox);
    }
  }
  reflowLabel(box) {
    const { options, label } = this;
    let anchor = options.labels.position;
    if (label) {
      anchor = anchor === ABOVE ? TOP : anchor;
      anchor = anchor === BELOW ? BOTTOM : anchor;
      label.reflow(box);
      label.box.alignTo(this.markerBox(), anchor);
      label.reflow(label.box);
    }
  }
  createHighlight() {
    const markers = this.options.highlight.markers;
    const defaultColor = this.markerBorder().color;
    const options = this.options.markers;
    const size = options.size + (options.border.width || 0) + (markers.border.width || 0);
    const shadow = new shape_element_default({
      type: options.type,
      width: size,
      height: size,
      rotation: options.rotation,
      background: markers.color || defaultColor,
      border: {
        color: markers.border.color,
        width: markers.border.width,
        opacity: valueOrDefault(markers.border.opacity, 1)
      },
      opacity: valueOrDefault(markers.opacity, 1)
    });
    shadow.reflow(this._childBox);
    return shadow.getElement();
  }
  highlightVisual() {
    return (this.marker || {}).visual;
  }
  highlightVisualArgs() {
    const marker = this.marker;
    let visual, rect;
    if (marker) {
      rect = marker.paddingBox.toRect();
      visual = marker.visual;
    } else {
      const size = this.options.markers.size;
      const halfSize = size / 2;
      const center = this.box.center();
      rect = new geometry_exports.Rect([center.x - halfSize, center.y - halfSize], [size, size]);
    }
    return {
      options: this.options,
      rect,
      visual
    };
  }
  createFocusHighlight() {
    const markerOptions = this.options.markers;
    const highlightOptions2 = this.options.focusHighlight;
    const size = markerOptions.size + (markerOptions.border.width || 0);
    const highlight = new shape_element_default({
      type: markerOptions.type,
      width: size,
      height: size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      opacity: highlightOptions2.opacity,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this._childBox);
    return highlight.getElement();
  }
  tooltipAnchor() {
    const markerBox = this.markerBox();
    const clipBox = this.owner.pane.clipBox();
    const showTooltip = !clipBox || clipBox.overlaps(markerBox);
    if (showTooltip) {
      const x = markerBox.x2 + TOOLTIP_OFFSET;
      const horizontalAlign = LEFT;
      let y, verticalAlign;
      if (this.aboveAxis) {
        y = markerBox.y1;
        verticalAlign = BOTTOM;
      } else {
        y = markerBox.y2;
        verticalAlign = TOP;
      }
      return {
        point: new point_default(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  overlapsBox(box) {
    const markerBox = this.markerBox();
    return markerBox.overlaps(box);
  }
  unclipElements() {
    if (this.label) {
      this.label.options.noclip = true;
    }
    if (this.note) {
      this.note.options.noclip = true;
    }
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      series: this.series
    };
  }
  focusVisual() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", this._id);
      }
      this.toggleFocusHighlight(true);
    }
  }
  clearFocusFromVisual() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", "");
      }
      this.toggleFocusHighlight(false);
    }
  }
  getIndex() {
    return defined(this.categoryIx) ? this.categoryIx : this.pointIx;
  }
};
LinePoint.prototype.defaults = {
  vertical: true,
  markers: {
    visible: true,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    position: ABOVE,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    }
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: "#fff",
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  errorBars: {
    line: {
      width: 1
    }
  },
  accessibility: {
    tabIndex: 0,
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
deepExtend(LinePoint.prototype, point_events_mixin_default);
deepExtend(LinePoint.prototype, note_mixin_default);
var line_point_default = LinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-segment.js
var LineSegment = class extends chart_element_default {
  constructor(linePoints, series, seriesIx) {
    super();
    this.linePoints = linePoints;
    this.series = series;
    this.seriesIx = seriesIx;
  }
  points() {
    return this.toGeometryPoints(this.linePoints);
  }
  toGeometryPoints(points) {
    const result = [];
    for (let i = 0, length = points.length; i < length; i++) {
      if (points[i] && points[i].visible !== false) {
        result.push(points[i]._childBox.toRect().center());
      }
    }
    return result;
  }
  createVisual() {
    const customVisual = this.series.visual;
    if (customVisual) {
      this.visual = customVisual({
        points: this.toGeometryPoints(this.linePoints),
        series: this.series,
        sender: this.getSender(),
        createVisual: () => {
          this.segmentVisual();
          return this.visual;
        }
      });
      if (this.visual && !defined(this.visual.options.zIndex)) {
        this.visual.options.zIndex = this.series.zIndex;
      }
    } else {
      this.segmentVisual();
    }
  }
  segmentVisual() {
    const { options, series } = this;
    let { color, _defaults: defaults } = series;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    const line = drawing_exports.Path.fromPoints(this.points(), {
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    if (options.closed) {
      line.close();
    }
    this.visual = line;
  }
  aliasFor(e, coords) {
    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);
  }
};
setDefaultOptions(LineSegment, {
  closed: false
});
var line_segment_default = LineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-mixin.js
var StepLineMixin = {
  calculateStepPoints: function(points) {
    const categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);
    const { justified, vertical, reverse } = categoryAxis.options;
    const stepAxis = vertical ? X : Y;
    const axis = vertical ? Y : X;
    const stepDir = reverse ? 2 : 1;
    const dir = stepDir;
    let previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);
    const result = [previousPoint];
    for (let idx = 1; idx < points.length; idx++) {
      const point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);
      if (previousPoint[stepAxis] !== point[stepAxis]) {
        const stepPoint = new geometry_exports.Point();
        stepPoint[stepAxis] = previousPoint[stepAxis];
        stepPoint[axis] = point[axis];
        result.push(stepPoint, point);
      }
      previousPoint = point;
    }
    if (!justified) {
      result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));
    } else if (previousPoint !== last(result)) {
      result.push(previousPoint);
    }
    return result;
  }
};
function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {
  const box = lintPoint.box;
  const result = new geometry_exports.Point();
  result[stepAxis] = box[stepAxis + stepDir];
  result[axis] = box[axis + dir];
  return result;
}
var step_line_mixin_default = StepLineMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-segment.js
var StepLineSegment = class extends line_segment_default {
  points() {
    return this.calculateStepPoints(this.linePoints);
  }
};
deepExtend(StepLineSegment.prototype, step_line_mixin_default);
var step_line_segment_default = StepLineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/spline-segment.js
var SplineSegment = class extends line_segment_default {
  segmentVisual() {
    const series = this.series;
    const defaults = series._defaults;
    let color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    const curveProcessor = new curve_processor_default(this.options.closed);
    const segments = curveProcessor.process(this.points());
    const curve = new drawing_exports.Path({
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    curve.segments.push.apply(curve.segments, segments);
    this.visual = curve;
  }
};
var spline_segment_default = SplineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/line-chart-mixin.js
var LineChartMixin = {
  renderSegments: function() {
    const { options, seriesPoints } = this;
    const series = options.series;
    const seriesCount = seriesPoints.length;
    let lastSegment;
    this._segments = [];
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      const currentSeries = series[seriesIx];
      const sortedPoints = this.sortPoints(seriesPoints[seriesIx]);
      const pointCount = sortedPoints.length;
      let linePoints = [];
      for (let pointIx = 0; pointIx < pointCount; pointIx++) {
        const point = sortedPoints[pointIx];
        if (point) {
          linePoints.push(point);
        } else if (this.seriesMissingValues(currentSeries) !== INTERPOLATE) {
          if (linePoints.length > 1) {
            lastSegment = this.createSegment(
              linePoints,
              currentSeries,
              seriesIx,
              lastSegment
            );
            this._addSegment(lastSegment);
          }
          linePoints = [];
        }
      }
      if (linePoints.length > 1) {
        lastSegment = this.createSegment(
          linePoints,
          currentSeries,
          seriesIx,
          lastSegment
        );
        this._addSegment(lastSegment);
      }
    }
    this.children.unshift.apply(this.children, this._segments);
  },
  _addSegment: function(segment) {
    this._segments.push(segment);
    segment.parent = this;
  },
  sortPoints: function(points) {
    return points;
  },
  seriesMissingValues: function(series) {
    const missingValues = series.missingValues;
    const assumeZero = !missingValues && this.options.isStacked;
    return assumeZero ? ZERO : missingValues || INTERPOLATE;
  },
  getNearestPoint: function(x, y, seriesIx) {
    const target = new point_default(x, y);
    const allPoints = this.seriesPoints[seriesIx];
    let nearestPointDistance = MAX_VALUE;
    let nearestPoint;
    for (let i = 0; i < allPoints.length; i++) {
      const point = allPoints[i];
      if (point && defined(point.value) && point.value !== null && point.visible !== false) {
        const pointBox = point.box;
        const pointDistance = pointBox.center().distanceTo(target);
        if (pointDistance < nearestPointDistance) {
          nearestPoint = point;
          nearestPointDistance = pointDistance;
        }
      }
    }
    return nearestPoint;
  }
};
var line_chart_mixin_default = LineChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/clip-animation.js
var ClipAnimation = class extends drawing_exports.Animation {
  setup() {
    this._setEnd(this.options.box.x1);
  }
  step(pos) {
    const box = this.options.box;
    this._setEnd(interpolateValue(box.x1, box.x2, pos));
  }
  _setEnd(x) {
    const element = this.element;
    const segments = element.segments;
    const topRight = segments[1].anchor();
    const bottomRight = segments[2].anchor();
    element.suspend();
    topRight.setX(x);
    element.resume();
    bottomRight.setX(x);
  }
};
setDefaultOptions(ClipAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register("clip", ClipAnimation);
var clip_animation_default = ClipAnimation;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/clip-animation-mixin.js
var ClipAnimationMixin = {
  createAnimation: function() {
    const root = this.getRoot();
    if (root && (root.options || {}).transitions !== false) {
      const box = root.size();
      const clipPath = drawing_exports.Path.fromRect(box.toRect());
      this.visual.clip(clipPath);
      this.animation = new clip_animation_default(clipPath, {
        box
      });
      if (anyHasZIndex(this.options.series)) {
        this._setChildrenAnimation(clipPath);
      }
    }
  },
  _setChildrenAnimation: function(clipPath) {
    const points = this.animationPoints();
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      if (point && point.visual && defined(point.visual.options.zIndex)) {
        point.visual.clip(clipPath);
      }
    }
  }
};
var clip_animation_mixin_default = ClipAnimationMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-chart.js
var LineChart = class extends categorical_chart_default {
  render() {
    super.render();
    this.updateStackRange();
    this.renderSegments();
  }
  pointType() {
    return line_point_default;
  }
  createPoint(data, fields) {
    const { series, seriesIx } = fields;
    const missingValues = this.seriesMissingValues(series);
    let value2 = data.valueFields.value;
    if (!defined(value2) || value2 === null) {
      if (missingValues === ZERO) {
        value2 = 0;
      } else {
        return null;
      }
    }
    let pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    let color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  plotRange(point) {
    let plotValue = this.plotValue(point);
    if (this.options.isStacked) {
      const categoryIx = point.categoryIx;
      const categoryPoints = this.categoryPoints[categoryIx];
      for (let i = 0; i < categoryPoints.length; i++) {
        const other = categoryPoints[i];
        if (point === other) {
          break;
        }
        plotValue += this.plotValue(other);
        if (this.options.isStacked100) {
          plotValue = Math.min(plotValue, 1);
        }
      }
    }
    return [plotValue, plotValue];
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = currentSeries.style;
    let pointType;
    if (style === STEP) {
      pointType = step_line_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result.concat(this._segments);
  }
  supportsPointInactiveOpacity() {
    return false;
  }
};
deepExtend(LineChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var line_chart_default = LineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-segment.js
var AreaSegment = class extends line_segment_default {
  constructor(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {
    super(linePoints, currentSeries, seriesIx);
    this.prevSegment = prevSegment;
    this.stackPoints = stackPoints;
  }
  createVisual() {
    const series = this.series;
    const defaults = series._defaults;
    const lineOptions = series.line || {};
    let color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    this.visual = new drawing_exports.Group({
      zIndex: series.zIndex
    });
    this.createFill({
      fill: createPatternFill(series.pattern, {
        color,
        opacity: series.opacity
      }),
      stroke: null
    });
    if (lineOptions.width > 0 && lineOptions.visible !== false) {
      this.createStroke({
        stroke: deepExtend({
          color,
          opacity: series.opacity,
          lineCap: "butt"
        }, lineOptions)
      });
    }
  }
  strokeSegments() {
    let segments = this._strokeSegments;
    if (!segments) {
      segments = this._strokeSegments = this.createStrokeSegments();
    }
    return segments;
  }
  createStrokeSegments() {
    return this.segmentsFromPoints(this.points());
  }
  stackSegments() {
    if (this.prevSegment) {
      return this.prevSegment.createStackSegments(this.stackPoints);
    }
    return this.createStackSegments(this.stackPoints);
  }
  createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();
  }
  segmentsFromPoints(points) {
    return points.map((point) => new geometry_exports.Segment(point));
  }
  createStroke(style) {
    const stroke = new drawing_exports.Path(style);
    stroke.segments.push.apply(stroke.segments, this.strokeSegments());
    this.visual.append(stroke);
  }
  hasStackSegment() {
    return this.prevSegment || this.stackPoints && this.stackPoints.length;
  }
  createFill(style) {
    const strokeSegments = this.strokeSegments();
    const fillSegments = strokeSegments.slice(0);
    const hasStackSegments = this.hasStackSegment();
    if (hasStackSegments) {
      const stackSegments = this.stackSegments();
      append(fillSegments, stackSegments);
    }
    const fill = new drawing_exports.Path(style);
    fill.segments.push.apply(fill.segments, fillSegments);
    if (!hasStackSegments && strokeSegments.length > 1) {
      this.fillToAxes(fill);
    }
    this.visual.append(fill);
  }
  fillToAxes(fillPath) {
    const chart = this.parent;
    const invertAxes = chart.options.invertAxes;
    const valueAxis = chart.seriesValueAxis(this.series);
    const crossingValue = chart.categoryAxisCrossingValue(valueAxis);
    const endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);
    const segments = this.strokeSegments();
    const firstPoint = segments[0].anchor();
    const lastPoint = last(segments).anchor();
    let end = invertAxes ? endSlot.x1 : endSlot.y1;
    if (invertAxes) {
      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);
    } else {
      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);
    }
  }
};
var area_segment_default = AreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/step-area-segment.js
var StepAreaSegment = class extends area_segment_default {
  createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));
  }
  createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();
  }
};
deepExtend(StepAreaSegment.prototype, step_line_mixin_default);
var step_area_segment_default = StepAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/spline-area-segment.js
var SplineAreaSegment = class extends area_segment_default {
  createStrokeSegments() {
    const curveProcessor = new curve_processor_default(this.options.closed);
    const linePoints = this.points();
    return curveProcessor.process(linePoints);
  }
  createStackSegments() {
    const strokeSegments = this.strokeSegments();
    const stackSegments = [];
    for (let idx = strokeSegments.length - 1; idx >= 0; idx--) {
      const segment = strokeSegments[idx];
      stackSegments.push(new geometry_exports.Segment(
        segment.anchor(),
        segment.controlOut(),
        segment.controlIn()
      ));
    }
    return stackSegments;
  }
};
var spline_area_segment_default = SplineAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js
var AreaChart = class extends line_chart_default {
  createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    const isStacked = this.options.isStacked;
    const style = (currentSeries.line || {}).style;
    let previousSegment;
    let stackPoints;
    if (isStacked && seriesIx > 0 && prevSegment) {
      const missingValues = this.seriesMissingValues(currentSeries);
      if (missingValues !== "gap") {
        stackPoints = prevSegment.linePoints;
        previousSegment = prevSegment;
      } else {
        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);
      }
    }
    let pointType;
    if (style === STEP) {
      pointType = step_area_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_area_segment_default;
    } else {
      pointType = area_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
  }
  reflow(targetBox) {
    super.reflow(targetBox);
    const stackPoints = this._stackPoints;
    if (stackPoints) {
      for (let idx = 0; idx < stackPoints.length; idx++) {
        const stackPoint = stackPoints[idx];
        const pointSlot = this.categoryAxis.getSlot(stackPoint.categoryIx);
        stackPoint.reflow(pointSlot);
      }
    }
  }
  _gapStackPoints(linePoints, seriesIx, style) {
    const seriesPoints = this.seriesPoints;
    let startIdx = linePoints[0].categoryIx;
    let length = linePoints.length;
    if (startIdx < 0) {
      startIdx = 0;
      length--;
    }
    const endIdx = startIdx + length;
    const pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;
    const stackPoints = [];
    this._stackPoints = this._stackPoints || [];
    for (let categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {
      const pointIx = categoryIx + pointOffset;
      let currentSeriesIx = seriesIx;
      let point;
      do {
        currentSeriesIx--;
        point = seriesPoints[currentSeriesIx][pointIx];
      } while (currentSeriesIx > 0 && !point);
      if (point) {
        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {
          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));
        }
        stackPoints.push(point);
        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {
          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));
        }
      } else {
        const gapStackPoint = this._createGapStackPoint(categoryIx);
        this._stackPoints.push(gapStackPoint);
        stackPoints.push(gapStackPoint);
      }
    }
    return stackPoints;
  }
  _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {
    const seriesPoints = this.seriesPoints;
    let index = seriesIdx;
    let point;
    while (index > 0 && !point) {
      index--;
      point = seriesPoints[index][segmentIx];
    }
    if (!point) {
      point = this._createGapStackPoint(categoryIx);
      this._stackPoints.push(point);
    } else {
      point = seriesPoints[index][pointIx];
    }
    return point;
  }
  _createGapStackPoint(categoryIx) {
    const options = this.pointOptions({}, 0);
    const point = new line_point_default(0, options);
    point.categoryIx = categoryIx;
    point.series = {};
    return point;
  }
  seriesMissingValues(series) {
    return series.missingValues || ZERO;
  }
  supportsPointInactiveOpacity() {
    return false;
  }
};
var area_chart_default = AreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-line-point.js
var RangeLinePoint = class extends line_point_default {
  aliasFor() {
    return this.parent;
  }
};
var range_line_point_default = RangeLinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-point.js
var AUTO2 = "auto";
var DEFAULT_FROM_FORMAT = "{0}";
var DEFAULT_TO_FORMAT = "{1}";
var RangeAreaPoint = class extends chart_element_default {
  constructor(value2, options) {
    super();
    this.value = value2;
    this.options = options;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
    this.initLabelsFormat();
  }
  render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    const { markers, labels } = this.options;
    const value2 = this.value;
    const fromPoint = this.fromPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.from,
      markers: markers.from
    }));
    const toPoint = this.toPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.to,
      markers: markers.to
    }));
    this.copyFields(fromPoint);
    this.copyFields(toPoint);
    this.append(fromPoint);
    this.append(toPoint);
  }
  reflow(targetBox) {
    this.render();
    const { from: fromBox, to: toBox } = targetBox;
    this.positionLabels(fromBox, toBox);
    this.fromPoint.reflow(fromBox);
    this.toPoint.reflow(toBox);
    this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());
  }
  createHighlight() {
    const group = new drawing_exports.Group();
    group.append(this.fromPoint.createHighlight());
    group.append(this.toPoint.createHighlight());
    return group;
  }
  highlightVisual() {
    return this.visual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      from: this.fromPoint.highlightVisualArgs(),
      to: this.toPoint.highlightVisualArgs()
    };
  }
  createFocusHighlight() {
    const group = new drawing_exports.Group();
    group.append(this.fromPoint.createFocusHighlight());
    group.append(this.toPoint.createFocusHighlight());
    return group;
  }
  tooltipAnchor() {
    const clipBox = this.owner.pane.clipBox();
    const showTooltip = !clipBox || clipBox.overlaps(this.box);
    if (showTooltip) {
      const box = this.box;
      const center = box.center();
      const horizontalAlign = LEFT;
      let x, y, verticalAlign;
      if (this.options.vertical) {
        x = center.x;
        y = box.y1 - TOOLTIP_OFFSET;
        verticalAlign = BOTTOM;
      } else {
        x = box.x2 + TOOLTIP_OFFSET;
        y = center.y;
        verticalAlign = CENTER;
      }
      return {
        point: new point_default(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  unclipElements() {
    this.fromPoint.unclipElements();
    this.toPoint.unclipElements();
  }
  initLabelsFormat() {
    const labels = this.options.labels;
    if (!labels.format) {
      if (!labels.from || !labels.from.format) {
        labels.from = Object.assign({}, labels.from, {
          format: DEFAULT_FROM_FORMAT
        });
      }
      if (!labels.to || !labels.to.format) {
        labels.to = Object.assign({}, labels.to, {
          format: DEFAULT_TO_FORMAT
        });
      }
    }
  }
  positionLabels(fromBox, toBox) {
    const { labels, vertical } = this.options;
    if (labels.position === AUTO2) {
      let fromLabelPosition, toLabelPosition;
      if (vertical) {
        if (toBox.y1 <= fromBox.y1) {
          toLabelPosition = ABOVE;
          fromLabelPosition = BELOW;
        } else {
          toLabelPosition = BELOW;
          fromLabelPosition = ABOVE;
        }
      } else {
        if (toBox.x1 <= fromBox.x1) {
          toLabelPosition = LEFT;
          fromLabelPosition = RIGHT;
        } else {
          toLabelPosition = RIGHT;
          fromLabelPosition = LEFT;
        }
      }
      if (!labels.from || !labels.from.position) {
        this.fromPoint.options.labels.position = fromLabelPosition;
      }
      if (!labels.to || !labels.to.position) {
        this.toPoint.options.labels.position = toLabelPosition;
      }
    }
  }
  copyFields(point) {
    point.dataItem = this.dataItem;
    point.category = this.category;
    point.series = this.series;
    point.color = this.color;
    point.owner = this.owner;
  }
  focusVisual() {
    this.fromPoint.focusVisual();
  }
  clearFocusFromVisual() {
    this.toPoint.clearFocusFromVisual();
  }
  getIndex() {
    return this.categoryIx;
  }
};
deepExtend(RangeAreaPoint.prototype, point_events_mixin_default);
deepExtend(RangeAreaPoint.prototype, note_mixin_default);
RangeAreaPoint.prototype.defaults = {
  markers: {
    visible: false,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    },
    position: AUTO2
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: WHITE,
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  tooltip: {
    format: "{0} - {1}"
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var range_area_point_default = RangeAreaPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-segment.js
var RangeAreaSegment = class extends area_segment_default {
  createStrokeSegments() {
    return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));
  }
  stackSegments() {
    let fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));
    }
    return fromSegments;
  }
  createStroke(style) {
    const toPath = new drawing_exports.Path(style);
    const fromPath = new drawing_exports.Path(style);
    toPath.segments.push.apply(toPath.segments, this.strokeSegments());
    fromPath.segments.push.apply(fromPath.segments, this.stackSegments());
    this.visual.append(toPath);
    this.visual.append(fromPath);
  }
  hasStackSegment() {
    return true;
  }
  fromPoints() {
    return this.linePoints.map((point) => point.fromPoint);
  }
  toPoints() {
    return this.linePoints.map((point) => point.toPoint);
  }
};
var range_area_segment_default = RangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/spline-range-area-segment.js
var SplineRangeAreaSegment = class extends range_area_segment_default {
  createStrokeSegments() {
    return this.createCurveSegments(this.toPoints());
  }
  stackSegments() {
    let fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());
    }
    return fromSegments;
  }
  createCurveSegments(points) {
    const curveProcessor = new curve_processor_default();
    return curveProcessor.process(this.toGeometryPoints(points));
  }
};
var spline_range_area_segment_default = SplineRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/step-range-area-segment.js
var StepRangeAreaSegment = class extends range_area_segment_default {
  createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));
  }
  stackSegments() {
    let fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));
      fromSegments.reverse();
    }
    return fromSegments;
  }
};
deepExtend(StepRangeAreaSegment.prototype, step_line_mixin_default);
var step_range_area_segment_default = StepRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-chart.js
var RangeAreaChart = class extends categorical_chart_default {
  render() {
    super.render();
    this.renderSegments();
  }
  pointType() {
    return range_area_point_default;
  }
  createPoint(data, fields) {
    const { series, seriesIx } = fields;
    let value2 = data.valueFields;
    if (!hasValue(value2.from) && !hasValue(value2.to)) {
      if (this.seriesMissingValues(series) === ZERO) {
        value2 = {
          from: 0,
          to: 0
        };
      } else {
        return null;
      }
    }
    let pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    let color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const point = new range_area_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = (currentSeries.line || {}).style;
    let segmentType;
    if (style === "smooth") {
      segmentType = spline_range_area_segment_default;
    } else if (style === "step") {
      segmentType = step_range_area_segment_default;
    } else {
      segmentType = range_area_segment_default;
    }
    return new segmentType(linePoints, currentSeries, seriesIx);
  }
  plotRange(point, startValue) {
    if (!point) {
      return [startValue, startValue];
    }
    return [point.value.from, point.value.to];
  }
  valueSlot(valueAxis, plotRange) {
    const fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);
    const toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);
    if (fromSlot && toSlot) {
      return {
        from: fromSlot,
        to: toSlot
      };
    }
  }
  pointSlot(categorySlot, valueSlot) {
    const { from, to } = valueSlot;
    let fromSlot, toSlot;
    if (this.options.invertAxes) {
      fromSlot = new box_default(from.x1, categorySlot.y1, from.x2, categorySlot.y2);
      toSlot = new box_default(to.x1, categorySlot.y1, to.x2, categorySlot.y2);
    } else {
      fromSlot = new box_default(categorySlot.x1, from.y1, categorySlot.x2, from.y2);
      toSlot = new box_default(categorySlot.x1, to.y1, categorySlot.x2, to.y2);
    }
    return {
      from: fromSlot,
      to: toSlot
    };
  }
  addValue(data, fields) {
    const valueFields = data.valueFields;
    if (!isNumber(valueFields.from)) {
      valueFields.from = valueFields.to;
    }
    if (!isNumber(valueFields.to)) {
      valueFields.to = valueFields.from;
    }
    super.addValue(data, fields);
  }
  updateRange(value2, fields) {
    if (value2 !== null && isNumber(value2.from) && isNumber(value2.to)) {
      const axisName = fields.series.axis;
      const axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
      const { from, to } = value2;
      axisRange.min = Math.min(axisRange.min, from, to);
      axisRange.max = Math.max(axisRange.max, from, to);
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.from, value2.to);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      if (point) {
        result.push((point.fromPoint || {}).marker);
        result.push((point.toPoint || {}).marker);
      }
    }
    return result.concat(this._segments);
  }
};
deepExtend(RangeAreaChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var range_area_chart_default = RangeAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick.js
var Candlestick = class extends chart_element_default {
  constructor(value2, options) {
    super(options);
    this.value = value2;
  }
  getLabelText(options) {
    return this.formatValue(options.format);
  }
  reflow(box) {
    const { options, value: value2, owner: chart } = this;
    const valueAxis = chart.seriesValueAxis(options);
    const ocSlot = valueAxis.getSlot(value2.open, value2.close);
    const lhSlot = valueAxis.getSlot(value2.low, value2.high);
    ocSlot.x1 = lhSlot.x1 = box.x1;
    ocSlot.x2 = lhSlot.x2 = box.x2;
    this.realBody = ocSlot;
    const mid = lhSlot.center().x;
    const points = [];
    points.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);
    points.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);
    this.lines = points;
    this.box = lhSlot.clone().wrap(ocSlot);
    if (!this._rendered) {
      this._rendered = true;
      this.createNote();
    }
    this.reflowNote();
  }
  reflowNote() {
    if (this.note) {
      this.note.reflow(this.box);
    }
  }
  createVisual() {
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    this._mainVisual = this.mainVisual(this.options);
    this.visual.append(
      this._mainVisual
    );
    this.createOverlay();
  }
  mainVisual(options) {
    const group = new drawing_exports.Group();
    this.createBody(group, options);
    this.createLines(group, options);
    return group;
  }
  createBody(container, options) {
    const body = drawing_exports.Path.fromRect(this.realBody.toRect(), {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: this.getBorderColor(),
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    alignPathToPixel(body);
    container.append(body);
    if (hasGradientOverlay(options)) {
      container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay)));
    }
  }
  createLines(container, options) {
    this.drawLines(container, options, this.lines, options.line);
  }
  drawLines(container, options, lines, lineOptions) {
    if (!lines) {
      return;
    }
    const lineStyle = {
      stroke: {
        color: lineOptions.color || this.color,
        opacity: valueOrDefault(lineOptions.opacity, options.opacity),
        width: lineOptions.width,
        dashType: lineOptions.dashType,
        lineCap: "butt"
      }
    };
    for (let i = 0; i < lines.length; i++) {
      const line = drawing_exports.Path.fromPoints(lines[i], lineStyle);
      alignPathToPixel(line);
      container.append(line);
    }
  }
  getBorderColor() {
    const border = this.options.border;
    let borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(this.color).brightness(border._brightness).toHex();
    }
    return borderColor;
  }
  createOverlay() {
    const overlay = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null
    });
    this.visual.append(overlay);
  }
  createHighlight() {
    const highlight = this.options.highlight;
    const normalColor = this.color;
    this.color = highlight.color || this.color;
    const overlay = this.mainVisual(
      deepExtend({}, this.options, {
        line: {
          color: this.getBorderColor()
        }
      }, highlight)
    );
    this.color = normalColor;
    return overlay;
  }
  highlightVisual() {
    return this._mainVisual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this._mainVisual
    };
  }
  tooltipAnchor() {
    const box = this.box;
    const clipBox = this.owner.pane.clipBox() || box;
    return {
      point: new point_default(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),
      align: {
        horizontal: LEFT,
        vertical: TOP
      }
    };
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      value: this.value,
      meanPoints: this.meanPoints,
      medianPoints: this.medianPoints,
      whiskerPoints: this.whiskerPoints,
      stackValue: this.stackValue,
      series: this.series
    };
  }
  getIndex() {
    return this.categoryIx;
  }
};
Candlestick.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Candlestick, {
  vertical: true,
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>"
  },
  labels: {
    format: ""
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Candlestick.prototype, point_events_mixin_default);
deepExtend(Candlestick.prototype, note_mixin_default);
deepExtend(Candlestick.prototype, accessibility_attributes_mixin_default);
var candlestick_default = Candlestick;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick-chart.js
var CandlestickChart = class extends categorical_chart_default {
  reflowCategories(categorySlots) {
    const children = this.children;
    const childrenLength = children.length;
    for (let i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  }
  addValue(data, fields) {
    const { categoryIx, category, series, seriesIx } = fields;
    const { children, options } = this;
    const value2 = data.valueFields;
    const valueParts = this.splitValue(value2);
    const hasValue4 = areNumbers(valueParts);
    const dataItem = series.data[categoryIx];
    let categoryPoints = this.categoryPoints[categoryIx];
    let point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue4) {
      point = this.createPoint(data, fields);
    }
    let cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
      point.noteText = data.fields.noteText;
    }
    this.points.push(point);
    categoryPoints.push(point);
  }
  pointType() {
    return candlestick_default;
  }
  createPoint(data, fields) {
    const { series } = fields;
    const pointType = this.pointType();
    const value2 = data.valueFields;
    let pointOptions = deepExtend({}, series);
    let color = data.fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (series.type === CANDLESTICK || series.type === OHLC) {
      if (value2.open > value2.close) {
        color = data.fields.downColor || series.downColor || series.color;
      }
    }
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.vertical = !this.options.invertAxes;
    const point = new pointType(value2, pointOptions);
    point.color = color;
    return point;
  }
  splitValue(value2) {
    return [value2.low, value2.open, value2.close, value2.high];
  }
  updateRange(value2, fields) {
    const axisName = fields.series.axis;
    const parts = this.splitValue(value2);
    let axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(
      format,
      value2.open,
      value2.high,
      value2.low,
      value2.close,
      point.category
    );
  }
  animationPoints() {
    return this.points;
  }
};
deepExtend(CandlestickChart.prototype, clip_animation_mixin_default);
var candlestick_chart_default = CandlestickChart;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-point.js
var OHLCPoint = class extends candlestick_default {
  reflow(box) {
    const { options, value: value2, owner: chart } = this;
    const valueAxis = chart.seriesValueAxis(options);
    const oPoints = [];
    const cPoints = [];
    const lhPoints = [];
    const lhSlot = valueAxis.getSlot(value2.low, value2.high);
    const oSlot = valueAxis.getSlot(value2.open, value2.open);
    const cSlot = valueAxis.getSlot(value2.close, value2.close);
    oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;
    oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;
    const mid = lhSlot.center().x;
    oPoints.push([oSlot.x1, oSlot.y1]);
    oPoints.push([mid, oSlot.y1]);
    cPoints.push([mid, cSlot.y1]);
    cPoints.push([cSlot.x2, cSlot.y1]);
    lhPoints.push([mid, lhSlot.y1]);
    lhPoints.push([mid, lhSlot.y2]);
    this.lines = [
      oPoints,
      cPoints,
      lhPoints
    ];
    this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));
    this.reflowNote();
  }
  createBody() {
  }
};
var ohlc_point_default = OHLCPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-chart.js
var OHLCChart = class extends candlestick_chart_default {
  pointType() {
    return ohlc_point_default;
  }
};
var ohlc_chart_default = OHLCChart;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot.js
var BoxPlot = class extends candlestick_default {
  constructor(value2, options) {
    super(value2, options);
    this.createNote();
  }
  reflow(box) {
    const { options, value: value2, owner: chart } = this;
    const valueAxis = chart.seriesValueAxis(options);
    let whiskerSlot, boxSlot;
    this.boxSlot = boxSlot = valueAxis.getSlot(value2.q1, value2.q3);
    this.realBody = boxSlot;
    this.reflowBoxSlot(box);
    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value2.lower, value2.upper);
    this.reflowWhiskerSlot(box);
    const medianSlot = valueAxis.getSlot(value2.median);
    if (value2.mean) {
      const meanSlot = valueAxis.getSlot(value2.mean);
      this.meanPoints = this.calcMeanPoints(box, meanSlot);
    }
    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);
    this.medianPoints = this.calcMedianPoints(box, medianSlot);
    this.box = whiskerSlot.clone().wrap(boxSlot);
    this.reflowNote();
  }
  reflowBoxSlot(box) {
    this.boxSlot.x1 = box.x1;
    this.boxSlot.x2 = box.x2;
  }
  reflowWhiskerSlot(box) {
    this.whiskerSlot.x1 = box.x1;
    this.whiskerSlot.x2 = box.x2;
  }
  calcMeanPoints(box, meanSlot) {
    return [
      [[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]
    ];
  }
  calcWhiskerPoints(boxSlot, whiskerSlot) {
    const mid = whiskerSlot.center().x;
    return [[
      [mid - 5, whiskerSlot.y1],
      [mid + 5, whiskerSlot.y1],
      [mid, whiskerSlot.y1],
      [mid, boxSlot.y1]
    ], [
      [mid - 5, whiskerSlot.y2],
      [mid + 5, whiskerSlot.y2],
      [mid, whiskerSlot.y2],
      [mid, boxSlot.y2]
    ]];
  }
  calcMedianPoints(box, medianSlot) {
    return [
      [[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]
    ];
  }
  renderOutliers(options) {
    const value2 = this.value;
    const outliers = value2.outliers || [];
    const outerFence = Math.abs(value2.q3 - value2.q1) * 3;
    const elements = [];
    let markers = options.markers || {};
    for (let i = 0; i < outliers.length; i++) {
      const outlierValue = outliers[i];
      if (outlierValue < value2.q3 + outerFence && outlierValue > value2.q1 - outerFence) {
        markers = options.outliers;
      } else {
        markers = options.extremes;
      }
      let markersBorder = deepExtend({}, markers.border);
      if (!defined(markersBorder.color)) {
        if (defined(this.color)) {
          markersBorder.color = this.color;
        } else {
          markersBorder.color = new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex();
        }
      }
      const shape = new shape_element_default({
        type: markers.type,
        width: markers.size,
        height: markers.size,
        rotation: markers.rotation,
        background: markers.background,
        border: markersBorder,
        opacity: markers.opacity
      });
      shape.value = outlierValue;
      elements.push(shape);
    }
    this.reflowOutliers(elements);
    return elements;
  }
  reflowOutliers(outliers) {
    const valueAxis = this.owner.seriesValueAxis(this.options);
    const center = this.box.center();
    for (let i = 0; i < outliers.length; i++) {
      const outlierValue = outliers[i].value;
      const markerBox = valueAxis.getSlot(outlierValue);
      if (this.options.vertical) {
        markerBox.move(center.x);
      } else {
        markerBox.move(void 0, center.y);
      }
      this.box = this.box.wrap(markerBox);
      outliers[i].reflow(markerBox);
    }
  }
  mainVisual(options) {
    const group = super.mainVisual(options);
    const outliers = this.renderOutliers(options);
    for (let i = 0; i < outliers.length; i++) {
      const element = outliers[i].getElement();
      if (element) {
        group.append(element);
      }
    }
    return group;
  }
  createLines(container, options) {
    this.drawLines(container, options, this.whiskerPoints, options.whiskers);
    this.drawLines(container, options, this.medianPoints, options.median);
    this.drawLines(container, options, this.meanPoints, options.mean);
  }
  getBorderColor() {
    if ((this.options.border || {}).color) {
      return this.options.border.color;
    }
    if (this.color) {
      return this.color;
    }
    return super.getBorderColor();
  }
};
setDefaultOptions(BoxPlot, {
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  median: {
    color: "#f6f6f6"
  },
  mean: {
    width: 2,
    dashType: "dash",
    color: "#f6f6f6"
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  outliers: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CROSS,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  },
  extremes: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  }
});
deepExtend(BoxPlot.prototype, point_events_mixin_default);
var box_plot_default = BoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/vertical-box-plot.js
var VerticalBoxPlot = class extends box_plot_default {
  reflowBoxSlot(box) {
    this.boxSlot.y1 = box.y1;
    this.boxSlot.y2 = box.y2;
  }
  reflowWhiskerSlot(box) {
    this.whiskerSlot.y1 = box.y1;
    this.whiskerSlot.y2 = box.y2;
  }
  calcMeanPoints(box, meanSlot) {
    return [
      [[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]
    ];
  }
  calcWhiskerPoints(boxSlot, whiskerSlot) {
    const mid = whiskerSlot.center().y;
    return [[
      [whiskerSlot.x1, mid - 5],
      [whiskerSlot.x1, mid + 5],
      [whiskerSlot.x1, mid],
      [boxSlot.x1, mid]
    ], [
      [whiskerSlot.x2, mid - 5],
      [whiskerSlot.x2, mid + 5],
      [whiskerSlot.x2, mid],
      [boxSlot.x2, mid]
    ]];
  }
  calcMedianPoints(box, medianSlot) {
    return [
      [[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]
    ];
  }
};
var vertical_box_plot_default = VerticalBoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot-chart.js
var BoxPlotChart = class extends candlestick_chart_default {
  addValue(data, fields) {
    const { categoryIx, category, series, seriesIx } = fields;
    const { children, options } = this;
    const value2 = data.valueFields;
    const valueParts = this.splitValue(value2);
    const hasValue4 = areNumbers(valueParts);
    const dataItem = series.data[categoryIx];
    let categoryPoints = this.categoryPoints[categoryIx];
    let point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue4) {
      point = this.createPoint(data, fields);
    }
    let cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
    }
    this.points.push(point);
    categoryPoints.push(point);
  }
  pointType() {
    if (this.options.invertAxes) {
      return vertical_box_plot_default;
    }
    return box_plot_default;
  }
  splitValue(value2) {
    return [
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper
    ];
  }
  updateRange(value2, fields) {
    const axisName = fields.series.axis;
    let parts = this.splitValue(value2).concat(this.filterOutliers(value2.outliers));
    if (defined(value2.mean)) {
      parts = parts.concat(value2.mean);
    }
    let axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(
      format,
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper,
      value2.mean,
      point.category
    );
  }
  filterOutliers(items) {
    const length = (items || []).length;
    const result = [];
    for (let i = 0; i < length; i++) {
      const item = items[i];
      if (defined(item) && item !== null) {
        result.push(item);
      }
    }
    return result;
  }
  supportsPointInactiveOpacity() {
    return false;
  }
};
var box_plot_chart_default = BoxPlotChart;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-segment.js
var WaterfallSegment = class extends chart_element_default {
  constructor(from, to, series) {
    super();
    this.from = from;
    this.to = to;
    this.series = series;
  }
  linePoints() {
    const from = this.from;
    const { from: { box: fromBox }, to: { box: toBox } } = this;
    const points = [];
    if (from.isVertical) {
      const y = from.aboveAxis ? fromBox.y1 : fromBox.y2;
      points.push(
        [fromBox.x1, y],
        [toBox.x2, y]
      );
    } else {
      const x = from.aboveAxis ? fromBox.x2 : fromBox.x1;
      points.push(
        [x, fromBox.y1],
        [x, toBox.y2]
      );
    }
    return points;
  }
  createVisual() {
    super.createVisual();
    const line = this.series.line || {};
    const path = drawing_exports.Path.fromPoints(this.linePoints(), {
      stroke: {
        color: line.color,
        width: line.width,
        opacity: line.opacity,
        dashType: line.dashType
      }
    });
    alignPathToPixel(path);
    this.visual.append(path);
  }
};
setDefaultOptions(WaterfallSegment, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  }
});
var waterfall_segment_default = WaterfallSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-chart.js
var WaterfallChart = class extends bar_chart_default {
  render() {
    super.render();
    this.createSegments();
  }
  traverseDataPoints(callback) {
    const series = this.options.series;
    const totalCategories = categoriesCount(series);
    const isVertical = !this.options.invertAxes;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      let total = 0;
      let runningTotal = 0;
      for (let categoryIx = 0; categoryIx < totalCategories; categoryIx++) {
        const data = series_binder_default.current.bindPoint(currentSeries, categoryIx);
        const value2 = data.valueFields.value;
        const summary = data.fields.summary;
        let from = total;
        let to;
        if (summary) {
          if (summary.toLowerCase() === "total") {
            data.valueFields.value = total;
            from = 0;
            to = total;
          } else {
            data.valueFields.value = runningTotal;
            to = from - runningTotal;
            runningTotal = 0;
          }
        } else if (isNumber(value2)) {
          runningTotal += value2;
          total += value2;
          to = total;
        }
        callback(data, {
          category: this.categoryAxis.categoryAt(categoryIx),
          categoryIx,
          series: currentSeries,
          seriesIx,
          total,
          runningTotal,
          from,
          to,
          isVertical
        });
      }
    }
  }
  updateRange(value2, fields) {
    super.updateRange({ value: fields.to }, fields);
  }
  aboveAxis(point) {
    return point.value >= 0;
  }
  plotRange(point) {
    return [point.from, point.to];
  }
  createSegments() {
    const series = this.options.series;
    const seriesPoints = this.seriesPoints;
    const segments = this.segments = [];
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const points = seriesPoints[seriesIx];
      if (points) {
        let prevPoint;
        for (let pointIx = 0; pointIx < points.length; pointIx++) {
          const point = points[pointIx];
          if (point && prevPoint) {
            const segment = new waterfall_segment_default(prevPoint, point, currentSeries);
            segments.push(segment);
            this.append(segment);
          }
          prevPoint = point;
        }
      }
    }
  }
};
var waterfall_chart_default = WaterfallChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-factory.js
function trendlineFactory(registry2, type, context) {
  const impl = registry2[String(type)];
  if (impl) {
    return impl(context);
  }
  return null;
}
var trendline_factory_default = trendlineFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-slope.js
function calculateSlope(sourceValues, valueGetter10) {
  let x = 0;
  let y = 0;
  let x2 = 0;
  let xy = 0;
  let count = 0;
  let slope, intercept;
  let xMin = Number.MAX_VALUE;
  let xMax = Number.MIN_VALUE;
  for (let i = 0; i < sourceValues.length; i++) {
    const value2 = sourceValues[i];
    const { xValue, yValue } = valueGetter10(value2);
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      x += xValue;
      y += yValue;
      x2 += Math.pow(xValue, 2);
      xy += xValue * yValue;
    }
  }
  if (count > 0) {
    slope = (count * xy - x * y) / (count * x2 - Math.pow(x, 2));
    intercept = (y - slope * x) / count;
  }
  return { slope, intercept, count, xMin, xMax };
}
var calculate_slope_default = calculateSlope;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/check-all-positive.js
var checkAllPositive = (sourceValues, fieldName) => sourceValues.every(({ valueFields }) => !hasValue(valueFields[fieldName]) || valueFields[fieldName] > 0);
var check_all_positive_default = checkAllPositive;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-trendline-data.js
function getTrendlineData(valueMapper, categoryAxis) {
  const data = [];
  const totalRange = categoryAxis.totalRangeIndices();
  const currentRange = categoryAxis.currentRangeIndices();
  const range = {
    min: Math.floor(Math.max(currentRange.min - 1, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + 2, totalRange.max))
  };
  for (let i = range.min; i < range.max; i++) {
    const x = i + 1;
    data[i] = {
      category: categoryAxis.categoryAt(i, true),
      value: valueMapper(x)
    };
  }
  return data;
}
var get_trendline_data_default = getTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/exponential-trendline.js
function exponentialTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx + 1, yValue: Math.log(valueFields[fieldName]) });
function getData({ seriesValues, categoryAxis, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, valueGetter(options.field));
  if (count > 0) {
    const a = Math.exp(intercept);
    const b = slope;
    return get_trendline_data_default((x) => a * Math.exp(b * x), categoryAxis);
  }
  return null;
}
var exponential_trendline_default = exponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/linear-trendline.js
function linearTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData2({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter2 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx + 1, yValue: valueFields[fieldName] });
function getData2({ seriesValues, categoryAxis, options }) {
  const { slope, intercept, count } = calculate_slope_default(seriesValues(), valueGetter2(options.field));
  if (count > 0) {
    return get_trendline_data_default((x) => slope * x + intercept, categoryAxis);
  }
  return null;
}
var linear_trendline_default = linearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/logarithmic-trendline.js
function logarithmicTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData3({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter3 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: Math.log(categoryIx + 1), yValue: valueFields[fieldName] });
function getData3({ seriesValues, categoryAxis, options }) {
  let { slope, intercept, count } = calculate_slope_default(seriesValues(), valueGetter3(options.field));
  if (count > 0) {
    const a = slope;
    const b = intercept;
    return get_trendline_data_default((x) => a * Math.log(x) + b, categoryAxis);
  }
  return null;
}
var logarithmic_trendline_default = logarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-moving-average.js
function calculateMovingAverage(sourceValues, valueGetter10, period) {
  const averagePoints = [];
  const values = [];
  const start = Math.max(MIN_MOVING_AVERAGE_PERIOD, period) - 1;
  let end = 0;
  let sum2 = 0;
  for (let i = 0; i < sourceValues.length; i++) {
    const value2 = sourceValues[i];
    const { xValue, yValue } = valueGetter10(value2);
    if (isFinite(yValue) && yValue !== null) {
      values.push(yValue);
      sum2 += yValue;
      end = Math.max(i, end);
    } else {
      values.push(null);
    }
    if (i >= start) {
      const count = values.filter((value3) => value3 !== null).length;
      const lastValue = values.shift() || 0;
      if (count > 0) {
        const average = sum2 / count;
        averagePoints.push([xValue, average]);
        sum2 -= lastValue;
        continue;
      }
    }
    averagePoints.push([xValue, null]);
  }
  return averagePoints.slice(0, end + 1);
}
var calculate_moving_average_default = calculateMovingAverage;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/moving-average.js
function movingAverageTrendline(context) {
  const { options } = context;
  const data = getData4(context);
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter4 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx, yValue: valueFields[fieldName] });
function calculatePoints({ options, categoryAxis, seriesValues }) {
  const period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  const totalRange = categoryAxis.totalRangeIndices();
  const currentRange = categoryAxis.currentRangeIndices();
  const range = {
    min: Math.floor(Math.max(currentRange.min - period, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + period + 2, totalRange.max))
  };
  return calculate_moving_average_default(seriesValues(range), valueGetter4(options.field), period);
}
function getData4(context) {
  const { categoryAxis } = context;
  const points = calculatePoints(context);
  const data = [];
  points.forEach(([categoryIx, value2]) => {
    data[categoryIx] = {
      category: categoryAxis.categoryAt(categoryIx, true),
      value: value2
    };
  });
  if (data.length > 0) {
    return data;
  }
  return null;
}
var moving_average_default = movingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-polynomial.js
var MIN_ORDER = 1;
var MAX_ORDER = 6;
function calculatePolynomial(sourceValues, valueGetter10, order) {
  let k = Math.min(Math.max(order || MIN_ORDER, MIN_ORDER), MAX_ORDER) + 1;
  let X2 = new matrix_default();
  let Y2 = new matrix_default();
  let count = 0;
  let xMin = Number.MAX_VALUE;
  let xMax = Number.MIN_VALUE;
  let valueMapper = (x) => x;
  let coefficients = [];
  for (let i = 0; i < sourceValues.length; i++) {
    const value2 = sourceValues[i];
    let { xValue, yValue } = valueGetter10(value2);
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      Y2.set(i, 0, yValue);
      X2.set(i, 0, 1);
      X2.set(i, 1, xValue);
      for (let pow3 = 2; pow3 <= k; pow3++) {
        X2.set(i, pow3, Math.pow(X2.get(i, 1), pow3));
      }
    } else {
      X2.set(i, 0, 0);
    }
  }
  X2.width = Math.min(k, count);
  if (count > 0) {
    coefficients = linearRegression(X2, Y2);
    valueMapper = (x) => coefficients.reduce((y, a, n) => y + a * Math.pow(x, n), 0);
  }
  return {
    coefficients,
    count,
    valueMapper,
    xMin,
    xMax
  };
}
function linearRegression(X2, Y2) {
  const Xt = X2.transpose();
  const B = Xt.multiply(X2).inverse().multiply(Xt).multiply(Y2);
  const coefficients = [];
  for (let i = 0; i < B.height; i++) {
    coefficients.push(B.get(i, 0));
  }
  return coefficients;
}
var calculate_polynomial_default = calculatePolynomial;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/polynomial-trendline.js
function polynomialTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData5({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter5 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx + 1, yValue: valueFields[fieldName] });
function getData5({ seriesValues, categoryAxis, options }) {
  const order = (options.trendline || {}).order;
  const { count, valueMapper } = calculate_polynomial_default(seriesValues(), valueGetter5(options.field), order);
  if (count > 0) {
    return get_trendline_data_default((x) => valueMapper(x), categoryAxis);
  }
  return null;
}
var polynomial_trendline_default = polynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/power-trendline.js
function powerTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData6({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter6 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: Math.log(categoryIx + 1), yValue: Math.log(valueFields[fieldName]) });
function getData6({ seriesValues, categoryAxis, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, valueGetter6(options.field));
  if (count > 0) {
    const a = Math.exp(intercept);
    const b = slope;
    return get_trendline_data_default((x) => a * Math.pow(x, b), categoryAxis);
  }
  return null;
}
var power_trendline_default = powerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-registry.js
var registry = {};
registry[TRENDLINE_EXPONENTIAL] = exponential_trendline_default;
registry[TRENDLINE_LINEAR] = linear_trendline_default;
registry[TRENDLINE_LOGARITHMIC] = logarithmic_trendline_default;
registry[TRENDLINE_MOVING_AVERAGE] = moving_average_default;
registry[TRENDLINE_POLYNOMIAL] = polynomial_trendline_default;
registry[TRENDLINE_POWER] = power_trendline_default;
var trendline_registry_default = registry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/categorical-plotarea.js
var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];
var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);
var CategoricalPlotArea = class extends plotarea_base_default {
  initFields(series) {
    this.namedCategoryAxes = {};
    this.namedValueAxes = {};
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
    this._seriesPointsCache = {};
    this._currentPointsCache = {};
    if (series.length > 0) {
      this.invertAxes = inArray(
        series[0].type,
        [
          BAR,
          BULLET,
          VERTICAL_LINE,
          VERTICAL_AREA,
          VERTICAL_RANGE_AREA,
          RANGE_BAR,
          HORIZONTAL_WATERFALL,
          VERTICAL_BOX_PLOT
        ]
      );
      for (let i = 0; i < series.length; i++) {
        const stack = series[i].stack;
        if (stack && stack.type === "100%") {
          this.stack100 = true;
          break;
        }
      }
    }
  }
  render(panes = this.panes) {
    this.series = [...this.originalSeries];
    this.createCategoryAxes(panes);
    this.aggregateCategories(panes);
    this.createTrendlineSeries(panes);
    this.createCategoryAxesLabels(panes);
    this.createCharts(panes);
    this.createValueAxes(panes);
  }
  removeAxis(axis) {
    const axisName = axis.options.name;
    super.removeAxis(axis);
    if (axis instanceof category_axis_default) {
      delete this.namedCategoryAxes[axisName];
    } else {
      this.valueAxisRangeTracker.reset(axisName);
      delete this.namedValueAxes[axisName];
    }
    if (axis === this.categoryAxis) {
      delete this.categoryAxis;
    }
    if (axis === this.valueAxis) {
      delete this.valueAxis;
    }
  }
  trendlineFactory(options, series) {
    const categoryAxis = this.seriesCategoryAxis(options);
    const seriesValues = this.seriesValues.bind(this, series.index);
    const trendline = trendline_factory_default(trendline_registry_default, options.type, {
      options,
      categoryAxis,
      seriesValues
    });
    if (trendline) {
      trendline.categoryAxis = series.categoryAxis;
      trendline.valueAxis = series.valueAxis;
      return this.filterSeries(trendline, categoryAxis);
    }
    return trendline;
  }
  trendlineAggregateForecast() {
    return this.series.map((series) => (series.trendline || {}).forecast).filter((forecast) => forecast !== void 0).reduce((result, forecast) => ({
      before: Math.max(result.before, forecast.before || 0),
      after: Math.max(result.after, forecast.after || 0)
    }), { before: 0, after: 0 });
  }
  seriesValues(seriesIx, range) {
    const result = [];
    let series = this.srcSeries[seriesIx];
    const categoryAxis = this.seriesCategoryAxis(series);
    const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
    if (dateAxis) {
      this._seriesPointsCache = {};
      this._currentPointsCache = {};
      categoryAxis.options.dataItems = [];
      series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());
    }
    const min4 = range ? range.min : 0;
    const max3 = range ? range.max : series.data.length;
    for (let categoryIx = min4; categoryIx < max3; categoryIx++) {
      const data = this.bindPoint(series, categoryIx);
      result.push({ categoryIx, category: data.fields.category, valueFields: data.valueFields });
    }
    return result;
  }
  createCharts(panes) {
    const seriesByPane = this.groupSeriesByPane();
    for (let i = 0; i < panes.length; i++) {
      const pane = panes[i];
      const paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this.addToLegend(paneSeries);
      const visibleSeries = this.filterVisibleSeries(paneSeries);
      if (!visibleSeries) {
        continue;
      }
      const groups = this.groupSeriesByCategoryAxis(visibleSeries);
      for (let groupIx = 0; groupIx < groups.length; groupIx++) {
        this.createChartGroup(groups[groupIx], pane);
      }
    }
  }
  createChartGroup(series, pane) {
    this.createAreaChart(
      filterSeriesByType(series, [AREA, VERTICAL_AREA]),
      pane
    );
    this.createRangeAreaChart(
      filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [COLUMN, BAR]),
      pane
    );
    this.createRangeBarChart(
      filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]),
      pane
    );
    this.createBulletChart(
      filterSeriesByType(series, [BULLET, VERTICAL_BULLET]),
      pane
    );
    this.createCandlestickChart(
      filterSeriesByType(series, CANDLESTICK),
      pane
    );
    this.createBoxPlotChart(
      filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]),
      pane
    );
    this.createOHLCChart(
      filterSeriesByType(series, OHLC),
      pane
    );
    this.createWaterfallChart(
      filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [LINE, VERTICAL_LINE]),
      pane
    );
  }
  aggregateCategories(panes) {
    const series = [...this.series];
    const processedSeries = [];
    this._currentPointsCache = {};
    this._seriesPointsCache = this._seriesPointsCache || {};
    for (let i = 0; i < series.length; i++) {
      let currentSeries = series[i];
      if (!this.isTrendline(currentSeries)) {
        const categoryAxis = this.seriesCategoryAxis(currentSeries);
        const axisPane = this.findPane(categoryAxis.options.pane);
        const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
        if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {
          currentSeries = this.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());
        } else {
          currentSeries = this.filterSeries(currentSeries, categoryAxis);
        }
      }
      processedSeries.push(currentSeries);
    }
    this._seriesPointsCache = this._currentPointsCache;
    this._currentPointsCache = null;
    this.srcSeries = series;
    this.series = processedSeries;
  }
  filterSeries(series, categoryAxis) {
    const dataLength = (series.data || {}).length;
    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);
    if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {
      return series;
    }
    const range = categoryAxis.currentRangeIndices();
    const outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);
    const currentSeries = deepExtend({}, series);
    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);
    if (outOfRangePoints) {
      createOutOfRangePoints(currentSeries, range, dataLength, (idx) => ({
        item: series.data[idx],
        category: categoryAxis.categoryAt(idx, true),
        categoryIx: idx - range.min
      }), (idx) => defined(series.data[idx]));
    }
    return currentSeries;
  }
  clearSeriesPointsCache() {
    this._seriesPointsCache = {};
  }
  seriesSourcePoints(series, categoryAxis) {
    const key = `${series.index};${categoryAxis.categoriesHash()}`;
    if (this._seriesPointsCache && this._seriesPointsCache[key]) {
      this._currentPointsCache[key] = this._seriesPointsCache[key];
      return this._seriesPointsCache[key];
    }
    const axisOptions2 = categoryAxis.options;
    const srcCategories = axisOptions2.srcCategories;
    const dateAxis = equalsIgnoreCase(axisOptions2.type, DATE);
    const srcData = series.data;
    const result = [];
    if (!dateAxis) {
      categoryAxis.indexCategories();
    }
    for (let idx = 0; idx < srcData.length; idx++) {
      let category = series_binder_default.current.bindPoint(series, idx).fields.category;
      if (dateAxis) {
        category = parseDateCategory(category, srcData[idx], this.chartService.intl);
      }
      if (!defined(category)) {
        category = srcCategories[idx];
      }
      if (defined(category) && category !== null) {
        const categoryIx = categoryAxis.totalIndex(category);
        result[categoryIx] = result[categoryIx] || { items: [], category };
        result[categoryIx].items.push(idx);
      }
    }
    this._currentPointsCache[key] = result;
    return result;
  }
  aggregateSeries(series, categoryAxis, range) {
    const srcData = series.data;
    if (!srcData.length) {
      return series;
    }
    const srcPoints = this.seriesSourcePoints(series, categoryAxis);
    const result = deepExtend({}, series);
    const aggregator = new series_aggregator_default(deepExtend({}, series), series_binder_default.current, default_aggregates_default.current);
    const data = result.data = [];
    const dataItems = categoryAxis.options.dataItems || [];
    const categoryItem = (idx) => {
      const categoryIdx = idx - range.min;
      let point = srcPoints[idx];
      if (!point) {
        point = srcPoints[idx] = {};
      }
      point.categoryIx = categoryIdx;
      if (!point.item) {
        const category = categoryAxis.categoryAt(idx, true);
        point.category = category;
        point.item = aggregator.aggregatePoints(point.items, category);
      }
      return point;
    };
    for (let idx = range.min; idx <= range.max; idx++) {
      const point = categoryItem(idx);
      data[point.categoryIx] = point.item;
      if (point.items && point.items.length) {
        dataItems[point.categoryIx] = point.item;
      }
    }
    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {
      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, (idx) => srcPoints[idx]);
    }
    categoryAxis.options.dataItems = dataItems;
    return result;
  }
  appendChart(chart, pane) {
    const series = chart.options.series;
    const categoryAxis = this.seriesCategoryAxis(series[0]);
    let categories = categoryAxis.options.categories;
    let categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);
    if (categoriesToAdd > 0) {
      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);
      while (categoriesToAdd--) {
        categories.push("");
      }
    }
    this.valueAxisRangeTracker.update(chart.valueAxisRanges);
    super.appendChart(chart, pane);
  }
  // TODO: Refactor, optionally use series.pane option
  seriesPaneName(series) {
    const options = this.options;
    const axisName = series.axis;
    const axisOptions2 = [].concat(options.valueAxis);
    const axis = grep(axisOptions2, function(a) {
      return a.name === axisName;
    })[0];
    const panes = options.panes || [{}];
    const defaultPaneName = (panes[0] || {}).name || "default";
    const paneName = (axis || {}).pane || defaultPaneName;
    return paneName;
  }
  seriesCategoryAxis(series) {
    const axisName = series.categoryAxis;
    const axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;
    if (!axis) {
      throw new Error("Unable to locate category axis with name " + axisName);
    }
    return axis;
  }
  stackableChartOptions(series, pane) {
    const anyStackedSeries = series.some((s) => s.stack);
    const isStacked100 = series.some((s) => s.stack && s.stack.type === "100%");
    const clip = pane.options.clip;
    return {
      defaultStack: series[0].stack,
      isStacked: anyStackedSeries,
      isStacked100,
      clip
    };
  }
  groupSeriesByCategoryAxis(series) {
    const categoryAxes = [];
    const unique = {};
    for (let idx = 0; idx < series.length; idx++) {
      const name = series[idx].categoryAxis || "$$default$$";
      if (!hasOwnProperty(unique, name)) {
        unique[name] = true;
        categoryAxes.push(name);
      }
    }
    const groups = [];
    for (let axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
      const axis = categoryAxes[axisIx];
      const axisSeries = groupSeries(series, axis, axisIx);
      if (axisSeries.length === 0) {
        continue;
      }
      groups.push(axisSeries);
    }
    return groups;
  }
  createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const barChart = new bar_chart_default(this, Object.assign({
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(barChart, pane);
  }
  createRangeBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const rangeColumnChart = new range_bar_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(rangeColumnChart, pane);
  }
  createBulletChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const bulletChart = new bullet_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(bulletChart, pane);
  }
  createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const lineChart = new line_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(lineChart, pane);
  }
  createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const areaChart = new area_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(areaChart, pane);
  }
  createRangeAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const rangeAreaChart = new range_area_chart_default(this, {
      invertAxes: this.invertAxes,
      series,
      clip: pane.options.clip
    });
    this.appendChart(rangeAreaChart, pane);
  }
  createOHLCChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const chart = new ohlc_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  }
  createCandlestickChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const chart = new candlestick_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  }
  createBoxPlotChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const chart = new box_plot_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  }
  createWaterfallChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const waterfallChart = new waterfall_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(waterfallChart, pane);
  }
  axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
    const centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);
    for (let seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
      const currentSeries = this.series[seriesIx];
      if (inArray(currentSeries.type, AREA_SERIES)) {
        const line = currentSeries.line;
        if (line && line.style === STEP) {
          centeredSeries.push(currentSeries);
        }
      }
    }
    for (let seriesIx = 0; seriesIx < centeredSeries.length; seriesIx++) {
      const seriesAxis = centeredSeries[seriesIx].categoryAxis || "";
      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
        return true;
      }
    }
  }
  aggregatedAxis(categoryAxisName, categoryAxisIndex) {
    const series = this.series;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const seriesAxis = series[seriesIx].categoryAxis || "";
      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
        return true;
      }
    }
  }
  createCategoryAxesLabels() {
    const axes = this.axes;
    for (let i = 0; i < axes.length; i++) {
      if (axes[i] instanceof category_axis_default) {
        axes[i].createLabels();
      }
    }
  }
  createCategoryAxes(panes) {
    const invertAxes = this.invertAxes;
    const definitions = [].concat(this.options.categoryAxis);
    const axes = [];
    for (let i = 0; i < definitions.length; i++) {
      let axisOptions2 = definitions[i];
      const axisPane = this.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        const { name, categories = [] } = axisOptions2;
        axisOptions2 = deepExtend({
          vertical: invertAxes,
          reverse: !invertAxes && this.chartService.rtl,
          axisCrossingValue: invertAxes ? MAX_VALUE : 0
        }, axisOptions2);
        if (!defined(axisOptions2.justified)) {
          axisOptions2.justified = this.isJustified();
        }
        if (this.axisRequiresRounding(name, i)) {
          axisOptions2.justified = false;
        }
        let categoryAxis;
        if (isDateAxis(axisOptions2, categories[0])) {
          axisOptions2._forecast = this.trendlineAggregateForecast();
          categoryAxis = new date_category_axis_default(axisOptions2, this.chartService);
        } else {
          categoryAxis = new category_axis_default(axisOptions2, this.chartService);
        }
        definitions[i].categories = categoryAxis.options.srcCategories;
        if (name) {
          if (this.namedCategoryAxes[name]) {
            throw new Error(`Category axis with name ${name} is already defined`);
          }
          this.namedCategoryAxes[name] = categoryAxis;
        }
        categoryAxis.axisIndex = i;
        axes.push(categoryAxis);
        this.appendAxis(categoryAxis);
      }
    }
    const primaryAxis = this.categoryAxis || axes[0];
    this.categoryAxis = primaryAxis;
    if (invertAxes) {
      this.axisY = primaryAxis;
    } else {
      this.axisX = primaryAxis;
    }
  }
  isJustified() {
    const series = this.series;
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      if (!inArray(currentSeries.type, AREA_SERIES)) {
        return false;
      }
    }
    return true;
  }
  createValueAxes(panes) {
    const tracker = this.valueAxisRangeTracker;
    const defaultRange = tracker.query();
    const definitions = [].concat(this.options.valueAxis);
    const invertAxes = this.invertAxes;
    const baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };
    const axes = [];
    if (this.stack100) {
      baseOptions.roundToMajorUnit = false;
      baseOptions.labels = { format: "P0" };
    }
    for (let i = 0; i < definitions.length; i++) {
      const axisOptions2 = definitions[i];
      const axisPane = this.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        const name = axisOptions2.name;
        const defaultAxisRange = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
        const range = tracker.query(name) || defaultRange || defaultAxisRange;
        if (i === 0 && range && defaultRange) {
          range.min = Math.min(range.min, defaultRange.min);
          range.max = Math.max(range.max, defaultRange.max);
        }
        let axisType;
        if (equalsIgnoreCase(axisOptions2.type, LOGARITHMIC)) {
          axisType = logarithmic_axis_default;
        } else {
          axisType = numeric_axis_default;
        }
        const valueAxis = new axisType(
          range.min,
          range.max,
          deepExtend({}, baseOptions, axisOptions2),
          this.chartService
        );
        if (name) {
          if (this.namedValueAxes[name]) {
            throw new Error(`Value axis with name ${name} is already defined`);
          }
          this.namedValueAxes[name] = valueAxis;
        }
        valueAxis.axisIndex = i;
        axes.push(valueAxis);
        this.appendAxis(valueAxis);
      }
    }
    const primaryAxis = this.valueAxis || axes[0];
    this.valueAxis = primaryAxis;
    if (invertAxes) {
      this.axisX = primaryAxis;
    } else {
      this.axisY = primaryAxis;
    }
  }
  _dispatchEvent(chart, e, eventType) {
    const coords = chart._eventCoordinates(e);
    const point = new point_default(coords.x, coords.y);
    const pane = this.pointPane(point);
    const categories = [];
    const values = [];
    if (!pane) {
      return;
    }
    const allAxes = pane.axes;
    for (let i = 0; i < allAxes.length; i++) {
      const axis = allAxes[i];
      if (axis.getValue) {
        appendIfNotNull(values, axis.getValue(point));
      } else {
        appendIfNotNull(categories, axis.getCategory(point));
      }
    }
    if (categories.length === 0) {
      appendIfNotNull(categories, this.categoryAxis.getCategory(point));
    }
    if (categories.length > 0 && values.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e),
        originalEvent: e,
        category: singleItemOrArray(categories),
        value: singleItemOrArray(values)
      });
    }
  }
  pointPane(point) {
    const panes = this.panes;
    for (let i = 0; i < panes.length; i++) {
      const currentPane = panes[i];
      if (currentPane.contentBox.containsPoint(point)) {
        return currentPane;
      }
    }
  }
  updateAxisOptions(axis, options) {
    updateAxisOptions(this.options, axis, options);
    updateAxisOptions(this.originalOptions, axis, options);
  }
  _pointsByVertical(basePoint, offset = 0) {
    if (this.invertAxes) {
      return this._siblingsBySeriesIndex(basePoint.series.index, offset);
    }
    return this._siblingsByPointIndex(basePoint.getIndex());
  }
  _pointsByHorizontal(basePoint, offset = 0) {
    if (this.invertAxes) {
      return this._siblingsByPointIndex(basePoint.getIndex());
    }
    const siblings = this._siblingsBySeriesIndex(basePoint.series.index, offset);
    if (this.chartService.rtl) {
      return siblings.reverse();
    }
    return siblings;
  }
  _siblingsByPointIndex(pointIndex) {
    const charts = this.charts;
    const result = [];
    for (let i = 0; i < charts.length; i++) {
      let chart = charts[i];
      if (chart.pane && chart.pane.options.name === "_navigator") {
        continue;
      }
      let chartPoints = chart.points.filter(
        (point) => point && point.visible !== false && point.getIndex() === pointIndex
      );
      result.push(...chartPoints.sort(this._getSeriesCompareFn(chartPoints[0])));
    }
    return result;
  }
  _siblingsBySeriesIndex(seriesIndex, offset) {
    const index = cycleIndex(seriesIndex + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  }
  _getSeriesCompareFn(point) {
    const isStacked = this._isInStackedSeries(point);
    if (isStacked && this.invertAxes || !isStacked && !this.invertAxes) {
      return (a, b) => a.box.center().x - b.box.center().x;
    }
    return (a, b) => a.box.center().y - b.box.center().y;
  }
  _isInStackedSeries(point) {
    const sortableSeries = inArray(
      point.series.type,
      [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, LINE, VERTICAL_LINE, RADAR_LINE, RADAR_AREA]
    );
    const stackableSeries = inArray(point.series.type, [COLUMN, BAR]);
    return sortableSeries || stackableSeries && point.options.isStacked;
  }
};
function updateAxisOptions(targetOptions, axis, options) {
  const axesOptions = axis instanceof category_axis_default ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);
  deepExtend(axesOptions[axis.axisIndex], options);
}
function groupSeries(series, axis, axisIx) {
  return grep(series, function(s) {
    return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;
  });
}
setDefaultOptions(CategoricalPlotArea, {
  categoryAxis: {},
  valueAxis: {}
});
deepExtend(CategoricalPlotArea.prototype, plotarea_events_mixin_default);
var categorical_plotarea_default = CategoricalPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bar-chart-animation.js
var BarChartAnimation = class extends drawing_exports.Animation {
  setup() {
    const { element, options } = this;
    const bbox = element.bbox();
    if (bbox) {
      this.origin = options.origin;
      const axis = options.vertical ? Y : X;
      const fromScale = this.fromScale = new geometry_exports.Point(1, 1);
      fromScale[axis] = START_SCALE;
      element.transform(
        geometry_exports.transform().scale(fromScale.x, fromScale.y)
      );
    } else {
      this.abort();
    }
  }
  step(pos) {
    const scaleX = interpolateValue(this.fromScale.x, 1, pos);
    const scaleY = interpolateValue(this.fromScale.y, 1, pos);
    this.element.transform(
      geometry_exports.transform().scale(scaleX, scaleY, this.origin)
    );
  }
  abort() {
    super.abort();
    this.element.transform(null);
  }
};
setDefaultOptions(BarChartAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(BAR, BarChartAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bubble-animation.js
var BubbleAnimation = class extends drawing_exports.Animation {
  setup() {
    const center = this.center = this.element.bbox().center();
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, center)
    );
  }
  step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.center)
    );
  }
};
setDefaultOptions(BubbleAnimation, {
  easing: "easeOutElastic"
});
drawing_exports.AnimationFactory.current.register(BUBBLE, BubbleAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/fade-in-animation.js
var FadeInAnimation = class extends drawing_exports.Animation {
  setup() {
    this.fadeTo = this.element.opacity();
    this.element.opacity(0);
  }
  step(pos) {
    this.element.opacity(pos * this.fadeTo);
  }
};
setDefaultOptions(FadeInAnimation, {
  duration: 200,
  easing: "linear"
});
drawing_exports.AnimationFactory.current.register(FADEIN, FadeInAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/pie-animation.js
var PieAnimation = class extends drawing_exports.Animation {
  setup() {
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, this.options.center)
    );
  }
  step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.options.center)
    );
  }
};
setDefaultOptions(PieAnimation, {
  easing: "easeOutElastic",
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(PIE, PieAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/scatter-error-bar.js
var ScatterErrorBar = class extends error_bar_base_default {
  getAxis() {
    const axes = this.chart.seriesAxes(this.series);
    const axis = this.isVertical ? axes.y : axes.x;
    return axis;
  }
};
var scatter_error_bar_default = ScatterErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-chart.js
var ScatterChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  _initFields() {
    this.xAxisRanges = {};
    this.yAxisRanges = {};
    this.points = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
  }
  render() {
    this.traverseDataPoints(this.addValue.bind(this));
  }
  addErrorBar(point, field, fields) {
    const value2 = point.value[field];
    const valueErrorField = field + "Value";
    const lowField = field + "ErrorLow";
    const highField = field + "ErrorHigh";
    const { seriesIx, series } = fields;
    const errorBars = point.options.errorBars;
    const lowValue = fields[lowField];
    const highValue = fields[highField];
    if (isNumber(value2)) {
      let errorRange;
      if (isNumber(lowValue) && isNumber(highValue)) {
        errorRange = { low: lowValue, high: highValue };
      }
      if (errorBars && defined(errorBars[valueErrorField])) {
        this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };
        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new error_range_calculator_default(errorBars[valueErrorField], series, field);
        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value2, errorBars[valueErrorField]);
      }
      if (errorRange) {
        this.addPointErrorBar(errorRange, point, field);
      }
    }
  }
  addPointErrorBar(errorRange, point, field) {
    const { low, high } = errorRange;
    const { series, options: { errorBars: options } } = point;
    const isVertical = field === Y;
    const item = {};
    point[field + "Low"] = low;
    point[field + "High"] = high;
    point.errorBars = point.errorBars || [];
    const errorBar = new scatter_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars.push(errorBar);
    point.append(errorBar);
    item[field] = low;
    this.updateRange(item, series);
    item[field] = high;
    this.updateRange(item, series);
  }
  addValue(value2, fields) {
    const { x, y } = value2;
    const seriesIx = fields.seriesIx;
    const series = this.options.series[seriesIx];
    const missingValues = this.seriesMissingValues(series);
    const seriesPoints = this.seriesPoints[seriesIx];
    let pointValue = value2;
    if (!(hasValue(x) && hasValue(y))) {
      pointValue = this.createMissingValue(pointValue, missingValues);
    }
    let point;
    if (pointValue) {
      point = this.createPoint(pointValue, fields);
      if (point) {
        Object.assign(point, fields);
        this.addErrorBar(point, X, fields);
        this.addErrorBar(point, Y, fields);
      }
      this.updateRange(pointValue, fields.series);
    }
    this.points.push(point);
    seriesPoints.push(point);
  }
  seriesMissingValues(series) {
    return series.missingValues;
  }
  createMissingValue() {
  }
  updateRange(value2, series) {
    const intlService = this.chartService.intl;
    const { xAxis: xAxisName, yAxis: yAxisName } = series;
    let { x, y } = value2;
    let xAxisRange = this.xAxisRanges[xAxisName];
    let yAxisRange = this.yAxisRanges[yAxisName];
    if (hasValue(x)) {
      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString(x)) {
        x = parseDate(intlService, x);
      }
      xAxisRange.min = Math.min(xAxisRange.min, x);
      xAxisRange.max = Math.max(xAxisRange.max, x);
    }
    if (hasValue(y)) {
      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString(y)) {
        y = parseDate(intlService, y);
      }
      yAxisRange.min = Math.min(yAxisRange.min, y);
      yAxisRange.max = Math.max(yAxisRange.max, y);
    }
  }
  evalPointOptions(options, value2, fields) {
    const { series, seriesIx } = fields;
    const state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    let doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    let pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem
      }, state);
    }
    return pointOptions;
  }
  pointType() {
    return line_point_default;
  }
  pointOptions(series, seriesIx) {
    let options = this.seriesOptions[seriesIx];
    if (!options) {
      const defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options;
  }
  createPoint(value2, fields) {
    const series = fields.series;
    let pointOptions = this.pointOptions(series, fields.seriesIx);
    let color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  seriesAxes(series) {
    const { xAxis: xAxisName, yAxis: yAxisName } = series;
    const plotArea = this.plotArea;
    const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      x: xAxis,
      y: yAxis
    };
  }
  reflow(targetBox) {
    const chartPoints = this.points;
    const limit = !this.options.clip;
    let pointIx = 0;
    this.traverseDataPoints((value2, fields) => {
      const point = chartPoints[pointIx++];
      const seriesAxes = this.seriesAxes(fields.series);
      const slotX = seriesAxes.x.getSlot(value2.x, value2.x, limit);
      const slotY = seriesAxes.y.getSlot(value2.y, value2.y, limit);
      if (point) {
        if (slotX && slotY) {
          const pointSlot = this.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  }
  pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  }
  traverseDataPoints(callback) {
    const { options: { series }, seriesPoints } = this;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const currentSeriesPoints = seriesPoints[seriesIx];
      if (!currentSeriesPoints) {
        seriesPoints[seriesIx] = [];
      }
      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        const { valueFields: value2, fields } = this.plotArea.bindPoint(currentSeries, pointIx);
        callback(value2, deepExtend({
          pointIx,
          series: currentSeries,
          seriesIx,
          dataItem: currentSeries.data[pointIx],
          owner: this
        }, fields));
      }
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  }
};
setDefaultOptions(ScatterChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}"
  },
  labels: {
    format: "{0}, {1}"
  },
  clip: true
});
deepExtend(ScatterChart.prototype, clip_animation_mixin_default);
var scatter_chart_default = ScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-line-chart.js
var ScatterLineChart = class extends scatter_chart_default {
  render() {
    super.render();
    this.renderSegments();
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = currentSeries.style;
    let pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  }
  animationPoints() {
    const points = super.animationPoints();
    return points.concat(this._segments);
  }
  createMissingValue(value2, missingValues) {
    if (missingValues === ZERO) {
      const missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (!hasValue(missingValue.x)) {
        missingValue.x = 0;
      }
      if (!hasValue(missingValue.y)) {
        missingValue.y = 0;
      }
      return missingValue;
    }
  }
};
deepExtend(ScatterLineChart.prototype, line_chart_mixin_default);
var scatter_line_chart_default = ScatterLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble.js
var Bubble = class extends line_point_default {
  constructor(value2, options) {
    super(value2, options);
    this.category = value2.category;
  }
  createHighlight() {
    const highlight = this.options.highlight;
    const border = highlight.border;
    const markers = this.options.markers;
    const center = this.box.center();
    const radius = (markers.size + markers.border.width + border.width) / 2;
    const highlightGroup = new drawing_exports.Group();
    const shadow = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {
      stroke: {
        color: "none"
      },
      fill: this.createGradient({
        gradient: "bubbleShadow",
        color: markers.background,
        stops: [{
          offset: 0,
          color: markers.background,
          opacity: 0.3
        }, {
          offset: 1,
          color: markers.background,
          opacity: 0
        }]
      })
    });
    const overlay = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), {
      stroke: {
        color: border.color || new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),
        width: border.width,
        opacity: border.opacity
      },
      fill: createPatternFill(this.options.pattern, {
        color: markers.background,
        opacity: highlight.opacity
      })
    });
    highlightGroup.append(shadow, overlay);
    return highlightGroup;
  }
  createFocusHighlight(style) {
    const highlightOptions2 = this.options.focusHighlight;
    const markers = this.options.markers;
    const center = this.box.center();
    const radius = (markers.size + markers.border.width) / 2 + highlightOptions2.border.width / 2;
    const highlight = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), style);
    return highlight;
  }
};
Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {
  labels: {
    position: CENTER
  },
  highlight: {
    opacity: 1,
    border: {
      color: "#fff",
      width: 2,
      opacity: 1
    }
  }
});
Bubble.prototype.defaults.highlight.zIndex = void 0;
var bubble_default = Bubble;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble-chart.js
var BubbleChart = class extends scatter_chart_default {
  _initFields() {
    this._maxSize = MIN_VALUE;
    super._initFields();
  }
  addValue(value2, fields) {
    if (value2.size !== null && (value2.size > 0 || value2.size < 0 && fields.series.negativeValues.visible)) {
      this._maxSize = Math.max(this._maxSize, Math.abs(value2.size));
      super.addValue(value2, fields);
    } else {
      this.points.push(null);
      this.seriesPoints[fields.seriesIx].push(null);
    }
  }
  reflow(box) {
    this.updateBubblesSize(box);
    super.reflow(box);
  }
  pointType() {
    return bubble_default;
  }
  createPoint(value2, fields) {
    const series = fields.series;
    const pointsCount = series.data.length;
    const delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);
    const animationOptions = {
      delay,
      duration: INITIAL_ANIMATION_DURATION - delay,
      type: BUBBLE
    };
    let color = fields.color || series.color;
    if (value2.size < 0 && series.negativeValues.visible) {
      color = valueOrDefault(
        series.negativeValues.color,
        color
      );
    }
    let pointOptions = deepExtend({
      labels: {
        animation: {
          delay,
          duration: INITIAL_ANIMATION_DURATION - delay
        }
      }
    }, this.pointOptions(series, fields.seriesIx), {
      markers: {
        type: CIRCLE,
        border: series.border,
        opacity: series.opacity,
        animation: animationOptions
      }
    });
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.markers.background = color;
    const point = new bubble_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  updateBubblesSize(box) {
    const { options: { series } } = this;
    const boxSize = Math.min(box.width(), box.height());
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const seriesPoints = this.seriesPoints[seriesIx];
      const minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);
      const maxSize = currentSeries.maxSize || boxSize * 0.2;
      const minR = minSize / 2;
      const maxR = maxSize / 2;
      const minArea = Math.PI * minR * minR;
      const maxArea = Math.PI * maxR * maxR;
      const areaRange = maxArea - minArea;
      const areaRatio = areaRange / this._maxSize;
      for (let pointIx = 0; pointIx < seriesPoints.length; pointIx++) {
        const point = seriesPoints[pointIx];
        if (point) {
          const area = Math.abs(point.value.size) * areaRatio;
          const radius = Math.sqrt((minArea + area) / Math.PI);
          const baseZIndex = valueOrDefault(point.options.zIndex, 0);
          const zIndex = baseZIndex + (1 - radius / maxR);
          deepExtend(point.options, {
            zIndex,
            markers: {
              size: radius * 2,
              zIndex
            },
            labels: {
              zIndex: zIndex + 1
            }
          });
        }
      }
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.size, point.category);
  }
  createAnimation() {
  }
  createVisual() {
  }
};
setDefaultOptions(BubbleChart, {
  tooltip: {
    format: "{3}"
  },
  labels: {
    format: "{3}"
  }
});
var bubble_chart_default = BubbleChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-scatter-trendline-data.js
function getScatterTrendlineData(valueMapper, range, options) {
  const data = [];
  let { xMin, xMax } = range;
  const forecast = (options || {}).forecast;
  if (forecast) {
    if (forecast.before > 0) {
      xMin -= forecast.before;
    }
    if (forecast.after > 0) {
      xMax += forecast.after;
    }
  }
  const samplingInterval = (options || {}).samplingInterval;
  let delta = valueOrDefault(samplingInterval, autoMajorUnit(xMin, xMax) / 10);
  if (samplingInterval <= 0) {
    delta = xMax - xMin;
  }
  for (let x = xMin; x <= xMax; x += delta) {
    data.push([
      x,
      valueMapper(x)
    ]);
  }
  return data;
}
var get_scatter_trendline_data_default = getScatterTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-exponential-trendline.js
function scatterExponentialTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData7({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter7 = (fieldName) => ({ valueFields }) => ({ xValue: valueFields.x, yValue: Math.log(valueFields[fieldName]) });
function getData7({ seriesValues, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  let { slope, intercept, count, xMin, xMax } = calculate_slope_default(sourceValues, valueGetter7(options.field));
  const range = { xMin, xMax };
  if (count > 0) {
    const a = Math.exp(intercept);
    const b = slope;
    return get_scatter_trendline_data_default((x) => a * Math.exp(b * x), range, options.trendline);
  }
  return null;
}
var scatter_exponential_trendline_default = scatterExponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-value-getter.js
var scatterValueGetter = (fieldName) => ({ valueFields }) => ({ xValue: valueFields.x, yValue: valueFields[fieldName] });
var scatter_value_getter_default = scatterValueGetter;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-linear-trendline.js
function scatterLinearTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData8({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData8({ seriesValues, options }) {
  let { slope, intercept, count, xMin, xMax } = calculate_slope_default(seriesValues(), scatter_value_getter_default(options.field));
  const range = { xMin, xMax };
  if (count > 0) {
    return get_scatter_trendline_data_default((x) => slope * x + intercept, range, options.trendline);
  }
  return null;
}
var scatter_linear_trendline_default = scatterLinearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/x-value-limits.js
function xValueLimits(sourceValues, valueGetter10) {
  let xMin = Number.MAX_VALUE;
  let xMax = Number.MIN_VALUE;
  for (let i = 0; i < sourceValues.length; i++) {
    const value2 = sourceValues[i];
    const { xValue, yValue } = valueGetter10(value2);
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
    }
  }
  return { xMin, xMax };
}
var x_value_limits_default = xValueLimits;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-logarithmic-trendline.js
function scatterLogarithmicTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData9({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter8 = (fieldName) => ({ valueFields }) => ({ xValue: valueFields.x, yValue: valueFields[fieldName] });
var logValueGetter = (fieldName) => ({ valueFields }) => ({ xValue: Math.log(valueFields.x), yValue: valueFields[fieldName] });
function getData9({ seriesValues, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, logValueGetter(options.field));
  let range = x_value_limits_default(sourceValues, valueGetter8(options.field));
  if (count > 0) {
    const a = slope;
    const b = intercept;
    return get_scatter_trendline_data_default((x) => a * Math.log(x) + b, range, options.trendline);
  }
  return null;
}
var scatter_logarithmic_trendline_default = scatterLogarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-moving-average.js
function scatterMovingAverageTrendline(context) {
  const { options } = context;
  const data = getData10(context);
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData10({ options, seriesValues }) {
  const period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  const range = { before: period, after: period };
  const data = calculate_moving_average_default(seriesValues(range), scatter_value_getter_default(options.field), period);
  if (data.length > 0) {
    return data;
  }
  return null;
}
var scatter_moving_average_default = scatterMovingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-polynomial-trendline.js
function scatterPolynomialTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData11({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData11({ seriesValues, options }) {
  const order = (options.trendline || {}).order;
  const valueGetter10 = scatter_value_getter_default(options.field);
  const { count, valueMapper, xMin, xMax } = calculate_polynomial_default(seriesValues(), valueGetter10, order);
  const range = { xMin, xMax };
  if (count > 0) {
    return get_scatter_trendline_data_default(valueMapper, range, options.trendline);
  }
  return null;
}
var scatter_polynomial_trendline_default = scatterPolynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-power-trendline.js
function scatterPowerTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData12({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter9 = (fieldName) => ({ valueFields }) => ({ xValue: Math.log(valueFields.x), yValue: Math.log(valueFields[fieldName]) });
function getData12({ seriesValues, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, valueGetter9(options.field));
  let range = x_value_limits_default(sourceValues, scatter_value_getter_default(options.field));
  if (count > 0) {
    const a = Math.exp(intercept);
    const b = slope;
    return get_scatter_trendline_data_default((x) => a * Math.pow(x, b), range, options.trendline);
  }
  return null;
}
var scatter_power_trendline_default = scatterPowerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-trendline-registry.js
var scatterRegistry = {};
scatterRegistry[TRENDLINE_EXPONENTIAL] = scatter_exponential_trendline_default;
scatterRegistry[TRENDLINE_LINEAR] = scatter_linear_trendline_default;
scatterRegistry[TRENDLINE_LOGARITHMIC] = scatter_logarithmic_trendline_default;
scatterRegistry[TRENDLINE_MOVING_AVERAGE] = scatter_moving_average_default;
scatterRegistry[TRENDLINE_POLYNOMIAL] = scatter_polynomial_trendline_default;
scatterRegistry[TRENDLINE_POWER] = scatter_power_trendline_default;
var scatter_trendline_registry_default = scatterRegistry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/xy-plotarea.js
var XYPlotArea = class extends plotarea_base_default {
  initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
    this.xAxisRangeTracker = new axis_group_range_tracker_default();
    this.yAxisRangeTracker = new axis_group_range_tracker_default();
  }
  render(panes = this.panes) {
    this.series = [...this.originalSeries];
    this.createTrendlineSeries();
    const seriesByPane = this.groupSeriesByPane();
    for (let i = 0; i < panes.length; i++) {
      const pane = panes[i];
      const paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this.addToLegend(paneSeries);
      const filteredSeries = this.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this.createScatterChart(
        filterSeriesByType(filteredSeries, SCATTER),
        pane
      );
      this.createScatterLineChart(
        filterSeriesByType(filteredSeries, SCATTER_LINE),
        pane
      );
      this.createBubbleChart(
        filterSeriesByType(filteredSeries, BUBBLE),
        pane
      );
    }
    this.createAxes(panes);
  }
  appendChart(chart, pane) {
    this.xAxisRangeTracker.update(chart.xAxisRanges);
    this.yAxisRangeTracker.update(chart.yAxisRanges);
    super.appendChart(chart, pane);
  }
  removeAxis(axis) {
    const axisName = axis.options.name;
    super.removeAxis(axis);
    if (axis.options.vertical) {
      this.yAxisRangeTracker.reset(axisName);
      delete this.namedYAxes[axisName];
    } else {
      this.xAxisRangeTracker.reset(axisName);
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  }
  // TODO: Refactor, optionally use series.pane option
  seriesPaneName(series) {
    const options = this.options;
    const xAxisName = series.xAxis;
    const xAxisOptions = [].concat(options.xAxis);
    const xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    const yAxisName = series.yAxis;
    const yAxisOptions = [].concat(options.yAxis);
    const yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    const panes = options.panes || [{}];
    const defaultPaneName = panes[0].name || "default";
    const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  }
  createScatterChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  }
  createScatterLineChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_line_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  }
  createBubbleChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new bubble_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  }
  createXYAxis(options, vertical, axisIndex) {
    const axisName = options.name;
    const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    const tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;
    const axisOptions2 = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical });
    const isLog = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC);
    const defaultRange = tracker.query();
    const defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
    const range = tracker.query(axisName) || defaultRange || defaultAxisRange;
    const typeSamples = [axisOptions2.min, axisOptions2.max];
    const series = this.series;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        const firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    if (axisIndex === 0 && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    let inferredDate;
    for (let i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    let axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_value_axis_default;
    } else if (isLog) {
      axisType = logarithmic_axis_default;
    } else {
      axisType = numeric_axis_default;
    }
    const axis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error(`${vertical ? "Y" : "X"} axis with name ${axisName} is already defined`);
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    return axis;
  }
  createAxes(panes) {
    const options = this.options;
    const xAxesOptions = [].concat(options.xAxis);
    const xAxes = [];
    const yAxesOptions = [].concat(options.yAxis);
    const yAxes = [];
    for (let idx = 0; idx < xAxesOptions.length; idx++) {
      const axisPane = this.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (let idx = 0; idx < yAxesOptions.length; idx++) {
      const axisPane = this.findPane(yAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  }
  _dispatchEvent(chart, e, eventType) {
    const coords = chart._eventCoordinates(e);
    const point = new point_default(coords.x, coords.y);
    const allAxes = this.axes;
    const length = allAxes.length;
    const xValues = [];
    const yValues = [];
    for (let i = 0; i < length; i++) {
      const axis = allAxes[i];
      const values = axis.options.vertical ? yValues : xValues;
      const currentValue = axis.getValue(point);
      if (currentValue !== null) {
        values.push(currentValue);
      }
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  }
  updateAxisOptions(axis, options) {
    const vertical = axis.options.vertical;
    const axes = this.groupAxes(this.panes);
    const index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions2(this.options, index, vertical, options);
    updateAxisOptions2(this.originalOptions, index, vertical, options);
  }
  trendlineFactory(options, series) {
    const seriesValues = this.seriesValues.bind(this, series.index);
    const trendline = trendline_factory_default(scatter_trendline_registry_default, options.type, {
      options,
      seriesValues
    });
    if (trendline) {
      trendline.xAxis = series.xAxis;
      trendline.yAxis = series.yAxis;
    }
    return trendline;
  }
  seriesValues(seriesIx) {
    const result = [];
    const currentSeries = this.series[seriesIx];
    for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
      const data = this.bindPoint(currentSeries, pointIx);
      result.push({ pointIx, valueFields: data.valueFields });
    }
    return result;
  }
};
function updateAxisOptions2(targetOptions, axisIndex, vertical, options) {
  const axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(XYPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(XYPlotArea.prototype, plotarea_events_mixin_default);
var xy_plotarea_default = XYPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-segment.js
var PieSegment = class extends chart_element_default {
  constructor(value2, sector, options) {
    super(options);
    this.value = value2;
    this.sector = sector;
  }
  render() {
    if (this._rendered || this.visible === false) {
      return;
    }
    this._rendered = true;
    this.createLabel();
  }
  createLabel() {
    const labels = this.options.labels;
    const chartService = this.owner.chartService;
    let labelText = this.getLabelText(labels);
    if (labels.visible && (labelText || labelText === 0)) {
      if (labels.position === CENTER || labels.position === INSIDE_END) {
        if (!labels.color) {
          labels.color = auto_text_color_default(this.options.color);
        }
        if (!labels.background) {
          labels.background = this.options.color;
        }
      } else {
        const themeLabels = chartService.theme.seriesDefaults.labels;
        labels.color = labels.color || themeLabels.color;
        labels.background = labels.background || themeLabels.background;
      }
      this.label = new text_box_default(labelText, deepExtend({}, labels, {
        align: CENTER,
        vAlign: "",
        animation: {
          type: FADEIN,
          delay: this.animationDelay
        }
      }), this.pointData());
      this.append(this.label);
    }
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.owner.chartService.format.auto(options.format, this.value);
  }
  reflow(targetBox) {
    this.render();
    this.box = targetBox;
    this.reflowLabel();
  }
  reflowLabel() {
    const { options: { labels: labelsOptions }, label } = this;
    const sector = this.sector.clone();
    const labelsDistance = labelsOptions.distance;
    const angle = sector.middle();
    if (label) {
      const labelHeight = label.box.height();
      const labelWidth = label.box.width();
      let lp;
      if (labelsOptions.position === CENTER) {
        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else if (labelsOptions.position === INSIDE_END) {
        sector.radius = sector.radius - labelHeight / 2;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        let x1;
        lp = sector.clone().expand(labelsDistance).point(angle);
        if (lp.x >= sector.center.x) {
          x1 = lp.x + labelWidth;
          label.orientation = RIGHT;
        } else {
          x1 = lp.x - labelWidth;
          label.orientation = LEFT;
        }
        label.reflow(new box_default(x1, lp.y - labelHeight, lp.x, lp.y));
      }
    }
  }
  createVisual() {
    const { sector, options } = this;
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    if (this.value) {
      if (options.visual) {
        const startAngle = (sector.startAngle + 180) % 360;
        const visual = options.visual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          series: this.series,
          percentage: this.percentage,
          center: new geometry_exports.Point(sector.center.x, sector.center.y),
          radius: sector.radius,
          innerRadius: sector.innerRadius,
          startAngle,
          endAngle: startAngle + sector.angle,
          options,
          sender: this.getSender(),
          createVisual: () => {
            const group = new drawing_exports.Group();
            this.createSegmentVisual(group);
            return group;
          }
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else {
        this.createSegmentVisual(this.visual);
      }
    }
  }
  createSegmentVisual(group) {
    const { sector, options } = this;
    const borderOptions = options.border || {};
    const border = borderOptions.width > 0 ? {
      stroke: {
        color: borderOptions.color,
        width: borderOptions.width,
        opacity: borderOptions.opacity,
        dashType: borderOptions.dashType
      }
    } : {};
    const color = options.color;
    const fill = createPatternFill(options.pattern, {
      color,
      opacity: options.opacity
    });
    const visual = this.createSegment(sector, deepExtend({
      fill,
      stroke: {
        opacity: options.opacity
      },
      zIndex: options.zIndex
    }, border));
    group.append(visual);
    if (hasGradientOverlay(options)) {
      group.append(this.createGradientOverlay(visual, {
        baseColor: color,
        fallbackFill: fill
      }, deepExtend({
        center: [sector.center.x, sector.center.y],
        innerRadius: sector.innerRadius,
        radius: sector.radius,
        userSpace: true
      }, options.overlay)));
    }
  }
  createSegment(sector, options) {
    if (options.singleSegment) {
      return new drawing_exports.Circle(new geometry_exports.Circle(new geometry_exports.Point(sector.center.x, sector.center.y), sector.radius), options);
    }
    return shape_builder_default.current.createRing(sector, options);
  }
  createAnimation() {
    const { options, sector: { center } } = this;
    deepExtend(options, {
      animation: {
        center: [center.x, center.y],
        delay: this.animationDelay
      }
    });
    super.createAnimation();
  }
  createHighlight(options) {
    const highlight = this.options.highlight || {};
    const border = highlight.border || {};
    return this.createSegment(this.sector, deepExtend({}, options, {
      fill: {
        color: highlight.color,
        opacity: highlight.opacity
      },
      stroke: {
        opacity: border.opacity,
        width: border.width,
        color: border.color
      }
    }));
  }
  highlightVisual() {
    return this.visual.children[0];
  }
  highlightVisualArgs() {
    const sector = this.sector;
    return {
      options: this.options,
      radius: sector.radius,
      innerRadius: sector.innerRadius,
      center: new geometry_exports.Point(sector.center.x, sector.center.y),
      startAngle: sector.startAngle,
      endAngle: sector.angle + sector.startAngle,
      visual: this.visual
    };
  }
  createFocusHighlight(style) {
    const borderWidth = this.options.focusHighlight.border.width;
    const result = this.createSegment(this.sector, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    }));
    const clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(result.bbox()));
    clipPath.paths.push(this.createSegment(this.sector, {}));
    result.clip(clipPath);
    return result;
  }
  tooltipAnchor() {
    const sector = this.sector.clone().expand(TOOLTIP_OFFSET);
    const midAndle = sector.middle();
    const midPoint = sector.point(midAndle);
    return {
      point: midPoint,
      align: tooltipAlignment(midAndle + 180)
    };
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  }
  getIndex() {
    return this.index;
  }
};
var RAD_30 = round(rad(30), DEFAULT_PRECISION);
var RAD_60 = round(rad(60), DEFAULT_PRECISION);
function tooltipAlignment(angle) {
  const radians = rad(angle);
  const sine = round(Math.sin(radians), DEFAULT_PRECISION);
  const cosine = round(Math.cos(radians), DEFAULT_PRECISION);
  let horizontal;
  if (Math.abs(sine) > RAD_60) {
    horizontal = CENTER;
  } else if (cosine < 0) {
    horizontal = RIGHT;
  } else {
    horizontal = LEFT;
  }
  let vertical;
  if (Math.abs(sine) < RAD_30) {
    vertical = CENTER;
  } else if (sine < 0) {
    vertical = BOTTOM;
  } else {
    vertical = TOP;
  }
  return {
    horizontal,
    vertical
  };
}
setDefaultOptions(PieSegment, {
  color: WHITE,
  overlay: {
    gradient: "roundedBevel"
  },
  border: {
    width: 0.5
  },
  labels: {
    visible: false,
    distance: 35,
    font: DEFAULT_FONT,
    margin: getSpacing(0.5),
    align: CIRCLE,
    zIndex: 1,
    position: OUTSIDE_END
  },
  animation: {
    type: PIE
  },
  highlight: {
    visible: true,
    border: {
      width: 1
    }
  },
  visible: true,
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(PieSegment.prototype, point_events_mixin_default);
deepExtend(PieSegment.prototype, accessibility_attributes_mixin_default);
var pie_segment_default = PieSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/pie-chart-mixin.js
var PieChartMixin = {
  createLegendItem: function(value2, point, options) {
    const legendOptions = this.options.legend || {};
    const labelsOptions = legendOptions.labels || {};
    const inactiveItems = legendOptions.inactiveItems || {};
    const inactiveItemsLabels = inactiveItems.labels || {};
    if (options && options.visibleInLegend !== false) {
      const pointVisible = options.visible !== false;
      const labelTemplate = pointVisible ? getTemplate(labelsOptions) : getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);
      let text = options.category;
      if (labelTemplate) {
        text = labelTemplate({
          text,
          series: options.series,
          dataItem: options.dataItem,
          percentage: options.percentage,
          value: value2
        });
      }
      let itemLabelOptions, markerColor;
      if (pointVisible) {
        itemLabelOptions = {};
        markerColor = point.color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = (inactiveItems.markers || {}).color;
      }
      if (hasValue(text) && text !== "") {
        this.legendItems.push({
          active: pointVisible,
          pointIndex: options.index,
          text,
          series: options.series,
          markerColor,
          pattern: point.pattern,
          labels: itemLabelOptions
        });
      }
    }
  }
};
var pie_chart_mixin_default = PieChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js
var PIE_SECTOR_ANIM_DELAY = 70;
var PieChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.legendItems = [];
    this.render();
  }
  render() {
    this.traverseDataPoints(this.addValue.bind(this));
  }
  traverseDataPoints(callback) {
    const { options, plotArea: { options: { seriesColors = [] } } } = this;
    const colorsCount = seriesColors.length;
    const series = options.series;
    const seriesCount = series.length;
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      const currentSeries = series[seriesIx];
      const data = currentSeries.data;
      const { total, points, count } = bindSegments(currentSeries);
      const anglePerValue = 360 / total;
      let constantAngle;
      if (!isFinite(anglePerValue)) {
        constantAngle = 360 / count;
      }
      let currentAngle;
      if (defined(currentSeries.startAngle)) {
        currentAngle = currentSeries.startAngle;
      } else {
        currentAngle = options.startAngle;
      }
      if (seriesIx !== seriesCount - 1) {
        if (currentSeries.labels.position === OUTSIDE_END) {
          currentSeries.labels.position = CENTER;
        }
      }
      for (let i = 0; i < points.length; i++) {
        const pointData = points[i];
        if (!pointData) {
          continue;
        }
        const { fields, value: value2, visible } = pointData;
        const angle = value2 !== 0 ? constantAngle || value2 * anglePerValue : 0;
        const explode = data.length !== 1 && Boolean(fields.explode);
        if (!isFunction(currentSeries.color)) {
          currentSeries.color = fields.color || seriesColors[i % colorsCount];
        }
        callback(value2, new ring_default(null, 0, 0, currentAngle, angle), {
          owner: this,
          category: defined(fields.category) ? fields.category : "",
          pattern: defined(fields.pattern) ? fields.pattern : currentSeries.pattern,
          index: i,
          series: currentSeries,
          seriesIx,
          dataItem: data[i],
          percentage: total !== 0 ? value2 / total : 0,
          explode,
          visibleInLegend: fields.visibleInLegend,
          visible,
          zIndex: seriesCount - seriesIx,
          animationDelay: this.animationDelay(i, seriesIx, seriesCount)
        });
        if (visible !== false) {
          currentAngle += angle;
        }
      }
    }
  }
  evalSegmentOptions(options, value2, fields) {
    const series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      category: fields.category,
      percentage: fields.percentage
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "visual",
      "toggle",
      "ariaTemplate",
      "ariaContent"
    ] });
  }
  addValue(value2, sector, fields) {
    const segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    segmentOptions.pattern = fields.pattern || segmentOptions.pattern;
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    const segment = new pie_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  }
  reflow(targetBox) {
    const { options, points, seriesConfigs = [] } = this;
    const count = points.length;
    const box = targetBox.clone();
    const space = 5;
    const minWidth = Math.min(box.width(), box.height());
    const halfMinWidth = minWidth / 2;
    const defaultPadding = minWidth - minWidth * 0.85;
    const newBox = new box_default(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
    const newBoxCenter = newBox.center();
    const boxCenter = box.center();
    const seriesCount = options.series.length;
    const leftSideLabels = [];
    const rightSideLabels = [];
    let padding = valueOrDefault(options.padding, defaultPadding);
    this.targetBox = targetBox;
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);
    const radius = halfMinWidth - padding;
    const center = new point_default(
      radius + newBox.x1 + padding,
      radius + newBox.y1 + padding
    );
    for (let i = 0; i < count; i++) {
      const segment = points[i];
      const sector = segment.sector;
      const seriesIndex = segment.seriesIx;
      sector.radius = radius;
      sector.center = center;
      if (seriesConfigs.length) {
        const seriesConfig = seriesConfigs[seriesIndex];
        sector.innerRadius = seriesConfig.innerRadius;
        sector.radius = seriesConfig.radius;
      }
      if (seriesIndex === seriesCount - 1 && segment.explode) {
        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
      }
      segment.reflow(newBox);
      const label = segment.label;
      if (label) {
        if (label.options.position === OUTSIDE_END) {
          if (seriesIndex === seriesCount - 1) {
            if (label.orientation === RIGHT) {
              rightSideLabels.push(label);
            } else {
              leftSideLabels.push(label);
            }
          }
        }
      }
    }
    if (leftSideLabels.length > 0) {
      leftSideLabels.sort(this.labelComparator(true));
      this.leftLabelsReflow(leftSideLabels);
    }
    if (rightSideLabels.length > 0) {
      rightSideLabels.sort(this.labelComparator(false));
      this.rightLabelsReflow(rightSideLabels);
    }
    this.box = newBox;
  }
  leftLabelsReflow(labels) {
    const distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  }
  rightLabelsReflow(labels) {
    const distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  }
  distanceBetweenLabels(labels) {
    const segment = last(this.points);
    const sector = segment.sector;
    const count = labels.length - 1;
    const lr = sector.radius + segment.options.labels.distance;
    const distances = [];
    let firstBox = labels[0].box;
    let distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));
    distances.push(distance);
    for (let i = 0; i < count; i++) {
      const secondBox = labels[i + 1].box;
      firstBox = labels[i].box;
      distance = round(secondBox.y1 - firstBox.y2);
      distances.push(distance);
    }
    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
    distances.push(distance);
    return distances;
  }
  distributeLabels(distances, labels) {
    const count = distances.length;
    let left, right, remaining;
    for (let i = 0; i < count; i++) {
      remaining = -distances[i];
      left = right = i;
      while (remaining > 0 && (left >= 0 || right < count)) {
        remaining = this._takeDistance(distances, i, --left, remaining);
        remaining = this._takeDistance(distances, i, ++right, remaining);
      }
    }
    this.reflowLabels(distances, labels);
  }
  _takeDistance(distances, anchor, position, amount) {
    let result = amount;
    if (distances[position] > 0) {
      const available = Math.min(distances[position], result);
      result -= available;
      distances[position] -= available;
      distances[anchor] += available;
    }
    return result;
  }
  reflowLabels(distances, labels) {
    const segment = last(this.points);
    const sector = segment.sector;
    const labelOptions = segment.options.labels;
    const labelsCount = labels.length;
    const labelDistance = labelOptions.distance;
    let boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
    let boxX;
    distances[0] += 2;
    for (let i = 0; i < labelsCount; i++) {
      const label = labels[i];
      const box = label.box;
      boxY += distances[i];
      boxX = this.hAlignLabel(
        box.x2,
        sector.clone().expand(labelDistance),
        boxY,
        boxY + box.height(),
        label.orientation === RIGHT
      );
      if (label.orientation === RIGHT) {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.radius + sector.center.x + labelDistance;
        }
        label.reflow(new box_default(boxX + box.width(), boxY, boxX, boxY));
      } else {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.center.x - sector.radius - labelDistance;
        }
        label.reflow(new box_default(boxX - box.width(), boxY, boxX, boxY));
      }
      boxY += box.height();
    }
  }
  createVisual() {
    const { options: { connectors }, points } = this;
    const count = points.length;
    const space = 4;
    super.createVisual();
    this._connectorLines = [];
    for (let i = 0; i < count; i++) {
      const segment = points[i];
      const { sector, label } = segment;
      const angle = sector.middle();
      const connectorsColor = (segment.options.connectors || {}).color || connectors.color;
      if (label) {
        const connectorLine = new drawing_exports.Path({
          stroke: {
            color: connectorsColor,
            width: connectors.width
          },
          animation: {
            type: FADEIN,
            delay: segment.animationDelay
          }
        });
        if (label.options.position === OUTSIDE_END) {
          const box = label.box;
          const centerPoint = sector.center;
          let start = sector.point(angle);
          let middle = new point_default(box.x1, box.center().y);
          let sr, end, crossing;
          start = sector.clone().expand(connectors.padding).point(angle);
          connectorLine.moveTo(start.x, start.y);
          if (label.orientation === RIGHT) {
            end = new point_default(box.x1 - connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x - space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.min(crossing.x, middle.x);
            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
              sr = sector.center.x + sector.radius + space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr < middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x + space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          } else {
            end = new point_default(box.x2 + connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x + space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.max(crossing.x, middle.x);
            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
              sr = sector.center.x - sector.radius - space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr > middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x - space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          }
          connectorLine.lineTo(end.x, end.y);
          this._connectorLines.push(connectorLine);
          this.visual.append(connectorLine);
        }
      }
    }
  }
  renderVisual() {
    super.renderVisual();
    if (find(this.options.series, (options) => options.autoFit)) {
      const targetBox = this.targetBox;
      const pieCenter = this.box.center();
      const bbox = this.visual.bbox();
      if (!bbox) {
        return;
      }
      const bboxBottom = bbox.bottomRight();
      const scale = Math.min(
        (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),
        (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),
        (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),
        (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)
      );
      if (scale < 1) {
        this.visual.transform(geometry_exports.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));
      }
    }
  }
  labelComparator(reverse) {
    const reverseValue = reverse ? -1 : 1;
    return function(a, b) {
      const first = (a.parent.sector.middle() + 270) % 360;
      const second = (b.parent.sector.middle() + 270) % 360;
      return (first - second) * reverseValue;
    };
  }
  hAlignLabel(originalX, sector, y1, y2, direction) {
    const { radius, center: { x: cx, y: cy } } = sector;
    const t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));
    if (t > radius) {
      return originalX;
    }
    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);
  }
  pointInCircle(point, center, radius) {
    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);
  }
  formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value);
  }
  animationDelay(categoryIndex) {
    return categoryIndex * PIE_SECTOR_ANIM_DELAY;
  }
  stackRoot() {
    return this;
  }
};
function intersection(a1, a2, b1, b2) {
  const uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  const ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
  let result;
  if (ub !== 0) {
    const ua = uat / ub;
    result = new point_default(
      a1.x + ua * (a2.x - a1.x),
      a1.y + ua * (a2.y - a1.y)
    );
  }
  return result;
}
setDefaultOptions(PieChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  },
  inactiveItems: {
    markers: {},
    labels: {}
  }
});
deepExtend(PieChart.prototype, pie_chart_mixin_default);
PieChart.prototype.isStackRoot = true;
var pie_chart_default = PieChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/pie-plotarea.js
var PiePlotArea = class extends plotarea_base_default {
  render() {
    this.createPieChart(this.series);
  }
  createPieChart(series) {
    const firstSeries = series[0];
    const pieChart = new pie_chart_default(this, {
      series,
      padding: firstSeries.padding,
      startAngle: firstSeries.startAngle,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(pieChart);
  }
  appendChart(chart, pane) {
    super.appendChart(chart, pane);
    append(this.options.legend.data, chart.legendItems);
  }
  getPointBelow(point) {
    return this.getPointToTheRight(point);
  }
  getPointAbove(point) {
    return this.getPointToTheLeft(point);
  }
};
var pie_plotarea_default = PiePlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-segment.js
var DonutSegment = class extends pie_segment_default {
  reflowLabel() {
    const { options: { labels: labelsOptions }, label } = this;
    const sector = this.sector.clone();
    const angle = sector.middle();
    if (label) {
      const labelHeight = label.box.height();
      if (labelsOptions.position === CENTER) {
        sector.radius -= (sector.radius - sector.innerRadius) / 2;
        const lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        super.reflowLabel();
      }
    }
  }
  createSegment(sector, options) {
    return shape_builder_default.current.createRing(sector, options);
  }
};
setDefaultOptions(DonutSegment, {
  overlay: {
    gradient: "roundedGlass"
  },
  labels: {
    position: CENTER
  },
  animation: {
    type: PIE
  }
});
deepExtend(DonutSegment.prototype, point_events_mixin_default);
var donut_segment_default = DonutSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-chart.js
var DONUT_SECTOR_ANIM_DELAY = 50;
var DonutChart = class extends pie_chart_default {
  addValue(value2, sector, fields) {
    const segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    segmentOptions.pattern = fields.pattern || segmentOptions.pattern;
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    const segment = new donut_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  }
  reflow(targetBox) {
    const options = this.options;
    const box = targetBox.clone();
    const space = 5;
    const minWidth = Math.min(box.width(), box.height());
    const halfMinWidth = minWidth / 2;
    const defaultPadding = minWidth - minWidth * 0.85;
    const series = options.series;
    const seriesCount = series.length;
    let padding = valueOrDefault(options.padding, defaultPadding);
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    let totalSize = halfMinWidth - padding;
    let seriesWithoutSize = 0;
    let holeSize;
    for (let i = 0; i < seriesCount; i++) {
      const currentSeries = series[i];
      if (i === 0) {
        if (defined(currentSeries.holeSize)) {
          holeSize = currentSeries.holeSize;
          totalSize -= currentSeries.holeSize;
        }
      }
      if (defined(currentSeries.size)) {
        totalSize -= currentSeries.size;
      } else {
        seriesWithoutSize++;
      }
      if (defined(currentSeries.margin) && i !== seriesCount - 1) {
        totalSize -= currentSeries.margin;
      }
    }
    if (!defined(holeSize)) {
      const currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);
      holeSize = currentSize * 0.75;
      totalSize -= holeSize;
    }
    let innerRadius = holeSize;
    let margin = 0;
    let size, radius;
    this.seriesConfigs = [];
    for (let i = 0; i < seriesCount; i++) {
      const currentSeries = series[i];
      size = valueOrDefault(currentSeries.size, totalSize / seriesWithoutSize);
      innerRadius += margin;
      radius = innerRadius + size;
      this.seriesConfigs.push({ innerRadius, radius });
      margin = currentSeries.margin || 0;
      innerRadius = radius;
    }
    super.reflow(targetBox);
  }
  animationDelay(categoryIndex, seriesIndex, seriesCount) {
    return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);
  }
};
setDefaultOptions(DonutChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  }
});
var donut_chart_default = DonutChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/donut-plotarea.js
var DonutPlotArea = class extends pie_plotarea_default {
  render() {
    this.createDonutChart(this.series);
  }
  createDonutChart(series) {
    const firstSeries = series[0];
    const donutChart = new donut_chart_default(this, {
      series,
      padding: firstSeries.padding,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(donutChart);
  }
  // These were overriden in the Pie, so revert to original behavior
  getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  }
  getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  }
};
var donut_plotarea_default = DonutPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea-base.js
var DEFAULT_PADDING = 0.15;
var PolarPlotAreaBase = class extends plotarea_base_default {
  initFields() {
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
  }
  render() {
    this.addToLegend(this.series);
    this.createPolarAxis();
    this.createCharts();
    this.createValueAxis();
  }
  alignAxes() {
    const axis = this.valueAxis;
    const range = axis.range();
    const crossingValue = axis.options.reverse ? range.max : range.min;
    const slot = axis.getSlot(crossingValue);
    const center = this.polarAxis.getSlot(0).center;
    const axisBox = axis.box.translate(
      center.x - slot.x1,
      center.y - slot.y1
    );
    axis.reflow(axisBox);
  }
  createValueAxis() {
    const tracker = this.valueAxisRangeTracker;
    const defaultRange = tracker.query();
    const axisOptions2 = this.valueAxisOptions({
      roundToMajorUnit: false,
      zIndex: -1
    });
    let axisType, axisDefaultRange;
    if (axisOptions2.type === LOGARITHMIC) {
      axisType = radar_logarithmic_axis_default;
      axisDefaultRange = { min: 0.1, max: 1 };
    } else {
      axisType = radar_numeric_axis_default;
      axisDefaultRange = { min: 0, max: 1 };
    }
    const range = defaultRange || axisDefaultRange;
    const valueAxis = new axisType(
      range.min,
      range.max,
      axisOptions2,
      this.chartService
    );
    this.valueAxis = valueAxis;
    this.appendAxis(valueAxis);
  }
  reflowAxes() {
    const { options: { plotArea: options }, valueAxis, polarAxis, box } = this;
    const defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;
    const padding = getSpacing(options.padding || {}, defaultPadding);
    const paddingBox = box.clone().unpad(padding);
    const axisBox = paddingBox.clone();
    axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());
    axisBox.align(paddingBox, Y, CENTER);
    const valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);
    polarAxis.reflow(axisBox);
    valueAxis.reflow(valueAxisBox);
    const heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();
    valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));
    this.axisBox = axisBox;
    this.alignAxes(axisBox);
  }
  backgroundBox() {
    return this.box;
  }
  detachLabels() {
  }
};
var polar_plotarea_base_default = PolarPlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-scatter-chart/polar-scatter-chart.js
var PolarScatterChart = class extends scatter_chart_default {
  pointSlot(slotX, slotY) {
    const valueRadius = slotX.center.y - slotY.y1;
    const slot = point_default.onCircle(slotX.center, slotX.startAngle, valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  }
};
setDefaultOptions(PolarScatterChart, {
  clip: false
});
var polar_scatter_chart_default = PolarScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-line-chart/polar-line-chart.js
var PolarLineChart = class extends scatter_line_chart_default {
};
PolarLineChart.prototype.pointSlot = polar_scatter_chart_default.prototype.pointSlot;
setDefaultOptions(PolarLineChart, {
  clip: false
});
var polar_line_chart_default = PolarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/spline-polar-area-segment.js
var SplinePolarAreaSegment = class extends spline_area_segment_default {
  fillToAxes(fillPath) {
    const center = this._polarAxisCenter();
    fillPath.lineTo(center.x, center.y);
  }
  _polarAxisCenter() {
    const polarAxis = this.parent.plotArea.polarAxis;
    const center = polarAxis.box.center();
    return center;
  }
  strokeSegments() {
    let segments = this._strokeSegments;
    if (!segments) {
      const center = this._polarAxisCenter();
      const curveProcessor = new curve_processor_default(false);
      const linePoints = this.points();
      linePoints.push(center);
      segments = this._strokeSegments = curveProcessor.process(linePoints);
      segments.pop();
    }
    return segments;
  }
};
var spline_polar_area_segment_default = SplinePolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-segment.js
var PolarAreaSegment = class extends area_segment_default {
  fillToAxes(fillPath) {
    const polarAxis = this.parent.plotArea.polarAxis;
    const center = polarAxis.box.center();
    const centerSegment = new geometry_exports.Segment([center.x, center.y]);
    fillPath.segments.unshift(centerSegment);
    fillPath.segments.push(centerSegment);
  }
};
var polar_area_segment_default = PolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-chart.js
var PolarAreaChart = class extends polar_line_chart_default {
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = (currentSeries.line || {}).style;
    let segment;
    if (style === SMOOTH) {
      segment = new spline_polar_area_segment_default(linePoints, currentSeries, seriesIx);
    } else {
      segment = new polar_area_segment_default(linePoints, currentSeries, seriesIx);
    }
    return segment;
  }
  createMissingValue(value2, missingValues) {
    let missingValue;
    if (hasValue(value2.x) && missingValues !== INTERPOLATE) {
      missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (missingValues === ZERO) {
        missingValue.y = 0;
      }
    }
    return missingValue;
  }
  seriesMissingValues(series) {
    return series.missingValues || ZERO;
  }
  _hasMissingValuesGap() {
    const series = this.options.series;
    for (let idx = 0; idx < series.length; idx++) {
      if (this.seriesMissingValues(series[idx]) === GAP) {
        return true;
      }
    }
  }
  sortPoints(points) {
    points.sort(xComparer);
    if (this._hasMissingValuesGap()) {
      for (let idx = 0; idx < points.length; idx++) {
        const point = points[idx];
        if (point) {
          const value2 = point.value;
          if (!hasValue(value2.y) && this.seriesMissingValues(point.series) === GAP) {
            delete points[idx];
          }
        }
      }
    }
    return points;
  }
};
function xComparer(a, b) {
  return a.value.x - b.value.x;
}
var polar_area_chart_default = PolarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea.js
var PolarPlotArea = class extends polar_plotarea_base_default {
  createPolarAxis() {
    const polarAxis = new polar_axis_default(this.options.xAxis, this.chartService);
    this.polarAxis = polarAxis;
    this.axisX = polarAxis;
    this.appendAxis(polarAxis);
  }
  render() {
    this.series = [...this.originalSeries];
    this.createTrendlineSeries();
    super.render();
  }
  valueAxisOptions(defaults) {
    return deepExtend(defaults, {
      majorGridLines: { type: ARC },
      minorGridLines: { type: ARC }
    }, this.options.yAxis);
  }
  createValueAxis() {
    super.createValueAxis();
    this.axisY = this.valueAxis;
  }
  trendlineFactory(options, series) {
    const trendline = xy_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = POLAR_LINE;
    }
    return trendline;
  }
  appendChart(chart, pane) {
    this.valueAxisRangeTracker.update(chart.yAxisRanges);
    plotarea_base_default.prototype.appendChart.call(this, chart, pane);
  }
  createCharts() {
    const series = this.filterVisibleSeries(this.series);
    const pane = this.panes[0];
    this.createLineChart(
      filterSeriesByType(series, [POLAR_LINE]),
      pane
    );
    this.createScatterChart(
      filterSeriesByType(series, [POLAR_SCATTER]),
      pane
    );
    this.createAreaChart(
      filterSeriesByType(series, [POLAR_AREA]),
      pane
    );
  }
  createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const lineChart = new polar_line_chart_default(this, { series });
    this.appendChart(lineChart, pane);
  }
  createScatterChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const scatterChart = new polar_scatter_chart_default(this, { series });
    this.appendChart(scatterChart, pane);
  }
  createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const areaChart = new polar_area_chart_default(this, { series });
    this.appendChart(areaChart, pane);
  }
  _dispatchEvent(chart, e, eventType) {
    const coords = chart._eventCoordinates(e);
    const point = new point_default(coords.x, coords.y);
    const xValue = this.axisX.getValue(point);
    const yValue = this.axisY.getValue(point);
    if (xValue !== null && yValue !== null) {
      chart.trigger(eventType, {
        element: eventElement(e),
        x: xValue,
        y: yValue
      });
    }
  }
  createCrosshairs() {
  }
};
setDefaultOptions(PolarPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(PolarPlotArea.prototype, plotarea_events_mixin_default, {
  seriesValues: xy_plotarea_default.prototype.seriesValues
});
var polar_plotarea_default = PolarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-line-chart/radar-line-chart.js
function groupBySeriesIx(segments) {
  const seriesSegments = [];
  for (let idx = 0; idx < segments.length; idx++) {
    const segment = segments[idx];
    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];
    seriesSegments[segment.seriesIx].push(segment);
  }
  return seriesSegments;
}
var RadarLineChart = class extends line_chart_default {
  pointSlot(categorySlot, valueSlot) {
    const valueRadius = categorySlot.center.y - valueSlot.y1;
    const slot = point_default.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  }
  renderSegments() {
    super.renderSegments();
    if (this._segments && this._segments.length > 1) {
      const seriesSegments = groupBySeriesIx(this._segments);
      for (let idx = 0; idx < seriesSegments.length; idx++) {
        const segments = seriesSegments[idx];
        if (segments && segments.length > 1) {
          const firstPoint = segments[0].linePoints[0];
          const lastSegment = last(segments);
          const lastPoint = last(lastSegment.linePoints);
          const isFirstDataPoint = firstPoint.categoryIx === 0;
          const isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;
          if (isFirstDataPoint && isLastDataPoint) {
            last(segments).linePoints.push(firstPoint);
          }
        }
      }
    }
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = currentSeries.style;
    let pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    const segment = new pointType(linePoints, currentSeries, seriesIx);
    const missingValues = this.seriesMissingValues(currentSeries);
    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {
      segment.options.closed = true;
    }
    return segment;
  }
};
setDefaultOptions(RadarLineChart, {
  clip: false,
  limitPoints: false
});
var radar_line_chart_default = RadarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/spline-radar-area-segment.js
var SplineRadarAreaSegment = class extends spline_area_segment_default {
  fillToAxes() {
  }
};
var spline_radar_area_segment_default = SplineRadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-segment.js
var RadarAreaSegment = class extends area_segment_default {
  fillToAxes() {
  }
};
var radar_area_segment_default = RadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-chart.js
var RadarAreaChart = class extends radar_line_chart_default {
  createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    const isStacked = this.options.isStacked;
    const style = (currentSeries.line || {}).style;
    let previousSegment;
    let stackPoints;
    let segment;
    if (isStacked && seriesIx > 0 && prevSegment) {
      stackPoints = prevSegment.linePoints.slice(0);
      previousSegment = prevSegment;
    }
    if (style === SMOOTH) {
      segment = new spline_radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
      segment.options.closed = true;
    } else {
      linePoints.push(linePoints[0]);
      segment = new radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
    }
    return segment;
  }
  seriesMissingValues(series) {
    return series.missingValues || ZERO;
  }
};
var radar_area_chart_default = RadarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-segment.js
var RadarSegment = class extends donut_segment_default {
  constructor(value2, options) {
    super(value2, null, options);
  }
  getIndex() {
    return this.categoryIx;
  }
};
setDefaultOptions(RadarSegment, {
  overlay: {
    gradient: "none"
  },
  labels: {
    distance: 10
  }
});
var radar_segment_default = RadarSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-cluster-layout.js
var RadarClusterLayout = class extends chart_element_default {
  constructor(options) {
    super(options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  reflow(sector) {
    const { options, children } = this;
    const { gap, spacing } = options;
    const count = children.length;
    const slots = count + gap + spacing * (count - 1);
    const slotAngle = sector.angle / slots;
    let angle = sector.startAngle + slotAngle * (gap / 2);
    this.forEach(children, (child) => {
      const slotSector = sector.clone();
      slotSector.startAngle = angle;
      slotSector.angle = slotAngle;
      if (child.sector) {
        slotSector.radius = child.sector.radius;
      }
      child.reflow(slotSector);
      child.sector = slotSector;
      angle += slotAngle + slotAngle * spacing;
    });
  }
};
setDefaultOptions(RadarClusterLayout, {
  gap: 1,
  spacing: 0
});
var radar_cluster_layout_default = RadarClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-stack-layout.js
var RadarStackLayout = class extends chart_element_default {
  reflow(sector) {
    const { options: { reverse }, children } = this;
    const childrenCount = children.length;
    const first = reverse ? childrenCount - 1 : 0;
    const step = reverse ? -1 : 1;
    this.box = new box_default();
    for (let i = first; i >= 0 && i < childrenCount; i += step) {
      const childSector = children[i].sector;
      childSector.startAngle = sector.startAngle;
      childSector.angle = sector.angle;
    }
  }
};
var radar_stack_layout_default = RadarStackLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-bar-chart.js
var RadarBarChart = class extends bar_chart_default {
  pointType() {
    return radar_segment_default;
  }
  clusterType() {
    return radar_cluster_layout_default;
  }
  stackType() {
    return radar_stack_layout_default;
  }
  categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  }
  pointSlot(categorySlot, valueSlot) {
    const slot = categorySlot.clone();
    const y = categorySlot.center.y;
    slot.radius = y - valueSlot.y1;
    slot.innerRadius = y - valueSlot.y2;
    return slot;
  }
  reflowPoint(point, pointSlot) {
    point.sector = pointSlot;
    point.reflow();
  }
  createAnimation() {
    this.options.animation.center = this.box.toRect().center();
    super.createAnimation();
  }
};
RadarBarChart.prototype.reflow = categorical_chart_default.prototype.reflow;
setDefaultOptions(RadarBarChart, {
  clip: false,
  limitPoints: false,
  animation: {
    type: "pie"
  }
});
var radar_bar_chart_default = RadarBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/radar-plotarea.js
var RadarPlotArea = class extends polar_plotarea_base_default {
  createPolarAxis() {
    const categoryAxis = new radar_category_axis_default(this.options.categoryAxis, this.chartService);
    this.polarAxis = categoryAxis;
    this.categoryAxis = categoryAxis;
    this.appendAxis(categoryAxis);
    this.aggregateCategories();
    this.createTrendlineSeries();
    this.createCategoryAxesLabels();
  }
  valueAxisOptions(defaults) {
    if (this._hasBarCharts) {
      deepExtend(defaults, {
        majorGridLines: { type: ARC },
        minorGridLines: { type: ARC }
      });
    }
    if (this._isStacked100) {
      deepExtend(defaults, {
        roundToMajorUnit: false,
        labels: { format: "P0" }
      });
    }
    return deepExtend(defaults, this.options.valueAxis);
  }
  aggregateCategories() {
    categorical_plotarea_default.prototype.aggregateCategories.call(this, this.panes);
  }
  createCategoryAxesLabels() {
    categorical_plotarea_default.prototype.createCategoryAxesLabels.call(this, this.panes);
  }
  filterSeries(currentSeries) {
    return currentSeries;
  }
  trendlineFactory(options, series) {
    const trendline = categorical_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = RADAR_LINE;
    }
    return trendline;
  }
  createCharts() {
    const series = this.filterVisibleSeries(this.series);
    const pane = this.panes[0];
    this.createAreaChart(
      filterSeriesByType(series, [RADAR_AREA]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [RADAR_LINE]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [RADAR_COLUMN]),
      pane
    );
  }
  chartOptions(series) {
    const options = { series };
    const firstSeries = series[0];
    if (firstSeries) {
      const filteredSeries = this.filterVisibleSeries(series);
      const stack = firstSeries.stack;
      options.isStacked = stack && filteredSeries.length > 1;
      options.isStacked100 = stack && stack.type === "100%" && filteredSeries.length > 1;
      if (options.isStacked100) {
        this._isStacked100 = true;
      }
    }
    return options;
  }
  createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const areaChart = new radar_area_chart_default(this, this.chartOptions(series));
    this.appendChart(areaChart, pane);
  }
  createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const lineChart = new radar_line_chart_default(this, this.chartOptions(series));
    this.appendChart(lineChart, pane);
  }
  createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const options = this.chartOptions(series);
    const filteredSeries = this.filterVisibleSeries(series);
    const anyStackedSeries = filteredSeries.some((s) => s.stack);
    const isStacked100 = filteredSeries.some((s) => s.stack && s.stack.type === "100%");
    options.gap = firstSeries.gap;
    options.spacing = firstSeries.spacing;
    options.defaultStack = firstSeries.stack && filteredSeries.length > 1;
    options.isStacked = anyStackedSeries && filteredSeries.length > 1;
    options.isStacked100 = isStacked100 && filteredSeries.length > 1;
    const barChart = new radar_bar_chart_default(this, options);
    this.appendChart(barChart, pane);
    this._hasBarCharts = true;
  }
  seriesCategoryAxis() {
    return this.categoryAxis;
  }
  _dispatchEvent(chart, e, eventType) {
    const coords = chart._eventCoordinates(e);
    const point = new point_default(coords.x, coords.y);
    const category = this.categoryAxis.getCategory(point);
    const value2 = this.valueAxis.getValue(point);
    if (category !== null && value2 !== null) {
      chart.trigger(eventType, {
        element: eventElement(e),
        category,
        value: value2
      });
    }
  }
  createCrosshairs() {
  }
  _pointsByVertical(basePoint) {
    return super._pointsByVertical(basePoint).sort(this._getSeriesCompareFn());
  }
  _getSeriesCompareFn() {
    return (a, b) => b.value - a.value;
  }
};
deepExtend(RadarPlotArea.prototype, plotarea_events_mixin_default, {
  appendChart: categorical_plotarea_default.prototype.appendChart,
  aggregateSeries: categorical_plotarea_default.prototype.aggregateSeries,
  seriesSourcePoints: categorical_plotarea_default.prototype.seriesSourcePoints,
  seriesValues: categorical_plotarea_default.prototype.seriesValues
});
setDefaultOptions(RadarPlotArea, {
  categoryAxis: {
    categories: []
  },
  valueAxis: {}
});
var radar_plotarea_default = RadarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-segment.js
var FunnelSegment = class extends chart_element_default {
  constructor(value2, options, segmentOptions) {
    super(options);
    this.value = value2;
    this.options.index = segmentOptions.index;
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  }
  reflow(chartBox) {
    const points = this.points;
    const label = this.children[0];
    const x1 = Math.min(points[0].x, points[3].x);
    const x2 = Math.max(points[1].x, points[2].x);
    this.box = new box_default(x1, points[0].y, x2, points[2].y);
    if (label) {
      label.reflow(new box_default(chartBox.x1, points[0].y, chartBox.x2, points[2].y));
    }
  }
  createVisual() {
    const options = this.options;
    let visual;
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    if (options.visual) {
      visual = options.visual({
        category: this.category,
        dataItem: this.dataItem,
        value: this.value,
        series: this.series,
        percentage: this.percentage,
        points: this.points,
        options,
        sender: this.getSender(),
        createVisual: () => this.createPath()
      });
    } else {
      visual = this.createPath();
    }
    if (visual) {
      this.visual.append(visual);
    }
  }
  createPath() {
    const options = this.options;
    const border = options.border;
    const path = drawing_exports.Path.fromPoints(this.points, {
      fill: createPatternFill(options.pattern, {
        color: options.color,
        opacity: options.opacity
      }),
      stroke: {
        color: border.color,
        opacity: border.opacity,
        width: border.width
      }
    }).close();
    return path;
  }
  createHighlight(style) {
    return drawing_exports.Path.fromPoints(this.points, style);
  }
  highlightVisual() {
    return this.visual.children[0];
  }
  highlightVisualArgs() {
    const path = drawing_exports.Path.fromPoints(this.points).close();
    return {
      options: this.options,
      path
    };
  }
  createFocusHighlight(style) {
    const borderWidth = this.options.focusHighlight.border.width;
    const result = drawing_exports.Path.fromPoints(this.points, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    })).close();
    const clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(this.box.clone().pad(borderWidth).toRect()));
    clipPath.paths.push(drawing_exports.Path.fromPoints(this.points));
    result.clip(clipPath);
    return result;
  }
  tooltipAnchor() {
    const box = this.box;
    return {
      point: new point_default(box.center().x, box.y1),
      align: {
        horizontal: "center",
        vertical: "top"
      }
    };
  }
  formatValue(format) {
    const point = this;
    return point.owner.formatPointValue(point, format);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  }
  getIndex() {
    return this.index;
  }
};
setDefaultOptions(FunnelSegment, {
  color: WHITE,
  border: {
    width: 1
  },
  labels: {
    format: ""
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(FunnelSegment.prototype, point_events_mixin_default);
deepExtend(FunnelSegment.prototype, accessibility_attributes_mixin_default);
var funnel_segment_default = FunnelSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-chart.js
var FunnelChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.labels = [];
    this.legendItems = [];
    this.render();
  }
  formatPointValue(point, format) {
    return this.plotArea.chartService.format.auto(format, point.value);
  }
  render() {
    const seriesIx = 0;
    const { options, plotArea: { options: { seriesColors = [] } } } = this;
    const series = options.series[seriesIx];
    const data = series.data;
    if (!data) {
      return;
    }
    const { total, points } = bindSegments(series);
    for (let i = 0; i < points.length; i++) {
      const pointData = points[i];
      if (!pointData) {
        continue;
      }
      let fields = pointData.fields;
      if (!isFunction(series.color)) {
        series.color = fields.color || seriesColors[i % seriesColors.length];
      }
      fields = deepExtend({
        index: i,
        owner: this,
        series,
        seriesIx,
        dataItem: data[i],
        percentage: pointData.value / total
      }, fields, { visible: pointData.visible });
      const value2 = pointData.valueFields.value;
      const segment = this.createSegment(value2, fields);
      const label = this.createLabel(value2, fields);
      if (segment && label) {
        segment.append(label);
      }
    }
  }
  evalSegmentOptions(options, value2, fields) {
    const series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      index: fields.index
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "toggle",
      "visual",
      "ariaTemplate",
      "ariaContent"
    ] });
  }
  createSegment(value2, fields) {
    const seriesOptions = deepExtend({}, fields.series);
    seriesOptions.pattern = fields.pattern || seriesOptions.pattern;
    this.evalSegmentOptions(seriesOptions, value2, fields);
    this.createLegendItem(value2, seriesOptions, fields);
    if (fields.visible !== false) {
      const segment = new funnel_segment_default(value2, seriesOptions, fields);
      Object.assign(segment, fields);
      this.append(segment);
      this.points.push(segment);
      return segment;
    }
  }
  createLabel(value2, fields) {
    const { series, dataItem } = fields;
    const labels = deepExtend({}, this.options.labels, series.labels);
    let text = value2;
    if (labels.visible) {
      const labelTemplate = getTemplate(labels);
      const data = {
        dataItem,
        value: value2,
        percentage: fields.percentage,
        category: fields.category,
        series
      };
      if (labelTemplate) {
        text = labelTemplate(data);
      } else if (labels.format) {
        text = this.chartService.format.auto(labels.format, text);
      }
      if (!labels.color) {
        labels.color = auto_text_color_default(series.color);
        if (!labels.background) {
          labels.background = series.color;
        }
      }
      this.evalSegmentOptions(labels, value2, fields);
      const textBox = new text_box_default(text, deepExtend({
        vAlign: labels.position
      }, labels), data);
      this.labels.push(textBox);
      return textBox;
    }
  }
  labelPadding() {
    const labels = this.labels;
    const padding = { left: 0, right: 0 };
    for (let i = 0; i < labels.length; i++) {
      const label = labels[i];
      const align = label.options.align;
      if (align !== CENTER) {
        const width = labels[i].box.width();
        if (align === LEFT) {
          padding.left = Math.max(padding.left, width);
        } else {
          padding.right = Math.max(padding.right, width);
        }
      }
    }
    return padding;
  }
  dynamicSlopeReflow(box, width, totalHeight) {
    const { options, points: segments } = this;
    const count = segments.length;
    const firstSegment = segments[0];
    let maxSegment = firstSegment;
    for (let idx = 0; idx < segments.length; idx++) {
      if (segments[idx].percentage > maxSegment.percentage) {
        maxSegment = segments[idx];
      }
    }
    let lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
    let previousOffset = (width - lastUpperSide) / 2;
    let previousHeight = 0;
    for (let idx = 0; idx < count; idx++) {
      const percentage = segments[idx].percentage;
      const nextSegment = segments[idx + 1];
      const nextPercentage = nextSegment ? nextSegment.percentage : percentage;
      const points = segments[idx].points = [];
      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      let offset;
      if (!percentage) {
        offset = nextPercentage ? 0 : width / 2;
      } else {
        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
      }
      offset = limitValue(offset, 0, width);
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + offset, box.y1 + height + previousHeight));
      previousOffset = offset;
      previousHeight += height + options.segmentSpacing;
      lastUpperSide = limitValue(width - 2 * offset, 0, width);
    }
  }
  constantSlopeReflow(box, width, totalHeight) {
    const { options, points: segments } = this;
    const count = segments.length;
    const decreasingWidth = options.neckRatio <= 1;
    const neckRatio = decreasingWidth ? options.neckRatio * width : width;
    let previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;
    const topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
    const finalNarrow = (topMostWidth - neckRatio) / 2;
    let previousHeight = 0;
    for (let idx = 0; idx < count; idx++) {
      const points = segments[idx].points = [];
      const percentage = segments[idx].percentage;
      const offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));
      previousOffset += offset;
      previousHeight += height + options.segmentSpacing;
    }
  }
  reflow(chartBox) {
    const points = this.points;
    const count = points.length;
    if (!count) {
      return;
    }
    const options = this.options;
    const box = chartBox.clone().unpad(this.labelPadding());
    const totalHeight = box.height() - options.segmentSpacing * (count - 1);
    const width = box.width();
    if (options.dynamicSlope) {
      this.dynamicSlopeReflow(box, width, totalHeight);
    } else {
      this.constantSlopeReflow(box, width, totalHeight);
    }
    for (let idx = 0; idx < count; idx++) {
      points[idx].reflow(chartBox);
    }
  }
};
setDefaultOptions(FunnelChart, {
  neckRatio: 0.3,
  width: 300,
  dynamicSlope: false,
  dynamicHeight: true,
  segmentSpacing: 0,
  labels: {
    visible: false,
    align: CENTER,
    position: CENTER,
    zIndex: 1
  }
});
deepExtend(FunnelChart.prototype, pie_chart_mixin_default);
var funnel_chart_default = FunnelChart;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/pyramid-chart.js
var MAX_NECK_RATIO = 1e6;
var PyramidChart = class extends funnel_chart_default {
  constructor(plotArea, options) {
    options.dynamicSlope = false;
    options.neckRatio = MAX_NECK_RATIO;
    super(plotArea, options);
  }
};
var pyramid_chart_default = PyramidChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/funnel-plotarea.js
var FunnelPlotArea = class extends plotarea_base_default {
  render() {
    this.createChart(funnel_chart_default, filterSeriesByType(this.series, [FUNNEL]));
    this.createChart(pyramid_chart_default, filterSeriesByType(this.series, [PYRAMID]));
  }
  createChart(chartType, series) {
    const firstSeries = series[0];
    if (!firstSeries) {
      return;
    }
    const chart = new chartType(this, {
      series,
      legend: this.options.legend,
      neckRatio: firstSeries.neckRatio,
      dynamicHeight: firstSeries.dynamicHeight,
      dynamicSlope: firstSeries.dynamicSlope,
      segmentSpacing: firstSeries.segmentSpacing,
      highlight: firstSeries.highlight
    });
    this.appendChart(chart);
  }
  appendChart(chart, pane) {
    super.appendChart(chart, pane);
    append(this.options.legend.data, chart.legendItems);
  }
  _pointsByVertical(basePoint) {
    return this.pointsBySeriesIndex(basePoint.series.index);
  }
  getPointToTheRight(point) {
    return this.getPointBelow(point);
  }
  getPointToTheLeft(point) {
    return this.getPointAbove(point);
  }
};
var funnel_plotarea_default = FunnelPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/color-scale.js
var colorScale = (color, minLightnessOffset = 0.05) => {
  const baseColor = parseColor(color);
  const offset = 1 - minLightnessOffset;
  return (value2) => {
    const hsl = baseColor.toHSL();
    const range = 100 - hsl.l;
    const point = offset - value2;
    hsl.l += Math.min(point * range, range);
    return hsl.toCss();
  };
};
var color_scale_default = colorScale;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-point.js
var HeatmapPoint = class extends chart_element_default {
  constructor(value2, options) {
    super();
    this.options = options;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createMarker();
    this.createLabel();
    this.createNote();
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    let labelColor = options.color;
    if (!labelColor) {
      labelColor = auto_text_color_default(this.color);
    }
    return new text_box_default(
      this.getLabelText(options),
      deepExtend(
        {
          align: CENTER,
          vAlign: CENTER,
          margin: {
            left: 5,
            right: 5
          },
          zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
        },
        options,
        {
          color: labelColor
        }
      ),
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  reflow(targetBox) {
    this.render();
    const label = this.label;
    this.box = targetBox;
    if (label) {
      label.reflow(this.markerBox());
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    this.marker.reflow(this.markerBox());
  }
  createVisual() {
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
  }
  markerBox() {
    const options = this.options;
    const markers = options.markers;
    const border = markers.border;
    const rect = this.box.toRect();
    const type = valueOrDefault(markers.type, "rect");
    const isRoundRect = type === ROUNDED_RECT;
    let borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);
    const halfBorderWidth = Math.round(borderWidth / 2);
    if (markers.size) {
      const center = rect.center();
      rect.size.width = rect.size.height = markers.size;
      rect.origin.x = Math.round(center.x - rect.size.width / 2);
      rect.origin.y = Math.round(center.y - rect.size.height / 2);
    }
    rect.size.width -= borderWidth;
    rect.size.height -= borderWidth;
    rect.origin.y += halfBorderWidth + 0.5;
    rect.origin.x += halfBorderWidth + 0.5;
    return rectToBox(rect);
  }
  markerBorder() {
    const options = this.options;
    const markers = options.markers;
    const border = markers.border;
    const opacity = valueOrDefault(border.opacity, options.opacity);
    return {
      color: border.color || this.color,
      width: border.width,
      opacity,
      dashType: border.dashType
    };
  }
  createMarker() {
    const options = this.options;
    const markerOptions = options.markers;
    const marker = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: this.color,
      border: this.markerBorder(),
      pattern: options.pattern,
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    this.marker = marker;
    this.append(marker);
  }
  createHighlight(style) {
    const options = this.options;
    const markerOptions = this.options.highlight.markers || this.options.markers;
    const highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: markerOptions.color || this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
    });
    highlight.reflow(this.markerBox());
    const visual = highlight.getElement();
    visual.options.fill = style.fill;
    visual.options.stroke = style.stroke;
    return visual;
  }
  highlightVisual() {
    return this.rectVisual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  }
  createFocusHighlight() {
    const markerOptions = this.options.markers;
    const highlightOptions2 = this.options.focusHighlight;
    const highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      borderRadius: markerOptions.borderRadius,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this.markerBox());
    return highlight.getElement();
  }
  tooltipAnchor() {
    const left = this.box.center().x;
    const top = this.box.y1 - TOOLTIP_OFFSET;
    return {
      point: new point_default(left, top),
      align: {
        horizontal: CENTER,
        vertical: BOTTOM
      }
    };
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  unclipElements() {
  }
  pointData() {
    return {
      x: this.value.x,
      y: this.value.y,
      value: this.value.value,
      dataItem: this.dataItem,
      series: this.series
    };
  }
};
deepExtend(HeatmapPoint.prototype, point_events_mixin_default);
deepExtend(HeatmapPoint.prototype, note_mixin_default);
deepExtend(HeatmapPoint.prototype, accessibility_attributes_mixin_default);
HeatmapPoint.prototype.defaults = {
  markers: {
    type: "rect",
    borderRadius: 4,
    border: {
      color: "transparent"
    }
  },
  padding: { top: 1 },
  labels: {
    visible: false,
    padding: 3
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var heatmap_point_default = HeatmapPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-chart.js
var HeatmapChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  _initFields() {
    this.points = [];
    this.seriesOptions = [];
    this.valueRange = { min: MAX_VALUE, max: MIN_VALUE };
    this._evalSeries = [];
  }
  render() {
    this.setRange();
    this.traverseDataPoints(this.addValue.bind(this));
  }
  setRange() {
    const { options: { series } } = this;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        const { valueFields } = this.plotArea.bindPoint(currentSeries, pointIx);
        if (defined(valueFields.value) && valueFields.value !== null) {
          this.valueRange.min = Math.min(this.valueRange.min, valueFields.value);
          this.valueRange.max = Math.max(this.valueRange.max, valueFields.value);
        }
      }
    }
  }
  addValue(value2, fields) {
    let point;
    if (value2 && defined(value2.value) && value2.value !== null) {
      point = this.createPoint(value2, fields);
      if (point) {
        Object.assign(point, fields);
      }
    }
    this.points.push(point);
  }
  evalPointOptions(options, value2, fields) {
    const { series, seriesIx } = fields;
    const state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    let doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    let pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem,
        min: this.valueRange.min,
        max: this.valueRange.max
      }, state);
    }
    return pointOptions;
  }
  pointType() {
    return heatmap_point_default;
  }
  pointOptions(series, seriesIx) {
    let options = this.seriesOptions[seriesIx];
    if (!options) {
      const defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return Object.assign({}, options);
  }
  createPoint(value2, fields) {
    const series = fields.series;
    let pointOptions = this.pointOptions(series, fields.seriesIx);
    let color = fields.color || series.color;
    pointOptions.pattern = fields.pattern || pointOptions.pattern;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    } else if (this.valueRange.max !== 0) {
      const scale = color_scale_default(color);
      color = scale(value2.value / this.valueRange.max);
    }
    const point = new heatmap_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  seriesAxes(series) {
    const { xAxis: xAxisName, yAxis: yAxisName } = series;
    const plotArea = this.plotArea;
    const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  }
  reflow(targetBox) {
    const chartPoints = this.points;
    const limit = !this.options.clip;
    let pointIx = 0;
    this.traverseDataPoints((value2, fields) => {
      const point = chartPoints[pointIx++];
      const { xAxis, yAxis } = this.seriesAxes(fields.series);
      const indexX = xAxis.categoryIndex(value2.x);
      const indexY = yAxis.categoryIndex(value2.y);
      const slotX = xAxis.getSlot(indexX, indexX, limit);
      const slotY = yAxis.getSlot(indexY, indexY, limit);
      if (point) {
        if (slotX && slotY) {
          const pointSlot = this.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  }
  pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  }
  traverseDataPoints(callback) {
    const { options: { series } } = this;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const { xAxis, yAxis } = this.seriesAxes(currentSeries);
      const xRange = xAxis.currentRangeIndices();
      const yRange = yAxis.currentRangeIndices();
      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        const { valueFields: value2, fields } = this.plotArea.bindPoint(currentSeries, pointIx);
        const xIndex = xAxis.totalIndex(value2.x);
        const yIndex = yAxis.totalIndex(value2.y);
        const xIn = xRange.min <= xIndex && xIndex <= xRange.max;
        const yIn = yRange.min <= yIndex && yIndex <= yRange.max;
        if (xIn && yIn) {
          callback(value2, deepExtend({
            pointIx,
            series: currentSeries,
            seriesIx,
            dataItem: currentSeries.data[pointIx],
            owner: this
          }, fields));
        }
      }
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.value);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  }
};
setDefaultOptions(HeatmapChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}: {2}"
  },
  labels: {
    format: "{2}"
  },
  clip: true
});
var heatmap_chart_default = HeatmapChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/heatmap-plotarea.js
var HeatmapPlotArea = class extends plotarea_base_default {
  initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
  }
  render(panes = this.panes) {
    this.bindCategories();
    this.createAxes(panes);
    this.createCharts(panes);
    this.createAxisLabels();
  }
  bindCategories() {
    const series = this.srcSeries || this.series;
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      const data = currentSeries.data || [];
      const { xAxis, yAxis } = this.seriesAxes(currentSeries);
      const xCategories = createHashSet(xAxis.categories || []);
      const yCategories = createHashSet(yAxis.categories || []);
      for (let pointIndex = 0; pointIndex < data.length; pointIndex++) {
        const { x, y } = series_binder_default.current.bindPoint(currentSeries, pointIndex).valueFields;
        if (!xCategories.has(x)) {
          xCategories.add(x);
        }
        if (!yCategories.has(y)) {
          yCategories.add(y);
        }
      }
      xAxis.categories = xCategories.values();
      yAxis.categories = yCategories.values();
    }
  }
  createCharts(panes) {
    const seriesByPane = this.groupSeriesByPane();
    for (let i = 0; i < panes.length; i++) {
      const pane = panes[i];
      const paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this.addToLegend(paneSeries);
      const filteredSeries = this.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this.createHeatmapChart(
        filterSeriesByType(filteredSeries, [HEATMAP]),
        pane
      );
    }
  }
  createHeatmapChart(series, pane) {
    const chart = new heatmap_chart_default(this, {
      series
    });
    this.appendChart(chart, pane);
  }
  seriesPaneName(series) {
    const options = this.options;
    const xAxisName = series.xAxis;
    const xAxisOptions = [].concat(options.xAxis);
    const xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    const yAxisName = series.yAxis;
    const yAxisOptions = [].concat(options.yAxis);
    const yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    const panes = options.panes || [{}];
    const defaultPaneName = panes[0].name || "default";
    const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  }
  seriesAxes(series) {
    let xAxis;
    let yAxis;
    const options = this.options;
    const xAxisOptions = [].concat(options.xAxis);
    const xAxisName = series.xAxis;
    if (xAxisName) {
      xAxis = xAxisOptions.find((axis) => axis.name === xAxisName);
    } else {
      xAxis = xAxisOptions[0];
    }
    const yAxisOptions = [].concat(options.yAxis);
    const yAxisName = series.yAxis;
    if (yAxisName) {
      yAxis = yAxisOptions.find((axis) => axis.name === yAxisName);
    } else {
      yAxis = yAxisOptions[0];
    }
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  }
  createAxisLabels() {
    const axes = this.axes;
    for (let i = 0; i < axes.length; i++) {
      axes[i].createLabels();
    }
  }
  createXYAxis(options, vertical, axisIndex) {
    const axisName = options.name;
    const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    const axisOptions2 = Object.assign({
      axisCrossingValue: 0
    }, options, {
      vertical,
      reverse: vertical || this.chartService.rtl ? !options.reverse : options.reverse,
      justified: false
    });
    const firstCategory = axisOptions2.categories ? axisOptions2.categories[0] : null;
    const typeSamples = [axisOptions2.min, axisOptions2.max, firstCategory];
    const series = this.series;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        const firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    let inferredDate;
    for (let i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    let axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_category_axis_default;
    } else {
      axisType = category_axis_default;
    }
    const axis = new axisType(axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error(`${vertical ? "Y" : "X"} axis with name ${axisName} is already defined`);
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    axis.indexCategories();
    return axis;
  }
  createAxes(panes) {
    const options = this.options;
    const xAxesOptions = [].concat(options.xAxis);
    const xAxes = [];
    const yAxesOptions = [].concat(options.yAxis);
    const yAxes = [];
    for (let idx = 0; idx < xAxesOptions.length; idx++) {
      const axisPane = this.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (let idx = 0; idx < yAxesOptions.length; idx++) {
      const axisPane = this.findPane(yAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  }
  removeAxis(axis) {
    const axisName = axis.options.name;
    super.removeAxis(axis);
    if (axis.options.vertical) {
      delete this.namedYAxes[axisName];
    } else {
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  }
  _dispatchEvent(chart, e, eventType) {
    const coords = chart._eventCoordinates(e);
    const point = new point_default(coords.x, coords.y);
    const allAxes = this.axes;
    const length = allAxes.length;
    const xValues = [];
    const yValues = [];
    for (let i = 0; i < length; i++) {
      const axis = allAxes[i];
      const values = axis.options.vertical ? yValues : xValues;
      appendIfNotNull(values, axis.getCategory(point));
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  }
  updateAxisOptions(axis, options) {
    const vertical = axis.options.vertical;
    const axes = this.groupAxes(this.panes);
    const index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions3(this.options, index, vertical, options);
    updateAxisOptions3(this.originalOptions, index, vertical, options);
  }
  crosshairOptions(axis) {
    return Object.assign({}, axis.options.crosshair, { zIndex: 0 });
  }
  _pointsByVertical(basePoint, offset = 0) {
    const normalizedOffset = this.axisX.options.reverse ? offset * -1 : offset;
    const axisXItems = this.axisX.children;
    let xIndex = this._getPointAxisXIndex(basePoint) + normalizedOffset;
    xIndex = cycleIndex(xIndex, axisXItems.length);
    const targetXValue = axisXItems[xIndex].value;
    const points = this.filterPoints((point) => compareValues(point.pointData().x, targetXValue)).sort((a, b) => this._getPointAxisYIndex(a) - this._getPointAxisYIndex(b));
    if (this.axisY.options.reverse) {
      return points.reverse();
    }
    return points;
  }
  _pointsByHorizontal(basePoint, offset = 0) {
    const normalizedOffset = this.axisY.options.reverse ? offset * -1 : offset;
    const axisYItems = this.axisY.children;
    let yIndex = this._getPointAxisYIndex(basePoint) + normalizedOffset;
    yIndex = cycleIndex(yIndex, axisYItems.length);
    const targetYValue = axisYItems[yIndex].value;
    const points = this.filterPoints((point) => compareValues(point.pointData().y, targetYValue)).sort((a, b) => this._getPointAxisXIndex(a) - this._getPointAxisXIndex(b));
    if (this.axisX.options.reverse) {
      return points.reverse();
    }
    return points;
  }
  _getPointAxisXIndex(point) {
    return this._getPointAxisIndex(this.axisX, point.pointData().x);
  }
  _getPointAxisYIndex(point) {
    return this._getPointAxisIndex(this.axisY, point.pointData().y);
  }
  _getPointAxisIndex(axis, pointValue) {
    return axis.children.findIndex((axisItem) => compareValues(pointValue, axisItem.value));
  }
};
function compareValues(a, b) {
  if (a instanceof Date && b instanceof Date) {
    return dateEquals(a, b);
  }
  return a === b;
}
function updateAxisOptions3(targetOptions, axisIndex, vertical, options) {
  const axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(HeatmapPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(HeatmapPlotArea.prototype, plotarea_events_mixin_default);
var heatmap_plotarea_default = HeatmapPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/register-charts.js
var COLOR = "color";
var FIRST = "first";
var FROM = "from";
var MAX = "max";
var MIN = "min";
var NOTE_TEXT = "noteText";
var SUMMARY_FIELD = "summary";
var TO = "to";
plotarea_factory_default.current.register(categorical_plotarea_default, [
  BAR,
  COLUMN,
  LINE,
  VERTICAL_LINE,
  AREA,
  VERTICAL_AREA,
  CANDLESTICK,
  OHLC,
  BULLET,
  VERTICAL_BULLET,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL,
  RANGE_AREA,
  VERTICAL_RANGE_AREA,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(xy_plotarea_default, [
  SCATTER,
  SCATTER_LINE,
  BUBBLE,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(pie_plotarea_default, [PIE]);
plotarea_factory_default.current.register(donut_plotarea_default, [DONUT]);
plotarea_factory_default.current.register(funnel_plotarea_default, [FUNNEL, PYRAMID]);
plotarea_factory_default.current.register(polar_plotarea_default, [
  POLAR_AREA,
  POLAR_LINE,
  POLAR_SCATTER,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(radar_plotarea_default, [
  RADAR_AREA,
  RADAR_COLUMN,
  RADAR_LINE,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(heatmap_plotarea_default, [HEATMAP]);
series_binder_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  [FROM, TO],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register(
  [WATERFALL, HORIZONTAL_WATERFALL],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X, Y], [COLOR, DRILLDOWN_FIELD, PATTERN_FIELD]);
series_binder_default.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [CATEGORY, COLOR, DRILLDOWN_FIELD, PATTERN_FIELD]);
series_binder_default.current.register(
  [FUNNEL, PYRAMID],
  [VALUE],
  [CATEGORY, COLOR, "visibleInLegend", "visible", DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL],
  { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }
);
default_aggregates_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  { from: MIN, to: MAX, color: FIRST, noteText: FIRST }
);
default_aggregates_default.current.register(
  [RADAR_AREA, RADAR_COLUMN, RADAR_LINE],
  { value: MAX, color: FIRST }
);
series_binder_default.current.register(
  [SCATTER, SCATTER_LINE, BUBBLE],
  [X, Y],
  [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]
);
series_binder_default.current.register(
  [BUBBLE],
  [X, Y, "size"],
  [COLOR, CATEGORY, NOTE_TEXT, PATTERN_FIELD]
);
series_binder_default.current.register(
  [HEATMAP],
  [X, Y, VALUE],
  [COLOR, NOTE_TEXT, PATTERN_FIELD]
);
series_binder_default.current.register(
  [CANDLESTICK, OHLC],
  ["open", "high", "low", "close"],
  [CATEGORY, COLOR, "downColor", NOTE_TEXT, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [CANDLESTICK, OHLC],
  {
    open: MAX,
    high: MAX,
    low: MIN,
    close: MAX,
    color: FIRST,
    downColor: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  ["lower", "q1", "median", "q3", "upper", "mean", "outliers"],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  {
    lower: MAX,
    q1: MAX,
    median: MAX,
    q3: MAX,
    upper: MAX,
    mean: MAX,
    outliers: FIRST,
    color: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BULLET, VERTICAL_BULLET],
  ["current", "target"],
  [CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BULLET, VERTICAL_BULLET],
  { current: MAX, target: MAX, color: FIRST, noteText: FIRST }
);
series_binder_default.current.register(
  [PIE, DONUT],
  [VALUE],
  [CATEGORY, COLOR, "explode", "visibleInLegend", "visible", DRILLDOWN_FIELD, PATTERN_FIELD]
);

// node_modules/@progress/kendo-charts/dist/es/chart/chart.js
var AXIS_NAMES = [CATEGORY, VALUE, X, Y];
var MOUSEDOWN = "mousedown";
var MOUSEMOVE = "mousemove";
var CONTEXTMENU = "contextmenu";
var MOUSELEAVE = "mouseleave";
var KEYDOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var MOUSEMOVE_DELAY = 20;
var NO_DATA_OVERLAY_TOP_CLASS = "k-chart-overlay-top";
var Chart = class extends class_default {
  constructor(element, userOptions, themeOptions, context = {}) {
    super();
    this.observers = [];
    this.addObserver(context.observer);
    this.chartService = new chart_service_default(this, context);
    this.chartService.theme = themeOptions;
    this._initElement(element);
    const options = deepExtend({}, this.options, userOptions);
    this._originalOptions = deepExtend({}, options);
    this._theme = themeOptions;
    this._initTheme(options, themeOptions);
    this._focusState = {};
    this._initHandlers();
    this._initSurface();
    this.bindCategories();
    font_loader_default.preloadFonts(userOptions, () => {
      this.fontLoaded = true;
      if (!this._destroyed) {
        this.trigger("init");
        this._redraw();
        this._attachEvents();
        this._restoreOverlayElement();
      }
    });
  }
  _initElement(element) {
    this._setElementClass(element);
    element.style.position = "relative";
    element.tabIndex = element.getAttribute("tabindex") ? element.getAttribute("tabindex") : 0;
    element.setAttribute("role", "graphics-document document");
    for (let i = element.childNodes.length - 1; i >= 0; i--) {
      const child = element.childNodes[i];
      if (!hasClasses(child, "k-chart-overlay")) {
        element.removeChild(child);
      } else {
        this.overlayElement = child;
      }
    }
    this.element = element;
  }
  _setElementClass(element) {
    addClass(element, "k-chart");
  }
  _restoreOverlayElement() {
    if (!this.overlayElement) {
      return;
    }
    if (this._hasSeriesData()) {
      this.overlayElement.style.display = "none";
    } else {
      if (!this.options.title || this.options.title && this.options.title.position !== BOTTOM) {
        addClass(this.overlayElement, NO_DATA_OVERLAY_TOP_CLASS);
      } else {
        removeClass(this.overlayElement, NO_DATA_OVERLAY_TOP_CLASS);
      }
      this.overlayElement.style.display = "";
    }
    if (this.overlayElement.parentElement !== this.element) {
      this.element.appendChild(this.overlayElement);
    }
  }
  _hasSeriesData() {
    const series = this.options.series || [];
    const hasData = series.length > 0 && series.some((x) => x.data && x.data.length > 0);
    return hasData;
  }
  _initTheme(options, themeOptions) {
    const seriesCopies = [];
    const series = options.series || [];
    for (let i = 0; i < series.length; i++) {
      seriesCopies.push(Object.assign({}, series[i]));
    }
    options.series = seriesCopies;
    resolveAxisAliases(options);
    this.applyDefaults(options, themeOptions);
    if (options.seriesColors === null) {
      delete options.seriesColors;
    }
    if (isString(options.title)) {
      options.title = { text: options.title };
    }
    this.options = deepExtend({}, themeOptions, options);
    this.applySeriesColors();
  }
  getSize() {
    const chartArea = this.options.chartArea || {};
    const width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);
    const height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);
    return {
      width,
      height
    };
  }
  resize(force) {
    const size = this.getSize();
    const currentSize = this._size;
    const hasSize = size.width > 0 || size.height > 0;
    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this._size = size;
      this._resize(size, force);
      this.trigger("resize", size);
    } else if (hasSize && this._selections && find(this._selections, (s) => !s.visible)) {
      this._destroySelections();
      this._setupSelection();
    }
  }
  _resize() {
    this._noTransitionsRedraw();
  }
  redraw(paneName) {
    this.applyDefaults(this.options);
    this.applySeriesColors();
    if (paneName) {
      const plotArea = this._model._plotArea;
      const pane = plotArea.findPane(paneName);
      plotArea.redraw(pane);
    } else {
      this._redraw();
    }
  }
  getAxis(name) {
    return findAxisByName(name, this._plotArea.axes);
  }
  findAxisByName(name) {
    return this.getAxis(name);
  }
  findPaneByName(name) {
    const panes = this._plotArea.panes;
    for (let idx = 0; idx < panes.length; idx++) {
      if (panes[idx].options.name === name) {
        return new chart_pane_default(panes[idx]);
      }
    }
  }
  findPaneByIndex(idx) {
    const panes = this._plotArea.panes;
    if (panes[idx]) {
      return new chart_pane_default(panes[idx]);
    }
  }
  plotArea() {
    return new chart_plotarea_default(this._plotArea);
  }
  toggleHighlight(show2, filter) {
    const plotArea = this._plotArea;
    const firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
    let points;
    if (isFunction(filter)) {
      points = plotArea.filterPoints(filter);
    } else {
      let seriesName, categoryName;
      if (isObject(filter)) {
        seriesName = filter.series;
        categoryName = filter.category;
      } else {
        seriesName = categoryName = filter;
      }
      if (firstSeries.type === DONUT) {
        points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
      } else if (inArray(firstSeries.type, [PIE, FUNNEL, PYRAMID])) {
        points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
      } else {
        points = plotArea.pointsBySeriesName(seriesName);
      }
    }
    if (points) {
      this.togglePointsHighlight(show2, points);
    }
  }
  togglePointsHighlight(show2, points) {
    const highlight = this._highlight;
    for (let idx = 0; idx < points.length; idx++) {
      highlight.togglePointHighlight(points[idx], show2);
    }
  }
  showTooltip(filter) {
    const shared = this._sharedTooltip();
    const { _tooltip: tooltip, _plotArea: plotArea } = this;
    let point, categoryIndex;
    if (isFunction(filter)) {
      point = plotArea.findPoint(filter);
      if (point && shared) {
        categoryIndex = point.categoryIx;
      }
    } else if (shared && defined(filter)) {
      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
    }
    if (shared) {
      if (categoryIndex >= 0) {
        const points = this._plotArea.pointsByCategoryIndex(categoryIndex);
        tooltip.showAt(points);
      }
    } else if (point) {
      tooltip.show(point);
    }
  }
  hideTooltip() {
    this._tooltip.hide();
  }
  _initSurface() {
    const surface = this.surface;
    const wrap = this._surfaceWrap();
    const chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      elementSize(wrap, { width: chartArea.width });
    }
    if (chartArea.height) {
      elementSize(wrap, { height: chartArea.height });
    }
    if (!surface || surface.options.type !== this.options.renderAs) {
      this._destroySurface();
      this.surface = drawing_exports.Surface.create(wrap, {
        type: this.options.renderAs
      });
      this.surface.bind("mouseenter", this._surfaceMouseenterHandler);
      this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);
    } else {
      this.surface.clear();
      this.surface.resize();
    }
    this.element._kendoExportVisual = this._kendoExportVisual.bind(this);
  }
  _surfaceWrap() {
    return this.element;
  }
  _redraw() {
    const model = this._getModel();
    this._size = {
      width: model.options.width,
      height: model.options.height
    };
    this._destroyView();
    this._setElementAccessibilityAttributes();
    this._model = model;
    this._plotArea = model._plotArea;
    this._legend = model._legend;
    model.renderVisual();
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.setup();
        }
      });
    }
    this._initSurface();
    this.surface.draw(model.visual);
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.play();
        }
      });
    }
    this._tooltip = this._createTooltip();
    this._highlight = new highlight_default();
    this._setupSelection();
    this._createPannable();
    this._createZoomSelection();
    this._createMousewheelZoom();
    this._setComputedStyles();
    this.trigger(RENDER);
    triggerPaneRender(this._plotArea.panes);
    if (!this._navState) {
      this._cancelDomEvents();
    }
    this._redrawFocusHighlight();
  }
  _setComputedStyles() {
    const titleHeight = this.titleHeight();
    this.element.style.setProperty("--kendo-chart-computed-title-height", `${titleHeight}px`);
  }
  _redrawFocusHighlight() {
    if (this._destroyed) {
      return;
    }
    const { _focusState: { legendInFocus, preserveHighlight } } = this;
    if (legendInFocus && preserveHighlight) {
      this._focusElement(this._getFocusedLegendItem(), false);
      this._focusState.preserveHighlight = false;
    }
  }
  _setElementAccessibilityAttributes() {
    let titleOptions = this.options.title;
    let title3 = isString(titleOptions) ? titleOptions : titleOptions.description || titleOptions.text;
    if (title3) {
      this.element.setAttribute("aria-roledescription", title3);
    }
  }
  _kendoExportVisual(size) {
    if (size && size.width && size.height) {
      const chartArea = this._originalOptions.chartArea || {};
      const exportOptions = {
        width: chartArea.width || size.width,
        height: chartArea.height || size.height
      };
      return this.exportVisual(exportOptions);
    }
    return this.exportVisual();
  }
  exportVisual(exportOptions) {
    let visual;
    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {
      const currentOptions = this.options;
      const options = deepExtend({}, exportOptions.options, {
        chartArea: {
          width: exportOptions.width,
          height: exportOptions.height
        }
      });
      clearMissingValues(this._originalOptions, options);
      this.options = deepExtend({}, this._originalOptions, options);
      this._initTheme(this.options, this._theme);
      this.bindCategories();
      const model = this._getModel();
      model.renderVisual();
      triggerPaneRender(model._plotArea.panes);
      visual = model.visual;
      this.options = currentOptions;
    } else {
      visual = this.surface.exportVisual();
    }
    return visual;
  }
  _sharedTooltip() {
    return this._plotArea instanceof categorical_plotarea_default && this.options.tooltip && this.options.tooltip.shared;
  }
  _createPannable() {
    const options = this.options;
    if (options.pannable !== false) {
      this._pannable = new pannable_default(this._plotArea, options.pannable);
    }
  }
  _createZoomSelection() {
    const zoomable = this.options.zoomable;
    const selection = (zoomable || {}).selection;
    if (zoomable !== false && selection !== false) {
      this._zoomSelection = new zoom_selection_default(this, selection);
    }
  }
  _createMousewheelZoom() {
    const zoomable = this.options.zoomable;
    const mousewheel = (zoomable || {}).mousewheel;
    if (zoomable !== false && mousewheel !== false) {
      this._mousewheelZoom = new mousewheel_zoom_default(this, mousewheel);
    }
  }
  _toggleDragZoomEvents() {
    const pannable = this.options.pannable;
    const zoomable = this.options.zoomable;
    const selection = (zoomable || {}).selection;
    const mousewheel = (zoomable || {}).mousewheel;
    const allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);
    const allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);
    const element = this.element;
    if (this._dragZoomEnabled && allowDrag && allowZoom) {
      element.style.touchAction = this._touchAction || "";
      this._dragZoomEnabled = false;
    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {
      element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
    this._toggleDomEvents(!allowDrag, !allowZoom);
  }
  _toggleDomEvents(drag, zoom) {
    const domEvents = this.domEvents;
    if (!domEvents) {
      return;
    }
    if (domEvents.toggleDrag) {
      domEvents.toggleDrag(drag);
    }
    if (domEvents.toggleZoom) {
      domEvents.toggleZoom(zoom);
    }
  }
  _createTooltip() {
    const { options: { tooltip: tooltipOptions } } = this;
    let tooltip;
    if (this._sharedTooltip()) {
      tooltip = this._createSharedTooltip(tooltipOptions);
    } else {
      tooltip = new tooltip_default(this.chartService, tooltipOptions);
    }
    return tooltip;
  }
  _createSharedTooltip(options) {
    return new shared_tooltip_default(this._plotArea, options);
  }
  applyDefaults(options, themeOptions) {
    applyAxisDefaults(options, themeOptions);
    applySeriesDefaults(options, themeOptions);
  }
  applySeriesColors() {
    const options = this.options;
    const series = options.series;
    const colors = options.seriesColors || [];
    for (let i = 0; i < series.length; i++) {
      const currentSeries = series[i];
      const seriesColor = colors[i % colors.length];
      const defaults = currentSeries._defaults;
      currentSeries.color = currentSeries.color || seriesColor;
      if (defaults) {
        defaults.color = defaults.color || seriesColor;
      }
    }
  }
  _getModel() {
    const options = this.options;
    const plotArea = this._createPlotArea();
    const model = new root_element_default(this._modelOptions());
    model.chart = this;
    model._plotArea = plotArea;
    const title3 = title_default.buildTitle(options.title);
    const subtitle2 = title_default.buildTitle(options.subtitle, {
      align: options.title.align,
      position: options.title.position
    });
    model.append.apply(model, title_default.orderTitles([title3, subtitle2]));
    if (options.legend && options.legend.visible) {
      const legend2 = new legend_default(plotArea.options.legend, this.chartService);
      model.append(legend2);
      model._legend = legend2;
    }
    model.append(plotArea);
    model.reflow();
    this._setTitleBox(title3, subtitle2);
    return model;
  }
  _setTitleBox(title3, subtitle2) {
    if (!title3 && !subtitle2) {
      return;
    }
    this._titleBox = (title3 || subtitle2).box.clone();
    const titlePosition = title3 ? title3.options.position : "";
    const subtitlePosition = subtitle2 ? subtitle2.options.position : "";
    const samePosition = titlePosition === subtitlePosition;
    const subtitleAtTop = subtitlePosition !== BOTTOM;
    if (samePosition && subtitle2) {
      this._titleBox.wrap(subtitle2.box);
    } else if (title3 && subtitle2 && subtitleAtTop) {
      this._titleBox = subtitle2.box.clone();
    }
  }
  _modelOptions() {
    const options = this.options;
    const size = this.getSize();
    return deepExtend({
      transitions: options.transitions,
      width: size.width || DEFAULT_WIDTH,
      height: size.height || DEFAULT_HEIGHT
    }, options.chartArea);
  }
  _createPlotArea(skipSeries) {
    const options = this.options;
    const plotArea = plotarea_factory_default.current.create(skipSeries ? [] : options.series, options, this.chartService);
    return plotArea;
  }
  _setupSelection() {
    const { _plotArea: { axes } } = this;
    const selections = this._selections = [];
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      const options = axis.options;
      if (axis instanceof category_axis_default && options.select && !options.vertical) {
        const range = axis.range();
        const selection = new selection_default(
          this,
          axis,
          deepExtend({ min: range.min, max: range.max }, options.select)
        );
        selections.push(selection);
      }
    }
  }
  _selectStart(e) {
    return this.trigger(SELECT_START, e);
  }
  _select(e) {
    return this.trigger(SELECT2, e);
  }
  _selectEnd(e) {
    return this.trigger(SELECT_END, e);
  }
  _initHandlers() {
    this._clickHandler = this._click.bind(this);
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._mousedownHandler = this._mousedown.bind(this);
    this._mousewheelHandler = this._mousewheel.bind(this);
    this._mouseleaveHandler = this._mouseleave.bind(this);
    this._surfaceMouseenterHandler = this._mouseover.bind(this);
    this._surfaceMouseleaveHandler = this._mouseout.bind(this);
    this._mousemoveThrottled = throttle(
      this._mousemove.bind(this),
      MOUSEMOVE_DELAY
    );
  }
  addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  }
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  }
  requiresHandlers(eventNames) {
    const observers = this.observers;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  }
  trigger(name, args = {}) {
    args.sender = this;
    if (name === SHOW_TOOLTIP) {
      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);
    } else if (name === SERIES_OVER) {
      this._updateDrilldownPoint(args.point);
    } else if (name === SERIES_LEAVE) {
      this._resetDrilldownPoint();
    } else if (name === SERIES_CLICK) {
      this._focusPoint(args.point);
      this._startDrilldown(args.point);
    } else if (name === LEGEND_ITEM_CLICK) {
      this._focusLegendItem(args);
    }
    const observers = this.observers;
    let isDefaultPrevented2 = false;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  }
  titleHeight() {
    if (!this._titleBox) {
      return 0;
    }
    return this._titleBox.height();
  }
  _attachEvents() {
    const element = this.element;
    this._touchAction = element.style.touchAction;
    bindEvents(element, {
      [CONTEXTMENU]: this._clickHandler,
      [MOUSEWHEEL]: this._mousewheelHandler,
      [MOUSELEAVE]: this._mouseleaveHandler,
      [KEYDOWN]: this._keydownHandler,
      [MOUSEDOWN]: this._mousedownHandler,
      [FOCUS]: this._focusHandler,
      [BLUR]: this._blurHandler
    });
    if (this._shouldAttachMouseMove()) {
      bindEvents(element, { [MOUSEMOVE]: this._mousemoveThrottled });
    }
    this.domEvents = dom_events_builder_default.create(this.element, {
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
    this._toggleDragZoomEvents();
  }
  _mouseleave(e) {
    if (this._hoveredPoint) {
      this._hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (this._plotAreaHovered) {
      this._plotAreaHovered = false;
      this.trigger(PLOT_AREA_LEAVE);
    }
    if (this._hasInactiveOpacity() && this._activeChartInstance) {
      this._applySeriesOpacity(this._activeChartInstance.children, null, true);
      this._updateSeriesOpacity(null, true);
    }
  }
  _cancelDomEvents() {
    if (this.domEvents && this.domEvents.cancel) {
      this.domEvents.cancel();
    }
  }
  _gesturestart(e) {
    if (this._mousewheelZoom && !this._stopChartHandlers(e)) {
      this._gestureDistance = e.distance;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this.surface.suspendTracking();
    }
  }
  _gestureend(e) {
    if (this._zooming && !this._stopChartHandlers(e)) {
      if (this.surface) {
        this.surface.resumeTracking();
      }
      this._zooming = false;
      this.trigger(ZOOM_END, {});
    }
  }
  _gesturechange(e) {
    const mousewheelZoom = this._mousewheelZoom;
    if (mousewheelZoom && !this._stopChartHandlers(e)) {
      e.preventDefault();
      const previousGestureDistance = this._gestureDistance;
      let scaleDelta = -e.distance / previousGestureDistance + 1;
      if (Math.abs(scaleDelta) >= 0.1) {
        scaleDelta = Math.round(scaleDelta * 10);
        this._gestureDistance = e.distance;
        const args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };
        if (this._zooming || !this.trigger(ZOOM_START, args)) {
          const coords = this._eventCoordinates(e);
          if (!this._zooming) {
            this._zooming = true;
          }
          const ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);
          if (ranges && !this.trigger(ZOOM, args)) {
            mousewheelZoom.zoom();
          }
        }
      }
    }
  }
  _mouseout(e) {
    if (e.element) {
      const element = this._drawingChartElement(e.element, e);
      if (element && element.leave) {
        element.leave(this, e.originalEvent);
      }
    }
  }
  _start(e) {
    const coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {
      this._startNavigation(e, coords, DRAG_START);
    }
    if (this._pannable && this._pannable.start(e)) {
      this.surface.suspendTracking();
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._suppressHover = true;
      this.chartService.panning = true;
    }
    if (this._zoomSelection) {
      if (this._zoomSelection.start(e)) {
        this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e });
      }
    }
  }
  _move(e) {
    let { _navState: state, _pannable: pannable } = this;
    if (this._stopChartHandlers(e)) {
      return;
    }
    if (pannable) {
      const ranges = pannable.move(e);
      if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e })) {
        pannable.pan();
      }
    } else if (state) {
      const ranges = {};
      const axes = state.axes;
      for (let i = 0; i < axes.length; i++) {
        const currentAxis = axes[i];
        const axisName = currentAxis.options.name;
        if (axisName) {
          const axis = currentAxis.options.vertical ? e.y : e.x;
          const delta = axis.startLocation - axis.location;
          if (delta !== 0) {
            ranges[currentAxis.options.name] = currentAxis.translateRange(delta);
          }
        }
      }
      state.axisRanges = ranges;
      this.trigger(DRAG, {
        axisRanges: ranges,
        originalEvent: e
      });
    }
    if (this._zoomSelection) {
      this._zoomSelection.move(e);
    }
  }
  _end(e) {
    if (this._stopChartHandlers(e)) {
      return;
    }
    const pannable = this._pannable;
    if (pannable && pannable.end(e)) {
      this.surface.resumeTracking();
      this.trigger(DRAG_END, {
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e
      });
      this._suppressHover = false;
      this.chartService.panning = false;
    } else {
      this._endNavigation(e, DRAG_END);
    }
    if (this._zoomSelection) {
      const ranges = this._zoomSelection.end(e);
      if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e })) {
        this._zoomSelection.zoom();
        this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e });
      }
    }
  }
  _stopChartHandlers(e) {
    const selections = this._selections || [];
    if (!selections.length) {
      return false;
    }
    const coords = this._eventCoordinates(e);
    const pane = this._plotArea.paneByPoint(coords);
    if (pane) {
      for (let idx = 0; idx < selections.length; idx++) {
        if (selections[idx].onPane(pane)) {
          return true;
        }
      }
    }
  }
  _mousewheelZoomRate() {
    const zoomable = this.options.zoomable;
    const mousewheel = (zoomable || {}).mousewheel || {};
    return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);
  }
  _mousewheel(e) {
    const delta = mousewheelDelta(e);
    const mousewheelZoom = this._mousewheelZoom;
    const coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (mousewheelZoom) {
      const args = { delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };
      if (this._zooming || !this.trigger(ZOOM_START, args)) {
        e.preventDefault();
        if (!this._zooming) {
          this._unsetActivePoint();
          this._clearFocusedElement();
          this.surface.suspendTracking();
          this._zooming = true;
        }
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);
        if (args.axisRanges && !this.trigger(ZOOM, args)) {
          mousewheelZoom.zoom();
        }
        this._mwTimeout = setTimeout(() => {
          this.trigger(ZOOM_END, args);
          this._zooming = false;
          if (this.surface) {
            this.surface.resumeTracking();
          }
        }, MOUSEWHEEL_DELAY);
      }
    } else {
      let state = this._navState;
      if (!state) {
        const prevented = this._startNavigation(e, coords, ZOOM_START);
        if (!prevented) {
          state = this._navState;
        }
      }
      if (state) {
        const totalDelta = state.totalDelta || delta;
        state.totalDelta = totalDelta + delta;
        const axes = this._navState.axes;
        const ranges = {};
        for (let i = 0; i < axes.length; i++) {
          const currentAxis = axes[i];
          const axisName = currentAxis.options.name;
          if (axisName) {
            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this._mousewheelZoomRate(), coords);
          }
        }
        this.trigger(ZOOM, {
          delta,
          axisRanges: ranges,
          originalEvent: e
        });
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        this._mwTimeout = setTimeout(() => {
          this._endNavigation(e, ZOOM_END);
        }, MOUSEWHEEL_DELAY);
      }
    }
  }
  _startNavigation(e, coords, chartEvent) {
    const plotArea = this._model._plotArea;
    const pane = plotArea.findPointPane(coords);
    const axes = plotArea.axes.slice(0);
    if (!pane) {
      return;
    }
    const ranges = axisRanges(axes);
    const prevented = this.trigger(chartEvent, {
      axisRanges: ranges,
      originalEvent: e
    });
    if (prevented) {
      this._cancelDomEvents();
    } else {
      this._suppressHover = true;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._navState = {
        axisRanges: ranges,
        pane,
        axes
      };
    }
  }
  _endNavigation(e, chartEvent) {
    if (this._navState) {
      this.trigger(chartEvent, {
        axisRanges: this._navState.axisRanges,
        originalEvent: e
      });
      this._suppressHover = false;
      this._navState = null;
    }
  }
  _getChartElement(e, match) {
    const element = this.surface.eventTarget(e);
    if (element) {
      return this._drawingChartElement(element, e, match);
    }
  }
  _drawingChartElement(element, e, match) {
    let current4 = element;
    let chartElement;
    while (current4 && !chartElement) {
      chartElement = current4.chartElement;
      current4 = current4.parent;
    }
    if (chartElement) {
      if (chartElement.aliasFor) {
        chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));
      }
      if (match) {
        chartElement = chartElement.closest(match);
        if (chartElement && chartElement.aliasFor) {
          chartElement = chartElement.aliasFor();
        }
      }
      return chartElement;
    }
  }
  _eventCoordinates(e) {
    const coordinates = eventCoordinates(e);
    return this._toModelCoordinates(coordinates.x, coordinates.y);
  }
  _elementPadding() {
    if (!this._padding) {
      const { paddingLeft, paddingTop } = elementStyles(this.element, ["paddingLeft", "paddingTop"]);
      this._padding = {
        top: paddingTop,
        left: paddingLeft
      };
    }
    return this._padding;
  }
  _toDocumentCoordinates(point) {
    const padding = this._elementPadding();
    const offset = elementOffset(this.element);
    return {
      left: round(point.x + padding.left + offset.left),
      top: round(point.y + padding.top + offset.top)
    };
  }
  // TODO: Breaking change due to peer version change
  // Reuse by exposing _surfacePoint on Surface
  _toModelCoordinates(clientX, clientY) {
    const element = this.element;
    const offset = elementOffset(element);
    const padding = this._elementPadding();
    const inverseTransform = elementScale(element).invert();
    const point = new geometry_exports.Point(
      clientX - offset.left - padding.left,
      clientY - offset.top - padding.top
    ).transform(inverseTransform);
    return new point_default(point.x, point.y);
  }
  _tap(e) {
    const drawingElement = this.surface.eventTarget(e);
    const element = this._drawingChartElement(drawingElement, e);
    const sharedTooltip = this._sharedTooltip();
    if (!this._startHover(drawingElement, e) && !sharedTooltip) {
      this._unsetActivePoint();
    }
    if (sharedTooltip) {
      this._trackSharedTooltip(this._eventCoordinates(e), e, true);
    }
    this._propagateClick(element, e);
    this.handlingTap = true;
    setTimeout(() => {
      this.handlingTap = false;
    }, 0);
  }
  _click(e) {
    const element = this._getChartElement(e);
    this._propagateClick(element, e);
  }
  _propagateClick(element, e) {
    let current4 = element;
    while (current4) {
      if (current4.click) {
        current4.click(this, e);
      }
      current4 = current4.parent;
    }
  }
  _isLegendBeforeChart() {
    const { options: { legend: { position: legendPosition } }, _legend: legend2 } = this;
    return legend2 && legend2.hasItems() && (legendPosition === TOP || legendPosition === LEFT);
  }
  _focus() {
    if (!this._preventInitialPointFocus) {
      if (this._isLegendBeforeChart()) {
        this._focusFirstLegendItem();
      } else {
        this._focusFirstPoint();
      }
    }
    this._preventInitialPointFocus = false;
  }
  _keydown(e) {
    const { _focusState: { legendInFocus, focusedElement }, _legend: legend2 } = this;
    if (e.key === TAB) {
      this._clearFocusedElement();
      const isLegendBeforeChart = this._isLegendBeforeChart();
      if (legendInFocus && isLegendBeforeChart !== e.shiftKey) {
        this._navigatePoints(e);
      } else if (!legendInFocus && isLegendBeforeChart === e.shiftKey && legend2.hasItems()) {
        this._navigateLegend(e);
      }
    } else if (e.key === ESCAPE) {
      if (focusedElement) {
        e.stopPropagation();
      }
      if (this._tooltip && this._tooltip.visible) {
        this._hideTooltip();
      } else {
        this._blur();
      }
    } else if (e.key === ENTER) {
      if (focusedElement) {
        this._focusState.preserveHighlight = true;
        this._propagateClick(focusedElement, e);
        this._focusElement(focusedElement);
      }
    } else if (!legendInFocus) {
      this._navigatePoints(e);
    } else {
      this._navigateLegend(e);
    }
  }
  _navigatePoints(e) {
    const { _focusState: focusState, _plotArea: plotArea } = this;
    focusState.legendInFocus = false;
    if (!focusState.focusedElement) {
      this._focusFirstPoint();
      e.preventDefault();
      return;
    }
    const moveFocus = (point) => {
      focusState.focusedPoint = point;
      this._focusElement(focusState.focusedPoint);
      this._displayTooltip(point);
      e.preventDefault();
    };
    switch (e.key) {
      case ARROW_RIGHT:
        moveFocus(plotArea.getPointToTheRight(focusState.focusedPoint));
        break;
      case ARROW_LEFT:
        moveFocus(plotArea.getPointToTheLeft(focusState.focusedPoint));
        break;
      case ARROW_DOWN:
        moveFocus(plotArea.getPointBelow(focusState.focusedPoint));
        break;
      case ARROW_UP:
        moveFocus(plotArea.getPointAbove(focusState.focusedPoint));
        break;
      default:
        break;
    }
  }
  _navigateLegend(e) {
    const { _focusState: focusState, _legend: legend2, chartService: { rtl } } = this;
    focusState.legendInFocus = true;
    if (!focusState.focusedElement) {
      this._focusFirstLegendItem();
      e.preventDefault();
      return;
    }
    const itemsLength = legend2.getItems().length;
    const moveFocus = (cycleFunc) => {
      focusState.focusedLegendItemIndex = cycleFunc(
        focusState.focusedLegendItemIndex,
        itemsLength
      );
      this._focusElement(this._getFocusedLegendItem());
      e.preventDefault();
    };
    switch (e.key) {
      case ARROW_UP:
      case ARROW_LEFT:
        moveFocus(rtl ? cycleUp : cycleDown);
        break;
      case ARROW_DOWN:
      case ARROW_RIGHT:
        moveFocus(rtl ? cycleDown : cycleUp);
        break;
      default:
        break;
    }
  }
  _focusFirstPoint() {
    const point = this._focusState.focusedPoint = this._plotArea.getFirstPoint();
    if (point) {
      this._focusElement(point);
      this._displayTooltip(point);
    }
  }
  _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  }
  _mousedown() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
    }
  }
  _focusChart() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
      this.element.focus();
    }
  }
  _focusPoint(point) {
    this._focusState.focusedPoint = point;
    this._focusChart();
    this._focusElement(point, true);
  }
  _focusFirstLegendItem() {
    const { _focusState: focusState } = this;
    focusState.focusedLegendItemIndex = 0;
    this._focusElement(this._getFocusedLegendItem());
    focusState.legendInFocus = true;
    this._hideTooltip();
  }
  _focusLegendItem(args) {
    const { _focusState: focusState } = this;
    focusState.focusedLegendItemIndex = this._legend.getItems().findIndex((x) => x.options.series.index === args.seriesIndex && x.options.pointIndex === args.pointIndex);
    focusState.legendInFocus = true;
    this._focusChart();
    this._focusElement(this._getFocusedLegendItem(), true);
  }
  _getFocusedLegendItem() {
    const { _focusState: focusState, _legend: legend2 } = this;
    return legend2.getItems()[focusState.focusedLegendItemIndex];
  }
  _focusElement(element, omitHighlight) {
    const { _focusState: focusState } = this;
    this._clearFocusedElement();
    if (!element) {
      return;
    }
    focusState.focusedElement = element;
    this._setElementActiveDescendant(element);
    if (!omitHighlight) {
      element.focusVisual();
      if (focusState.legendInFocus) {
        const options = element.options;
        this._showSeriesInactiveOpacity(options.series.index, options.pointIndex);
      } else {
        this._showInactiveOpacity(element);
      }
    }
  }
  _clearFocusedElement() {
    const { _focusState: focusState } = this;
    if (!focusState) {
      return;
    }
    if (focusState.focusedElement && focusState.focusedElement.clearFocusFromVisual) {
      focusState.focusedElement.clearFocusFromVisual();
      this._clearElementActiveDescendant();
    }
    focusState.focusedElement = null;
  }
  _setElementActiveDescendant(element) {
    if (this.options.renderAs === "canvas") {
      this._pseudoFocusedElement = this._createPseudoFocusedElement(element);
      this.element.append(this._pseudoFocusedElement);
    }
    this.element.setAttribute(ARIA_ACTIVE_DESCENDANT, element._id);
  }
  _clearElementActiveDescendant() {
    if (this._pseudoFocusedElement) {
      this._pseudoFocusedElement.remove();
      this._pseudoFocusedElement = null;
    }
    this.element.removeAttribute(ARIA_ACTIVE_DESCENDANT);
  }
  _createPseudoFocusedElement(element) {
    const pseudoElement = document.createElement("div");
    const accessibilityOptions = element.options.accessibility;
    pseudoElement.id = element._id;
    pseudoElement.setAttribute("aria-label", element.getAriaLabelText());
    pseudoElement.setAttribute("role", accessibilityOptions.role);
    pseudoElement.setAttribute("aria-roledescription", accessibilityOptions.ariaRoleDescription);
    const checked = accessibilityOptions.ariaChecked;
    if (defined(checked)) {
      pseudoElement.setAttribute("aria-checked", checked);
    }
    return pseudoElement;
  }
  _blur() {
    this._focusState.legendInFocus = false;
    this._clearFocusedElement();
    this._hideInactiveOpacity();
  }
  _startHover(element, e) {
    if (this._suppressHover) {
      return false;
    }
    let point = this._drawingChartElement(element, e, function(element2) {
      return (element2.hover || element2.over) && !(element2 instanceof plotarea_base_default);
    });
    const activePoint = this._activePoint;
    this._updateHoveredPoint(point, e);
    if (point && activePoint !== point && point.hover) {
      this._activePoint = point;
      if (!this._sharedTooltip() && !point.hover(this, e)) {
        this._displayTooltip(point);
        this._showInactiveOpacity(point);
      }
    }
    return point;
  }
  _displayTooltip(point) {
    const tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);
    if (tooltipOptions.visible) {
      if (this._sharedTooltip() && point.box) {
        this._trackSharedTooltip(point.box.center(), {});
      } else {
        this._tooltip.show(point);
      }
    }
  }
  _hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  }
  _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {
    const chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);
    if (!chartInstance) {
      return;
    }
    if (multipleSeries) {
      this._updateSeriesOpacity(activePoint);
      this._applySeriesOpacity(chartInstance.children, null, true);
      this._applySeriesOpacity(chartInstance.children, activePoint.series);
      this._highlight.show(highlightPoints || activePoint);
    } else {
      let inactivePoints;
      if (!chartInstance.supportsPointInactiveOpacity()) {
        this._highlight.show(activePoint);
        return;
      }
      inactivePoints = this._getInactivePoints(activePoint, chartInstance);
      if (inactivePoints && inactivePoints.length) {
        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));
      }
    }
  }
  _getInactivePoints(activePoint, chartInstance) {
    let allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);
    return allPoints.filter((point) => point !== activePoint);
  }
  _getAllPointsOfType(container, type) {
    let points = [];
    for (let i = 0; i < container.children.length; i++) {
      const element = container.children[i];
      if (element.constructor === type) {
        points.push(element);
      } else if (element.children && element.children.length) {
        points = points.concat(this._getAllPointsOfType(element, type));
      }
    }
    return points;
  }
  _updateHoveredPoint(point, e) {
    const hoveredPoint = this._hoveredPoint;
    if (hoveredPoint && hoveredPoint !== point) {
      hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (point && hoveredPoint !== point && point.over) {
      this._hoveredPoint = point;
      point.over(this, e);
    }
  }
  _updateDrilldownPoint(point) {
    if (!point || !point.series) {
      return;
    }
    const { fields } = series_binder_default.current.bindPoint(point.series, null, point.dataItem);
    if (fields.drilldown) {
      this._drilldownState = { cursor: this.element.style.cursor };
      this.element.style.cursor = "pointer";
    }
  }
  _resetDrilldownPoint() {
    if (this._drilldownState) {
      this.element.style.cursor = this._drilldownState.cursor;
      this._drilldownState = null;
    }
  }
  _startDrilldown(point) {
    if (!point || !point.series) {
      return;
    }
    const series = point.series;
    const { fields } = series_binder_default.current.bindPoint(series, null, point.dataItem);
    const value2 = fields.drilldown;
    if (value2) {
      const args = { series, point, value: value2, sender: this };
      this.trigger(DRILLDOWN, args);
    }
  }
  _updateSeriesOpacity(point, resetOpacity) {
    const plotArea = this._plotArea;
    const length = plotArea.series.length;
    for (let i = 0; i < length; i++) {
      const currSeries = plotArea.series[i];
      const defaultOpacity = this._getDefaultOpacityForSeries(currSeries);
      const inactiveOpacity = this._getInactiveOpacityForSeries(currSeries);
      if (!resetOpacity && currSeries !== point.series) {
        currSeries.defaultOpacity = defaultOpacity;
        currSeries.opacity = inactiveOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = inactiveOpacity;
        }
      } else {
        currSeries.opacity = defaultOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = defaultOpacity;
        }
      }
    }
  }
  _applySeriesOpacity(elements, activeSeries, reset, series) {
    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      const currSeries = element.series || series;
      const shouldHighlight = currSeries && (currSeries.highlight || {}).visible;
      if (shouldHighlight && element.visual) {
        const opacity = series ? series.opacity : element.series.opacity;
        if (currSeries !== activeSeries || reset) {
          element.visual.opacity(reset ? 1 : opacity);
        }
      }
      if (element.children && element.children.length) {
        this._applySeriesOpacity(element.children, activeSeries, reset, element.series);
      }
    }
  }
  _chartInstanceFromPoint(point) {
    let chartInstance = point.parent;
    while (chartInstance && !chartInstance.plotArea) {
      chartInstance = chartInstance.parent;
    }
    return chartInstance;
  }
  _showInactiveOpacity(point) {
    const multipleSeries = this._plotArea.series.length > 1;
    const hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      this._displayInactiveOpacity(point, multipleSeries);
    } else {
      this._highlight.show(point);
    }
  }
  _hideInactiveOpacity(point) {
    const multipleSeries = this._plotArea.series.length > 1;
    const hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      if (multipleSeries && this._activeChartInstance) {
        this._updateSeriesOpacity(point, true);
        this._applySeriesOpacity(this._activeChartInstance.children, null, true);
        this._activeChartInstance = null;
      }
      this._highlight && this._highlight.hide();
      this._activePoint = null;
    }
  }
  _hasInactiveOpacity() {
    let hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== void 0;
    let hasInactiveOpacity = this.options.series.filter((s) => s.highlight.inactiveOpacity !== void 0).length > 0;
    return hasDefaultInactiveOpacity || hasInactiveOpacity;
  }
  _getInactiveOpacityForSeries(series) {
    let defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;
    let seriesInactiveOpacity = series.highlight.inactiveOpacity;
    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  }
  _getDefaultOpacityForSeries(series) {
    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  }
  _mouseover(e) {
    const point = this._startHover(e.element, e.originalEvent);
    if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {
      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);
      bindEvents(document, {
        [MOUSEMOVE]: this._mouseMoveTrackHandler
      });
    }
  }
  _mouseMoveTracking(e) {
    const { options, _tooltip: tooltip, _highlight: highlight, _activePoint: point } = this;
    const coords = this._eventCoordinates(e);
    if (this._plotArea.box.containsPoint(coords)) {
      if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {
        const seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);
        if (seriesPoint && seriesPoint !== point) {
          this._activePoint = seriesPoint;
          if (!seriesPoint.hover(this, e)) {
            const tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);
            if (tooltipOptions.visible) {
              tooltip.show(seriesPoint);
            }
            highlight.show(seriesPoint);
          }
        }
      }
    } else {
      unbindEvents(document, {
        [MOUSEMOVE]: this._mouseMoveTrackHandler
      });
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._mouseMoveTrackHandler = null;
      this._hideInactiveOpacity(point);
    }
  }
  _mousemove(e) {
    const coords = this._eventCoordinates(e);
    const plotArea = this._plotArea;
    this._trackCrosshairs(coords);
    if (plotArea.hover) {
      const overPlotArea = plotArea.backgroundContainsPoint(coords);
      if (overPlotArea) {
        this._plotAreaHovered = true;
        this._plotArea.hover(this, e);
      } else if (this._plotAreaHovered && !overPlotArea) {
        this._plotAreaHovered = false;
        this.trigger(PLOT_AREA_LEAVE);
      }
    }
    if (this._sharedTooltip()) {
      this._trackSharedTooltip(coords, e);
    }
  }
  _trackCrosshairs(coords) {
    const crosshairs = this._plotArea.crosshairs;
    for (let i = 0; i < crosshairs.length; i++) {
      const current4 = crosshairs[i];
      if (current4.box.containsPoint(coords)) {
        current4.showAt(coords);
      } else {
        current4.hide();
      }
    }
  }
  _trackSharedTooltip(coords, e, toggle) {
    if (this._suppressHover) {
      return;
    }
    const { options: { tooltip: tooltipOptions }, _plotArea: plotArea, _plotArea: { categoryAxis }, _tooltip: tooltip, _highlight: highlight } = this;
    if (plotArea.backgroundContainsPoint(coords)) {
      const index = categoryAxis.pointCategoryIndex(coords);
      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {
        const points = plotArea.pointsByCategoryIndex(index);
        const pointArgs = points.map(function(point) {
          return point.eventArgs(e);
        });
        const hoverArgs = pointArgs[0] || {};
        hoverArgs.categoryPoints = pointArgs;
        if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {
          if (tooltipOptions.visible) {
            tooltip.showAt(points, coords);
          }
          highlight.show(points);
          this._sharedHighlight = true;
        } else {
          tooltip.hide();
        }
        this._tooltipCategoryIx = index;
      } else if (toggle && this._sharedHighlight) {
        highlight.hide();
        tooltip.hide();
        this._sharedHighlight = false;
      }
    } else if (this._sharedHighlight) {
      highlight.hide();
      tooltip.hide();
      this._tooltipCategoryIx = null;
      this._sharedHighlight = false;
    }
  }
  hideElements(options) {
    const plotArea = this._plotArea;
    this._mousemoveThrottled.cancel();
    plotArea.hideCrosshairs();
    this._unsetActivePoint(options);
  }
  _unsetActivePoint(options) {
    const { _highlight: highlight } = this;
    this._activePoint = null;
    this._hoveredPoint = null;
    if (!options || !options.keepTooltipOpen) {
      this._hideTooltip();
    }
    this._tooltipCategoryIx = null;
    this._sharedHighlight = false;
    if (highlight) {
      highlight.hide();
    }
  }
  _deferRedraw() {
    this._redraw();
  }
  _clearRedrawTimeout() {
    if (this._redrawTimeout) {
      clearInterval(this._redrawTimeout);
      this._redrawTimeout = null;
    }
  }
  bindCategories() {
    const options = this.options;
    const definitions = [].concat(options.categoryAxis);
    for (let axisIx = 0; axisIx < definitions.length; axisIx++) {
      const axis = definitions[axisIx];
      if (axis.autoBind !== false) {
        this.bindCategoryAxisFromSeries(axis, axisIx);
      }
    }
  }
  bindCategoryAxisFromSeries(axis, axisIx) {
    const uniqueCategories = /* @__PURE__ */ new Set();
    const seriesOnAxis = this.options.series.filter((series) => series.categoryAxis === axis.name || !series.categoryAxis && axisIx === 0);
    const hasCategoryBinding = seriesOnAxis.some((series) => Boolean(series.categoryField));
    const seriesWithData = seriesOnAxis.filter((series) => series.data && series.data.length > 0);
    const categorySamples = seriesWithData.map((series) => series_binder_default.current.bindPoint(series, 0).fields.category);
    const dateAxis = categorySamples.reduce((result, firstCategory) => result || isDateAxis(axis, firstCategory), false);
    const seriesWithBinding = seriesWithData.filter((series, seriesIx) => series.categoryField || defined(categorySamples[seriesIx]));
    seriesWithBinding.forEach((series) => series.data.forEach((row, index) => {
      let category = series_binder_default.current.bindPoint(series, index).fields.category;
      if (dateAxis) {
        const date = parseDateCategory(category, row, this.chartService.intl);
        category = date ? date.getTime() : void 0;
      }
      uniqueCategories.add(category);
    }));
    if (uniqueCategories.size > 0) {
      let categories = Array.from(uniqueCategories.values());
      if (dateAxis) {
        categories = categories.sort().map((time) => time && new Date(time));
      }
      axis.categories = categories;
    } else if (hasCategoryBinding) {
      axis.categories = [];
    }
  }
  _isBindable(series) {
    const valueFields = series_binder_default.current.valueFields(series);
    let result = true;
    for (let i = 0; i < valueFields.length; i++) {
      let field = valueFields[i];
      if (field === VALUE) {
        field = "field";
      } else {
        field = field + "Field";
      }
      if (!defined(series[field])) {
        result = false;
        break;
      }
    }
    return result;
  }
  _noTransitionsRedraw() {
    const options = this.options;
    let transitionsState;
    if (options.transitions !== false) {
      options.transitions = false;
      transitionsState = true;
    }
    this._redraw();
    if (transitionsState) {
      options.transitions = true;
    }
  }
  _legendItemHover(seriesIndex, pointIndex) {
    this._showSeriesInactiveOpacity(seriesIndex, pointIndex);
  }
  _showSeriesInactiveOpacity(seriesIndex, pointIndex) {
    const { _plotArea: plotArea, _highlight: highlight } = this;
    const currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
    let items;
    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL, PYRAMID])) {
      items = plotArea.findPoint(function(point) {
        return point.series.index === seriesIndex && point.index === pointIndex;
      });
    } else {
      items = plotArea.pointsBySeriesIndex(seriesIndex);
    }
    if (this._hasInactiveOpacity() && currentSeries.visible && items) {
      const multipleSeries = plotArea.series.length > 1;
      const point = items.length ? items[0] : items;
      this._displayInactiveOpacity(point, multipleSeries, items);
    } else {
      highlight.show(items);
    }
  }
  _shouldAttachMouseMove() {
    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);
  }
  updateMouseMoveHandler() {
    unbindEvents(this.element, {
      [MOUSEMOVE]: this._mousemoveThrottled
    });
    if (this._shouldAttachMouseMove()) {
      bindEvents(this.element, {
        [MOUSEMOVE]: this._mousemoveThrottled
      });
    }
  }
  applyOptions(options, theme) {
    clearMissingValues(this._originalOptions, options);
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    if (theme) {
      this._theme = theme;
      this.chartService.theme = theme;
    }
    this._initTheme(this.options, this._theme);
    this._toggleDragZoomEvents();
  }
  setOptions(options, theme) {
    this.applyOptions(options, theme);
    this.bindCategories();
    this.redraw();
    this.updateMouseMoveHandler();
    this._restoreOverlayElement();
  }
  setDirection(rtl) {
    this.chartService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this._destroySurface();
    }
  }
  setIntlService(intl) {
    this.chartService.intl = intl;
  }
  noTransitionsRedraw() {
    this._noTransitionsRedraw();
  }
  destroy() {
    this._destroyed = true;
    unbindEvents(this.element, {
      [CONTEXTMENU]: this._clickHandler,
      [MOUSEWHEEL]: this._mousewheelHandler,
      [MOUSEMOVE]: this._mousemoveThrottled,
      [MOUSELEAVE]: this._mouseleaveHandler,
      [MOUSEDOWN]: this._mousedownHandler,
      [KEYDOWN]: this._keydownHandler,
      [FOCUS]: this._focusHandler,
      [BLUR]: this._blurHandler
    });
    if (this.domEvents) {
      this.domEvents.destroy();
      delete this.domEvents;
    }
    if (this._mouseMoveTrackHandler) {
      unbindEvents(document, {
        [MOUSEMOVE]: this._mouseMoveTrackHandler
      });
    }
    this._focusState = null;
    this.element._kendoExportVisual = null;
    this._destroyView();
    this._destroySurface();
    this._clearRedrawTimeout();
  }
  _destroySurface() {
    const surface = this.surface;
    if (surface) {
      surface.unbind("mouseenter", this._surfaceMouseenterHandler);
      surface.unbind("mouseleave", this._surfaceMouseleaveHandler);
      surface.destroy();
      this.surface = null;
    }
  }
  _destroySelections() {
    const selections = this._selections;
    if (selections) {
      while (selections.length > 0) {
        selections.shift().destroy();
      }
    }
  }
  _destroyView() {
    const model = this._model;
    if (model) {
      model.destroy();
      this._model = null;
    }
    this._unsetActivePoint();
    this._clearFocusedElement();
    this._resetDrilldownPoint();
    this._destroySelections();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this._highlight) {
      this._highlight.destroy();
    }
    if (this._zoomSelection) {
      this._zoomSelection.destroy();
      delete this._zoomSelection;
    }
    if (this._pannable) {
      this._pannable.destroy();
      delete this._pannable;
    }
    if (this._mousewheelZoom) {
      this._mousewheelZoom.destroy();
      delete this._mousewheelZoom;
    }
  }
};
function resolveAxisAliases(options) {
  const aliases = AXIS_NAMES;
  for (let idx = 0; idx < aliases.length; idx++) {
    const alias = aliases[idx] + "Axes";
    if (options[alias]) {
      options[aliases[idx] + "Axis"] = options[alias];
      delete options[alias];
    }
  }
}
function pointByCategoryName(points, name) {
  if (points) {
    for (let idx = 0; idx < points.length; idx++) {
      if (points[idx].category === name) {
        return [points[idx]];
      }
    }
  }
}
function applyAxisDefaults(options, themeOptions) {
  const themeAxisDefaults = (themeOptions || {}).axisDefaults || {};
  let axisName, axisDefaults2, axes;
  function mapAxisOptions(axisOptions2) {
    const axisColor = (axisOptions2 || {}).color || axisDefaults2.color;
    const result = deepExtend(
      {},
      themeAxisDefaults,
      themeAxisDefaults[axisName],
      axisDefaults2,
      axisDefaults2[axisName],
      {
        line: { color: axisColor },
        labels: { color: axisColor },
        title: { color: axisColor }
      },
      axisOptions2
    );
    delete result[axisName];
    return result;
  }
  for (let idx = 0; idx < AXIS_NAMES.length; idx++) {
    axisName = AXIS_NAMES[idx] + "Axis";
    axisDefaults2 = options.axisDefaults || {};
    axes = [].concat(options[axisName]);
    axes = axes.map(mapAxisOptions);
    options[axisName] = axes.length > 1 ? axes : axes[0];
  }
}
function applySeriesDefaults(options, themeOptions) {
  const series = options.series;
  const seriesLength = series.length;
  const seriesDefaults2 = options.seriesDefaults;
  const commonDefaults = deepExtend({}, options.seriesDefaults);
  const themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};
  const commonThemeDefaults = deepExtend({}, themeSeriesDefaults);
  cleanupNestedSeriesDefaults(commonDefaults);
  cleanupNestedSeriesDefaults(commonThemeDefaults);
  for (let i = 0; i < seriesLength; i++) {
    const seriesType = series[i].type || options.seriesDefaults.type;
    const baseOptions = deepExtend(
      { data: [] },
      commonThemeDefaults,
      themeSeriesDefaults[seriesType],
      { tooltip: options.tooltip },
      commonDefaults,
      seriesDefaults2[seriesType]
    );
    series[i]._defaults = baseOptions;
    series[i] = deepExtend({}, baseOptions, series[i]);
    series[i].data = series[i].data || [];
  }
}
function cleanupNestedSeriesDefaults(seriesDefaults2) {
  delete seriesDefaults2.bar;
  delete seriesDefaults2.column;
  delete seriesDefaults2.rangeColumn;
  delete seriesDefaults2.line;
  delete seriesDefaults2.verticalLine;
  delete seriesDefaults2.pie;
  delete seriesDefaults2.donut;
  delete seriesDefaults2.area;
  delete seriesDefaults2.verticalArea;
  delete seriesDefaults2.scatter;
  delete seriesDefaults2.scatterLine;
  delete seriesDefaults2.bubble;
  delete seriesDefaults2.candlestick;
  delete seriesDefaults2.ohlc;
  delete seriesDefaults2.boxPlot;
  delete seriesDefaults2.bullet;
  delete seriesDefaults2.verticalBullet;
  delete seriesDefaults2.polarArea;
  delete seriesDefaults2.polarLine;
  delete seriesDefaults2.radarArea;
  delete seriesDefaults2.radarLine;
  delete seriesDefaults2.waterfall;
}
function axisRanges(axes) {
  const ranges = {};
  for (let i = 0; i < axes.length; i++) {
    const axis = axes[i];
    const axisName = axis.options.name;
    if (axisName) {
      ranges[axisName] = axis.range();
    }
  }
  return ranges;
}
var DATA_FIELDS = ["data", "categories"];
function clearMissingValues(originalOptions, options) {
  for (let field in options) {
    if (!inArray(field, DATA_FIELDS) && hasOwnProperty(options, field)) {
      const fieldValue = options[field];
      const originalValue = originalOptions[field];
      if (defined(originalValue)) {
        const nullValue = fieldValue === null;
        if (nullValue || !defined(fieldValue)) {
          delete originalOptions[field];
          if (nullValue) {
            delete options[field];
          }
        } else if (originalValue && isObject(fieldValue)) {
          if (isObject(originalValue)) {
            clearMissingValues(originalValue, fieldValue);
          }
        }
      }
    }
  }
}
function triggerPaneRender(panes) {
  for (let idx = 0; idx < panes.length; idx++) {
    panes[idx].notifyRender();
  }
}
setDefaultOptions(Chart, {
  renderAs: "",
  chartArea: {},
  legend: {
    visible: true,
    labels: {},
    accessibility: {},
    focusHighlight: {
      border: {
        opacity: 1,
        color: BLACK,
        width: 2
      }
    }
  },
  categoryAxis: {},
  seriesDefaults: {
    type: COLUMN,
    data: [],
    highlight: {
      visible: true
    },
    labels: {},
    negativeValues: {
      visible: false
    },
    accessibility: {},
    focusHighlight: {
      border: {
        opacity: 1,
        width: 2
      },
      zIndex: 200
    }
  },
  series: [],
  seriesColors: null,
  tooltip: {
    visible: false
  },
  transitions: true,
  valueAxis: {
    narrowRange: false
  },
  plotArea: {},
  title: {},
  xAxis: {},
  yAxis: {},
  panes: [{}],
  pannable: false,
  zoomable: false
});
var chart_default = Chart;

// node_modules/@progress/kendo-charts/dist/es/sparkline/shared-tooltip.js
var TOP_OFFSET = -2;
var SharedTooltip2 = class extends shared_tooltip_default {
  _slotAnchor(coords, slot) {
    const axis = this.plotArea.categoryAxis;
    const vertical = axis.options.vertical;
    const align = vertical ? {
      horizontal: "left",
      vertical: "center"
    } : {
      horizontal: "center",
      vertical: "bottom"
    };
    let point;
    if (vertical) {
      point = new point_default(this.plotArea.box.x2, slot.center().y);
    } else {
      point = new point_default(slot.center().x, TOP_OFFSET);
    }
    return {
      point,
      align
    };
  }
  _defaultAnchor(point, slot) {
    return this._slotAnchor({}, slot);
  }
};
var shared_tooltip_default2 = SharedTooltip2;

// node_modules/@progress/kendo-charts/dist/es/sparkline/sparkline.js
var DEAULT_BAR_WIDTH = 150;
var DEAULT_BULLET_WIDTH = 150;
var NO_CROSSHAIR = [BAR, BULLET];
function hide(children) {
  const state = [];
  for (let idx = 0; idx < children.length; idx++) {
    const child = children[idx];
    state[idx] = child.style.display;
    child.style.display = "none";
  }
  return state;
}
function show(children, state) {
  for (let idx = 0; idx < children.length; idx++) {
    children[idx].style.display = state[idx];
  }
}
function wrapNumber(value2) {
  return isNumber(value2) ? [value2] : value2;
}
var Sparkline = class extends chart_default {
  _setElementClass(element) {
    addClass(element, "k-sparkline");
  }
  _initElement(element) {
    super._initElement(element);
    this._initialWidth = Math.floor(elementSize(element).width);
  }
  _resize() {
    const element = this.element;
    const state = hide(element.childNodes);
    this._initialWidth = Math.floor(elementSize(element).width);
    show(element.childNodes, state);
    super._resize();
  }
  _modelOptions() {
    const chartOptions = this.options;
    const stage = this._surfaceWrap();
    const displayState = hide(stage.childNodes);
    const space = document.createElement("span");
    space.innerHTML = "&nbsp;";
    stage.appendChild(space);
    const options = deepExtend({
      width: this._autoWidth,
      height: elementSize(stage).height,
      transitions: chartOptions.transitions
    }, chartOptions.chartArea, {
      inline: true,
      align: false
    });
    elementSize(stage, {
      width: options.width,
      height: options.height
    });
    stage.removeChild(space);
    show(stage.childNodes, displayState);
    if (this.surface) {
      this.surface.resize();
    }
    return options;
  }
  _surfaceWrap() {
    if (!this.stage) {
      const stage = this.stage = document.createElement("span");
      this.element.appendChild(stage);
    }
    return this.stage;
  }
  _createPlotArea(skipSeries) {
    const plotArea = super._createPlotArea(skipSeries);
    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);
    return plotArea;
  }
  _calculateWidth(plotArea) {
    const options = this.options;
    const margin = getSpacing(options.chartArea.margin);
    const charts = plotArea.charts;
    const stage = this._surfaceWrap();
    let total = 0;
    for (let i = 0; i < charts.length; i++) {
      const currentChart = charts[i];
      const firstSeries = (currentChart.options.series || [])[0];
      if (!firstSeries) {
        continue;
      }
      if (firstSeries.type === BAR) {
        return DEAULT_BAR_WIDTH;
      }
      if (firstSeries.type === BULLET) {
        return DEAULT_BULLET_WIDTH;
      }
      if (firstSeries.type === PIE) {
        return elementSize(stage).height;
      }
      const categoryAxis = currentChart.categoryAxis;
      if (categoryAxis) {
        const pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);
        total = Math.max(total, pointsCount);
      }
    }
    let size = total * options.pointWidth;
    if (size > 0) {
      size += margin.left + margin.right;
    }
    return size;
  }
  _createSharedTooltip(options) {
    return new shared_tooltip_default2(this._plotArea, options);
  }
  static normalizeOptions(userOptions) {
    let options = wrapNumber(userOptions);
    if (isArray(options)) {
      options = { seriesDefaults: { data: options } };
    } else {
      options = deepExtend({}, options);
    }
    if (!options.series) {
      options.series = [{ data: wrapNumber(options.data) }];
    }
    deepExtend(options, {
      seriesDefaults: {
        type: options.type
      }
    });
    if (inArray(options.series[0].type, NO_CROSSHAIR) || inArray(options.seriesDefaults.type, NO_CROSSHAIR)) {
      options = deepExtend({}, {
        categoryAxis: {
          crosshair: {
            visible: false
          }
        }
      }, options);
    }
    return options;
  }
};
setDefaultOptions(Sparkline, {
  chartArea: {
    margin: 2
  },
  axisDefaults: {
    visible: false,
    majorGridLines: {
      visible: false
    },
    valueAxis: {
      narrowRange: true
    }
  },
  seriesDefaults: {
    type: "line",
    area: {
      line: {
        width: 0.5
      }
    },
    bar: {
      stack: true
    },
    padding: 2,
    width: 0.5,
    overlay: {
      gradient: null
    },
    highlight: {
      visible: false
    },
    border: {
      width: 0
    },
    markers: {
      size: 2,
      visible: false
    }
  },
  tooltip: {
    visible: true,
    shared: true
  },
  categoryAxis: {
    crosshair: {
      visible: true,
      tooltip: {
        visible: false
      }
    }
  },
  legend: {
    visible: false
  },
  transitions: false,
  pointWidth: 5,
  panes: [{ clip: false }]
});
var sparkline_default = Sparkline;

// node_modules/@progress/kendo-charts/dist/es/stock/fade-out-animation.js
var FadeOutAnimation = class extends drawing_exports.Animation {
  setup() {
    this._initialOpacity = parseFloat(elementStyles(this.element, "opacity").opacity);
  }
  step(pos) {
    elementStyles(this.element, {
      opacity: String(interpolateValue(this._initialOpacity, 0, pos))
    });
  }
  abort() {
    super.abort();
    elementStyles(this.element, {
      display: "none",
      opacity: String(this._initialOpacity)
    });
  }
  cancel() {
    super.abort();
    elementStyles(this.element, {
      opacity: String(this._initialOpacity)
    });
  }
};
var fade_out_animation_default = FadeOutAnimation;

// node_modules/@progress/kendo-charts/dist/es/stock/navigator-hint.js
function createDiv2(className, style) {
  const div = document.createElement("div");
  div.className = className;
  if (style) {
    div.style.cssText = style;
  }
  return div;
}
var NavigatorHint = class extends class_default {
  constructor(container, chartService, options) {
    super();
    this.options = deepExtend({}, this.options, options);
    this.container = container;
    this.chartService = chartService;
    const padding = elementStyles(container, ["paddingLeft", "paddingTop"]);
    this.chartPadding = {
      top: padding.paddingTop,
      left: padding.paddingLeft
    };
    this.createElements();
    container.appendChild(this.element);
  }
  createElements() {
    const element = this.element = createDiv2("k-navigator-hint", "display: none; position: absolute; top: 1px; left: 1px;");
    const tooltip = this.tooltip = createDiv2("k-tooltip k-chart-tooltip");
    const scroll = this.scroll = createDiv2("k-scroll");
    tooltip.innerHTML = "&nbsp;";
    element.appendChild(tooltip);
    element.appendChild(scroll);
  }
  show(from, to, bbox) {
    const { element, options, scroll, tooltip } = this;
    const middle = toDate(toTime(from) + toTime(to - from) / 2);
    const scrollWidth = bbox.width() * 0.4;
    const minPos = bbox.center().x - scrollWidth;
    const maxPos = bbox.center().x;
    const posRange = maxPos - minPos;
    const range = options.max - options.min;
    const scale = posRange / range;
    const offset = middle - options.min;
    let text = this.chartService.intl.format(options.format, from, to);
    const template = getTemplate(options);
    this.clearHideTimeout();
    if (!this._visible) {
      elementStyles(element, {
        visibility: "hidden",
        display: "block"
      });
      this._visible = true;
    }
    if (template) {
      text = template({
        from,
        to
      });
    }
    tooltip.innerHTML = text;
    elementStyles(tooltip, {
      left: bbox.center().x - tooltip.offsetWidth / 2,
      top: bbox.y1
    });
    const tooltipStyle = elementStyles(tooltip, ["marginTop", "borderTopWidth", "height"]);
    elementStyles(scroll, {
      width: scrollWidth,
      left: minPos + offset * scale,
      top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2
    });
    elementStyles(element, {
      visibility: "visible"
    });
  }
  clearHideTimeout() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    if (this._hideAnimation) {
      this._hideAnimation.cancel();
    }
  }
  hide() {
    this.clearHideTimeout();
    this._hideTimeout = setTimeout(() => {
      this._visible = false;
      this._hideAnimation = new fade_out_animation_default(this.element);
      this._hideAnimation.setup();
      this._hideAnimation.play();
    }, this.options.hideDelay);
  }
  destroy() {
    this.clearHideTimeout();
    if (this.container) {
      this.container.removeChild(this.element);
    }
    delete this.container;
    delete this.chartService;
    delete this.element;
    delete this.tooltip;
    delete this.scroll;
  }
};
setDefaultOptions(NavigatorHint, {
  format: "{0:d} - {1:d}",
  hideDelay: 500
});
var navigator_hint_default = NavigatorHint;

// node_modules/@progress/kendo-charts/dist/es/stock/constants.js
var NAVIGATOR_PANE = "_navigator";
var NAVIGATOR_AXIS = NAVIGATOR_PANE;
var DEFAULT_PANE = "_default";

// node_modules/@progress/kendo-charts/dist/es/stock/navigator.js
var ZOOM_ACCELERATION2 = 3;
var Navigator = class _Navigator extends class_default {
  constructor(chart) {
    super();
    this.chart = chart;
    const options = this.options = deepExtend({}, this.options, chart.options.navigator);
    const select = options.select;
    if (select) {
      select.from = this.parseDate(select.from);
      select.to = this.parseDate(select.to);
    }
    if (!defined(options.hint.visible)) {
      options.hint.visible = options.visible;
    }
    this.chartObserver = new instance_observer_default(this, {
      [DRAG]: "_drag",
      [DRAG_END]: "_dragEnd",
      [ZOOM]: "_zoom",
      [ZOOM_END]: "_zoomEnd"
    });
    chart.addObserver(this.chartObserver);
  }
  parseDate(value2) {
    return parseDate(this.chart.chartService.intl, value2);
  }
  clean() {
    if (this.selection) {
      this.selection.destroy();
      this.selection = null;
    }
    if (this.hint) {
      this.hint.destroy();
      this.hint = null;
    }
  }
  destroy() {
    if (this.chart) {
      this.chart.removeObserver(this.chartObserver);
      delete this.chart;
    }
    this.clean();
  }
  redraw() {
    this._redrawSelf();
    this.initSelection();
  }
  initSelection() {
    const { chart, options } = this;
    const axis = this.mainAxis();
    const { min: min4, max: max3 } = axis.roundedRange();
    const { from, to, mousewheel } = options.select;
    const axisClone = clone(axis);
    if (axis.categoriesCount() === 0) {
      return;
    }
    this.clean();
    axisClone.box = axis.box;
    this.selection = new selection_default(chart, axisClone, {
      min: min4,
      max: max3,
      from: from || min4,
      to: to || max3,
      mousewheel: valueOrDefault(mousewheel, { zoom: "left" }),
      visible: options.visible
    }, new instance_observer_default(this, {
      selectStart: "_selectStart",
      select: "_select",
      selectEnd: "_selectEnd"
    }));
    if (options.hint.visible) {
      this.hint = new navigator_hint_default(chart.element, chart.chartService, {
        min: min4,
        max: max3,
        template: getTemplate(options.hint),
        format: options.hint.format
      });
    }
  }
  setRange() {
    const plotArea = this.chart._createPlotArea(true);
    const axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    const { min: min4, max: max3 } = axis.roundedRange();
    const select = this.options.select || {};
    let from = select.from || min4;
    if (from < min4) {
      from = min4;
    }
    let to = select.to || max3;
    if (to > max3) {
      to = max3;
    }
    this.options.select = deepExtend({}, select, {
      from,
      to
    });
    this.filterAxes();
  }
  _redrawSelf(silent) {
    const plotArea = this.chart._plotArea;
    if (plotArea) {
      plotArea.redraw(last(plotArea.panes), silent);
    }
  }
  redrawSlaves() {
    const chart = this.chart;
    const plotArea = chart._plotArea;
    const slavePanes = plotArea.panes.filter((pane) => pane.options.name !== NAVIGATOR_PANE);
    plotArea.srcSeries = chart.options.series;
    plotArea.options.categoryAxis = chart.options.categoryAxis;
    plotArea.clearSeriesPointsCache();
    plotArea.redraw(slavePanes);
  }
  _drag(e) {
    const { chart, selection } = this;
    const coords = chart._eventCoordinates(e.originalEvent);
    const navigatorAxis = this.mainAxis();
    const naviRange = navigatorAxis.roundedRange();
    const inNavigator = navigatorAxis.pane.box.containsPoint(coords);
    const axis = chart._plotArea.categoryAxis;
    const range = e.axisRanges[axis.options.name];
    const select = this.options.select;
    let duration2;
    if (!range || inNavigator || !selection) {
      return;
    }
    if (select.from && select.to) {
      duration2 = toTime(select.to) - toTime(select.from);
    } else {
      duration2 = toTime(selection.options.to) - toTime(selection.options.from);
    }
    const from = toDate(limitValue(
      toTime(range.min),
      naviRange.min,
      toTime(naviRange.max) - duration2
    ));
    const to = toDate(limitValue(
      toTime(from) + duration2,
      toTime(naviRange.min) + duration2,
      naviRange.max
    ));
    this.options.select = { from, to };
    if (this.options.liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(from, to);
    this.showHint(from, to);
  }
  _dragEnd() {
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    if (this.hint) {
      this.hint.hide();
    }
  }
  readSelection() {
    const { selection: { options: { from, to } }, options: { select } } = this;
    select.from = from;
    select.to = to;
  }
  filterAxes() {
    const { options: { select = {} }, chart } = this;
    const allAxes = chart.options.categoryAxis;
    const { from, to } = select;
    for (let idx = 0; idx < allAxes.length; idx++) {
      const axis = allAxes[idx];
      if (axis.pane !== NAVIGATOR_PANE) {
        axis.min = from;
        axis.max = to;
      }
    }
  }
  filter() {
    const { chart, options: { select } } = this;
    if (!chart.requiresHandlers(["navigatorFilter"])) {
      return;
    }
    const mainAxis = this.mainAxis();
    const args = {
      from: select.from,
      to: select.to
    };
    if (mainAxis.options.type !== "category") {
      const axisOptions2 = new date_category_axis_default(deepExtend({
        baseUnit: "fit"
      }, chart.options.categoryAxis[0], {
        categories: [select.from, select.to]
      }), chart.chartService).options;
      args.from = addDuration(axisOptions2.min, -axisOptions2.baseUnitStep, axisOptions2.baseUnit);
      args.to = addDuration(axisOptions2.max, axisOptions2.baseUnitStep, axisOptions2.baseUnit);
    }
    this.chart.trigger("navigatorFilter", args);
  }
  _zoom(e) {
    const { chart: { _plotArea: { categoryAxis: axis } }, selection, options: { select, liveDrag } } = this;
    const mainAxis = this.mainAxis();
    let delta = e.delta;
    if (!selection) {
      return;
    }
    const fromIx = mainAxis.categoryIndex(selection.options.from);
    const toIx = mainAxis.categoryIndex(selection.options.to);
    const coords = this.chart._eventCoordinates(e.originalEvent);
    e.originalEvent.preventDefault();
    if (Math.abs(delta) > 1) {
      delta *= ZOOM_ACCELERATION2;
    }
    if (toIx - fromIx > 1) {
      selection.zoom(delta, coords);
      this.readSelection();
    } else {
      axis.options.min = select.from;
      select.from = axis.scaleRange(-e.delta * this.chart._mousewheelZoomRate(), coords).min;
    }
    if (liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(select.from, select.to);
    this.showHint(this.options.select.from, this.options.select.to);
  }
  _zoomEnd(e) {
    this._dragEnd(e);
  }
  showHint(from, to) {
    const plotArea = this.chart._plotArea;
    if (this.hint) {
      this.hint.show(from, to, plotArea.backgroundBox());
    }
  }
  _selectStart(e) {
    return this.chart._selectStart(e);
  }
  _select(e) {
    this.showHint(e.from, e.to);
    return this.chart._select(e);
  }
  _selectEnd(e) {
    if (this.hint) {
      this.hint.hide();
    }
    this.readSelection();
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    return this.chart._selectEnd(e);
  }
  mainAxis() {
    const plotArea = this.chart._plotArea;
    if (plotArea) {
      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    }
  }
  select(from, to) {
    const select = this.options.select;
    if (from && to) {
      select.from = this.parseDate(from);
      select.to = this.parseDate(to);
      this.filterAxes();
      this.filter();
      this.redrawSlaves();
      this.selection.set(from, to);
    }
    return {
      from: select.from,
      to: select.to
    };
  }
  static setup(options = {}, themeOptions = {}) {
    if (options.__navi) {
      return;
    }
    options.__navi = true;
    const naviOptions = deepExtend({}, themeOptions.navigator, options.navigator);
    const panes = options.panes = [].concat(options.panes);
    const paneOptions = deepExtend({}, naviOptions.pane, { name: NAVIGATOR_PANE });
    if (!naviOptions.visible) {
      paneOptions.visible = false;
      paneOptions.height = 0.1;
    }
    if (options.navigator.position !== "top") {
      panes.push(paneOptions);
    } else {
      panes.unshift(paneOptions);
    }
    panes.forEach((pane) => {
      pane.name = pane.name || DEFAULT_PANE;
    });
    _Navigator.attachAxes(options, naviOptions);
    _Navigator.attachSeries(options, naviOptions, themeOptions);
  }
  static attachAxes(options, naviOptions) {
    const series = naviOptions.series || [];
    const categoryAxes = options.categoryAxis = [].concat(options.categoryAxis);
    const valueAxes = options.valueAxis = [].concat(options.valueAxis);
    const allAxes = categoryAxes.concat(valueAxes);
    allAxes.forEach((axis) => {
      axis.pane = axis.pane || DEFAULT_PANE;
    });
    const equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);
    const justifyAxis = equallySpacedSeries.length === 0;
    const base = deepExtend({
      type: "date",
      pane: NAVIGATOR_PANE,
      roundToBaseUnit: !justifyAxis,
      justified: justifyAxis,
      _collapse: false,
      majorTicks: { visible: true },
      tooltip: { visible: false },
      labels: { step: 1 },
      autoBind: naviOptions.autoBindElements,
      autoBaseUnitSteps: {
        minutes: [1],
        hours: [1, 2],
        days: [1, 2],
        weeks: [],
        months: [1],
        years: [1]
      }
    });
    const user = naviOptions.categoryAxis;
    categoryAxes.push(
      deepExtend({}, base, {
        maxDateGroups: 200
      }, user, {
        name: NAVIGATOR_AXIS,
        title: null,
        baseUnit: "fit",
        baseUnitStep: "auto",
        labels: { visible: false },
        majorTicks: { visible: false }
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_labels",
        maxDateGroups: 20,
        baseUnitStep: "auto",
        labels: { position: "" },
        plotBands: [],
        autoBaseUnitSteps: {
          minutes: []
        },
        _overlap: true
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_ticks",
        maxDateGroups: 200,
        majorTicks: {
          width: 0.5
        },
        plotBands: [],
        title: null,
        labels: { visible: false, mirror: true },
        _overlap: true
      })
    );
    valueAxes.push(deepExtend({
      name: NAVIGATOR_AXIS,
      pane: NAVIGATOR_PANE,
      majorGridLines: {
        visible: false
      },
      visible: false
    }, naviOptions.valueAxis));
  }
  static attachSeries(options, naviOptions, themeOptions) {
    const series = options.series = options.series || [];
    const navigatorSeries = [].concat(naviOptions.series || []);
    const seriesColors = themeOptions.seriesColors;
    const defaults = naviOptions.seriesDefaults;
    for (let idx = 0; idx < navigatorSeries.length; idx++) {
      series.push(
        deepExtend({
          color: seriesColors[idx % seriesColors.length],
          categoryField: naviOptions.dateField,
          visibleInLegend: false,
          tooltip: {
            visible: false
          }
        }, defaults, navigatorSeries[idx], {
          axis: NAVIGATOR_AXIS,
          categoryAxis: NAVIGATOR_AXIS,
          autoBind: naviOptions.autoBindElements
        })
      );
    }
  }
};
function ClonedObject() {
}
function clone(obj) {
  ClonedObject.prototype = obj;
  return new ClonedObject();
}
var navigator_default = Navigator;

// node_modules/@progress/kendo-charts/dist/es/stock/stock-chart.js
var AUTO_CATEGORY_WIDTH = 28;
var StockChart = class extends chart_default {
  applyDefaults(options, themeOptions) {
    const width = elementSize(this.element).width || DEFAULT_WIDTH;
    let theme = themeOptions;
    const stockDefaults = {
      seriesDefaults: {
        categoryField: options.dateField
      },
      axisDefaults: {
        categoryAxis: {
          name: "default",
          majorGridLines: {
            visible: false
          },
          labels: {
            step: 2
          },
          majorTicks: {
            visible: false
          },
          maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)
        }
      }
    };
    if (theme) {
      theme = deepExtend({}, theme, stockDefaults);
    }
    navigator_default.setup(options, theme);
    super.applyDefaults(options, theme);
  }
  _setElementClass(element) {
    addClass(element, "k-chart k-stockchart");
  }
  setOptions(options) {
    this.destroyNavigator();
    super.setOptions(options);
  }
  noTransitionsRedraw() {
    const transitions = this.options.transitions;
    this.options.transitions = false;
    this._fullRedraw();
    this.options.transitions = transitions;
  }
  _resize() {
    this.noTransitionsRedraw();
  }
  _redraw() {
    const navigator2 = this.navigator;
    if (!this._dirty() && navigator2 && navigator2.options.partialRedraw) {
      navigator2.redrawSlaves();
    } else {
      this._fullRedraw();
    }
  }
  _dirty() {
    const options = this.options;
    const series = [].concat(options.series, options.navigator.series);
    const seriesCount = grep(series, function(s) {
      return s && s.visible;
    }).length;
    const dirty = this._seriesCount !== seriesCount;
    this._seriesCount = seriesCount;
    return dirty;
  }
  _fullRedraw() {
    let navigator2 = this.navigator;
    if (!navigator2) {
      navigator2 = this.navigator = new navigator_default(this);
      this.trigger("navigatorCreated", { navigator: navigator2 });
    }
    navigator2.clean();
    navigator2.setRange();
    super._redraw();
    navigator2.initSelection();
  }
  _trackSharedTooltip(coords) {
    const plotArea = this._plotArea;
    const pane = plotArea.paneByPoint(coords);
    if (pane && pane.options.name === NAVIGATOR_PANE) {
      this._unsetActivePoint();
    } else {
      super._trackSharedTooltip(coords);
    }
  }
  bindCategories() {
    super.bindCategories();
    this.copyNavigatorCategories();
  }
  copyNavigatorCategories() {
    const definitions = [].concat(this.options.categoryAxis);
    let categories;
    for (let axisIx = 0; axisIx < definitions.length; axisIx++) {
      const axis = definitions[axisIx];
      if (axis.name === NAVIGATOR_AXIS) {
        categories = axis.categories;
      } else if (categories && axis.pane === NAVIGATOR_PANE) {
        axis.categories = categories;
      }
    }
  }
  destroyNavigator() {
    if (this.navigator) {
      this.navigator.destroy();
      this.navigator = null;
    }
  }
  destroy() {
    this.destroyNavigator();
    super.destroy();
  }
  _stopChartHandlers(e) {
    const coords = this._eventCoordinates(e);
    const pane = this._plotArea.paneByPoint(coords);
    return super._stopChartHandlers(e) || pane && pane.options.name === NAVIGATOR_PANE;
  }
  _toggleDragZoomEvents() {
    if (!this._dragZoomEnabled) {
      this.element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
  }
};
setDefaultOptions(StockChart, {
  dateField: "date",
  axisDefaults: {
    categoryAxis: {
      type: "date",
      baseUnit: "fit",
      justified: true
    },
    valueAxis: {
      narrowRange: true,
      labels: {
        format: "C"
      }
    }
  },
  navigator: {
    select: {},
    seriesDefaults: {
      markers: {
        visible: false
      },
      tooltip: {
        visible: false
      },
      highlight: {
        visible: false
      },
      line: {
        width: 2
      }
    },
    hint: {},
    visible: true
  },
  tooltip: {
    visible: true
  },
  legend: {
    visible: false
  }
});
var stock_chart_default = StockChart;

// node_modules/@progress/kendo-charts/dist/es/gauges/constants.js
var ANGULAR_SPEED = 150;
var LINEAR_SPEED = 250;
var ARROW = "arrow";
var ARROW_POINTER = "arrowPointer";
var BAR_POINTER = "barPointer";
var DEFAULT_HEIGHT2 = 200;
var DEFAULT_LINE_WIDTH = 0.5;
var DEFAULT_WIDTH2 = 200;
var DEGREE = Math.PI / 180;
var INSIDE2 = "inside";
var LINEAR2 = "linear";
var OUTSIDE2 = "outside";
var RADIAL_POINTER = "radialPointer";
var RADIAL_RANGE_POINTER = "radialRangePointer";

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/pad.js
function pad(bbox, value2) {
  const origin = bbox.getOrigin();
  const size = bbox.getSize();
  const spacing = getSpacing(value2);
  bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);
  bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);
  return bbox;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/build-label-element.js
var { Group, Path, Text: Text2 } = drawing_exports;
function buildLabelElement(label, options) {
  const labelBox = label.box;
  const textBox = label.children[0].box;
  const border = options.border || {};
  const background = options.background || "";
  const wrapper = Path.fromRect(new geometry_exports.Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {
    stroke: {}
  });
  const text = new Text2(label.text, new geometry_exports.Point(textBox.x1, textBox.y1), {
    font: options.font,
    fill: { color: options.color }
  });
  const styleGeometry = pad(text.bbox().clone(), options.padding);
  const styleBox = Path.fromRect(styleGeometry, {
    stroke: {
      color: border.width ? border.color : "",
      width: border.width,
      opacity: border.opacity,
      dashType: border.dashType,
      lineJoin: "round",
      lineCap: "round"
    },
    fill: {
      color: background
    }
  });
  const elements = new Group();
  elements.append(wrapper);
  elements.append(styleBox);
  elements.append(text);
  return elements;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/get-range.js
function getRange(range, min4, max3) {
  const from = defined(range.from) ? range.from : MIN_VALUE;
  const to = defined(range.to) ? range.to : MAX_VALUE;
  range.from = Math.max(Math.min(to, from), min4);
  range.to = Math.min(Math.max(to, from), max3);
  return range;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/unpad.js
function unpad(bbox, value2) {
  const spacing = getSpacing(value2);
  spacing.left = -spacing.left;
  spacing.top = -spacing.top;
  spacing.right = -spacing.right;
  spacing.bottom = -spacing.bottom;
  return pad(bbox, spacing);
}

// node_modules/@progress/kendo-charts/dist/es/gauges/gauge.js
var DEFAULT_MARGIN = 5;
var { Path: Path2, Surface } = drawing_exports;
var Gauge = class extends class_default {
  constructor(element, userOptions, theme, context = {}) {
    super();
    this.element = element;
    this.theme = theme;
    this.contextService = new chart_service_default(this, context);
    this._originalOptions = deepExtend({}, this.options, userOptions);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  destroy() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
    }
    delete this.element;
    delete this.surfaceElement;
  }
  value(pointerValue) {
    const pointer = this.pointers[0];
    if (arguments.length === 0) {
      return pointer.value();
    }
    pointer.value(pointerValue);
    this._setValueOptions(pointerValue);
  }
  _draw() {
    const surface = this.surface;
    surface.clear();
    surface.draw(this._visuals);
  }
  exportVisual() {
    return this._visuals;
  }
  allValues(values) {
    const pointers = this.pointers;
    const allValues = [];
    if (arguments.length === 0) {
      for (let i = 0; i < pointers.length; i++) {
        allValues.push(pointers[i].value());
      }
      return allValues;
    }
    if (isArray(values)) {
      for (let i = 0; i < values.length; i++) {
        if (isNumber(values[i])) {
          pointers[i].value(values[i]);
        }
      }
    }
    this._setValueOptions(values);
  }
  _setValueOptions(values) {
    const pointers = [].concat(this.options.pointer);
    const arrayValues = [].concat(values);
    for (let i = 0; i < arrayValues.length; i++) {
      pointers[i].value = arrayValues[i];
    }
  }
  resize() {
    this.noTransitionsRedraw();
  }
  noTransitionsRedraw() {
    const transitions = this.options.transitions;
    this._toggleTransitions(false);
    this.redraw();
    this._toggleTransitions(transitions);
  }
  redraw() {
    const size = this._surfaceSize();
    const wrapper = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._initSurface();
    this.gaugeArea = this._createGaugeArea();
    this._createModel();
    const bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);
    this.reflow(bbox);
  }
  setOptions(options, theme) {
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  setDirection(rtl) {
    this.contextService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this.surface.destroy();
      this.surface = null;
    }
  }
  setIntlService(intl) {
    this.contextService.intl = intl;
  }
  _initTheme(theme) {
    let currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
    const options = this.options;
    const pointer = options.pointer;
    if (isArray(pointer)) {
      const pointers = [];
      for (let i = 0; i < pointer.length; i++) {
        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));
      }
      options.pointer = pointers;
    }
  }
  _createGaugeArea() {
    const options = this.options.gaugeArea;
    const size = this.surface.size();
    const border = options.border || {};
    let areaGeometry = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;
    if (border.width > 0) {
      areaGeometry = unpad(areaGeometry, border.width);
    }
    const gaugeArea = Path2.fromRect(areaGeometry, {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        opacity: border.opacity,
        dashType: border.dashType,
        lineJoin: "round",
        lineCap: "round"
      },
      fill: {
        color: options.background
      }
    });
    return gaugeArea;
  }
  _initSurface() {
    const { options, surface } = this;
    const element = this._surfaceElement();
    const size = this._surfaceSize();
    elementSize(element, size);
    if (!surface || surface.options.type !== options.renderAs) {
      if (surface) {
        surface.destroy();
      }
      this.surface = Surface.create(element, {
        type: options.renderAs
      });
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  }
  _surfaceSize() {
    const options = this.options;
    const size = this._getSize();
    if (options.gaugeArea) {
      deepExtend(size, options.gaugeArea);
    }
    return size;
  }
  _surfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
    return this.surfaceElement;
  }
  getSize() {
    return this._getSize();
  }
  _getSize() {
    const element = this.element;
    const defaultSize = this._defaultSize();
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    if (!width) {
      width = defaultSize.width;
    }
    if (!height) {
      height = defaultSize.height;
    }
    return { width, height };
  }
  _defaultSize() {
    return {
      width: DEFAULT_WIDTH2,
      height: DEFAULT_HEIGHT2
    };
  }
  _toggleTransitions(value2) {
    this.options.transitions = value2;
    for (let i = 0; i < this.pointers.length; i++) {
      this.pointers[i].options.animation.transitions = value2;
    }
  }
};
setDefaultOptions(Gauge, {
  plotArea: {},
  theme: "default",
  renderAs: "",
  pointer: {},
  scale: {},
  gaugeArea: {}
});
var gauge_default = Gauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-scale.js
var { Path: Path3, Group: Group2 } = drawing_exports;
var Point2 = geometry_exports.Point;
function renderAxisTick(tickRenderOptions, tickOptions) {
  const { position, tickX, tickY } = tickRenderOptions;
  let start, end;
  if (tickRenderOptions.vertical) {
    start = new Point2(tickX, position);
    end = new Point2(tickX + tickOptions.size, position);
  } else {
    start = new Point2(position, tickY);
    end = new Point2(position, tickY + tickOptions.size);
  }
  const tickPath = new Path3({
    stroke: {
      color: tickOptions.color,
      width: tickOptions.width
    }
  }).moveTo(start).lineTo(end);
  return tickPath;
}
function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {
  const count = tickPositions.length;
  if (tickOptions.visible) {
    const { mirror, lineBox } = tickRenderOptions;
    for (let i = tickOptions.skip; i < count; i += tickOptions.step) {
      if (i % tickOptions.skipUnit === 0) {
        continue;
      }
      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickRenderOptions.position = tickPositions[i];
      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));
    }
  }
}
var LinearScale = class extends numeric_axis_default {
  constructor(options, service) {
    let scaleOptions = options || {};
    if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {
      scaleOptions = Object.assign({}, scaleOptions, {
        reverse: true
      });
    }
    super(0, 1, scaleOptions, service);
    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;
  }
  initUserOptions(options) {
    let scaleOptions = deepExtend({}, this.options, options);
    scaleOptions = deepExtend({}, scaleOptions, { labels: { mirror: scaleOptions.mirror } });
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    return scaleOptions;
  }
  initFields() {
  }
  render() {
    const elements = this.elements = new Group2();
    const labels = this.renderLabels();
    const scaleLine = this.renderLine();
    const scaleTicks = this.renderTicks();
    const ranges = this.renderRanges();
    elements.append(scaleLine, labels, scaleTicks, ranges);
    return elements;
  }
  renderRanges() {
    const options = this.options;
    const { min: min4, max: max3, vertical, labels: { mirror } } = options;
    const ranges = options.ranges || [];
    const elements = new Group2();
    const count = ranges.length;
    const rangeSize = options.rangeSize || options.minorTicks.size / 2;
    for (let i = 0; i < count; i++) {
      const range = getRange(ranges[i], min4, max3);
      const slot = this.getSlot(range.from, range.to);
      const slotX = vertical ? this.lineBox() : slot;
      const slotY = vertical ? slot : this.lineBox();
      if (vertical) {
        slotX.x1 -= rangeSize * (mirror ? -1 : 1);
      } else {
        slotY.y2 += rangeSize * (mirror ? -1 : 1);
      }
      elements.append(Path3.fromRect(new geometry_exports.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {
        fill: { color: range.color, opacity: range.opacity },
        stroke: {}
      }));
    }
    return elements;
  }
  renderLabels() {
    const { labels, options } = this;
    const elements = new Group2();
    for (let i = 0; i < labels.length; i++) {
      elements.append(buildLabelElement(labels[i], options.labels));
    }
    return elements;
  }
  renderLine() {
    const line = this.options.line;
    const lineBox = this.lineBox();
    const elements = new Group2();
    if (line.width > 0 && line.visible) {
      const linePath = new Path3({
        stroke: {
          color: line.color,
          dashType: line.dashType,
          width: line.width
        }
      });
      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      elements.append(linePath);
    }
    return elements;
  }
  renderTicks() {
    const ticks = new Group2();
    const options = this.options;
    const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    const tickRenderOptions = {
      vertical: options.vertical,
      mirror: options.labels.mirror,
      lineBox: this.lineBox()
    };
    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);
    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {
      skipUnit: majorUnit / options.minorUnit
    }, options.minorTicks));
    return ticks;
  }
};
setDefaultOptions(LinearScale, {
  min: 0,
  max: 50,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  line: {
    width: DEFAULT_LINE_WIDTH
  },
  labels: {
    position: INSIDE2,
    padding: 2
  },
  mirror: false,
  _alignLines: false
});
var linear_scale_default = LinearScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/pointer.js
var Pointer = class extends class_default {
  constructor(scale, userOptions) {
    super();
    const { min: min4, max: max3 } = scale.options;
    const options = this.options = deepExtend({}, this.options, userOptions);
    options.fill = options.color;
    this.scale = scale;
    if (defined(options.value)) {
      options.value = limitValue(options.value, min4, max3);
    } else {
      options.value = min4;
    }
  }
  value(newValue) {
    const options = this.options;
    const value2 = options.value;
    if (arguments.length === 0) {
      return value2;
    }
    const { min: min4, max: max3 } = this.scale.options;
    options._oldValue = defined(options._oldValue) ? options.value : min4;
    options.value = limitValue(newValue, min4, max3);
    if (this.elements) {
      this.repaint();
    }
  }
};
setDefaultOptions(Pointer, {
  color: BLACK
});
var pointer_default = Pointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-pointer.js
var LinearPointer = class extends pointer_default {
  constructor(scale, options) {
    super(scale, options);
    this.options = deepExtend({
      track: {
        visible: defined(options.track)
      }
    }, this.options);
  }
  reflow() {
    const { options, scale } = this;
    const { mirror, vertical } = scale.options;
    const scaleLine = scale.lineBox();
    const trackSize = options.track.size || options.size;
    const pointerHalfSize = options.size / 2;
    const margin = getSpacing(options.margin);
    let space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    let pointerBox, pointerRangeBox, trackBox;
    space = mirror ? -space : space;
    if (vertical) {
      trackBox = new box_default(
        scaleLine.x1 + space,
        scaleLine.y1,
        scaleLine.x1 + space,
        scaleLine.y2
      );
      if (mirror) {
        trackBox.x1 -= trackSize;
      } else {
        trackBox.x2 += trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x2 + space,
          scaleLine.y1 - pointerHalfSize,
          scaleLine.x2 + space,
          scaleLine.y2 + pointerHalfSize
        );
        pointerBox = pointerRangeBox;
      }
    } else {
      trackBox = new box_default(
        scaleLine.x1,
        scaleLine.y1 - space,
        scaleLine.x2,
        scaleLine.y1 - space
      );
      if (mirror) {
        trackBox.y2 += trackSize;
      } else {
        trackBox.y1 -= trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x1 - pointerHalfSize,
          scaleLine.y1 - space,
          scaleLine.x2 + pointerHalfSize,
          scaleLine.y1 - space
        );
        pointerBox = pointerRangeBox;
      }
    }
    this.trackBox = trackBox;
    this.pointerRangeBox = pointerRangeBox;
    this.box = pointerBox || trackBox.clone().pad(options.border.width);
  }
  getElementOptions() {
    const options = this.options;
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: defined(options.border) ? {
        color: options.border.width ? options.border.color || options.color : "",
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: options.opacity
      } : null
    };
  }
  _margin() {
    const { scale, options } = this;
    const { mirror, vertical } = scale.options;
    const margin = getSpacing(options.margin);
    const space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    return space;
  }
};
setDefaultOptions(LinearPointer, {
  shape: BAR_POINTER,
  track: {
    border: {
      width: 1
    }
  },
  color: BLACK,
  border: {
    width: 1
  },
  opacity: 1,
  margin: getSpacing(3),
  animation: {
    type: BAR_POINTER
  },
  visible: true
});
var linear_pointer_default = LinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer-animation.js
var ArrowLinearPointerAnimation = class extends drawing_exports.Animation {
  setup() {
    const options = this.options;
    const { margin, from, to, vertical } = options;
    const axis = vertical ? "x1" : "y1";
    if (options.mirror === vertical) {
      from[axis] -= margin;
      to[axis] -= margin;
    } else {
      from[axis] += margin;
      to[axis] += margin;
    }
    const fromScale = this.fromScale = new geometry_exports.Point(from.x1, from.y1);
    const toScale = this.toScale = new geometry_exports.Point(to.x1, to.y1);
    if (options.duration !== 0) {
      options.duration = Math.max(fromScale.distanceTo(toScale) / options.duration * 1e3, 1);
    }
  }
  step(pos) {
    const translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);
    const translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);
    this.element.transform(geometry_exports.transform().translate(translateX, translateY));
  }
};
setDefaultOptions(ArrowLinearPointerAnimation, {
  easing: LINEAR2,
  duration: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);
var arrow_linear_pointer_animation_default = ArrowLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer.js
var Point3 = geometry_exports.Point;
var Path4 = drawing_exports.Path;
var ArrowLinearPointer = class extends linear_pointer_default {
  constructor(scale, options) {
    super(scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.6;
    }
  }
  pointerShape() {
    const { scale, options: { size } } = this;
    const halfSize = size / 2;
    const sign = scale.options.mirror ? -1 : 1;
    let shape;
    if (scale.options.vertical) {
      shape = [
        new Point3(0, 0 - halfSize),
        new Point3(0 - sign * size, 0),
        new Point3(0, 0 + halfSize)
      ];
    } else {
      shape = [
        new Point3(0 - halfSize, 0),
        new Point3(0, 0 + sign * size),
        new Point3(0 + halfSize, 0)
      ];
    }
    return shape;
  }
  repaint() {
    const { scale, options } = this;
    const animation = new arrow_linear_pointer_animation_default(this.elements, deepExtend(options.animation, {
      vertical: scale.options.vertical,
      mirror: scale.options.mirror,
      margin: this._margin(options.margin),
      from: scale.getSlot(options._oldValue),
      to: scale.getSlot(options.value)
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  }
  render() {
    const { scale, options } = this;
    const elementOptions = this.getElementOptions();
    const shape = this.pointerShape(options.value);
    options.animation.type = ARROW_POINTER;
    const elements = new Path4({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();
    const slot = scale.getSlot(options.value);
    elements.transform(geometry_exports.transform().translate(slot.x1, slot.y1));
    this.elements = elements;
    return elements;
  }
};
var arrow_linear_pointer_default = ArrowLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer-animation.js
var BarLinearPointerAnimation = class extends drawing_exports.Animation {
  setup() {
    const options = this.options;
    const axis = this.axis = options.vertical ? Y : X;
    const to = this.to = options.newPoints[0][axis];
    const from = this.from = options.oldPoints[0][axis];
    if (options.duration !== 0) {
      options.duration = Math.max(Math.abs(to - from) / options.speed * 1e3, 1);
    }
    this._set(from);
  }
  step(pos) {
    const value2 = interpolateValue(this.from, this.to, pos);
    this._set(value2);
  }
  _set(value2) {
    const setter = "set" + this.axis.toUpperCase();
    const points = this.options.newPoints;
    points[0][setter](value2);
    points[1][setter](value2);
  }
};
setDefaultOptions(BarLinearPointerAnimation, {
  easing: LINEAR2,
  speed: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);
var bar_linear_pointer_animation_default = BarLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer.js
var { Group: Group3, Path: Path5 } = drawing_exports;
var BarLinearPointer = class extends linear_pointer_default {
  constructor(scale, options) {
    super(scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.3;
    }
  }
  pointerShape(value2) {
    const { scale, options } = this;
    const { mirror, vertical } = scale.options;
    const dir = mirror === vertical ? -1 : 1;
    const size = options.size * dir;
    const minSlot = scale.getSlot(scale.options.min);
    const slot = scale.getSlot(value2);
    const axis = vertical ? Y : X;
    const sizeAxis = vertical ? X : Y;
    const margin = this._margin() * dir;
    const p1 = new geometry_exports.Point();
    p1[axis] = minSlot[axis + "1"];
    p1[sizeAxis] = minSlot[sizeAxis + "1"];
    const p2 = new geometry_exports.Point();
    p2[axis] = slot[axis + "1"];
    p2[sizeAxis] = slot[sizeAxis + "1"];
    if (vertical) {
      p1.translate(margin, 0);
      p2.translate(margin, 0);
    } else {
      p1.translate(0, margin);
      p2.translate(0, margin);
    }
    const p3 = p2.clone();
    const p4 = p1.clone();
    if (vertical) {
      p3.translate(size, 0);
      p4.translate(size, 0);
    } else {
      p3.translate(0, size);
      p4.translate(0, size);
    }
    return [p1, p2, p3, p4];
  }
  repaint() {
    const { scale, options } = this;
    const shape = this.pointerShape(options.value);
    const pointerPath = this.pointerPath;
    const oldShape = this.pointerShape(options._oldValue);
    pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();
    const animation = new bar_linear_pointer_animation_default(pointerPath, deepExtend(options.animation, {
      reverse: scale.options.reverse,
      vertical: scale.options.vertical,
      oldPoints: [oldShape[1], oldShape[2]],
      newPoints: [shape[1], shape[2]]
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  }
  render() {
    const group = new Group3();
    const elementOptions = this.getElementOptions();
    if (this.options.track.visible) {
      group.append(this.renderTrack());
    }
    const pointer = this.pointerPath = new Path5({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    });
    group.append(pointer);
    this.elements = group;
    return group;
  }
  renderTrack() {
    const trackOptions = this.options.track;
    const border = trackOptions.border || {};
    const trackBox = this.trackBox.clone().pad(border.width || 0);
    return new Path5.fromRect(trackBox.toRect(), {
      fill: {
        color: trackOptions.color,
        opacity: trackOptions.opacity
      },
      stroke: {
        color: border.width ? border.color || trackOptions.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
  }
};
var bar_linear_pointer_default = BarLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-gauge.js
var DEFAULT_MIN_WIDTH = 60;
var DEFAULT_MIN_HEIGHT = 60;
var Group4 = drawing_exports.Group;
var LinearGauge = class extends gauge_default {
  reflow(bbox) {
    const pointers = this.pointers;
    const bboxX = bbox.origin.x;
    const bboxY = bbox.origin.y;
    const box = new box_default(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());
    this.scale.reflow(box);
    this._shrinkScaleWidth(box);
    for (let i = 0; i < pointers.length; i++) {
      pointers[i].reflow();
    }
    this.bbox = this._getBox(box);
    this._alignElements();
    this._shrinkElements();
    this._buildVisual();
    this._draw();
  }
  _buildVisual() {
    const visuals = new Group4();
    const scaleElements = this.scale.render();
    const pointers = this.pointers;
    visuals.append(this.gaugeArea);
    visuals.append(scaleElements);
    for (let i = 0; i < pointers.length; i++) {
      const current4 = pointers[i];
      visuals.append(current4.render());
      current4.value(current4.options.value);
    }
    this._visuals = visuals;
  }
  _createModel() {
    const options = this.options;
    const scale = this.scale = new linear_scale_default(options.scale, this.contextService);
    this.pointers = [];
    let pointers = options.pointer;
    pointers = isArray(pointers) ? pointers : [pointers];
    for (let i = 0; i < pointers.length; i++) {
      const currentOptions = deepExtend({}, pointers[i], {
        animation: {
          transitions: options.transitions
        }
      });
      const pointerType = currentOptions.shape === ARROW ? arrow_linear_pointer_default : bar_linear_pointer_default;
      this.pointers.push(new pointerType(scale, currentOptions));
    }
  }
  _defaultSize() {
    const vertical = this.options.scale.vertical;
    return {
      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH2,
      height: vertical ? DEFAULT_HEIGHT2 : DEFAULT_MIN_HEIGHT
    };
  }
  _getBox(box) {
    const { scale, pointers } = this;
    const boxCenter = box.center();
    let plotAreaBox = pointers[0].box.clone().wrap(scale.box);
    for (let i = 0; i < pointers.length; i++) {
      plotAreaBox.wrap(pointers[i].box.clone());
    }
    let size;
    if (scale.options.vertical) {
      size = plotAreaBox.width() / 2;
      plotAreaBox = new box_default(
        boxCenter.x - size,
        box.y1,
        boxCenter.x + size,
        box.y2
      );
    } else {
      size = plotAreaBox.height() / 2;
      plotAreaBox = new box_default(
        box.x1,
        boxCenter.y - size,
        box.x2,
        boxCenter.y + size
      );
    }
    return plotAreaBox;
  }
  _alignElements() {
    const { scale, pointers } = this;
    const scaleBox = scale.box;
    const box = pointers[0].box.clone().wrap(scale.box);
    const plotAreaBox = this.bbox;
    for (let i = 0; i < pointers.length; i++) {
      box.wrap(pointers[i].box.clone());
    }
    let diff;
    if (scale.options.vertical) {
      diff = plotAreaBox.center().x - box.center().x;
      scale.reflow(new box_default(
        scaleBox.x1 + diff,
        plotAreaBox.y1,
        scaleBox.x2 + diff,
        plotAreaBox.y2
      ));
    } else {
      diff = plotAreaBox.center().y - box.center().y;
      scale.reflow(new box_default(
        scaleBox.x1,
        scaleBox.y1 + diff,
        scaleBox.x2,
        scaleBox.y2 + diff
      ));
    }
    for (let i = 0; i < pointers.length; i++) {
      pointers[i].reflow(this.bbox);
    }
  }
  _shrinkScaleWidth(bbox) {
    const { scale } = this;
    if (!scale.options.vertical) {
      const overflow = scale.contentBox().width() - bbox.width();
      if (overflow > 0) {
        scale.box.shrink(overflow, 0);
        scale.box.alignTo(bbox, "center");
        scale.reflow(scale.box);
      }
    }
  }
  _shrinkElements() {
    const { scale, pointers } = this;
    const scaleBox = scale.box.clone();
    const pos = scale.options.vertical ? "y" : "x";
    const pointerBox = pointers[0].box;
    for (let i = 0; i < pointers.length; i++) {
      pointerBox.wrap(pointers[i].box.clone());
    }
    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);
    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);
    scale.reflow(scaleBox);
    for (let i = 0; i < pointers.length; i++) {
      pointers[i].reflow(this.bbox);
    }
  }
};
setDefaultOptions(LinearGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  },
  scale: {
    vertical: true
  }
});
var linear_gauge_default = LinearGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-scale.js
var GEO_ARC_ADJUST_ANGLE = 180;
var { Arc, Path: Path6, Group: Group5 } = drawing_exports;
function drawTicks(arc, tickAngles, unit, tickOptions) {
  const ticks = new Group5();
  const center = arc.center;
  const radius = arc.getRadiusX();
  if (tickOptions.visible) {
    for (let i = 0; i < tickAngles.length; i++) {
      const tickStart = arc.pointAt(tickAngles[i]);
      const tickEnd = new geometry_exports.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);
      ticks.append(new Path6({
        stroke: {
          color: tickOptions.color,
          width: tickOptions.width
        }
      }).moveTo(tickStart).lineTo(tickEnd));
    }
  }
  return ticks;
}
function rangeSegment(from, to, color, opacity) {
  return { from, to, color, opacity };
}
var RadialScale = class extends numeric_axis_default {
  constructor(options, service) {
    super(0, 1, options, service);
  }
  initUserOptions(options) {
    const scaleOptions = deepExtend({}, this.options, options);
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;
    return scaleOptions;
  }
  initFields() {
  }
  render(center, radius) {
    const arc = this.renderArc(center, radius);
    this.bbox = arc.bbox();
    this.labelElements = this.renderLabels();
    this.ticks = this.renderTicks();
    this.ranges = this.renderRanges();
  }
  reflow(bbox) {
    const center = bbox.center();
    const radius = Math.min(bbox.height(), bbox.width()) / 2;
    if (defined(this.bbox)) {
      this.bbox = this.arc.bbox();
      this.radius(this.arc.getRadiusX());
      this.repositionRanges();
      this.renderLabels();
    } else {
      return this.render(center, radius);
    }
  }
  slotAngle(value2) {
    const { min: min4, max: max3, reverse, startAngle, endAngle } = this.options;
    const angle = endAngle - startAngle;
    let result;
    if (reverse) {
      result = endAngle - (value2 - min4) / (max3 - min4) * angle;
    } else {
      result = (value2 - min4) / (max3 - min4) * angle + startAngle;
    }
    return result + GEO_ARC_ADJUST_ANGLE;
  }
  hasRanges() {
    const ranges = this.options.ranges;
    return ranges && ranges.length;
  }
  ticksSize() {
    const { majorTicks, minorTicks } = this.options;
    let size = 0;
    if (majorTicks.visible) {
      size = majorTicks.size;
    }
    if (minorTicks.visible) {
      size = Math.max(minorTicks.size, size);
    }
    return size;
  }
  labelsCount() {
    let count = super.labelsCount();
    const options = this.options;
    const angle = options.endAngle - options.startAngle;
    if (angle >= 360 && options.max % options.majorUnit === 0) {
      count -= 1;
    }
    return count;
  }
  renderLabels() {
    const options = this.options;
    const arc = this.arc.clone();
    let radius = arc.getRadiusX();
    const tickAngles = this.tickAngles(arc, options.majorUnit);
    const rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;
    const labelsGroup = new Group5();
    let rangeDistance = radius * 0.05;
    if (defined(options.rangeDistance)) {
      rangeDistance = options.rangeDistance;
    } else {
      options.rangeDistance = rangeDistance;
    }
    const labelsOptions = options.labels;
    const isInside = labelsOptions.position === INSIDE2;
    const hasLabelElements = defined(this.labelElements);
    if (isInside) {
      radius -= this.ticksSize();
      if (this.hasRanges() && !hasLabelElements) {
        radius -= rangeSize + rangeDistance;
      }
      arc.setRadiusX(radius).setRadiusY(radius);
    }
    const labels = this.labels;
    const count = labels.length;
    const padding = getSpacing(labelsOptions.padding);
    const paddingWidth = (padding.left + padding.right) / 2;
    const paddingHeight = (padding.top + padding.bottom) / 2;
    for (let i = 0; i < count; i++) {
      const label = labels[i];
      const halfWidth = label.box.width() / 2;
      const halfHeight = label.box.height() / 2;
      const angle = tickAngles[i];
      const labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;
      const lp = arc.pointAt(angle);
      const cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);
      const cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);
      label.reflow(new box_default(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));
      const labelPos = new geometry_exports.Point(label.box.x1, label.box.y1);
      let labelElement;
      if (!hasLabelElements) {
        labelElement = buildLabelElement(label, options.labels);
        labelsGroup.append(labelElement);
      } else {
        labelElement = this.labelElements.children[i];
        const prevLabelPos = labelElement.bbox().origin;
        const labelTransform = labelElement.transform() || geometry_exports.transform();
        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);
        labelElement.transform(labelTransform);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, labelElement.bbox());
    }
    return labelsGroup;
  }
  repositionRanges() {
    const ranges = this.ranges.children;
    if (ranges.length > 0) {
      const { rangeDistance, rangeSize } = this.options;
      let rangeRadius = this.getRangeRadius();
      if (this.options.labels.position === INSIDE2) {
        rangeRadius += rangeSize + rangeDistance;
      }
      const newRadius = rangeRadius + rangeSize / 2;
      for (let i = 0; i < ranges.length; i++) {
        ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, this.ranges.bbox());
    }
  }
  renderRanges() {
    const segments = this.rangeSegments();
    const segmentsCount = segments.length;
    const result = new Group5();
    if (segmentsCount) {
      const { rangeSize, reverse, rangeDistance } = this.options;
      const rangeRadius = this.getRangeRadius();
      this.radius(this.radius() - rangeSize - rangeDistance);
      for (let i = 0; i < segmentsCount; i++) {
        const segment = segments[i];
        const from = this.slotAngle(segment[reverse ? "to" : "from"]);
        const to = this.slotAngle(segment[!reverse ? "to" : "from"]);
        if (to - from !== 0) {
          result.append(this.createRange(from, to, rangeRadius, segment));
        }
      }
    }
    return result;
  }
  createRange(startAngle, endAngle, rangeRadius, options) {
    const rangeSize = this.options.rangeSize;
    const rangeGeom = new geometry_exports.Arc(this.arc.center, {
      radiusX: rangeRadius + rangeSize / 2,
      radiusY: rangeRadius + rangeSize / 2,
      startAngle,
      endAngle
    });
    return new Arc(rangeGeom, {
      stroke: {
        width: rangeSize,
        color: options.color,
        opacity: options.opacity,
        lineCap: options.lineCap
      }
    });
  }
  rangeSegments() {
    const options = this.options;
    const ranges = options.ranges || [];
    const count = ranges.length;
    const segments = [];
    if (count) {
      const { min: min4, max: max3, rangePlaceholderColor: defaultColor } = options;
      segments.push(rangeSegment(min4, max3, defaultColor));
      for (let i = 0; i < count; i++) {
        const range = getRange(ranges[i], min4, max3);
        const segmentsCount = segments.length;
        for (let j = 0; j < segmentsCount; j++) {
          const segment = segments[j];
          if (segment.from <= range.from && range.from <= segment.to) {
            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));
            if (segment.from <= range.to && range.to <= segment.to) {
              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));
            }
            segment.to = range.from;
            break;
          }
        }
      }
    }
    return segments;
  }
  getRangeRadius() {
    const { arc, options } = this;
    const { rangeSize, rangeDistance, majorTicks: { size: majorTickSize } } = options;
    let radius;
    if (options.labels.position === OUTSIDE2) {
      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;
    } else {
      radius = arc.getRadiusX() - rangeSize;
    }
    return radius;
  }
  renderArc(center, radius) {
    const options = this.options;
    const arc = this.arc = new geometry_exports.Arc(center, {
      radiusX: radius,
      radiusY: radius,
      startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,
      endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE
    });
    return arc;
  }
  renderTicks() {
    const { arc, options } = this;
    const tickArc = arc.clone();
    this.majorTickAngles = this.tickAngles(arc, options.majorUnit);
    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);
    const allTicks = new Group5();
    allTicks.append(this.majorTicks);
    const majorTickSize = options.majorTicks.size;
    const minorTickSize = options.minorTicks.size;
    this._tickDifference = majorTickSize - minorTickSize;
    if (options.labels.position === OUTSIDE2) {
      const radius = tickArc.getRadiusX();
      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);
    }
    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));
    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);
    allTicks.append(this.minorTicks);
    return allTicks;
  }
  normalizeTickAngles(angles) {
    const options = this.options;
    const skip = options.majorUnit / options.minorUnit;
    for (let i = angles.length - 1; i >= 0; i--) {
      if (i % skip === 0) {
        angles.splice(i, 1);
      }
    }
    return angles;
  }
  tickAngles(ring, stepValue) {
    const options = this.options;
    const reverse = options.reverse;
    const range = options.max - options.min;
    const angle = ring.endAngle - ring.startAngle;
    let tickCount = range / stepValue;
    let pos = ring.startAngle;
    let step = angle / tickCount;
    if (reverse) {
      pos += angle;
      step = -step;
    }
    if (angle >= 360 && options.max % stepValue === 0) {
      tickCount -= 1;
    }
    const positions = [];
    for (let i = 0; i < tickCount; i++) {
      positions.push(round(pos, COORD_PRECISION));
      pos += step;
    }
    if (round(pos) <= ring.endAngle) {
      positions.push(pos);
    }
    return positions;
  }
  radius(value2) {
    if (value2) {
      this.arc.setRadiusX(value2).setRadiusY(value2);
      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);
      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);
    } else {
      return this.arc.getRadiusX();
    }
  }
  repositionTicks(ticks, tickAngles, minor) {
    const diff = minor ? this._tickDifference || 0 : 0;
    let tickArc = this.arc;
    const radius = tickArc.getRadiusX();
    if (minor && this.options.labels.position === OUTSIDE2 && diff !== 0) {
      tickArc = this.arc.clone();
      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);
    }
    for (let i = 0; i < ticks.length; i++) {
      const newPoint = tickArc.pointAt(tickAngles[i]);
      const segments = ticks[i].segments;
      const xDiff = newPoint.x - segments[0].anchor().x;
      const yDiff = newPoint.y - segments[0].anchor().y;
      ticks[i].transform(new geometry_exports.transform().translate(xDiff, yDiff));
    }
  }
};
setDefaultOptions(RadialScale, {
  min: 0,
  max: 100,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  startAngle: -30,
  endAngle: 210,
  labels: {
    position: INSIDE2,
    padding: 2
  }
});
var radial_scale_default = RadialScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer-animation.js
var RadialPointerAnimation = class extends drawing_exports.Animation {
  constructor(element, options) {
    super(element, options);
    const animationOptions = this.options;
    animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3, 1);
  }
  step(pos) {
    const options = this.options;
    const angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.transform(geometry_exports.transform().rotate(angle, options.center));
  }
};
setDefaultOptions(RadialPointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);
var radial_pointer_animation_default = RadialPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer.js
var CAP_SIZE = 0.05;
var { Circle, Group: Group6, Path: Path7 } = drawing_exports;
var RadialPointer = class extends pointer_default {
  setAngle(angle) {
    this.elements.transform(geometry_exports.transform().rotate(angle, this.center));
  }
  repaint() {
    const { scale, options } = this;
    const oldAngle = scale.slotAngle(options._oldValue);
    const newAngle = scale.slotAngle(options.value);
    if (options.animation.transitions === false) {
      this.setAngle(newAngle);
    } else {
      new radial_pointer_animation_default(this.elements, deepExtend(options.animation, {
        oldAngle,
        newAngle
      })).play();
    }
  }
  render() {
    const { scale, options } = this;
    const elements = new Group6();
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    elements.append(this._renderNeedle(), this._renderCap());
    this.elements = elements;
    this.setAngle(DEGREE);
    return elements;
  }
  reflow(arc) {
    const center = this.center = arc.center;
    const length = limitValue(this.options.length || 1, 0.1, 1.5);
    const radius = this.radius = arc.getRadiusX() * length;
    const capSize = this.capSize = Math.round(radius * this.options.cap.size);
    this.bbox = geometry_exports.Rect.fromPoints(
      new geometry_exports.Point(center.x - capSize, center.y - capSize),
      new geometry_exports.Point(center.x + capSize, center.y + capSize)
    );
  }
  _renderNeedle() {
    const minorTickSize = this.scale.options.minorTicks.size;
    const center = this.center;
    const needleColor = this.options.color;
    const needlePath = new Path7({
      fill: { color: needleColor },
      stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }
    });
    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();
    return needlePath;
  }
  _renderCap() {
    const options = this.options;
    const capColor = options.cap.color || options.color;
    const circle = new geometry_exports.Circle(this.center, this.capSize);
    const cap = new Circle(circle, {
      fill: { color: capColor },
      stroke: { color: capColor }
    });
    return cap;
  }
};
setDefaultOptions(RadialPointer, {
  cap: {
    size: CAP_SIZE
  },
  arrow: {
    width: 16,
    height: 14
  },
  animation: {
    type: RADIAL_POINTER,
    duration: ANGULAR_SPEED
  }
});
var radial_pointer_default = RadialPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-gauge.js
var Group7 = drawing_exports.Group;
var RadialGauge = class extends gauge_default {
  reflow(bbox) {
    const pointers = this.pointers;
    this.scale.reflow(bbox);
    this._initialPlotArea = this.scale.bbox;
    for (let i = 0; i < pointers.length; i++) {
      pointers[i].reflow(this.scale.arc);
      this._initialPlotArea = geometry_exports.Rect.union(this._initialPlotArea, pointers[i].bbox);
    }
    this.fitScale(bbox);
    this.alignScale(bbox);
    this._buildVisual(this.gaugeArea, pointers, this.scale);
    this._draw();
  }
  _buildVisual(gaugeArea, pointers, scale) {
    const visuals = this._visuals = new Group7();
    visuals.append(gaugeArea);
    visuals.append(scale.ticks);
    visuals.append(scale.ranges);
    this._buildPointers(pointers);
    visuals.append(scale.labelElements);
  }
  _buildPointers(pointers) {
    for (let i = 0; i < pointers.length; i++) {
      const current4 = pointers[i];
      current4.render();
      this._visuals.append(current4.elements);
      current4.value(current4.options.value);
    }
  }
  fitScale(bbox) {
    const arc = this.scale.arc;
    const plotAreaBox = this._initialPlotArea;
    const step = Math.abs(this.getDiff(plotAreaBox, bbox));
    let min4 = round(step, COORD_PRECISION);
    let max3 = round(-step, COORD_PRECISION);
    let minDiff, midDiff, maxDiff, mid, oldDiff;
    let staleFlag = 0;
    let i = 0;
    while (i++ < 100) {
      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;
      if (staleFlag > 5) {
        break;
      }
      if (min4 !== mid) {
        minDiff = this.getPlotBox(min4, bbox, arc);
        if (0 <= minDiff && minDiff <= 2) {
          break;
        }
      }
      if (max3 !== mid) {
        maxDiff = this.getPlotBox(max3, bbox, arc);
        if (0 <= maxDiff && maxDiff <= 2) {
          break;
        }
      }
      if (minDiff > 0 && maxDiff > 0) {
        mid = min4 * 2;
      } else if (minDiff < 0 && maxDiff < 0) {
        mid = max3 * 2;
      } else {
        mid = round((min4 + max3) / 2 || 1, COORD_PRECISION);
      }
      midDiff = this.getPlotBox(mid, bbox, arc);
      if (0 <= midDiff && midDiff <= 2) {
        break;
      }
      oldDiff = maxDiff;
      if (midDiff > 0) {
        max3 = mid;
        maxDiff = midDiff;
      } else {
        min4 = mid;
        minDiff = midDiff;
      }
    }
  }
  getPlotBox(step, bbox, arc) {
    const scale = this.scale;
    const pointers = this.pointers;
    const radius = arc.getRadiusX();
    const scaleArc = arc.clone();
    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);
    scale.arc = scaleArc;
    scale.reflow(bbox);
    this.plotBbox = scale.bbox;
    for (let i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scaleArc);
      this.plotBbox = geometry_exports.Rect.union(this.plotBbox, pointers[i].bbox);
    }
    return this.getDiff(this.plotBbox, bbox);
  }
  getDiff(plotBox, box) {
    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());
  }
  alignScale(bbox) {
    const plotBoxCenter = this.plotBbox.center();
    const boxCenter = bbox.center();
    const paddingX = plotBoxCenter.x - boxCenter.x;
    const paddingY = plotBoxCenter.y - boxCenter.y;
    const { scale, pointers } = this;
    scale.arc.center.x -= paddingX;
    scale.arc.center.y -= paddingY;
    scale.reflow(bbox);
    for (let i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scale.arc);
      this.plotBbox = geometry_exports.Rect.union(scale.bbox, pointers[i].bbox);
    }
  }
  _createModel() {
    const options = this.options;
    const pointers = options.pointer;
    const scale = this.scale = new radial_scale_default(options.scale, this.contextService);
    this.pointers = [];
    const pointersArr = isArray(pointers) ? pointers : [pointers];
    for (let i = 0; i < pointersArr.length; i++) {
      const current4 = new radial_pointer_default(scale, deepExtend({}, pointersArr[i], {
        animation: {
          transitions: options.transitions
        }
      }));
      this.pointers.push(current4);
    }
  }
};
setDefaultOptions(RadialGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  }
});
var radial_gauge_default = RadialGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-scale.js
var ArcScale = class extends radial_scale_default {
  rangeSegments() {
    const { min: min4, max: max3, rangePlaceholderColor, rangeLineCap } = this.options;
    return [{ from: min4, to: max3, color: rangePlaceholderColor, lineCap: rangeLineCap }];
  }
  hasRanges() {
    return true;
  }
  placeholderRangeAngle(angle) {
    const geometry = this.ranges.children[0].geometry();
    if (this.options.reverse) {
      geometry.setEndAngle(angle);
    } else {
      geometry.setStartAngle(angle);
    }
  }
  addRange(from, to, options) {
    const reverse = this.options.reverse;
    const startAngle = this.slotAngle(reverse ? to : from);
    const endAngle = this.slotAngle(reverse ? from : to);
    const range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);
    this.ranges.append(range);
    return range;
  }
};
setDefaultOptions(ArcScale, {
  min: 0,
  max: 100,
  majorTicks: {
    visible: false
  },
  minorTicks: {
    visible: false
  },
  labels: {
    visible: false
  },
  startAngle: 0,
  endAngle: 180,
  rangeLineCap: "round"
});
var arc_scale_default = ArcScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer-animation.js
var MAX_DURATION = 800;
var RangePointerAnimation = class extends drawing_exports.Animation {
  constructor(element, options) {
    super(element, options);
    const animationOptions = this.options;
    const duration2 = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3;
    animationOptions.duration = limitValue(duration2, ANGULAR_SPEED, MAX_DURATION);
    const startColor = element.elements.options.get("stroke.color");
    const color = element.currentColor();
    if (startColor !== color) {
      this.startColor = new color_default(startColor);
      this.color = new color_default(color);
    }
  }
  step(pos) {
    const { options, startColor, color } = this;
    const angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.angle(angle);
    if (color) {
      const r = round(interpolateValue(startColor.r, color.r, pos));
      const g = round(interpolateValue(startColor.g, color.g, pos));
      const b = round(interpolateValue(startColor.b, color.b, pos));
      this.element.stroke(new color_default(r, g, b).toHex());
    }
  }
};
setDefaultOptions(RangePointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);
var range_pointer_animation_default = RangePointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer.js
var RangePointer = class extends pointer_default {
  repaint() {
    const { scale, options } = this;
    const oldAngle = scale.slotAngle(options._oldValue);
    const newAngle = scale.slotAngle(options.value);
    if (this.animation) {
      this.animation.abort();
    }
    if (options.animation.transitions === false) {
      this.angle(newAngle);
      this.stroke(this.currentColor());
    } else {
      this.animation = new range_pointer_animation_default(this, deepExtend(options.animation, {
        oldAngle,
        newAngle
      }));
      this.animation.play();
    }
  }
  angle(value2) {
    const geometry = this.elements.geometry();
    if (this.scale.options.reverse) {
      geometry.setStartAngle(value2);
    } else {
      geometry.setEndAngle(value2);
    }
    this.scale.placeholderRangeAngle(value2);
  }
  stroke(value2) {
    this.elements.stroke(value2);
  }
  render() {
    if (this.elements) {
      return;
    }
    const { scale, options } = this;
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    this.elements = scale.addRange(scale.options.min, this.options.value, {
      color: this.currentColor(),
      opacity: options.opacity,
      lineCap: scale.options.rangeLineCap
    });
  }
  currentColor() {
    const { min: min4, max: max3 } = this.scale.options;
    const { colors, color, value: value2 } = this.options;
    const currentValue = isNumber(value2) ? value2 : min4;
    if (colors) {
      for (let idx = 0; idx < colors.length; idx++) {
        const { color: rangeColor, from = min4, to = max3 } = colors[idx];
        if (from <= currentValue && currentValue <= to) {
          return rangeColor;
        }
      }
    }
    return color;
  }
  reflow() {
    this.render();
    this.bbox = this.elements.bbox();
  }
};
setDefaultOptions(RangePointer, {
  animation: {
    type: RADIAL_RANGE_POINTER,
    duration: ANGULAR_SPEED
  }
});
var range_pointer_default = RangePointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-gauge.js
var ArcGauge = class extends radial_gauge_default {
  _initTheme(theme) {
    super._initTheme(theme);
    this.options.color = this.options.color || (this.theme.pointer || {}).color;
  }
  _createModel() {
    const options = this.options;
    const scale = this.scale = new arc_scale_default(options.scale, this.contextService);
    const pointer = new range_pointer_default(scale, deepExtend({}, {
      colors: options.colors,
      color: options.color,
      value: options.value,
      opacity: options.opacity,
      animation: {
        transitions: options.transitions
      }
    }));
    this.pointers = [pointer];
  }
  _buildPointers(pointers) {
    for (let i = 0; i < pointers.length; i++) {
      const current4 = pointers[i];
      current4.render();
      current4.value(current4.options.value);
    }
  }
  _setValueOptions(value2) {
    this.options.value = value2;
  }
  currentColor() {
    const pointer = this.pointers[0];
    if (pointer) {
      return pointer.currentColor();
    }
  }
  centerLabelPosition(width, height) {
    const size = this.getSize();
    const center = this.scale.arc.center;
    let left = center.x - width / 2;
    let top = center.y - height / 2;
    if (width < size.width) {
      const right = left + width;
      left = Math.max(left, 0);
      if (right > size.width) {
        left -= right - size.width;
      }
    }
    if (height < size.height) {
      const bbox = this.scale.bbox;
      const yLimit = bbox.bottomRight().y;
      const bottom = top + height;
      top = Math.max(top, bbox.origin.y);
      if (bottom > yLimit) {
        top -= bottom - yLimit;
      }
    }
    return {
      left,
      top
    };
  }
};
var arc_gauge_default = ArcGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/circular/circular-gauge.js
var defaultStartAngle = 90;
var CircularGauge = class extends arc_gauge_default {
  _createModel() {
    const scaleOptions = this.options.scale;
    if (typeof scaleOptions.startAngle !== "number") {
      scaleOptions.startAngle = defaultStartAngle;
    }
    scaleOptions.endAngle = scaleOptions.startAngle + 360;
    super._createModel();
  }
};
var circular_gauge_default = CircularGauge;

// node_modules/@progress/kendo-charts/dist/es/sankey/calculation.js
var max = (array, mapFn) => Math.max.apply(null, array.map(mapFn));
var min = (array, mapFn) => Math.min.apply(null, array.map(mapFn));
var sum = (array, mapFn) => array.map(mapFn).reduce((acc, curr) => acc + curr, 0);
var sortAsc = (a, b) => a.y0 === b.y0 ? a.index - b.index : a.y0 + a.y1 - b.y0 - b.y1;
var sortSource = (a, b) => sortAsc(a.source, b.source);
var sortTarget = (a, b) => sortAsc(a.target, b.target);
var value = (node) => node.value;
function sortLinks(nodes) {
  nodes.forEach((node) => {
    node.targetLinks.forEach((link) => {
      link.source.sourceLinks.sort(sortTarget);
    });
    node.sourceLinks.forEach((link) => {
      link.target.targetLinks.sort(sortSource);
    });
  });
}
var calcLayer = (node, maxDepth) => {
  if (node.align === "left") {
    return node.depth;
  }
  if (node.align === "right") {
    return maxDepth - node.height;
  }
  return node.sourceLinks.length ? node.depth : maxDepth;
};
var Sankey = class {
  constructor(options) {
    const { offset = {}, align } = options.nodesOptions;
    this.data = {
      nodes: options.nodes.map((node) => deepExtend({}, { offset, align }, node)),
      links: options.links.map((link) => deepExtend({}, link))
    };
    this.width = options.width;
    this.height = options.height;
    this.offsetX = options.offsetX || 0;
    this.offsetY = options.offsetY || 0;
    this.nodeWidth = options.nodesOptions.width;
    this.nodePadding = options.nodesOptions.padding;
    this.reverse = options.reverse;
    this.targetColumnIndex = options.targetColumnIndex;
    this.loops = options.loops;
    this.autoLayout = options.autoLayout;
  }
  calculate() {
    const { nodes, links } = this.data;
    this.connectLinksToNodes(nodes, links);
    this.calculateNodeValues(nodes);
    const circularLinks = this.calculateNodeHeights(nodes);
    if (circularLinks) {
      return { nodes: [], links: [], columns: [], circularLinks };
    }
    this.calculateNodeDepths(nodes);
    const columns = this.calculateNodeColumns(nodes);
    this.calculateNodeBreadths(columns);
    this.applyNodesOffset(nodes);
    this.calculateLinkBreadths(nodes);
    return Object.assign({}, this.data, { columns });
  }
  connectLinksToNodes(nodes, links) {
    const nodesMap = /* @__PURE__ */ new Map();
    nodes.forEach((node, i) => {
      node.index = i;
      node.sourceLinks = [];
      node.targetLinks = [];
      node.id = node.id !== void 0 ? node.id : node.label.text;
      nodesMap.set(node.id, node);
    });
    links.forEach((link) => {
      link.source = nodesMap.get(link.sourceId);
      link.target = nodesMap.get(link.targetId);
      link.source.sourceLinks.push(link);
      link.target.targetLinks.push(link);
    });
  }
  calculateNodeValues(nodes) {
    nodes.forEach((node) => {
      node.value = Math.max(
        sum(node.sourceLinks, value),
        sum(node.targetLinks, value)
      );
    });
  }
  calculateNodeDepths(nodes) {
    let current4 = new Set(nodes);
    let next = /* @__PURE__ */ new Set();
    let currDepth = 0;
    while (current4.size) {
      const currentNodes = Array.from(current4);
      for (let n = 0; n < currentNodes.length; n++) {
        const node = currentNodes[n];
        node.depth = currDepth;
        for (let l = 0; l < node.sourceLinks.length; l++) {
          const link = node.sourceLinks[l];
          next.add(link.target);
        }
      }
      currDepth++;
      current4 = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  calculateNodeHeights(nodes) {
    const nodesLength = nodes.length;
    let current4 = new Set(nodes);
    let next = /* @__PURE__ */ new Set();
    let currentHeight = 0;
    const eachNode = (node) => {
      node.height = currentHeight;
      node.targetLinks.forEach((link) => {
        next.add(link.source);
      });
    };
    while (current4.size) {
      current4.forEach(eachNode);
      currentHeight++;
      if (currentHeight > nodesLength) {
        return true;
      }
      current4 = next;
      next = /* @__PURE__ */ new Set();
    }
    return false;
  }
  calculateNodeColumns(nodes) {
    const maxDepth = max(nodes, (d) => d.depth);
    const columnWidth = (this.width - this.offsetX - this.nodeWidth) / maxDepth;
    const columns = new Array(maxDepth + 1);
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const layer = Math.max(0, Math.min(maxDepth, calcLayer(node, maxDepth)));
      node.x0 = this.offsetX + layer * columnWidth;
      node.x1 = node.x0 + this.nodeWidth;
      node.layer = layer;
      columns[layer] = columns[layer] || [];
      columns[layer].push(node);
    }
    return columns;
  }
  calculateNodeBreadths(columns) {
    const kSize = min(columns, (c) => (this.height - this.offsetY - (c.length - 1) * this.nodePadding) / sum(c, value));
    columns.forEach((nodes) => {
      let y = this.offsetY;
      nodes.forEach((node) => {
        node.y0 = y;
        node.y1 = y + node.value * kSize;
        y = node.y1 + this.nodePadding;
        node.sourceLinks.forEach((link) => {
          link.width = link.value * kSize;
        });
      });
      y = (this.height - y + this.nodePadding) / (nodes.length + 1);
      nodes.forEach((node, i) => {
        node.y0 += y * (i + 1);
        node.y1 += y * (i + 1);
      });
    });
    if (this.autoLayout !== false) {
      const loops = this.loops !== void 0 ? this.loops : columns.length - 1;
      const targetColumnIndex = this.targetColumnIndex || 1;
      for (let i = 0; i < loops; i++) {
        if (!this.reverse) {
          this.uncurlLinksToLeft(columns, targetColumnIndex);
          this.uncurlLinksToRight(columns, targetColumnIndex);
        } else {
          this.uncurlLinksToRight(columns, targetColumnIndex);
          this.uncurlLinksToLeft(columns, targetColumnIndex);
        }
      }
    }
    columns.forEach(sortLinks);
  }
  applyNodesOffset(nodes) {
    nodes.forEach((node) => {
      const offsetX = (node.offset ? node.offset.left : 0) || 0;
      const offsetY = (node.offset ? node.offset.top : 0) || 0;
      node.x0 += offsetX;
      node.x1 += offsetX;
      node.y0 += offsetY;
      node.y1 += offsetY;
    });
  }
  calculateLinkBreadths(nodes) {
    nodes.forEach((node) => {
      const { sourceLinks, targetLinks } = node;
      let y = node.y0;
      let y1 = y;
      sourceLinks.forEach((link) => {
        link.x0 = link.source.x1;
        link.y0 = y + link.width / 2;
        y += link.width;
      });
      targetLinks.forEach((link) => {
        link.x1 = link.target.x0;
        link.y1 = y1 + link.width / 2;
        y1 += link.width;
      });
    });
  }
  uncurlLinksToRight(columns, targetColumnIndex) {
    const n = columns.length;
    for (let i = targetColumnIndex; i < n; i++) {
      const column = columns[i];
      column.forEach((target) => {
        let y = 0;
        let sum2 = 0;
        target.targetLinks.forEach((link) => {
          let kValue = link.value * (target.layer - link.source.layer);
          y += this.targetTopPos(link.source, target) * kValue;
          sum2 += kValue;
        });
        let dy = y === 0 ? 0 : y / sum2 - target.y0;
        target.y0 += dy;
        target.y1 += dy;
        sortLinks([target]);
      });
      column.sort(sortAsc);
      this.arrangeNodesVertically(column);
    }
  }
  uncurlLinksToLeft(columns, targetColumnIndex) {
    const l = columns.length;
    const startIndex = l - 1 - targetColumnIndex;
    for (let i = startIndex; i >= 0; i--) {
      const column = columns[i];
      for (let j = 0; j < column.length; j++) {
        const source = column[j];
        let y = 0;
        let sum2 = 0;
        source.sourceLinks.forEach((link) => {
          let kValue = link.value * (link.target.layer - source.layer);
          y += this.sourceTopPos(source, link.target) * kValue;
          sum2 += kValue;
        });
        let dy = y === 0 ? 0 : y / sum2 - source.y0;
        source.y0 += dy;
        source.y1 += dy;
        sortLinks([source]);
      }
      column.sort(sortAsc);
      this.arrangeNodesVertically(column);
    }
  }
  arrangeNodesVertically(nodes) {
    const startIndex = 0;
    const endIndex = nodes.length - 1;
    this.arrangeUp(nodes, this.height, endIndex);
    this.arrangeDown(nodes, this.offsetY, startIndex);
  }
  arrangeDown(nodes, yPos, index) {
    let currentY = yPos;
    for (let i = index; i < nodes.length; i++) {
      const node = nodes[i];
      const dy = Math.max(0, currentY - node.y0);
      node.y0 += dy;
      node.y1 += dy;
      currentY = node.y1 + this.nodePadding;
    }
  }
  arrangeUp(nodes, yPos, index) {
    let currentY = yPos;
    for (let i = index; i >= 0; --i) {
      const node = nodes[i];
      const dy = Math.max(0, node.y1 - currentY);
      node.y0 -= dy;
      node.y1 -= dy;
      currentY = node.y0 - this.nodePadding;
    }
  }
  sourceTopPos(source, target) {
    let y = target.y0 - (target.targetLinks.length - 1) * this.nodePadding / 2;
    for (let i = 0; i < target.targetLinks.length; i++) {
      const link = target.targetLinks[i];
      if (link.source === source) {
        break;
      }
      y += link.width + this.nodePadding;
    }
    for (let i = 0; i < source.sourceLinks.length; i++) {
      const link = source.sourceLinks[i];
      if (link.target === target) {
        break;
      }
      y -= link.width;
    }
    return y;
  }
  targetTopPos(source, target) {
    let y = source.y0 - (source.sourceLinks.length - 1) * this.nodePadding / 2;
    for (let i = 0; i < source.sourceLinks.length; i++) {
      const link = source.sourceLinks[i];
      if (link.target === target) {
        break;
      }
      y += link.width + this.nodePadding;
    }
    for (let i = 0; i < target.targetLinks.length; i++) {
      const link = target.targetLinks[i];
      if (link.source === source) {
        break;
      }
      y -= link.width;
    }
    return y;
  }
};
var calculateSankey = (options) => new Sankey(options).calculate();
var crossesValue = (links) => {
  let value2 = 0;
  const linksLength = links.length;
  for (let i = 0; i < linksLength; i++) {
    const link = links[i];
    for (let lNext = i + 1; lNext < linksLength; lNext++) {
      const nextLink = links[lNext];
      if (intersect(link, nextLink)) {
        value2 += Math.min(link.value, nextLink.value);
      }
    }
  }
  return value2;
};
function rotationDirection(p1x, p1y, p2x, p2y, p3x, p3y) {
  const expression1 = (p3y - p1y) * (p2x - p1x);
  const expression2 = (p2y - p1y) * (p3x - p1x);
  if (expression1 > expression2) {
    return 1;
  } else if (expression1 === expression2) {
    return 0;
  }
  return -1;
}
function intersect(link1, link2) {
  const f1 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x1, link2.y1);
  const f2 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x0, link2.y0);
  const f3 = rotationDirection(link1.x0, link1.y0, link2.x0, link2.y0, link2.x1, link2.y1);
  const f4 = rotationDirection(link1.x1, link1.y1, link2.x0, link2.y0, link2.x1, link2.y1);
  return f1 !== f2 && f3 !== f4;
}

// node_modules/@progress/kendo-charts/dist/es/sankey/element.js
var SankeyElement = class extends class_default {
  constructor(options) {
    super();
    this.options = deepExtend({}, this.options, options);
    this.createVisual();
  }
  createVisual() {
    this.visual = this.createElement();
  }
  exportVisual() {
    return this.visual;
  }
  createElement() {
    const customVisual = this.options.visual;
    let visual;
    if (customVisual) {
      visual = customVisual({
        sender: this.getSender(),
        options: this.visualOptions(),
        createVisual: () => this.getElement()
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  }
  getSender() {
    return this;
  }
};

// node_modules/@progress/kendo-charts/dist/es/sankey/node.js
var Node = class extends SankeyElement {
  getElement() {
    return drawing_exports.Path.fromRect(this.getRect(), this.visualOptions());
  }
  getRect() {
    const node = this.options.node;
    return new geometry_exports.Rect([node.x0, node.y0], [node.x1 - node.x0, node.y1 - node.y0]);
  }
  getLabelText(options) {
    let labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ node: options.node });
    }
  }
  visualOptions() {
    const options = deepExtend({}, this.options, this.options.node);
    const ariaLabel = this.getLabelText(options);
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: { width: 0 },
      className: "k-sankey-node",
      role: "graphics-symbol",
      ariaRoleDescription: "Node",
      ariaLabel
    };
  }
  createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    this._highlight = drawing_exports.Path.fromRect(this.getRect(), {
      stroke: this.options.focusHighlight.border,
      visible: false
    });
    return this._highlight;
  }
  focus(options) {
    if (this._highlight) {
      const { highlight = true } = options || {};
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      const id = this.options.node.id;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  }
  blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  }
};
var nodeColor = (node, nodeColors, index) => node.color || nodeColors[index % nodeColors.length];
var resolveNodeOptions = (node, options, nodeColors, index) => {
  const nodeOptions = deepExtend({}, options, options.node);
  return deepExtend(
    {},
    { color: nodeColor(node, nodeColors, index) },
    nodeOptions,
    { node },
    {
      visual: node.visual,
      opacity: node.opacity,
      offset: node.offset,
      color: node.color
    }
  );
};

// node_modules/@progress/kendo-charts/dist/es/sankey/link.js
var bezierPoint = (p1, p2, p3, p4, t) => {
  const t1 = 1 - t;
  const t1t1 = t1 * t1;
  const tt = t * t;
  return p1 * t1t1 * t1 + 3 * p2 * t * t1t1 + 3 * p3 * tt * t1 + p4 * tt * t;
};
function calculatePerpendicularLine(x1, y1, x2, y2, L) {
  let xM = (x1 + x2) / 2;
  let yM = (y1 + y2) / 2;
  let dx, dy;
  if (y1 === y2) {
    dx = 0;
    dy = L / 2;
  } else if (x1 === x2) {
    dx = L / 2;
    dy = 0;
  } else {
    let m = (y2 - y1) / (x2 - x1);
    let mPerp = -1 / m;
    dx = L / 2 / Math.sqrt(1 + mPerp * mPerp);
    dy = mPerp * dx;
  }
  let P1 = { x: xM - dx, y: yM - dy };
  let P2 = { x: xM + dx, y: yM + dy };
  return { P1, P2 };
}
function findIntersection(a, b, L, p, q) {
  const midpoint = {
    x: (a.x + b.x) / 2,
    y: (a.y + b.y) / 2
  };
  const ab_dx = b.x - a.x;
  const ab_dy = b.y - a.y;
  let perp_dx = -ab_dy;
  let perp_dy = ab_dx;
  const magnitude = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
  perp_dx = perp_dx / magnitude * L;
  perp_dy = perp_dy / magnitude * L;
  const c1 = {
    x: midpoint.x + perp_dx,
    y: midpoint.y + perp_dy
  };
  const c2 = {
    x: midpoint.x - perp_dx,
    y: midpoint.y - perp_dy
  };
  const pq_dx = q.x - p.x;
  const pq_dy = q.y - p.y;
  const denominator = pq_dy * (c1.x - c2.x) - pq_dx * (c1.y - c2.y);
  if (Math.abs(denominator) < 1e-10) {
    return null;
  }
  const ua = (pq_dx * (c2.y - p.y) - pq_dy * (c2.x - p.x)) / denominator;
  const ub = ((c1.x - c2.x) * (c2.y - p.y) - (c1.y - c2.y) * (c2.x - p.x)) / denominator;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    const intersection2 = {
      x: c2.x + ua * (c1.x - c2.x)
      // y: c2.y + ua * (c1.y - c2.y)
    };
    return intersection2;
  }
  return null;
}
var calculateControlPointsOffsetX = (link, rtl) => {
  const halfWidth = link.width / 2;
  const x0 = rtl ? link.x1 : link.x0;
  const x1 = rtl ? link.x0 : link.x1;
  const y0 = rtl ? link.y1 : link.y0;
  const y1 = rtl ? link.y0 : link.y1;
  const xC = (x0 + x1) / 2;
  const middlePoint = [xC, bezierPoint(y0, y0, y1, y1, 0.5)];
  const tH = 0.4999;
  const pointH = [
    bezierPoint(x0, xC, xC, x1, tH),
    bezierPoint(y0, y0, y1, y1, tH)
  ];
  const line = calculatePerpendicularLine(middlePoint[0], middlePoint[1], pointH[0], pointH[1], link.width);
  const middlePointDown = [xC, bezierPoint(y0 + halfWidth, y0 + halfWidth, y1 + halfWidth, y1 + halfWidth, 0.5)];
  const P = line.P1.y > line.P2.y ? line.P1 : line.P2;
  const L = halfWidth;
  const LDir = (y0 > y1 ? 1 : -1) * L;
  const a = P;
  const b = { x: middlePointDown[0], y: middlePointDown[1] };
  const p = { x: middlePointDown[0], y: middlePointDown[1] };
  const q = { x: Math.max(1, middlePointDown[0] + LDir), y: middlePointDown[1] };
  const Pmx = findIntersection(a, b, L, p, q) || { x: (middlePointDown[0] + P.x) / 2 };
  const P1 = x0;
  const P4 = x1;
  const P2 = (Pmx.x - 0.125 * P1 - 0.125 * P4) / 0.75;
  return xC - P2;
};
var Link = class extends SankeyElement {
  getElement() {
    const link = this.options.link;
    const { x0, x1, y0, y1 } = link;
    const xC = (x0 + x1) / 2;
    return new drawing_exports.Path(this.visualOptions()).moveTo(x0, y0).curveTo([xC, y0], [xC, y1], [x1, y1]);
  }
  getLabelText(options) {
    let labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ link: options.link });
    }
  }
  visualOptions() {
    const options = this.options;
    const link = this.options.link;
    const ariaLabel = this.getLabelText(options);
    return {
      stroke: {
        width: options.link.width,
        color: link.color || options.color,
        opacity: defined(link.opacity) ? link.opacity : options.opacity
      },
      role: "graphics-symbol",
      ariaRoleDescription: "Link",
      ariaLabel
    };
  }
  createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    const { link } = this.options;
    const { x0, x1, y0, y1 } = link;
    const xC = (x0 + x1) / 2;
    const halfWidth = link.width / 2;
    const offset = calculateControlPointsOffsetX(link, this.options.rtl);
    this._highlight = new drawing_exports.Path({ stroke: this.options.focusHighlight.border, visible: false }).moveTo(x0, y0 + halfWidth).lineTo(x0, y0 - halfWidth).curveTo([xC + offset, y0 - halfWidth], [xC + offset, y1 - halfWidth], [x1, y1 - halfWidth]).lineTo(x1, y1 + halfWidth).curveTo([xC - offset, y1 + halfWidth], [xC - offset, y0 + halfWidth], [x0, y0 + halfWidth]);
  }
  focus(options) {
    if (this._highlight) {
      const { highlight = true } = options || {};
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      const id = `${this.options.link.sourceId}->${this.options.link.targetId}`;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  }
  blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  }
};
var resolveLinkOptions = (link, options, sourceNode, targetNode) => {
  const linkOptions = deepExtend(
    {},
    options,
    {
      link,
      opacity: link.opacity,
      color: link.color,
      colorType: link.colorType,
      visual: link.visual,
      highlight: link.highlight
    }
  );
  if (linkOptions.colorType === "source") {
    linkOptions.color = sourceNode.options.fill.color;
  } else if (linkOptions.colorType === "target") {
    linkOptions.color = targetNode.options.fill.color;
  }
  return linkOptions;
};

// node_modules/@progress/kendo-charts/dist/es/sankey/label.js
var INSIDE3 = "inside";
var BEFORE = "before";
var AFTER = "after";
var Label = class extends SankeyElement {
  getElement() {
    const options = deepExtend({}, this.options, this.options.node.label);
    const { node, diagramMinX, diagramMaxX, text, offset, rtl } = options;
    let position = options.position;
    if (rtl && position !== INSIDE3) {
      position = position === BEFORE ? AFTER : BEFORE;
    }
    if (!options.visible || !text) {
      return null;
    }
    const nodeBox = new box_default(node.x0, node.y0, node.x1, node.y1);
    const visualOptions = this.visualOptions();
    if (rtl && !visualOptions.align) {
      visualOptions.align = "right";
    }
    const textbox = new text_box_default(text, visualOptions);
    textbox.reflow(new box_default());
    const textSizeBox = textbox.box;
    const textY = nodeBox.center().y - textSizeBox.height() / 2;
    const labelAfterLastNode = node.x1 + textSizeBox.width() > diagramMaxX;
    const labelBeforeFirstNode = node.x0 - textSizeBox.width() < diagramMinX;
    let side = position === BEFORE || position === INSIDE3 && labelAfterLastNode ? BEFORE : AFTER;
    if (rtl) {
      side = position === AFTER || position === INSIDE3 && labelBeforeFirstNode ? AFTER : BEFORE;
    }
    const textOrigin = [side === BEFORE ? node.x0 - textSizeBox.width() : node.x1, textY];
    const textRect = new box_default(textOrigin[0], textOrigin[1], textOrigin[0] + textSizeBox.width(), textOrigin[1] + textSizeBox.height());
    textRect.translate(offset.left || 0, offset.top || 0);
    textbox.reflow(textRect);
    textbox.renderVisual();
    return textbox.visual;
  }
  visualOptions() {
    const options = deepExtend({}, this.options, this.options.node.label);
    return {
      color: options.color,
      font: options.font,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      align: options.align,
      paintOrder: options.paintOrder,
      stroke: options.stroke
    };
  }
};
setDefaultOptions(Label, {
  position: INSIDE3
  // inside, before, after
});
var resolveLabelOptions = (node, options, rtl, diagramMinX, diagramMaxX) => deepExtend(
  {},
  options,
  {
    node,
    diagramMinX,
    diagramMaxX,
    rtl,
    visual: node.label.visual,
    visible: node.label.visible,
    margin: node.label.margin,
    padding: node.label.padding,
    border: node.label.border,
    align: node.label.align,
    offset: node.label.offset
  }
);

// node_modules/@progress/kendo-charts/dist/es/sankey/title.js
var Title2 = class extends SankeyElement {
  getElement() {
    const options = this.options;
    const { drawingRect, text } = options;
    if (options.visible === false || !text) {
      return null;
    }
    const title3 = title_default.buildTitle(text, options);
    title3.reflow(drawingRect);
    title3.renderVisual();
    return title3.visual;
  }
  createElement() {
    return this.getElement();
  }
};
setDefaultOptions(Title2, {
  align: CENTER,
  // 'left', 'right', 'center'
  border: {
    width: 0
  },
  margin: getSpacing(5),
  padding: getSpacing(5)
});

// node_modules/@progress/kendo-charts/dist/es/sankey/legend.js
var sortData = (a, b) => {
  if (a.node.x0 - b.node.x0 !== 0) {
    return a.node.x0 - b.node.x0;
  }
  return a.node.y0 - b.node.y0;
};
var sortDataRTL = (a, b) => {
  if (a.node.x1 - b.node.x1 !== 0) {
    return a.node.x1 - b.node.x1;
  }
  return b.node.y0 - a.node.y0;
};
var sort = (rtl) => rtl ? sortDataRTL : sortData;
var Legend2 = class extends SankeyElement {
  getElement() {
    const options = this.options;
    const { drawingRect, rtl, nodes = [], item, position } = options;
    if (options.visible === false || !nodes.length) {
      return null;
    }
    const labels = options.labels || {};
    let labelsTemplate;
    if (labels.content) {
      labelsTemplate = getTemplate(labels);
    }
    const data = nodes.map((node) => ({
      text: labelsTemplate ? labelsTemplate(node) : node.label && node.label.text || "",
      area: {
        background: item.areaBackground !== void 0 ? item.areaBackground : node.color,
        opacity: item.areaOpacity !== void 0 ? item.areaOpacity : node.opacity
      },
      node
    }));
    data.sort(sort(rtl));
    const reverse = rtl && position !== LEFT && position !== RIGHT;
    const legend2 = new legend_default(Object.assign({}, options, { data, reverse }), { rtl });
    legend2.reflow(drawingRect);
    legend2.renderVisual();
    return legend2.visual;
  }
  createElement() {
    return this.getElement();
  }
};
setDefaultOptions(Legend2, {
  markers: { visible: false },
  item: {
    type: AREA,
    cursor: POINTER,
    opacity: 1
  },
  position: BOTTOM,
  align: CENTER,
  accessibility: {
    role: "presentation",
    ariaLabel: null,
    ariaRoleDescription: null
  },
  border: {
    width: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/sankey.js
var LINK = "link";
var NODE = "node";
var toRtl = (sankey) => {
  const { nodes, links } = sankey;
  const startX = Math.min(...nodes.map((node) => node.x0));
  const endX = Math.max(...nodes.map((node) => node.x1));
  const width = endX - startX;
  nodes.forEach((node) => {
    const x0 = width - (node.x1 - 2 * startX);
    const x1 = width - (node.x0 - 2 * startX);
    node.x0 = x0;
    node.x1 = x1;
  });
  links.forEach((link) => {
    const x0 = width - (link.x1 - 2 * startX);
    const x1 = width - (link.x0 - 2 * startX);
    link.x1 = x0;
    link.x0 = x1;
  });
};
var Sankey2 = class extends Observable {
  constructor(element, options, theme) {
    super();
    this._initTheme(theme);
    this._setOptions(options);
    this._initElement(element);
    this._initSurface();
    if (options && options.data) {
      this._redraw();
      this._initResizeObserver();
      this._initNavigation(element);
    }
  }
  destroy() {
    this.unbind();
    this._destroySurface();
    this._destroyResizeObserver();
    if (this.element) {
      this.element.removeEventListener("keydown", this._keydownHandler);
      this.element.removeEventListener("focus", this._focusHandler);
      this.element.removeEventListener("mousedown", this._onDownHandler);
      this.element.removeEventListener("touchstart", this._onDownHandler);
      this.element.removeEventListener("pointerdown", this._onDownHandler);
    }
    this._focusState = null;
    this.element = null;
  }
  _initElement(element) {
    this.element = element;
    addClass(element, ["k-chart", "k-sankey"]);
    element.setAttribute("role", "graphics-document");
    const { title: title3 } = this.options;
    if (title3.text) {
      element.setAttribute("aria-label", title3.text);
    }
    if (title3.description) {
      element.setAttribute("aria-roledescription", title3.description);
    }
  }
  _initSurface() {
    if (!this.surface) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  }
  _initNavigation(element) {
    element.tabIndex = element.getAttribute("tabindex") || 0;
    if (this.options.disableKeyboardNavigation) {
      return;
    }
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._onDownHandler = this._onDown.bind(this);
    element.addEventListener("keydown", this._keydownHandler);
    element.addEventListener("focus", this._focusHandler);
    element.addEventListener("blur", this._blurHandler);
    element.addEventListener("mousedown", this._onDownHandler);
    element.addEventListener("touchstart", this._onDownHandler);
    element.addEventListener("pointerdown", this._onDownHandler);
    this._focusState = {
      node: this.firstFocusableNode(),
      link: null
    };
  }
  firstFocusableNode() {
    return this.columns[0][0];
  }
  _initResizeObserver() {
    const observer = new ResizeObserver((entries) => {
      entries.forEach((entry) => {
        const { width, height } = entry.contentRect;
        if (entry.target !== this.element || this.size && this.size.width === width && this.size.height === height) {
          return;
        }
        this.size = { width, height };
        this.surface.setSize(this.size);
        this.resize = true;
        this._redraw();
      });
    });
    this._resizeObserver = observer;
    observer.observe(this.element);
  }
  _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      mouseenter: this._mouseenter.bind(this),
      mouseleave: this._mouseleave.bind(this),
      mousemove: this._mousemove.bind(this),
      click: this._click.bind(this)
    });
  }
  _initTheme(theme) {
    let currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
  }
  setLinksOpacity(opacity) {
    this.linksVisuals.forEach((link) => {
      this.setOpacity(link, opacity, link.linkOptions.opacity);
    });
  }
  setLinksInactivityOpacity(inactiveOpacity) {
    this.linksVisuals.forEach((link) => {
      this.setOpacity(link, inactiveOpacity, link.linkOptions.highlight.inactiveOpacity);
    });
  }
  setOpacity(link, opacity, linkValue) {
    link.options.set("stroke", Object.assign(
      {},
      link.options.stroke,
      { opacity: defined(linkValue) ? linkValue : opacity }
    ));
  }
  trigger(name, ev) {
    let dataItem = ev.element.dataItem;
    const targetType = ev.element.type;
    const event = Object.assign(
      {},
      ev,
      {
        type: name,
        targetType,
        dataItem
      }
    );
    return super.trigger(name, event);
  }
  _mouseenter(ev) {
    const element = ev.element;
    const isLink = element.type === LINK;
    const isNode = element.type === NODE;
    const isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    if (isLink && this.trigger("linkEnter", ev) || isNode && this.trigger("nodeEnter", ev)) {
      return;
    }
    const { highlight } = this.options.links;
    if (isLink) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      this.setOpacity(element, highlight.opacity, element.linkOptions.highlight.opacity);
    } else if (isNode) {
      this.highlightLinks(element, highlight);
    } else if (isLegendItem) {
      const nodeVisual = this.nodesVisuals.get(element.chartElement.options.node.id);
      this.highlightLinks(nodeVisual, highlight);
    }
  }
  _mouseleave(ev) {
    const element = ev.element;
    const isLink = element.type === LINK;
    const isNode = element.type === NODE;
    const isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    const target = ev.originalEvent.relatedTarget;
    if (isLink && target && target.nodeName === "text") {
      return;
    }
    if (isLink || isNode) {
      if (this.tooltipTimeOut) {
        clearTimeout(this.tooltipTimeOut);
        this.tooltipTimeOut = null;
      }
      this.tooltipShown = false;
      this.trigger("tooltipHide", ev);
    }
    if (isLink && this.trigger("linkLeave", ev) || isNode && this.trigger("nodeLeave", ev)) {
      return;
    }
    if (isLink || isNode || isLegendItem) {
      this.linksVisuals.forEach((link) => {
        this.setOpacity(link, this.options.links.opacity, link.linkOptions.opacity);
      });
    }
  }
  _mousemove(ev) {
    const { followPointer, delay } = this.options.tooltip;
    const element = ev.element;
    const tooltipElType = element.type;
    if (tooltipElType !== LINK && tooltipElType !== NODE || this.tooltipShown && !followPointer) {
      return;
    }
    const mouseEvent = ev.originalEvent;
    const rect = this.element.getBoundingClientRect();
    const isLeft = mouseEvent.clientX - rect.left < rect.width / 2;
    const isTop = mouseEvent.clientY - rect.top < rect.height / 2;
    ev.tooltipData = {
      popupOffset: {
        left: mouseEvent.pageX,
        top: mouseEvent.pageY
      },
      popupAlign: {
        horizontal: isLeft ? "left" : "right",
        vertical: isTop ? "top" : "bottom"
      }
    };
    if (tooltipElType === NODE) {
      const { sourceLinks, targetLinks } = element.dataItem;
      const links = targetLinks.length ? targetLinks : sourceLinks;
      ev.nodeValue = links.reduce((acc, link) => acc + link.value, 0);
    }
    if (this.tooltipTimeOut) {
      clearTimeout(this.tooltipTimeOut);
      this.tooltipTimeOut = null;
    }
    const nextDelay = followPointer && this.tooltipShown ? 0 : delay;
    this.tooltipTimeOut = setTimeout(() => {
      this.trigger("tooltipShow", ev);
      this.tooltipShown = true;
      this.tooltipTimeOut = null;
    }, nextDelay);
  }
  _click(ev) {
    const element = ev.element;
    const dataItem = element.dataItem;
    const isLink = element.type === LINK;
    const isNode = element.type === NODE;
    const focusState = this._focusState || {};
    if (isNode) {
      const focusedNodeClicked = !focusState.link && this.sameNode(focusState.node, dataItem);
      if (!focusedNodeClicked) {
        this._focusState = { node: dataItem, link: null };
        this._focusNode({ highlight: false });
      }
      this.trigger("nodeClick", ev);
    } else if (isLink) {
      const link = {
        sourceId: dataItem.source.id,
        targetId: dataItem.target.id,
        value: dataItem.value
      };
      const focusedLinkClicked = this.sameLink(focusState.link, link);
      if (!focusedLinkClicked) {
        this._focusState = { node: dataItem.source, link };
        this._focusLink({ highlight: false });
      }
      this.trigger("linkClick", ev);
    }
  }
  sameNode(node1, node2) {
    return node1 && node2 && node1.id === node2.id;
  }
  sameLink(link1, link2) {
    return link1 && link2 && link1.sourceId === link2.sourceId && link1.targetId === link2.targetId;
  }
  _focusNode(options) {
    this._cleanFocusHighlight();
    const nodeData = this._focusState.node;
    const node = this.models.map.get(nodeData.id);
    node.focus(options);
  }
  _focusLink(options) {
    this._cleanFocusHighlight();
    const linkData = this._focusState.link;
    const link = this.models.map.get(`${linkData.sourceId}-${linkData.targetId}`);
    link.focus(options);
  }
  _focusNextNode(direction = 1) {
    const current4 = this._focusState.node;
    const columnIndex = this.columns.findIndex((column) => column.find((n) => n.id === current4.id));
    const columnNodes = this.columns[columnIndex];
    const nodeIndex = columnNodes.findIndex((n) => n.id === current4.id);
    const nextNode = columnNodes[nodeIndex + direction];
    if (nextNode) {
      this._focusState.node = nextNode;
      this._focusNode();
    }
  }
  _focusNextLink(direction = 1) {
    const node = this._focusState.node;
    const link = this._focusState.link;
    const sourceLinkIndex = node.sourceLinks.findIndex((l) => l.sourceId === link.sourceId && l.targetId === link.targetId);
    const targetLinkIndex = node.targetLinks.findIndex((l) => l.sourceId === link.sourceId && l.targetId === link.targetId);
    if (sourceLinkIndex !== -1) {
      const nextLink = node.sourceLinks[sourceLinkIndex + direction];
      if (nextLink) {
        this._focusState.link = nextLink;
        this._focusLink();
      }
    } else if (targetLinkIndex !== -1) {
      const nextLink = node.targetLinks[targetLinkIndex + direction];
      if (nextLink) {
        this._focusState.link = nextLink;
        this._focusLink();
      }
    }
  }
  _focusSourceNode() {
    const linkData = this._focusState.link;
    const sourceNode = this.models.map.get(linkData.sourceId);
    this._focusState = { node: sourceNode.options.node, link: null };
    this._focusNode();
  }
  _focusTargetNode() {
    const linkData = this._focusState.link;
    const targetNode = this.models.map.get(linkData.targetId);
    this._focusState = { node: targetNode.options.node, link: null };
    this._focusNode();
  }
  _focusSourceLink() {
    const nodeData = this._focusState.node;
    const sourceLinks = nodeData.sourceLinks;
    const linkData = sourceLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  }
  _focusTargetLink() {
    const nodeData = this._focusState.node;
    const targetLinks = nodeData.targetLinks;
    const linkData = targetLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  }
  _focus() {
    if (!this._skipFocusHighlight) {
      if (this._focusState.link) {
        this._focusLink();
      } else {
        this._focusNode();
      }
    }
    this._skipFocusHighlight = false;
  }
  _blur() {
    this._cleanFocusHighlight();
  }
  _onDown() {
    if (!this._hasFocus()) {
      this._skipFocusHighlight = true;
    }
  }
  _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  }
  _cleanFocusHighlight() {
    this.models.nodes.forEach((node) => node.blur());
    this.models.links.forEach((link) => link.blur());
  }
  _keydown(ev) {
    let handler = this["on" + ev.key];
    const rtl = this.options.rtl;
    if (rtl && ev.key === "ArrowLeft") {
      handler = this.onArrowRight;
    } else if (rtl && ev.key === "ArrowRight") {
      handler = this.onArrowLeft;
    }
    if (handler) {
      handler.call(this, ev);
    }
  }
  onEscape(ev) {
    ev.preventDefault();
    this._focusState = { node: this.firstFocusableNode(), link: null };
    this._focusNode();
  }
  onArrowDown(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(1);
    } else {
      this._focusNextNode(1);
    }
  }
  onArrowUp(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(-1);
    } else {
      this._focusNextNode(-1);
    }
  }
  onArrowLeft(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusSourceNode();
    } else {
      this._focusTargetLink();
    }
  }
  onArrowRight(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusTargetNode();
    } else {
      this._focusSourceLink();
    }
  }
  highlightLinks(node, highlight) {
    if (node) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      node.links.forEach((link) => {
        this.setOpacity(link, highlight.opacity, link.linkOptions.highlight.opacity);
      });
    }
  }
  _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  }
  _destroyResizeObserver() {
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
  }
  _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
  }
  _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  }
  setOptions(options, theme) {
    this._setOptions(options);
    this._initTheme(theme);
    this._initSurface();
    this._redraw();
  }
  _redraw() {
    this.surface.clear();
    const { width, height } = this._getSize();
    this.size = { width, height };
    this.surface.setSize(this.size);
    this.createVisual();
    this.surface.draw(this.visual);
  }
  _getSize() {
    return this.element.getBoundingClientRect();
  }
  createVisual() {
    this.visual = this._render();
  }
  titleBox(title3, drawingRect) {
    if (!title3 || title3.visible === false || !title3.text) {
      return null;
    }
    const titleElement = new Title2(Object.assign({}, { drawingRect }, title3));
    const titleVisual = titleElement.exportVisual();
    return titleVisual.chartElement.box;
  }
  legendBox(options, nodes, drawingRect) {
    if (!options || options.visible === false) {
      return null;
    }
    const legend2 = new Legend2(Object.assign({}, { nodes }, options, { drawingRect }));
    const legendVisual = legend2.exportVisual();
    return legendVisual.chartElement.box;
  }
  calculateSankey(calcOptions, sankeyOptions) {
    const { title: title3, legend: legend2, data, nodes, labels, nodeColors, disableAutoLayout, disableKeyboardNavigation, rtl } = sankeyOptions;
    const autoLayout = !disableAutoLayout;
    const focusHighlightWidth = ((nodes.focusHighlight || {}).border || {}).width || 0;
    const padding = disableKeyboardNavigation ? 0 : focusHighlightWidth / 2;
    const sankeyBox = new box_default(0, 0, calcOptions.width, calcOptions.height);
    sankeyBox.unpad(padding);
    const titleBox = this.titleBox(title3, sankeyBox);
    let legendArea = sankeyBox.clone();
    if (titleBox) {
      const titleHeight = titleBox.height();
      if (title3.position === TOP) {
        sankeyBox.unpad({ top: titleHeight });
        legendArea = new box_default(0, titleHeight, calcOptions.width, calcOptions.height);
      } else {
        sankeyBox.shrink(0, titleHeight);
        legendArea = new box_default(0, 0, calcOptions.width, calcOptions.height - titleHeight);
      }
    }
    const legendBox = this.legendBox(legend2, data.nodes, legendArea);
    const legendPosition = legend2 && legend2.position || Legend2.prototype.options.position;
    if (legendBox) {
      if (legendPosition === LEFT) {
        sankeyBox.unpad({ left: legendBox.width() });
      }
      if (legendPosition === RIGHT) {
        sankeyBox.shrink(legendBox.width(), 0);
      }
      if (legendPosition === TOP) {
        sankeyBox.unpad({ top: legendBox.height() });
      }
      if (legendPosition === BOTTOM) {
        sankeyBox.shrink(0, legendBox.height());
      }
    }
    const { nodes: calculatedNodes, circularLinks } = calculateSankey(Object.assign({}, calcOptions, { offsetX: 0, offsetY: 0, width: sankeyBox.width(), height: sankeyBox.height() }));
    if (circularLinks) {
      console.warn("Circular links detected. Kendo Sankey diagram does not support circular links.");
      return { sankey: { nodes: [], links: [], columns: [[]], circularLinks }, legendBox, titleBox };
    }
    const box = new box_default();
    const diagramMinX = calculatedNodes.reduce((acc, node) => Math.min(acc, node.x0), Infinity);
    const diagramMaxX = calculatedNodes.reduce((acc, node) => Math.max(acc, node.x1), 0);
    calculatedNodes.forEach((nodeEl, i) => {
      if (rtl) {
        const { x0, x1 } = nodeEl;
        nodeEl.x0 = diagramMaxX - x1;
        nodeEl.x1 = diagramMaxX - x0;
      }
      const nodeOps = resolveNodeOptions(nodeEl, nodes, nodeColors, i);
      const nodeInstance = new Node(nodeOps);
      box.wrap(rectToBox(nodeInstance.exportVisual().rawBBox()));
      const labelInstance = new Label(resolveLabelOptions(nodeEl, labels, rtl, diagramMinX, diagramMaxX));
      const labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        box.wrap(rectToBox(labelVisual.rawBBox()));
      }
    });
    let offsetX = sankeyBox.x1;
    let offsetY = sankeyBox.y1;
    let width = sankeyBox.width() + offsetX;
    let height = sankeyBox.height() + offsetY;
    width -= box.x2 > sankeyBox.width() ? box.x2 - sankeyBox.width() : 0;
    height -= box.y2 > sankeyBox.height() ? box.y2 - sankeyBox.height() : 0;
    offsetX += box.x1 < 0 ? -box.x1 : 0;
    offsetY += box.y1 < 0 ? -box.y1 : 0;
    if (autoLayout === false) {
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })),
        legendBox,
        titleBox
      };
    }
    if (this.resize && autoLayout && this.permutation) {
      this.resize = false;
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation)),
        legendBox,
        titleBox
      };
    }
    const startColumn = 1;
    const loops = 2;
    const columnsLength = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })).columns.length;
    const results = [];
    const permutation = (targetColumnIndex, reverse) => {
      let currPerm = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, loops, targetColumnIndex, reverse }));
      let crosses = crossesValue(currPerm.links);
      results.push({
        crosses,
        reverse,
        targetColumnIndex
      });
      return crosses === 0;
    };
    for (let index = startColumn; index <= columnsLength - 1; index++) {
      if (permutation(index, false) || permutation(index, true)) {
        break;
      }
    }
    const minCrosses = Math.min.apply(null, results.map((r) => r.crosses));
    const bestResult = results.find((r) => r.crosses === minCrosses);
    this.permutation = { targetColumnIndex: bestResult.targetColumnIndex, reverse: bestResult.reverse };
    const result = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation));
    return {
      sankey: result,
      legendBox,
      titleBox
    };
  }
  _render(options, context) {
    const sankeyOptions = options || this.options;
    const sankeyContext = context || this;
    const { labels: labelOptions, nodes: nodesOptions, links: linkOptions, nodeColors, title: title3, legend: legend2, rtl, disableKeyboardNavigation } = sankeyOptions;
    let data = sankeyOptions.data;
    const { width, height } = sankeyContext.size;
    const calcOptions = Object.assign({}, data, { width, height, nodesOptions, title: title3, legend: legend2 });
    const { sankey, titleBox, legendBox } = this.calculateSankey(calcOptions, sankeyOptions);
    if (rtl) {
      toRtl(sankey);
    }
    const { nodes, links, columns } = sankey;
    sankeyContext.columns = columns.map((column) => {
      const newColumn = column.slice();
      newColumn.sort((a, b) => a.y0 - b.y0);
      return newColumn;
    });
    const visual = new drawing_exports.Group({
      clip: drawing_exports.Path.fromRect(new geometry_exports.Rect([0, 0], [width, height]))
    });
    if (titleBox) {
      const titleElement = new Title2(Object.assign({}, title3, { drawingRect: titleBox }));
      const titleVisual = titleElement.exportVisual();
      visual.append(titleVisual);
    }
    if (sankey.circularLinks) {
      return visual;
    }
    const visualNodes = /* @__PURE__ */ new Map();
    sankeyContext.nodesVisuals = visualNodes;
    const models = {
      nodes: [],
      links: [],
      map: /* @__PURE__ */ new Map()
    };
    sankeyContext.models = models;
    const focusHighlights = [];
    nodes.forEach((node, i) => {
      const nodeOps = resolveNodeOptions(node, nodesOptions, nodeColors, i);
      nodeOps.root = () => sankeyContext.element;
      nodeOps.navigatable = disableKeyboardNavigation !== true;
      const nodeInstance = new Node(nodeOps);
      const nodeVisual = nodeInstance.exportVisual();
      nodeVisual.links = [];
      nodeVisual.type = NODE;
      node.color = nodeOps.color;
      node.opacity = nodeOps.opacity;
      nodeVisual.dataItem = Object.assign(
        {},
        data.nodes[i],
        {
          color: nodeOps.color,
          opacity: nodeOps.opacity,
          sourceLinks: node.sourceLinks.map((link) => ({ sourceId: link.sourceId, targetId: link.targetId, value: link.value })),
          targetLinks: node.targetLinks.map((link) => ({ sourceId: link.sourceId, targetId: link.targetId, value: link.value }))
        }
      );
      visualNodes.set(node.id, nodeVisual);
      models.nodes.push(nodeInstance);
      models.map.set(node.id, nodeInstance);
      visual.append(nodeVisual);
      nodeInstance.createFocusHighlight();
      if (nodeInstance._highlight) {
        focusHighlights.push(nodeInstance._highlight);
      }
    });
    const sortedLinks = links.slice().sort((a, b) => b.value - a.value);
    const linksVisuals = [];
    sankeyContext.linksVisuals = linksVisuals;
    sortedLinks.forEach((link) => {
      const { source, target } = link;
      const sourceNode = visualNodes.get(source.id);
      const targetNode = visualNodes.get(target.id);
      const resolvedOptions = resolveLinkOptions(link, linkOptions, sourceNode, targetNode);
      resolvedOptions.root = () => sankeyContext.element;
      resolvedOptions.navigatable = disableKeyboardNavigation !== true;
      resolvedOptions.rtl = rtl;
      const linkInstance = new Link(resolvedOptions);
      const linkVisual = linkInstance.exportVisual();
      linkVisual.type = LINK;
      linkVisual.dataItem = {
        source: Object.assign({}, sourceNode.dataItem),
        target: Object.assign({}, targetNode.dataItem),
        value: link.value
      };
      linkVisual.linkOptions = resolvedOptions;
      linksVisuals.push(linkVisual);
      sourceNode.links.push(linkVisual);
      targetNode.links.push(linkVisual);
      models.links.push(linkInstance);
      models.map.set(`${source.id}-${target.id}`, linkInstance);
      linkInstance.createFocusHighlight();
      if (linkInstance._highlight) {
        focusHighlights.push(linkInstance._highlight);
      }
      visual.append(linkVisual);
    });
    const diagramMinX = nodes.reduce((acc, node) => Math.min(acc, node.x0), Infinity);
    const diagramMaxX = nodes.reduce((acc, node) => Math.max(acc, node.x1), 0);
    nodes.forEach((node) => {
      const textOps = resolveLabelOptions(node, labelOptions, rtl, diagramMinX, diagramMaxX);
      const labelInstance = new Label(textOps);
      const labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        visual.append(labelVisual);
      }
    });
    if (legendBox) {
      const legendElement = new Legend2(Object.assign({}, legend2, { rtl, drawingRect: legendBox, nodes }));
      const legendVisual = legendElement.exportVisual();
      visual.append(legendVisual);
    }
    if (focusHighlights.length !== 0) {
      const focusHighlight = new drawing_exports.Group();
      focusHighlight.append(...focusHighlights);
      visual.append(focusHighlight);
    }
    return visual;
  }
  exportVisual(exportOptions) {
    const options = exportOptions && exportOptions.options ? deepExtend({}, this.options, exportOptions.options) : this.options;
    const context = {
      size: {
        width: defined(exportOptions && exportOptions.width) ? exportOptions.width : this.size.width,
        height: defined(exportOptions && exportOptions.height) ? exportOptions.height : this.size.height
      }
    };
    return this._render(options, context);
  }
  _setOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
};
var highlightOptions = {
  opacity: 1,
  width: 2,
  color: BLACK
};
setDefaultOptions(Sankey2, {
  title: {
    position: TOP
    // 'top', 'bottom'
  },
  labels: {
    visible: true,
    margin: {
      left: 8,
      right: 8
    },
    padding: 0,
    border: {
      width: 0
    },
    paintOrder: "stroke",
    stroke: {
      lineJoin: "round",
      width: 1
    },
    offset: { left: 0, top: 0 }
  },
  nodes: {
    width: 24,
    padding: 16,
    opacity: 1,
    align: "stretch",
    // 'left', 'right', 'stretch'
    offset: { left: 0, top: 0 },
    focusHighlight: {
      border: Object.assign({}, highlightOptions)
    },
    labels: {
      ariaTemplate: ({ node }) => node.label.text
    }
  },
  links: {
    colorType: "static",
    // 'source', 'target', 'static'
    opacity: 0.4,
    highlight: {
      opacity: 0.8,
      inactiveOpacity: 0.2
    },
    focusHighlight: {
      border: Object.assign({}, highlightOptions)
    },
    labels: {
      ariaTemplate: ({ link }) => `${link.source.label.text} to ${link.target.label.text}`
    }
  },
  tooltip: {
    followPointer: false,
    delay: 200
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/utils.js
var createSankeyData = (data, dimensions, measure) => {
  const nodes = /* @__PURE__ */ new Set();
  const links = /* @__PURE__ */ new Map();
  const linksMap = /* @__PURE__ */ new Map();
  data.forEach((row) => {
    dimensions.forEach((dimension) => {
      nodes.add(dimension.value(row));
    });
    for (let i = 0; i < dimensions.length - 1; i++) {
      const source = dimensions[i].value(row);
      const target = dimensions[i + 1].value(row);
      const key = `${source}_${target}`;
      const value2 = measure.value(row);
      const existingValue = links.get(key);
      if (existingValue !== void 0) {
        links.set(key, existingValue + value2);
      } else {
        links.set(key, value2);
        linksMap.set(key, { source, target });
      }
    }
  });
  const nodesId = /* @__PURE__ */ new Map();
  const nodesArray = Array.from(nodes).map((node, index) => {
    nodesId.set(node, index);
    return { id: index, label: { text: String(node) } };
  });
  const linksArray = Array.from(links).map(([key, value2]) => {
    const { source, target } = linksMap.get(key);
    return {
      sourceId: nodesId.get(source),
      targetId: nodesId.get(target),
      value: value2
    };
  });
  return { nodes: nodesArray, links: linksArray };
};

// node_modules/@progress/kendo-charts/dist/es/chart/theme/base-theme.js
var BAR_GAP = 1.5;
var BAR_SPACING = 0.4;
var BLACK2 = "#000";
var SANS = "Arial, Helvetica, sans-serif";
var SANS11 = "11px " + SANS;
var SANS12 = "12px " + SANS;
var SANS16 = "16px " + SANS;
var TRANSPARENT = "transparent";
var WHITE2 = "#fff";
var lineSeriesLegendItem = {
  type: LINE
};
var areaSeriesLegendItem = {
  type: AREA
};
var areaNoMarkersSeriesLegendItem = Object.assign(
  {},
  areaSeriesLegendItem,
  {
    markers: {
      visible: false
    },
    highlight: {
      visible: false
    }
  }
);
var notes = () => ({
  icon: {
    border: {
      width: 1
    }
  },
  label: {
    font: SANS12,
    padding: 3
  },
  line: {
    length: 10,
    width: 2
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  visible: true
});
var axisDefaults = () => ({
  labels: {
    font: SANS12
  },
  notes: notes(),
  title: {
    font: SANS16,
    margin: 5
  }
});
var areaSeries = () => ({
  highlight: {
    markers: {
      border: {}
    }
  },
  line: {
    opacity: 1,
    width: 0
  },
  markers: {
    size: 6,
    visible: false
  },
  legendItem: areaSeriesLegendItem,
  opacity: 0.4
});
var rangeAreaSeries = () => ({
  highlight: {
    markers: {
      border: {}
    }
  },
  line: {
    opacity: 1,
    width: 0
  },
  markers: {
    size: 6,
    visible: false
  },
  legendItem: areaSeriesLegendItem,
  opacity: 0.4
});
var barSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var boxPlotSeries = () => ({
  outliersField: "",
  meanField: "",
  border: {
    _brightness: 0.8,
    width: 1
  },
  downColor: WHITE2,
  gap: 1,
  highlight: {
    border: {
      opacity: 1,
      width: 2
    },
    whiskers: {
      width: 3
    },
    mean: {
      width: 2
    },
    median: {
      width: 2
    }
  },
  mean: {
    width: 2
  },
  median: {
    width: 2
  },
  spacing: 0.3,
  whiskers: {
    width: 2
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var bubbleSeries = () => ({
  border: {
    width: 0
  },
  labels: {
    background: TRANSPARENT
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  opacity: 0.6
});
var bulletSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  target: {
    color: "#ff0000"
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var candlestickSeries = () => ({
  border: {
    _brightness: 0.8,
    width: 1
  },
  downColor: WHITE2,
  gap: 1,
  highlight: {
    border: {
      opacity: 1,
      width: 2
    },
    line: {
      width: 2
    }
  },
  line: {
    color: BLACK2,
    width: 1
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  spacing: 0.3
});
var columnSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var radarColumnSeries = () => ({
  legendItem: areaNoMarkersSeriesLegendItem
});
var polarScatterSeries = () => ({
  legendItem: lineSeriesLegendItem
});
var scatterSeries = () => ({
  legendItem: lineSeriesLegendItem
});
var donutSeries = () => ({
  margin: 1,
  legendItem: areaNoMarkersSeriesLegendItem
});
var lineSeries = () => ({
  width: 2,
  legendItem: lineSeriesLegendItem
});
var ohlcSeries = () => ({
  gap: 1,
  highlight: {
    line: {
      opacity: 1,
      width: 3
    }
  },
  line: {
    width: 1
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  spacing: 0.3
});
var radarAreaSeries = () => ({
  line: {
    opacity: 1,
    width: 0
  },
  markers: {
    size: 6,
    visible: false
  },
  legendItem: areaSeriesLegendItem,
  opacity: 0.5
});
var radarLineSeries = () => ({
  markers: {
    visible: false
  },
  legendItem: lineSeriesLegendItem,
  width: 2
});
var rangeBarSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var rangeColumnSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var scatterLineSeries = () => ({
  width: 1,
  legendItem: lineSeriesLegendItem
});
var waterfallSeries = () => ({
  gap: 0.5,
  line: {
    color: BLACK2,
    width: 1
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  spacing: BAR_SPACING
});
var pieSeries = () => ({
  labels: {
    background: "",
    color: "",
    padding: {
      top: 5,
      bottom: 5,
      left: 7,
      right: 7
    }
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var funnelSeries = () => ({
  labels: {
    background: "",
    color: "",
    padding: {
      top: 5,
      bottom: 5,
      left: 7,
      right: 7
    }
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var pyramidSeries = funnelSeries;
var heatmapSeries = () => ({
  labels: {
    color: "",
    background: TRANSPARENT,
    visible: true
  },
  highlight: {
    border: {
      width: 0
    }
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var trendlineSeriesDefaults = (options) => Object.assign({
  color: INHERIT,
  trendline: {},
  markers: {
    visible: false
  },
  width: 1,
  dashType: "longDash",
  legendItem: lineSeriesLegendItem
}, options);
var seriesDefaults = (options) => ({
  visible: true,
  labels: {
    font: SANS11
  },
  overlay: options.gradients ? {} : {
    gradient: "none"
  },
  area: areaSeries(),
  rangeArea: rangeAreaSeries(),
  verticalRangeArea: rangeAreaSeries(),
  bar: barSeries(),
  boxPlot: boxPlotSeries(),
  bubble: bubbleSeries(),
  bullet: bulletSeries(),
  candlestick: candlestickSeries(),
  column: columnSeries(),
  heatmap: heatmapSeries(),
  pie: pieSeries(),
  donut: donutSeries(),
  funnel: funnelSeries(),
  pyramid: pyramidSeries(),
  horizontalWaterfall: waterfallSeries(),
  line: lineSeries(),
  notes: notes(),
  ohlc: ohlcSeries(),
  radarArea: radarAreaSeries(),
  radarLine: radarLineSeries(),
  radarColumn: radarColumnSeries(),
  polarArea: radarAreaSeries(),
  polarLine: radarLineSeries(),
  polarScatter: polarScatterSeries(),
  rangeBar: rangeBarSeries(),
  rangeColumn: rangeColumnSeries(),
  scatter: scatterSeries(),
  scatterLine: scatterLineSeries(),
  verticalArea: areaSeries(),
  verticalBoxPlot: boxPlotSeries(),
  verticalBullet: bulletSeries(),
  verticalLine: lineSeries(),
  waterfall: waterfallSeries(),
  linearTrendline: trendlineSeriesDefaults(),
  exponentialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  logarithmicTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  polynomialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  powerTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  movingAverageTrendline: trendlineSeriesDefaults()
});
var title = () => ({
  font: SANS16
});
var subtitle = () => ({
  font: SANS12
});
var legend = () => ({
  labels: {
    font: SANS12
  }
});
var baseTheme = (options = {}) => ({
  axisDefaults: axisDefaults(),
  categoryAxis: {
    majorGridLines: {
      visible: true
    }
  },
  navigator: {
    pane: {
      height: 90,
      margin: {
        top: 10
      }
    }
  },
  seriesDefaults: seriesDefaults(options),
  title: title(),
  subtitle: subtitle(),
  legend: legend()
});

// node_modules/@progress/kendo-charts/dist/es/chart/theme/load-theme.js
var SERIES_COLORS = 30;
var seriesVar = "--kendo-chart-series-";
var elementStyles2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element);
var cache = {};
var toColor = (colorMix, element) => {
  if (cache[colorMix]) {
    return cache[colorMix];
  }
  const curColor = element.style.color;
  element.style.color = colorMix;
  const color = elementStyles2(element).color;
  element.style.color = curColor;
  cache[colorMix] = color;
  return color;
};
var getProp = (element, prop) => {
  let value2 = elementStyles2(element).getPropertyValue(prop);
  if (/^color-mix/i.test(value2)) {
    value2 = toColor(value2, element);
  }
  return value2;
};
var getNumberProp = (element, prop) => parseFloat(elementStyles2(element).getPropertyValue(prop));
var getFont = (element, weightProp, sizeProp, familyProp) => {
  const styles = elementStyles2(element);
  return [styles.getPropertyValue(weightProp), styles.getPropertyValue(sizeProp), styles.getPropertyValue(familyProp) || styles.fontFamily].join(" ");
};
var getSeriesColors = (element) => {
  const styles = elementStyles2(element);
  const result = [];
  let count = 1;
  let color = styles.getPropertyValue(`${seriesVar}${count}`);
  while (color || count <= SERIES_COLORS) {
    result.push(color);
    count++;
    color = styles.getPropertyValue(`${seriesVar}${count}`);
  }
  return result;
};
var defaultFont = (element) => getFont(element, "--kendo-font-weight", "--kendo-chart-font-size", "--kendo-font-family");
var paneTitleFont = (element) => getFont(element, "--kendo-chart-pane-title-font-weight", "--kendo-chart-pane-title-font-size", "--kendo-font-family");
var normalTextColor = (element) => getProp(element, "--kendo-chart-text");
var title2 = (element) => ({
  color: normalTextColor(element),
  font: getFont(element, "--kendo-font-weight", "--kendo-chart-title-font-size", "--kendo-font-family")
});
var sankeyLegend = (element) => {
  const textColorNormal = normalTextColor(element);
  return {
    labels: {
      color: textColorNormal,
      font: defaultFont(element)
    },
    title: {
      color: textColorNormal
    }
  };
};
var chartLegend = (element) => {
  const inactiveColor = getProp(element, "--kendo-chart-inactive");
  return Object.assign(
    {},
    { inactiveItems: {
      labels: {
        color: inactiveColor
      },
      markers: {
        color: inactiveColor
      }
    } },
    sankeyLegend(element)
  );
};
var gaugeTheme = (element) => {
  const textColorNormal = normalTextColor(element);
  return {
    pointer: {
      color: getProp(element, "--kendo-chart-gauge-pointer")
    },
    scale: {
      labels: {
        color: textColorNormal
      },
      rangePlaceholderColor: getProp(element, "--kendo-chart-gauge-track"),
      minorTicks: {
        color: textColorNormal
      },
      majorTicks: {
        color: textColorNormal
      },
      line: {
        color: textColorNormal
      }
    }
  };
};
var sankeyTheme = (element) => ({
  labels: {
    color: normalTextColor(element),
    font: defaultFont(element),
    stroke: {
      color: getProp(element, "--kendo-chart-bg")
    }
  },
  links: {
    color: getProp(element, "--kendo-color-subtle")
  },
  nodeColors: getSeriesColors(element),
  title: title2(element),
  legend: sankeyLegend(element)
});
var notes2 = (element) => ({
  icon: {
    background: getProp(element, "--kendo-chart-notes-bg"),
    border: {
      color: getProp(element, "--kendo-chart-notes-border")
    }
  },
  line: {
    color: getProp(element, "--kendo-chart-notes-lines")
  },
  label: {
    font: defaultFont(element)
  }
});
var chartTheme = (element) => {
  const majorLines = getProp(element, "--kendo-chart-major-lines");
  const normalTextColor2 = getProp(element, "--kendo-chart-text");
  const axisLabelFont = getFont(element, "--kendo-font-weight", "--kendo-chart-label-font-size", "--kendo-font-family");
  const chartBg = getProp(element, "--kendo-chart-bg");
  const notesProps = notes2(element);
  const areaOpacity = getNumberProp(element, "--kendo-chart-area-opacity");
  const surfaceColor = getProp(element, "--kendo-color-surface");
  const primaryBg = getProp(element, "--kendo-chart-primary-bg");
  const boxPlot = () => ({
    downColor: majorLines,
    mean: {
      color: surfaceColor
    },
    median: {
      color: surfaceColor
    },
    whiskers: {
      color: primaryBg
    }
  });
  const waterfall = () => ({
    line: {
      color: majorLines
    }
  });
  const area = () => ({
    opacity: areaOpacity,
    highlight: {
      inactiveOpacity: getNumberProp(element, "--kendo-chart-area-inactive-opacity")
    }
  });
  const line = () => ({
    highlight: {
      inactiveOpacity: getNumberProp(element, "--kendo-chart-line-inactive-opacity")
    }
  });
  const bullet = () => ({
    target: {
      color: normalTextColor2
    }
  });
  return {
    axisDefaults: {
      crosshair: {
        color: getProp(element, "--kendo-chart-crosshair-bg")
      },
      labels: {
        color: normalTextColor2,
        font: axisLabelFont
      },
      line: {
        color: majorLines
      },
      majorGridLines: {
        color: majorLines
      },
      minorGridLines: {
        color: getProp(element, "--kendo-chart-minor-lines")
      },
      notes: structuredClone(notesProps),
      title: {
        color: normalTextColor2,
        font: defaultFont(element)
      }
    },
    chartArea: {
      background: chartBg
    },
    legend: chartLegend(element),
    seriesColors: getSeriesColors(element),
    seriesDefaults: {
      area: area(),
      verticalArea: area(),
      radarArea: area(),
      boxPlot: boxPlot(),
      verticalBoxPlot: boxPlot(),
      bullet: bullet(),
      verticalBullet: bullet(),
      horizontalWaterfall: waterfall(),
      waterfall: waterfall(),
      line: line(),
      verticalLine: line(),
      candlestick: {
        downColor: normalTextColor2,
        line: {
          color: normalTextColor2
        }
      },
      errorBars: {
        color: getProp(element, "--kendo-chart-error-bars-bg")
      },
      icon: {
        border: {
          color: majorLines
        }
      },
      labels: {
        background: chartBg,
        color: normalTextColor2,
        font: axisLabelFont,
        opacity: areaOpacity
      },
      notes: structuredClone(notesProps)
    },
    subtitle: {
      color: normalTextColor2,
      font: paneTitleFont(element)
    },
    title: title2(element),
    paneDefaults: {
      title: {
        font: paneTitleFont(element)
      }
    }
  };
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/encoding.js
var DEFAULT_QUIET_ZONE_LENGTH = 10;
var Encoding = class extends class_default {
  constructor(options) {
    super();
    this.setOptions(options);
    this.initProperties();
  }
  initProperties() {
  }
  setOptions(options) {
    this.options = Object.assign({}, this.options, options);
    this.quietZoneLength = this.options.addQuietZone ? 2 * this.options.quietZoneLength : 0;
  }
  encode(value2, width, height) {
    const convertedValue = defined(value2) ? String(value2) : value2;
    this.initValue(convertedValue, width, height);
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    this.addData();
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    return {
      baseUnit: this.baseUnit,
      pattern: this.pattern
    };
  }
  initValue() {
  }
  addQuietZone() {
    this.pattern.push(this.options.quietZoneLength || DEFAULT_QUIET_ZONE_LENGTH);
  }
  addData() {
  }
  invalidCharacterError(character) {
    throw new Error(`Character "${character}" is not valid for symbology ${this.name}.`);
  }
};
setDefaultOptions(Encoding, {
  quietZoneLength: DEFAULT_QUIET_ZONE_LENGTH,
  addQuietZone: true,
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code11.js
var extend2 = Object.assign;
var Code11 = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend2(this, {
      name: "Code 11",
      characterMap: ["111121", "211121", "121121", "221111", "112121", "212111", "122111", "111221", "211211", "211111", "112111"],
      cCheckSumTotal: 10,
      kCheckSumTotal: 9,
      kCheckSumMinLength: 10,
      checkSumMod: 11,
      DASH_VALUE: 10,
      DASH: "-",
      START: "112211",
      STOP: "11221"
    });
  }
  initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.totalUnits = 0;
  }
  addData() {
    const value2 = this.value;
    this.addPattern(this.START);
    for (let i = 0; i < value2.length; i++) {
      this.addCharacter(value2.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  }
  setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  }
  addCheckSum() {
    const value2 = this.value;
    let length = value2.length;
    const cValue = this.getWeightedSum(value2, length, this.cCheckSumTotal) % this.checkSumMod;
    this.checksum = String(cValue);
    this.addPattern(this.characterMap[cValue]);
    length++;
    if (length >= this.kCheckSumMinLength) {
      let kValue = (cValue + this.getWeightedSum(value2, length, this.kCheckSumTotal)) % this.checkSumMod;
      this.checksum += kValue;
      this.addPattern(this.characterMap[kValue]);
    }
  }
  getWeightedSum(value2, length, total) {
    let weightedSum = 0;
    for (let i = 0; i < value2.length; i++) {
      weightedSum += this.weightedValue(this.getValue(value2.charAt(i)), length, i, total);
    }
    return weightedSum;
  }
  weightedValue(value2, length, index, total) {
    const weight = (length - index) % total || total;
    return weight * value2;
  }
  getValue(character) {
    if (!isNaN(character)) {
      return parseInt(character, 10);
    } else if (character !== this.DASH) {
      this.invalidCharacterError(character);
    }
    return this.DASH_VALUE;
  }
  addCharacter(character) {
    const value2 = this.getValue(character);
    const pattern = this.characterMap[value2];
    this.addPattern(pattern);
  }
  addPattern(pattern) {
    let value2;
    for (let i = 0; i < pattern.length; i++) {
      value2 = parseInt(pattern.charAt(i), 10);
      this.pattern.push(value2);
      this.totalUnits += value2;
    }
  }
};
setDefaultOptions(Code11, {
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39.js
var extend3 = Object.assign;
var Code39Base = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend3(this, {
      minBaseUnitLength: 0.7
    });
  }
  addData() {
    const value2 = this.value;
    this.addStart();
    for (let idx = 0; idx < value2.length; idx++) {
      this.addCharacter(value2.charAt(idx));
    }
    if (this.options.addCheckSum) {
      this.pushCheckSum();
    }
    this.addStop();
    this.prepareValues();
  }
  addCharacter(character) {
    const characterData = this.characterMap[character];
    if (!characterData) {
      this.invalidCharacterError(character);
    }
    this.addBase(characterData);
  }
  addBase() {
  }
};
var Code39 = class extends Code39Base {
  initProperties() {
    super.initProperties();
    extend3(this, {
      name: "Code 39",
      checkSumMod: 43,
      minRatio: 2.5,
      maxRatio: 3,
      gapWidth: 1,
      splitCharacter: "|",
      patternMappings: {
        "b": "1|",
        "w": "1|",
        "B": "ratio|",
        "W": "ratio|"
      },
      characterMap: {
        "0": { "pattern": "bwbWBwBwb", "value": 0 },
        "1": { "pattern": "BwbWbwbwB", "value": 1 },
        "2": { "pattern": "bwBWbwbwB", "value": 2 },
        "3": { "pattern": "BwBWbwbwb", "value": 3 },
        "4": { "pattern": "bwbWBwbwB", "value": 4 },
        "5": { "pattern": "BwbWBwbwb", "value": 5 },
        "6": { "pattern": "bwBWBwbwb", "value": 6 },
        "7": { "pattern": "bwbWbwBwB", "value": 7 },
        "8": { "pattern": "BwbWbwBwb", "value": 8 },
        "9": { "pattern": "bwBWbwBwb", "value": 9 },
        "A": { "pattern": "BwbwbWbwB", "value": 10 },
        "B": { "pattern": "bwBwbWbwB", "value": 11 },
        "C": { "pattern": "BwBwbWbwb", "value": 12 },
        "D": { "pattern": "bwbwBWbwB", "value": 13 },
        "E": { "pattern": "BwbwBWbwb", "value": 14 },
        "F": { "pattern": "bwBwBWbwb", "value": 15 },
        "G": { "pattern": "bwbwbWBwB", "value": 16 },
        "H": { "pattern": "BwbwbWBwb", "value": 17 },
        "I": { "pattern": "bwBwbWBwb", "value": 18 },
        "J": { "pattern": "bwbwBWBwb", "value": 19 },
        "K": { "pattern": "BwbwbwbWB", "value": 20 },
        "L": { "pattern": "bwBwbwbWB", "value": 21 },
        "M": { "pattern": "BwBwbwbWb", "value": 22 },
        "N": { "pattern": "bwbwBwbWB", "value": 23 },
        "O": { "pattern": "BwbwBwbWb", "value": 24 },
        "P": { "pattern": "bwBwBwbWb", "value": 25 },
        "Q": { "pattern": "bwbwbwBWB", "value": 26 },
        "R": { "pattern": "BwbwbwBWb", "value": 27 },
        "S": { "pattern": "bwBwbwBWb", "value": 28 },
        "T": { "pattern": "bwbwBwBWb", "value": 29 },
        "U": { "pattern": "BWbwbwbwB", "value": 30 },
        "V": { "pattern": "bWBwbwbwB", "value": 31 },
        "W": { "pattern": "BWBwbwbwb", "value": 32 },
        "X": { "pattern": "bWbwBwbwB", "value": 33 },
        "Y": { "pattern": "BWbwBwbwb", "value": 34 },
        "Z": { "pattern": "bWBwBwbwb", "value": 35 },
        "-": { "pattern": "bWbwbwBwB", "value": 36 },
        ".": { "pattern": "BWbwbwBwb", "value": 37 },
        " ": { "pattern": "bWBwbwBwb", "value": 38 },
        "$": { "pattern": "bWbWbWbwb", "value": 39 },
        "/": { "pattern": "bWbWbwbWb", "value": 40 },
        "+": { "pattern": "bWbwbWbWb", "value": 41 },
        "%": { "pattern": "bwbWbWbWb", "value": 42 },
        START: { pattern: "bWbwBwBwb" }
      }
    });
  }
  initValue(value2, width, height) {
    this.width = width;
    this.height = height;
    this.value = value2;
    this.dataLength = value2.length;
    this.pattern = [];
    this.patternString = "";
  }
  prepareValues() {
    const minBaseUnit = this.minBaseUnitLength;
    const minRatio = this.minRatio;
    const minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    let baseUnit;
    let ratio = this.maxRatio;
    if (this.height < minHeight) {
      throw new Error(`Insufficient height for Code39 encoding: the current height is ${this.height}px and the minimum height is ${minHeight}px.`);
    }
    baseUnit = this.getBaseUnit(ratio);
    while (baseUnit < minBaseUnit && ratio > minRatio) {
      ratio = parseFloat((ratio - 0.1).toFixed(1));
      baseUnit = this.getBaseUnit(ratio);
    }
    if (baseUnit < minBaseUnit) {
      let minWidth = Math.ceil(this.getBaseWidth(minRatio) * minBaseUnit);
      throw new Error(`Insufficient width for Code39 encoding: the current width is ${this.width}px and the minimum width for value "${this.value}" is ${minWidth}px.`);
    }
    this.ratio = ratio;
    this.baseUnit = baseUnit;
    this.patternString = this.patternString.substring(0, this.patternString.length - 1);
    this.pattern = this.pattern.concat(this.patternString.replace(/ratio/g, ratio).split(this.splitCharacter));
  }
  getBaseUnit(ratio) {
    return this.width / this.getBaseWidth(ratio);
  }
  getBaseWidth(ratio) {
    const characterLength = 3 * (ratio + 2);
    return this.quietZoneLength + characterLength * (this.dataLength + 2) + this.gapWidth * (this.dataLength + 1);
  }
  addStart() {
    this.addPattern(this.characterMap.START.pattern);
    this.addCharacterGap();
  }
  addBase(character) {
    this.addPattern(character.pattern);
    this.addCharacterGap();
  }
  addStop() {
    this.addPattern(this.characterMap.START.pattern);
  }
  addPattern(pattern) {
    for (let i = 0; i < pattern.length; i++) {
      this.patternString += this.patternMappings[pattern.charAt(i)];
    }
  }
  addCharacterGap() {
    this.patternString += this.gapWidth + this.splitCharacter;
  }
};
setDefaultOptions(Code39, {
  addCheckSum: false
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39-extended.js
var Code39ExtendedBase = {
  addCharacter(character) {
    if (this.characterMap[character]) {
      this.addBase(this.characterMap[character]);
    } else if (character.charCodeAt(0) > 127) {
      this.invalidCharacterError(character);
    } else {
      this.addExtended(character.charCodeAt(0));
    }
  },
  addExtended(code) {
    let patterns;
    for (let i = 0; i < this.extendedMappings.length; i++) {
      patterns = this.extendedMappings[i].call(this, code);
      if (patterns) {
        for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
          const pattern = patterns[patternIndex];
          this.addBase(pattern);
        }
        this.dataLength += patterns.length - 1;
        return;
      }
    }
  },
  extendedMappings: [
    function(code) {
      if (97 <= code && code <= 122) {
        return [this.characterMap[this.shiftCharacters[0]], this.characterMap[String.fromCharCode(code - 32)]];
      }
    },
    function(code) {
      if (33 <= code && code <= 58) {
        return [this.characterMap[this.shiftCharacters[1]], this.characterMap[String.fromCharCode(code + 32)]];
      }
    },
    function(code) {
      if (1 <= code && code <= 26) {
        return [this.characterMap[this.shiftCharacters[2]], this.characterMap[String.fromCharCode(code + 64)]];
      }
    },
    function(code) {
      let result;
      let dataCharacter;
      if (!this.specialAsciiCodes[code]) {
        dataCharacter = Math.floor(code / 32) * 6 + (code - 27) % 32 + 64;
        result = [this.characterMap[this.shiftCharacters[3]], this.characterMap[String.fromCharCode(dataCharacter)]];
      } else {
        result = [];
        for (let i = 0; i < this.specialAsciiCodes[code].length; i++) {
          result.push(this.characterMap[this.shiftCharacters[3]]);
          result.push(this.characterMap[this.specialAsciiCodes[code][i]]);
        }
      }
      return result;
    }
  ],
  specialAsciiCodes: {
    "0": ["U"],
    "64": ["V"],
    "96": ["W"],
    "127": ["T", "X", "Y", "Z"]
  },
  shiftValuesAsciiCodes: {
    "39": 36,
    "40": 47,
    "41": 43,
    "42": 37
  },
  characterMap: {
    "+": false,
    "/": false,
    "$": false,
    "%": false
  },
  shiftCharacters: ["SHIFT0", "SHIFT1", "SHIFT2", "SHIFT3"]
};
var Code39Extended = class extends Code39 {
  initProperties() {
    super.initProperties();
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 39 extended",
      characterMap: {
        SHIFT0: { "pattern": "bWbwbWbWb", "value": 41 },
        SHIFT1: { "pattern": "bWbWbwbWb", "value": 40 },
        SHIFT2: { "pattern": "bWbWbWbwb", "value": 39 },
        SHIFT3: { "pattern": "bwbWbWbWb", "value": 42 }
      }
    });
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93.js
var extend4 = Object.assign;
var Code93 = class extends Code39Base {
  initProperties() {
    super.initProperties();
    extend4(this, {
      name: "Code 93",
      cCheckSumTotal: 20,
      kCheckSumTotal: 15,
      checkSumMod: 47,
      characterMap: {
        "0": { "pattern": "131112", "value": 0 },
        "1": { "pattern": "111213", "value": 1 },
        "2": { "pattern": "111312", "value": 2 },
        "3": { "pattern": "111411", "value": 3 },
        "4": { "pattern": "121113", "value": 4 },
        "5": { "pattern": "121212", "value": 5 },
        "6": { "pattern": "121311", "value": 6 },
        "7": { "pattern": "111114", "value": 7 },
        "8": { "pattern": "131211", "value": 8 },
        "9": { "pattern": "141111", "value": 9 },
        "A": { "pattern": "211113", "value": 10 },
        "B": { "pattern": "211212", "value": 11 },
        "C": { "pattern": "211311", "value": 12 },
        "D": { "pattern": "221112", "value": 13 },
        "E": { "pattern": "221211", "value": 14 },
        "F": { "pattern": "231111", "value": 15 },
        "G": { "pattern": "112113", "value": 16 },
        "H": { "pattern": "112212", "value": 17 },
        "I": { "pattern": "112311", "value": 18 },
        "J": { "pattern": "122112", "value": 19 },
        "K": { "pattern": "132111", "value": 20 },
        "L": { "pattern": "111123", "value": 21 },
        "M": { "pattern": "111222", "value": 22 },
        "N": { "pattern": "111321", "value": 23 },
        "O": { "pattern": "121122", "value": 24 },
        "P": { "pattern": "131121", "value": 25 },
        "Q": { "pattern": "212112", "value": 26 },
        "R": { "pattern": "212211", "value": 27 },
        "S": { "pattern": "211122", "value": 28 },
        "T": { "pattern": "211221", "value": 29 },
        "U": { "pattern": "221121", "value": 30 },
        "V": { "pattern": "222111", "value": 31 },
        "W": { "pattern": "112122", "value": 32 },
        "X": { "pattern": "112221", "value": 33 },
        "Y": { "pattern": "122121", "value": 34 },
        "Z": { "pattern": "123111", "value": 35 },
        "-": { "pattern": "121131", "value": 36 },
        ".": { "pattern": "311112", "value": 37 },
        " ": { "pattern": "311211", "value": 38 },
        "$": { "pattern": "321111", "value": 39 },
        "/": { "pattern": "112131", "value": 40 },
        "+": { "pattern": "113121", "value": 41 },
        "%": { "pattern": "211131", "value": 42 },
        SHIFT0: { "pattern": "122211", "value": 46 },
        SHIFT1: { "pattern": "311121", "value": 45 },
        SHIFT2: { "pattern": "121221", "value": 43 },
        SHIFT3: { "pattern": "312111", "value": 44 },
        START: { "pattern": "111141" },
        TERMINATION_BAR: "1"
      }
    });
  }
  initValue(value2, width, height) {
    this.value = value2;
    this.width = width;
    this.height = height;
    this.pattern = [];
    this.values = [];
    this.dataLength = value2.length;
  }
  prepareValues() {
    let minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    if (this.height < minHeight) {
      throw new Error(`Insufficient height for Code93 encoding: the current height is ${this.height}px, the minimum required height is ${minHeight}px.`);
    }
    this.setBaseUnit();
    if (this.baseUnit < this.minBaseUnitLength) {
      const minWidth = Math.ceil(this.minBaseUnitLength * (this.width / this.baseUnit));
      throw new Error(`Insufficient width for Code93 encoding: the current width is ${this.width}px and the minimum required width for value "${this.value}" is ${minWidth}px.`);
    }
  }
  setBaseUnit() {
    const checkSumLength = 2;
    this.baseUnit = this.width / (9 * (this.dataLength + 2 + checkSumLength) + this.quietZoneLength + 1);
  }
  addStart() {
    let pattern = this.characterMap.START.pattern;
    this.addPattern(pattern);
  }
  addStop() {
    this.addStart();
    this.pattern.push(this.characterMap.TERMINATION_BAR);
  }
  addBase(charData) {
    this.addPattern(charData.pattern);
    this.values.push(charData.value);
  }
  pushCheckSum() {
    const checkValues = this._getCheckValues();
    let charData;
    this.checksum = checkValues.join("");
    for (let i = 0; i < checkValues.length; i++) {
      charData = this.characterMap[this._findCharacterByValue(checkValues[i])];
      this.addPattern(charData.pattern);
    }
  }
  _getCheckValues() {
    const values = this.values;
    const length = values.length;
    let wightedSum = 0;
    let cValue;
    let kValue;
    let idx;
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this.weightedValue(values[idx], length - idx, this.cCheckSumTotal);
    }
    cValue = wightedSum % this.checkSumMod;
    wightedSum = this.weightedValue(cValue, 1, this.kCheckSumTotal);
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this.weightedValue(values[idx], length - idx + 1, this.kCheckSumTotal);
    }
    kValue = wightedSum % this.checkSumMod;
    return [cValue, kValue];
  }
  _findCharacterByValue(value2) {
    for (let character in this.characterMap) {
      if (this.characterMap[character].value === value2) {
        return character;
      }
    }
  }
  weightedValue(value2, index, total) {
    return (index % total || total) * value2;
  }
  addPattern(pattern) {
    let value2;
    for (let i = 0; i < pattern.length; i++) {
      value2 = parseInt(pattern.charAt(i), 10);
      this.pattern.push(value2);
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93-extended.js
var Code93Extended = class extends Code93 {
  initProperties() {
    super.initProperties();
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 93 extended",
      pushCheckSum: function() {
        const checkValues = this._getCheckValues();
        let value2;
        this.checksum = checkValues.join("");
        for (let i = 0; i < checkValues.length; i++) {
          value2 = checkValues[i];
          if (this.shiftValuesAsciiCodes[value2]) {
            this.addExtended(this.shiftValuesAsciiCodes[value2]);
          } else {
            const characterByValue = this._findCharacterByValue(value2);
            this.addPattern(this.characterMap[characterByValue].pattern);
          }
        }
      }
    });
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/postnet.js
var numberRegex = /^\d+$/;
var extend5 = Object.assign;
var Postnet = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend5(this, {
      name: "Postnet",
      START: "2",
      VALID_CODE_LENGTHS: [5, 9, 11],
      DIGIT_SEPARATOR: "-",
      characterMap: ["22111", "11122", "11212", "11221", "12112", "12121", "12211", "21112", "21121", "21211"]
    });
  }
  initValue(value2, width, height) {
    this.height = height;
    this.width = width;
    this.baseHeight = height / 2;
    this.value = value2.replace(new RegExp(this.DIGIT_SEPARATOR, "g"), "");
    this.pattern = [];
    this.validate(this.value);
    this.checkSum = 0;
    this.setBaseUnit();
  }
  addData() {
    const value2 = this.value;
    this.addPattern(this.START);
    for (let i = 0; i < value2.length; i++) {
      this.addCharacter(value2.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.START);
    this.pattern.pop();
  }
  addCharacter(character) {
    const pattern = this.characterMap[character];
    this.checkSum += parseInt(character, 10);
    this.addPattern(pattern);
  }
  addCheckSum() {
    this.checksum = (10 - this.checkSum % 10) % 10;
    this.addCharacter(this.checksum);
  }
  setBaseUnit() {
    const startStopLength = 3;
    this.baseUnit = this.width / ((this.value.length + 1) * 10 + startStopLength + this.quietZoneLength);
  }
  validate(value2) {
    if (!numberRegex.test(value2)) {
      this.invalidCharacterError(value2.match(/[^0-9]/)[0]);
    }
    if (!inArray(value2.length, this.VALID_CODE_LENGTHS)) {
      throw new Error("Invalid value length. Valid lengths for the Postnet symbology are " + this.VALID_CODE_LENGTHS.join(",") + ".");
    }
  }
  addPattern(pattern) {
    let y1;
    for (let i = 0; i < pattern.length; i++) {
      y1 = this.height - this.baseHeight * pattern.charAt(i);
      this.pattern.push({ width: 1, y1, y2: this.height });
      this.pattern.push(1);
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code128.js
var numberRegex2 = /^\d+$/;
var alphanumericRegex = /^[a-z0-9]+$/i;
var extend6 = Object.assign;
var State128 = class extends class_default {
  constructor(encoding) {
    super();
    this.encoding = encoding;
    this.initProperties();
  }
  initProperties() {
  }
  addStart() {
  }
  is() {
  }
  isCode() {
    return false;
  }
  move() {
  }
  pushState() {
  }
};
var State128AB = class extends State128 {
  constructor(encoding, states) {
    super(encoding);
    this.states = states;
    this._initMoves(states);
  }
  initProperties() {
    super.initProperties();
    deepExtend(this, {
      FNC4: "FNC4",
      SHIFT: 98
    });
  }
  addStart() {
    this.encoding.addPattern(this.START);
  }
  is(value2, index) {
    let code = value2.charCodeAt(index);
    return this.isCode(code);
  }
  move(encodingState) {
    let idx = 0;
    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {
      idx++;
    }
  }
  pushState(encodingState) {
    let states = this.states, value2 = encodingState.value, maxLength = value2.length, code;
    if (inArray("C", states)) {
      let numberMatch = value2.substr(encodingState.index).match(/\d{4,}/g);
      if (numberMatch) {
        maxLength = value2.indexOf(numberMatch[0], encodingState.index);
      }
    }
    while ((code = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code) && encodingState.index < maxLength) {
      this.encoding.addPattern(this.getValue(code));
      encodingState.index++;
    }
  }
  _initMoves(states) {
    this._moves = [];
    if (inArray(this.FNC4, states)) {
      this._moves.push(this._moveFNC);
    }
    if (inArray(this.shiftKey, states)) {
      this._moves.push(this._shiftState);
    }
    this._moves.push(this._moveState);
  }
  _moveFNC(encodingState) {
    if (encodingState.fnc) {
      encodingState.fnc = false;
      return encodingState.previousState === this.key;
    }
  }
  _shiftState(encodingState) {
    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {
      this.encoding.addPattern(this.SHIFT);
      encodingState.shifted = true;
      return true;
    }
  }
  _moveState() {
    this.encoding.addPattern(this.MOVE);
    return true;
  }
};
var states128 = {};
states128.A = class State128A extends State128AB {
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "A",
      shiftKey: "B",
      MOVE: 101,
      START: 103
    });
  }
  isCode(code) {
    return 0 <= code && code < 96;
  }
  getValue(code) {
    if (code < 32) {
      return code + 64;
    }
    return code - 32;
  }
};
states128.B = class State128B extends State128AB {
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "B",
      shiftKey: "A",
      MOVE: 100,
      START: 104
    });
  }
  isCode(code) {
    return 32 <= code && code < 128;
  }
  getValue(code) {
    return code - 32;
  }
};
states128.C = class State128C extends State128 {
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "C",
      MOVE: 99,
      START: 105
    });
  }
  addStart() {
    this.encoding.addPattern(this.START);
  }
  is(value2, index) {
    let next4 = getSubstring(value2, index, 4);
    return (index + 4 <= value2.length || value2.length === 2) && numberRegex2.test(next4);
  }
  move() {
    this.encoding.addPattern(this.MOVE);
  }
  pushState(encodingState) {
    let code;
    while ((code = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex2.test(code) && code.length === 2) {
      this.encoding.addPattern(parseInt(code, 10));
      encodingState.index += 2;
    }
  }
  getValue(code) {
    return code;
  }
};
states128.FNC4 = class State128FNC4 extends State128 {
  constructor(encoding, states) {
    super(encoding);
    this._initSubStates(states);
  }
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "FNC4",
      dependentStates: ["A", "B"]
    });
  }
  addStart(encodingState) {
    let code = encodingState.value.charCodeAt(0) - 128, subState = this._getSubState(code);
    this.encoding[subState].addStart();
  }
  is(value2, index) {
    let code = value2.charCodeAt(index);
    return this.isCode(code);
  }
  isCode(code) {
    return 128 <= code && code < 256;
  }
  pushState(encodingState) {
    let subState = this._initSubState(encodingState), encoding = this.encoding, length = subState.value.length;
    let code;
    encodingState.index += length;
    if (length < 3) {
      for (; subState.index < length; subState.index++) {
        code = subState.value.charCodeAt(subState.index);
        subState.state = this._getSubState(code);
        if (subState.previousState !== subState.state) {
          subState.previousState = subState.state;
          encoding[subState.state].move(subState);
        }
        encoding.addPattern(encoding[subState.state].MOVE);
        encoding.addPattern(encoding[subState.state].getValue(code));
      }
    } else {
      if (subState.state !== subState.previousState) {
        encoding[subState.state].move(subState);
      }
      this._pushStart(subState);
      encoding.pushData(subState, this.subStates);
      if (encodingState.index < encodingState.value.length) {
        this._pushStart(subState);
      }
    }
    encodingState.fnc = true;
    encodingState.state = subState.state;
  }
  _pushStart(subState) {
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
  }
  _initSubState(encodingState) {
    const subState = {
      value: this._getAll(encodingState.value, encodingState.index),
      index: 0
    };
    subState.state = this._getSubState(subState.value.charCodeAt(0));
    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;
    return subState;
  }
  _initSubStates(states) {
    this.subStates = [];
    for (let i = 0; i < states.length; i++) {
      if (inArray(states[i], this.dependentStates)) {
        this.subStates.push(states[i]);
      }
    }
  }
  _getSubState(code) {
    for (let i = 0; i < this.subStates.length; i++) {
      if (this.encoding[this.subStates[i]].isCode(code)) {
        return this.subStates[i];
      }
    }
  }
  _getAll(value2, index) {
    let code;
    let result = "";
    let i = index;
    while ((code = value2.charCodeAt(i++)) && this.isCode(code)) {
      result += String.fromCharCode(code - 128);
    }
    return result;
  }
};
states128.FNC1 = class States128FNC1 extends State128 {
  constructor(encoding, states) {
    super(encoding);
    this.states = states;
  }
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "FNC1",
      startState: "C",
      startAI: "(",
      endAI: ")",
      dependentStates: ["C", "B"],
      applicationIdentifiers: {
        "22": { max: 29, type: "alphanumeric" },
        "402": { length: 17 },
        "7004": { max: 4, type: "alphanumeric" },
        "242": { max: 6, type: "alphanumeric" },
        "8020": { max: 25, type: "alphanumeric" },
        "703": { min: 3, max: 30, type: "alphanumeric" },
        "8008": { min: 8, max: 12, type: "alphanumeric" },
        "253": { min: 13, max: 17, type: "alphanumeric" },
        "8003": { min: 14, max: 30, type: "alphanumeric" },
        multiKey: [{
          ids: ["15", "17", "8005", "8100"],
          ranges: [
            [11, 13],
            [310, 316],
            [320, 336],
            [340, 369]
          ],
          type: { length: 6 }
        }, {
          ids: ["240", "241", "250", "251", "400", "401", "403", "7002", "8004", "8007", "8110"],
          ranges: [[90 - 99]],
          type: { max: 30, type: "alphanumeric" }
        }, {
          ids: ["7001"],
          ranges: [[410, 414]],
          type: { length: 13 }
        }, {
          ids: ["10", "21", "254", "420", "8002"],
          type: { max: 20, type: "alphanumeric" }
        }, {
          ids: ["00", "8006", "8017", "8018"],
          type: { length: 18 }
        }, {
          ids: ["01", "02", "8001"],
          type: { length: 14 }
        }, {
          ids: ["422"],
          ranges: [
            [424, 426]
          ],
          type: { length: 3 }
        }, {
          ids: ["20", "8102"],
          type: { length: 2 }
        }, {
          ids: ["30", "37"],
          type: { max: 8, type: "alphanumeric" }
        }, {
          ids: ["390", "392"],
          type: { max: 15, type: "alphanumeric" }
        }, {
          ids: ["421", "423"],
          type: { min: 3, max: 15, type: "alphanumeric" }
        }, {
          ids: ["391", "393"],
          type: { min: 3, max: 18, type: "alphanumeric" }
        }, {
          ids: ["7003", "8101"],
          type: { length: 10 }
        }]
      },
      START: 102
    });
  }
  addStart() {
    this.encoding[this.startState].addStart();
  }
  is() {
    return inArray(this.key, this.states);
  }
  pushState(encodingState) {
    let encoding = this.encoding, value2 = encodingState.value.replace(/\s/g, ""), regexSeparators = new RegExp("[" + this.startAI + this.endAI + "]", "g"), index = encodingState.index, subState = {
      state: this.startState
    }, current4, nextStart, separatorLength;
    encoding.addPattern(this.START);
    const trueCondition = true;
    while (trueCondition) {
      subState.index = 0;
      separatorLength = value2.charAt(index) === this.startAI ? 2 : 0;
      current4 = separatorLength > 0 ? this.getBySeparator(value2, index) : this.getByLength(value2, index);
      if (current4.ai.length) {
        nextStart = index + separatorLength + current4.id.length + current4.ai.length;
      } else {
        nextStart = value2.indexOf(this.startAI, index + 1);
        if (nextStart < 0) {
          if (index + current4.ai.max + current4.id.length + separatorLength < value2.length) {
            throw new Error("Separators are required after variable length identifiers");
          }
          nextStart = value2.length;
        }
      }
      subState.value = value2.substring(index, nextStart).replace(regexSeparators, "");
      this.validate(current4, subState.value);
      encoding.pushData(subState, this.dependentStates);
      if (nextStart >= value2.length) {
        break;
      }
      index = nextStart;
      if (subState.state !== this.startState) {
        encoding[this.startState].move(subState);
        subState.state = this.startState;
      }
      if (!current4.ai.length) {
        encoding.addPattern(this.START);
      }
    }
    encodingState.index = encodingState.value.length;
  }
  validate(current4, value2) {
    let code = value2.substr(current4.id.length), ai = current4.ai;
    if (!ai.type && !numberRegex2.test(code)) {
      throw new Error("Application identifier " + current4.id + " is numeric only but contains non numeric character(s).");
    }
    if (ai.type === "alphanumeric" && !alphanumericRegex.test(code)) {
      throw new Error("Application identifier " + current4.id + " is alphanumeric only but contains non alphanumeric character(s).");
    }
    if (ai.length && ai.length !== code.length) {
      throw new Error("Application identifier " + current4.id + " must be " + ai.length + " characters long.");
    }
    if (ai.min && ai.min > code.length) {
      throw new Error("Application identifier " + current4.id + " must be at least " + ai.min + " characters long.");
    }
    if (ai.max && ai.max < code.length) {
      throw new Error("Application identifier " + current4.id + " must be at most " + ai.max + " characters long.");
    }
  }
  getByLength(value2, index) {
    let id;
    let applicationIdentifier;
    for (let i = 2; i <= 4; i++) {
      id = getSubstring(value2, index, i);
      applicationIdentifier = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substring(0, id.length - 1));
      if (applicationIdentifier) {
        return {
          id,
          ai: applicationIdentifier
        };
      }
    }
    this.unsupportedAIError(id);
  }
  unsupportedAIError(id) {
    throw new Error("'" + id + "' is not a supported Application Identifier");
  }
  getBySeparator(value2, index) {
    let start = value2.indexOf(this.startAI, index), end = value2.indexOf(this.endAI, start), id = value2.substring(start + 1, end), ai = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substr(id.length - 1));
    if (!ai) {
      this.unsupportedAIError(id);
    }
    return {
      ai,
      id
    };
  }
  getApplicationIdentifier(id) {
    let applicationIdentifier = this.applicationIdentifiers, multiKey = applicationIdentifier.multiKey;
    if (applicationIdentifier[id]) {
      return applicationIdentifier[id];
    }
    for (let i = 0; i < multiKey.length; i++) {
      if (multiKey[i].ids && inArray(id, multiKey[i].ids)) {
        return multiKey[i].type;
      } else if (multiKey[i].ranges) {
        let ranges = multiKey[i].ranges;
        for (let j = 0; j < ranges.length; j++) {
          if (ranges[j][0] <= id && id <= ranges[j][1]) {
            return multiKey[i].type;
          }
        }
      }
    }
  }
};
var Code128Base = class extends Encoding {
  constructor(options) {
    super(options);
    this._initStates();
  }
  initProperties() {
    super.initProperties();
    extend6(this, {
      characterMap: [
        212222,
        222122,
        222221,
        121223,
        121322,
        131222,
        122213,
        122312,
        132212,
        221213,
        221312,
        231212,
        112232,
        122132,
        122231,
        113222,
        123122,
        123221,
        223211,
        221132,
        221231,
        213212,
        223112,
        312131,
        311222,
        321122,
        321221,
        312212,
        322112,
        322211,
        212123,
        212321,
        232121,
        111323,
        131123,
        131321,
        112313,
        132113,
        132311,
        211313,
        231113,
        231311,
        112133,
        112331,
        132131,
        113123,
        113321,
        133121,
        313121,
        211331,
        231131,
        213113,
        213311,
        213131,
        311123,
        311321,
        331121,
        312113,
        312311,
        332111,
        314111,
        221411,
        431111,
        111224,
        111422,
        121124,
        121421,
        141122,
        141221,
        112214,
        112412,
        122114,
        122411,
        142112,
        142211,
        241211,
        221114,
        413111,
        241112,
        134111,
        111242,
        121142,
        121241,
        114212,
        124112,
        124211,
        411212,
        421112,
        421211,
        212141,
        214121,
        412121,
        111143,
        111341,
        131141,
        114113,
        114311,
        411113,
        411311,
        113141,
        114131,
        311141,
        411131,
        211412,
        211214,
        211232,
        2331112
      ],
      STOP: 106
    });
  }
  _initStates() {
    for (let i = 0; i < this.states.length; i++) {
      this[this.states[i]] = new states128[this.states[i]](this, this.states);
    }
  }
  initValue(value2, width, height) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.height = height;
    this.checkSum = 0;
    this.totalUnits = 0;
    this.index = 0;
    this.position = 1;
  }
  addData() {
    let encodingState = {
      value: this.value,
      index: 0,
      state: ""
    };
    if (this.value.length === 0) {
      return;
    }
    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);
    this.addStart(encodingState);
    this.pushData(encodingState, this.states);
    this.addCheckSum();
    this.addStop();
    this.setBaseUnit();
  }
  pushData(encodingState, states) {
    const trueCondition = true;
    while (trueCondition) {
      this[encodingState.state].pushState(encodingState);
      if (encodingState.index >= encodingState.value.length) {
        break;
      }
      if (!encodingState.shifted) {
        encodingState.previousState = encodingState.state;
        encodingState.state = this.getNextState(encodingState, states);
        this[encodingState.state].move(encodingState);
      } else {
        let temp = encodingState.state;
        encodingState.state = encodingState.previousState;
        encodingState.previousState = temp;
        encodingState.shifted = false;
      }
    }
  }
  addStart(encodingState) {
    this[encodingState.state].addStart(encodingState);
    this.position = 1;
  }
  addCheckSum() {
    this.checksum = this.checkSum % 103;
    this.addPattern(this.checksum);
  }
  addStop() {
    this.addPattern(this.STOP);
  }
  setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  }
  addPattern(code) {
    const pattern = this.characterMap[code].toString();
    let value2;
    for (let i = 0; i < pattern.length; i++) {
      value2 = parseInt(pattern.charAt(i), 10);
      this.pattern.push(value2);
      this.totalUnits += value2;
    }
    this.checkSum += code * this.position++;
  }
  getNextState(encodingState, states) {
    for (let i = 0; i < states.length; i++) {
      if (this[states[i]].is(encodingState.value, encodingState.index)) {
        return states[i];
      }
    }
    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));
  }
};
var Code128a = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128 A",
      states: ["A"]
    });
  }
};
var Code128b = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128 B",
      states: ["B"]
    });
  }
};
var Code128c = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128 C",
      states: ["C"]
    });
  }
};
var Code128 = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128",
      states: ["C", "B", "A", "FNC4"]
    });
  }
};
var CodeGS1128 = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code GS1-128",
      states: ["FNC1", "C", "B"]
    });
  }
};
function getSubstring(value2, index, count) {
  return value2.substring(index, index + count);
}

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/msi.js
var extend7 = Object.assign;
var MsiBase = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend7(this, {
      characterMap: [
        "12121212",
        "12121221",
        "12122112",
        "12122121",
        "12211212",
        "12211221",
        "12212112",
        "12212121",
        "21121212",
        "21121221"
      ],
      START: "21",
      STOP: "121",
      checkSumType: "",
      checkSums
    });
  }
  initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.checkSumLength = 0;
    this.width = width;
  }
  setBaseUnit() {
    const startStopLength = 7;
    this.baseUnit = this.width / (12 * (this.value.length + this.checkSumLength) + this.quietZoneLength + startStopLength);
  }
  addData() {
    const value2 = this.value;
    this.addPattern(this.START);
    for (let i = 0; i < value2.length; i++) {
      this.addCharacter(value2.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  }
  addCharacter(character) {
    const pattern = this.characterMap[character];
    if (!pattern) {
      this.invalidCharacterError(character);
    }
    this.addPattern(pattern);
  }
  addPattern(pattern) {
    for (let i = 0; i < pattern.length; i++) {
      this.pattern.push(parseInt(pattern.charAt(i), 10));
    }
  }
  addCheckSum() {
    const checkSumFunction = this.checkSums[this.checkSumType];
    const checkValues = checkSumFunction.call(this.checkSums, this.value);
    this.checksum = checkValues.join("");
    for (let i = 0; i < checkValues.length; i++) {
      this.checkSumLength++;
      this.addPattern(this.characterMap[checkValues[i]]);
    }
  }
};
var MsiMod10 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo10",
      checkSumType: "Modulo10"
    });
  }
};
var MsiMod11 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo11",
      checkSumType: "Modulo11"
    });
  }
};
var MsiMod1010 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo10 Modulo10",
      checkSumType: "Modulo10Modulo10"
    });
  }
};
var MsiMod1110 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo11 Modulo10",
      checkSumType: "Modulo11Modulo10"
    });
  }
};
var checkSums = {
  Modulo10(value2) {
    let checkValues = [0, ""], odd = value2.length % 2, idx, evenSum, oddSum;
    for (idx = 0; idx < value2.length; idx++) {
      checkValues[(idx + odd) % 2] += parseInt(value2.charAt(idx), 10);
    }
    oddSum = checkValues[0];
    evenSum = (checkValues[1] * 2).toString();
    for (idx = 0; idx < evenSum.length; idx++) {
      oddSum += parseInt(evenSum.charAt(idx), 10);
    }
    return [(10 - oddSum % 10) % 10];
  },
  Modulo11(value2) {
    let weightedSum = 0, mod = 11, length = value2.length, weight, checkValue;
    for (let i = 0; i < length; i++) {
      weight = ((length - i) % 6 || 6) + 1;
      weightedSum += weight * value2.charAt(i);
    }
    checkValue = (mod - weightedSum % mod) % mod;
    if (checkValue !== 10) {
      return [checkValue];
    }
    return [1, 0];
  },
  Modulo11Modulo10(value2) {
    let checkValues = this.Modulo11(value2), mod11Value;
    mod11Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod11Value));
  },
  Modulo10Modulo10(value2) {
    let checkValues = this.Modulo10(value2), mod10Value;
    mod10Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod10Value));
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean13.js
var extend8 = Object.assign;
var Ean13 = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend8(this, {
      name: "EAN 13",
      keyTable: [
        "000000",
        "001011",
        "001101",
        "001110",
        "010011",
        "011001",
        "011100",
        "010101",
        "010110",
        "011010"
      ],
      characterMap: {
        digits: [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2]
        ],
        start: [1, 1, 1],
        middle: [1, 1, 1, 1, 1]
      }
    });
  }
  initValue(value2, width, height) {
    const valueAsString = String(value2);
    if (valueAsString.length !== 12 || /\D/.test(valueAsString)) {
      throw new Error('The value of the "EAN13" encoding should be 12 symbols');
    }
    this.pattern = [];
    this.options.height = height;
    this.baseUnit = width / (95 + this.quietZoneLength);
    this.value = valueAsString;
    this.checksum = this.calculateChecksum();
    this.leftKey = valueAsString[0];
    this.leftPart = valueAsString.substr(1, 6);
    this.rightPart = valueAsString.substr(7) + this.checksum;
  }
  addData() {
    this.addPieces(this.characterMap.start);
    this.addSide(this.leftPart, this.leftKey);
    this.addPieces(this.characterMap.middle);
    this.addSide(this.rightPart);
    this.addPieces(this.characterMap.start);
  }
  addSide(leftPart, key) {
    for (let i = 0; i < leftPart.length; i++) {
      if (key && parseInt(this.keyTable[key].charAt(i), 10)) {
        this.addPieces(Array.prototype.slice.call(this.characterMap.digits[leftPart.charAt(i)]).reverse(), true);
      } else {
        this.addPieces(this.characterMap.digits[leftPart.charAt(i)], true);
      }
    }
  }
  addPieces(arrToAdd, limitedHeight) {
    for (let i = 0; i < arrToAdd.length; i++) {
      if (limitedHeight) {
        this.pattern.push({
          y1: 0,
          y2: this.options.height * 0.95,
          width: arrToAdd[i]
        });
      } else {
        this.pattern.push(arrToAdd[i]);
      }
    }
  }
  calculateChecksum() {
    let odd = 0, even = 0, value2 = this.value.split("").reverse().join("");
    for (let i = 0; i < value2.length; i++) {
      if (i % 2) {
        even += parseInt(value2.charAt(i), 10);
      } else {
        odd += parseInt(value2.charAt(i), 10);
      }
    }
    let checksum = (10 - (3 * odd + even) % 10) % 10;
    return checksum;
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean8.js
var extend9 = Object.assign;
var Ean8 = class extends Ean13 {
  initProperties() {
    super.initProperties();
    extend9(this, {
      name: "EAN 8"
    });
  }
  initValue(value2, width, height) {
    if (value2.length !== 7 || /\D/.test(value2)) {
      throw new Error("Invalid value provided");
    }
    this.value = value2;
    this.options.height = height;
    this.checksum = this.calculateChecksum(this.value);
    this.leftPart = this.value.substr(0, 4);
    this.rightPart = this.value.substr(4) + this.checksum;
    this.pattern = [];
    this.baseUnit = width / (67 + this.quietZoneLength);
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/main.js
var Encodings = {
  code11: Code11,
  code39: Code39,
  code39extended: Code39Extended,
  code93: Code93,
  code93extended: Code93Extended,
  code128: Code128,
  code128a: Code128a,
  code128b: Code128b,
  code128c: Code128c,
  ["gs1-128"]: CodeGS1128,
  msimod10: MsiMod10,
  msimod11: MsiMod11,
  msimod1010: MsiMod1010,
  msimod1110: MsiMod1110,
  postnet: Postnet,
  ean8: Ean8,
  ean13: Ean13
};

// node_modules/@progress/kendo-charts/dist/es/barcode/surface-size.js
function surfaceSize(element, surfaceType) {
  const display = element.style.display;
  if (surfaceType === "canvas") {
    element.style.display = "block";
  }
  const size = {
    width: element.clientWidth,
    height: element.clientHeight
  };
  element.style.display = display;
  return size;
}

// node_modules/@progress/kendo-charts/dist/es/barcode/barcode.js
var DEFAULT_BARCODE_WIDTH = 300;
var DEFAULT_BARCODE_HEIGHT = 100;
var Barcode = class extends class_default {
  constructor(element, options, errorHandler = defaultErrorHandler) {
    super();
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this._setOptions(options);
    if (options && defined(options.value)) {
      this.redraw();
    }
  }
  destroy() {
    this._destroySurface();
  }
  _initElement() {
    addClass(this.element, "k-barcode");
  }
  _initSurface() {
    const { options, surface } = this;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  }
  _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  }
  _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  }
  _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  }
  _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  }
  setOptions(options) {
    this._setOptions(options);
    this._initSurface();
    this.redraw();
  }
  redraw() {
    let size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size.width,
      height: size.height
    });
    this.createVisual();
    this.surface.draw(this.visual);
  }
  getSize() {
    return {
      width: this.element.offsetWidth,
      height: this.element.offsetHeight
    };
  }
  _resize() {
    this.redraw();
  }
  createVisual() {
    this.visual = this._render();
  }
  _render() {
    const options = this.options;
    const value2 = options.value;
    const textOptions = options.text;
    const textMargin = getSpacing(textOptions.margin);
    const size = this._getSize();
    const border = options.border || {};
    const encoding = this.encoding;
    const contentBox = new box_default(0, 0, size.width, size.height).unpad(border.width).unpad(options.padding);
    let barHeight = contentBox.height();
    let encodedValue;
    let textToDisplay;
    let textHeight;
    const visual = new drawing_exports.Group();
    this.contentBox = contentBox;
    visual.append(this._getBackground(size));
    if (textOptions.visible) {
      textHeight = drawing_exports.util.measureText(value2, { font: textOptions.font }).height;
      barHeight -= textHeight + textMargin.top + textMargin.bottom;
    }
    try {
      encodedValue = encoding.encode(value2, contentBox.width(), barHeight);
    } catch (error) {
      this.onError(error);
      return visual;
    }
    if (textOptions.visible) {
      textToDisplay = value2;
      if (options.checksum && defined(encoding.checksum)) {
        textToDisplay += " " + encoding.checksum;
      }
      visual.append(this._getText(textToDisplay));
    }
    this.barHeight = barHeight;
    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);
    visual.append(this._bandsGroup);
    return visual;
  }
  exportVisual() {
    return this._render();
  }
  _getSize() {
    const element = this.element;
    const elementSize2 = surfaceSize(element, this.options.renderAs);
    const size = new geometry_exports.Size(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);
    if (elementSize2.width > 0) {
      size.width = elementSize2.width;
    }
    if (elementSize2.height > 0) {
      size.height = elementSize2.height;
    }
    if (this.options.width) {
      size.width = this.options.width;
    }
    if (this.options.height) {
      size.height = this.options.height;
    }
    return size;
  }
  value(value2) {
    if (!defined(value2)) {
      return this.options.value;
    }
    this.options.value = String(value2);
    this.redraw();
  }
  _getBands(pattern, baseUnit) {
    const contentBox = this.contentBox;
    let offsetX = contentBox.x1;
    let stepX;
    let patternItem;
    const group = new drawing_exports.Group();
    for (let i = 0; i < pattern.length; i++) {
      patternItem = isObject(pattern[i]) ? pattern[i] : {
        width: pattern[i],
        y1: 0,
        y2: this.barHeight
      };
      stepX = patternItem.width * baseUnit;
      if (i % 2) {
        const rect = geometry_exports.Rect.fromPoints(
          new geometry_exports.Point(offsetX, patternItem.y1 + contentBox.y1),
          new geometry_exports.Point(offsetX + stepX, patternItem.y2 + contentBox.y1)
        );
        const path = drawing_exports.Path.fromRect(rect, {
          fill: {
            color: this.options.color
          },
          stroke: null
        });
        group.append(path);
      }
      offsetX += stepX;
    }
    return group;
  }
  _getBackground(size) {
    const options = this.options;
    const border = options.border || {};
    const box = new box_default(0, 0, size.width, size.height).unpad(border.width / 2);
    const path = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: options.background
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
    return path;
  }
  _getText(value2) {
    const textOptions = this.options.text;
    const text = this._textbox = new text_box_default(value2, {
      font: textOptions.font,
      color: textOptions.color,
      align: "center",
      vAlign: "bottom",
      margin: textOptions.margin
    });
    text.reflow(this.contentBox);
    text.renderVisual();
    return text.visual;
  }
  _setOptions(options) {
    this.type = (options.type || this.options.type).toLowerCase();
    if (this.type === "upca") {
      this.type = "ean13";
      options.value = "0" + options.value;
    }
    if (this.type === "upce") {
      this.type = "ean8";
      options.value = "0" + options.value;
    }
    if (!Encodings[this.type]) {
      throw new Error(`Encoding '${this.type}' is not supported.`);
    }
    this.encoding = new Encodings[this.type]();
    this.options = deepExtend({}, this.options, options);
  }
};
setDefaultOptions(Barcode, {
  name: "Barcode",
  renderAs: "svg",
  value: "",
  type: "code39",
  checksum: false,
  width: 0,
  height: 0,
  color: "black",
  background: "white",
  text: {
    visible: true,
    font: "16px Consolas, Monaco, Sans Mono, monospace, sans-serif",
    color: "black",
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  },
  border: {
    width: 0,
    dashType: "solid",
    color: "black"
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/qrcode/utils.js
var extend10 = Object.assign;
function splitInto(str, chunkLength) {
  let result = [];
  let idx = 0;
  while (idx < str.length) {
    result.push(str.substring(idx, idx + chunkLength));
    idx += chunkLength;
  }
  return result;
}
function toBitsString(value2, length) {
  let bitString = Number(value2).toString(2);
  if (bitString.length < length) {
    bitString = new Array(length - bitString.length + 1).join(0) + bitString;
  }
  return bitString;
}
function toDecimal(value2) {
  return parseInt(value2, 2);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/free-cell-visitor.js
var FreeCellVisitor = class extends class_default {
  constructor(matrix) {
    super();
    this.matrix = matrix;
    this.row = matrix.length - 1;
    this.column = matrix.length - 1;
    this.startColumn = this.column;
    this.dir = -1;
    this.c = 0;
  }
  move() {
    this.row += this.dir * this.c;
    this.c ^= 1;
    this.column = this.startColumn - this.c;
  }
  getNextCell() {
    while (this.matrix[this.row][this.column] !== void 0) {
      this.move();
      if (this.row < 0 || this.row >= this.matrix.length) {
        this.dir = -this.dir;
        this.startColumn -= this.startColumn !== 8 ? 2 : 3;
        this.column = this.startColumn;
        this.row = this.dir < 0 ? this.matrix.length - 1 : 0;
      }
    }
    return {
      row: this.row,
      column: this.column
    };
  }
  getNextRemainderCell() {
    this.move();
    if (this.matrix[this.row][this.column] === void 0) {
      return {
        row: this.row,
        column: this.column
      };
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding-result.js
var EncodingResult = class extends class_default {
  constructor(dataString, version) {
    super();
    this.dataString = dataString;
    this.version = version;
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/choose-mode.js
var NUMERIC = "numeric";
var ALPHA_NUMERIC = "alphanumeric";
var BYTE = "byte";
var numberRegex3 = /^\d+/;
var alphaPattern = "A-Z0-9 $%*+./:-";
var alphaExclusiveSet = "A-Z $%*+./:-";
var alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+");
var alphaNumericRegex = new RegExp("^[" + alphaPattern + "]+");
var byteRegex = new RegExp("^[^" + alphaPattern + "]+");
function chooseMode(str, minNumericBeforeAlpha2, minNumericBeforeByte2, minAlphaBeforeByte2, previousMode) {
  let numeric = numberRegex3.exec(str), numericMatch = numeric ? numeric[0] : "", alpha = alphaRegex.exec(str), alphaMatch = alpha ? alpha[0] : "", alphaNumeric = alphaNumericRegex.exec(str), alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "", mode, modeString;
  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha2 || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte2 && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {
    mode = NUMERIC;
    modeString = numericMatch;
  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte2 || previousMode === ALPHA_NUMERIC)) {
    mode = ALPHA_NUMERIC;
    modeString = numericMatch || alphaMatch;
  } else {
    mode = BYTE;
    if (alphaNumericMatch) {
      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];
    } else {
      modeString = byteRegex.exec(str)[0];
    }
  }
  return {
    mode,
    modeString
  };
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/qr-data-mode.js
var QRDataMode = class extends class_default {
  constructor() {
    super();
    this.initProperties();
  }
  initProperties() {
    extend10(this, {
      modeIndicator: "",
      bitsInCharacterCount: []
    });
  }
  getVersionIndex(version) {
    if (version < 10) {
      return 0;
    } else if (version > 26) {
      return 2;
    }
    return 1;
  }
  getBitsCharacterCount(version) {
    return this.bitsInCharacterCount[this.getVersionIndex(version || 40)];
  }
  getModeCountString(length, version) {
    return this.modeIndicator + toBitsString(length, this.getBitsCharacterCount(version));
  }
  encode() {
  }
  getStringBitsLength() {
  }
  getValue() {
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/numeric-data-mode.js
var NumericQRDataMode = class extends QRDataMode {
  initProperties() {
    super.initProperties();
    extend10(this, {
      bitsInCharacterCount: [10, 12, 14],
      modeIndicator: "0001"
    });
  }
  getValue(character) {
    return parseInt(character, 10);
  }
  encode(str, version) {
    let mode = this, parts = splitInto(str, 3), result = mode.getModeCountString(str.length, version);
    let i;
    for (i = 0; i < parts.length - 1; i++) {
      result += toBitsString(parts[i], 10);
    }
    return result + toBitsString(parts[i], 1 + 3 * parts[i].length);
  }
  getStringBitsLength(inputLength, version) {
    let mod3 = inputLength % 3;
    return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/alpha-numeric-data-mode.js
var AlphaNumericQRDataMode = class extends QRDataMode {
  initProperties() {
    super.initProperties();
    extend10(this, {
      characters: {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15,
        "G": 16,
        "H": 17,
        "I": 18,
        "J": 19,
        "K": 20,
        "L": 21,
        "M": 22,
        "N": 23,
        "O": 24,
        "P": 25,
        "Q": 26,
        "R": 27,
        "S": 28,
        "T": 29,
        "U": 30,
        "V": 31,
        "W": 32,
        "X": 33,
        "Y": 34,
        "Z": 35,
        " ": 36,
        "$": 37,
        "%": 38,
        "*": 39,
        "+": 40,
        "-": 41,
        ".": 42,
        "/": 43,
        ":": 44
      },
      bitsInCharacterCount: [9, 11, 13],
      modeIndicator: "0010"
    });
  }
  getValue(character) {
    return this.characters[character];
  }
  encode(str, version) {
    let parts = splitInto(str, 2), result = this.getModeCountString(str.length, version), value2;
    let i;
    for (i = 0; i < parts.length - 1; i++) {
      value2 = 45 * this.getValue(parts[i].charAt(0)) + this.getValue(parts[i].charAt(1));
      result += toBitsString(value2, 11);
    }
    value2 = parts[i].length === 2 ? 45 * this.getValue(parts[i].charAt(0)) + this.getValue(parts[i].charAt(1)) : this.getValue(parts[i].charAt(0));
    return result + toBitsString(value2, 1 + 5 * parts[i].length);
  }
  getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/byte-data-mode.js
var ByteQRDataMode = class extends QRDataMode {
  initProperties() {
    super.initProperties();
    extend10(this, {
      bitsInCharacterCount: [8, 16, 16],
      modeIndicator: "0100"
    });
  }
  getValue(character) {
    let code = character.charCodeAt(0);
    if (code <= 127 || 160 <= code && code <= 255) {
      return code;
    }
    throw new Error(`Unsupported character in QR Code: "${character}".`);
  }
  encode(str, version) {
    let mode = this, result = mode.getModeCountString(str.length, version);
    for (let i = 0; i < str.length; i++) {
      result += toBitsString(mode.getValue(str.charAt(i)), 8);
    }
    return result;
  }
  getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/data-mode-instances.js
var NUMERIC2 = "numeric";
var ALPHA_NUMERIC2 = "alphanumeric";
var BYTE2 = "byte";
var DataModeInstances = {
  [NUMERIC2]: new NumericQRDataMode(),
  [ALPHA_NUMERIC2]: new AlphaNumericQRDataMode(),
  [BYTE2]: new ByteQRDataMode()
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-data-codewords-count.js
function getDataCodewordsCount(modes) {
  let length = 0, mode;
  for (let i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    length += mode.getStringBitsLength(modes[i].modeString.length);
  }
  return Math.ceil(length / 8);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-data-string.js
function getDataString(modes, version) {
  let dataString = "", mode;
  for (let i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    dataString += mode.encode(modes[i].modeString, version);
  }
  return dataString;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-modes.js
var initMinNumericBeforeAlpha = 8;
var initMinNumericBeforeByte = 5;
var initMinAlphaBeforeByte = 8;
var minNumericBeforeAlpha = 17;
var minNumericBeforeByte = 9;
var minAlphaBeforeByte = 16;
function getModes(inputString) {
  let modes = [], previousMode, idx = 0;
  let str = inputString;
  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));
  previousMode = modes[0].mode;
  str = str.substr(modes[0].modeString.length);
  while (str.length > 0) {
    let nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);
    if (nextMode.mode !== previousMode) {
      previousMode = nextMode.mode;
      modes.push(nextMode);
      idx++;
    } else {
      modes[idx].modeString += nextMode.modeString;
    }
    str = str.substr(nextMode.modeString.length);
  }
  return modes;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/version-codewords.js
var VersionsCodewordsInformation = [{
  L: {
    groups: [
      [1, 19]
    ],
    totalDataCodewords: 19,
    errorCodewordsPerBlock: 7
  },
  M: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 10
  },
  Q: {
    groups: [
      [1, 13]
    ],
    totalDataCodewords: 13,
    errorCodewordsPerBlock: 13
  },
  H: {
    groups: [
      [1, 9]
    ],
    totalDataCodewords: 9,
    errorCodewordsPerBlock: 17
  }
}, {
  L: {
    groups: [
      [1, 34]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 10
  },
  M: {
    groups: [
      [1, 28]
    ],
    totalDataCodewords: 28,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [1, 22]
    ],
    totalDataCodewords: 22,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [1, 55]
    ],
    totalDataCodewords: 55,
    errorCodewordsPerBlock: 15
  },
  M: {
    groups: [
      [1, 44]
    ],
    totalDataCodewords: 44,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [2, 17]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 13]
    ],
    totalDataCodewords: 26,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [1, 80]
    ],
    totalDataCodewords: 80,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [2, 32]
    ],
    totalDataCodewords: 64,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 24]
    ],
    totalDataCodewords: 48,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [4, 9]
    ],
    totalDataCodewords: 36,
    errorCodewordsPerBlock: 16
  }
}, {
  L: {
    groups: [
      [1, 108]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [2, 43]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [2, 15],
      [2, 16]
    ],
    totalDataCodewords: 62,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 11],
      [2, 12]
    ],
    totalDataCodewords: 46,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [2, 68]
    ],
    totalDataCodewords: 136,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 27]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [4, 19]
    ],
    totalDataCodewords: 76,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [4, 15]
    ],
    totalDataCodewords: 60,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [2, 78]
    ],
    totalDataCodewords: 156,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [4, 31]
    ],
    totalDataCodewords: 124,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 14],
      [4, 15]
    ],
    totalDataCodewords: 88,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [4, 13],
      [1, 14]
    ],
    totalDataCodewords: 66,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 97]
    ],
    totalDataCodewords: 194,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [2, 38],
      [2, 39]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 18],
      [2, 19]
    ],
    totalDataCodewords: 110,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [4, 14],
      [2, 15]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 116]
    ],
    totalDataCodewords: 232,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 36],
      [2, 37]
    ],
    totalDataCodewords: 182,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 16],
      [4, 17]
    ],
    totalDataCodewords: 132,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [4, 12],
      [4, 13]
    ],
    totalDataCodewords: 100,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 68],
      [2, 69]
    ],
    totalDataCodewords: 274,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 43],
      [1, 44]
    ],
    totalDataCodewords: 216,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [6, 19],
      [2, 20]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [6, 15],
      [2, 16]
    ],
    totalDataCodewords: 122,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 81]
    ],
    totalDataCodewords: 324,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [1, 50],
      [4, 51]
    ],
    totalDataCodewords: 254,
    errorCodewordsPerBlock: 30
  },
  Q: {
    groups: [
      [4, 22],
      [4, 23]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [3, 12],
      [8, 13]
    ],
    totalDataCodewords: 140,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 92],
      [2, 93]
    ],
    totalDataCodewords: 370,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [6, 36],
      [2, 37]
    ],
    totalDataCodewords: 290,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 20],
      [6, 21]
    ],
    totalDataCodewords: 206,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [7, 14],
      [4, 15]
    ],
    totalDataCodewords: 158,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 107]
    ],
    totalDataCodewords: 428,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 37],
      [1, 38]
    ],
    totalDataCodewords: 334,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [8, 20],
      [4, 21]
    ],
    totalDataCodewords: 244,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [12, 11],
      [4, 12]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [3, 115],
      [1, 116]
    ],
    totalDataCodewords: 461,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 40],
      [5, 41]
    ],
    totalDataCodewords: 365,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [11, 16],
      [5, 17]
    ],
    totalDataCodewords: 261,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [11, 12],
      [5, 13]
    ],
    totalDataCodewords: 197,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 87],
      [1, 88]
    ],
    totalDataCodewords: 523,
    errorCodewordsPerBlock: 22
  },
  M: {
    groups: [
      [5, 41],
      [5, 42]
    ],
    totalDataCodewords: 415,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [5, 24],
      [7, 25]
    ],
    totalDataCodewords: 295,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 12],
      [7, 13]
    ],
    totalDataCodewords: 223,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 98],
      [1, 99]
    ],
    totalDataCodewords: 589,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [7, 45],
      [3, 46]
    ],
    totalDataCodewords: 453,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 19],
      [2, 20]
    ],
    totalDataCodewords: 325,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [3, 15],
      [13, 16]
    ],
    totalDataCodewords: 253,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [1, 107],
      [5, 108]
    ],
    totalDataCodewords: 647,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [10, 46],
      [1, 47]
    ],
    totalDataCodewords: 507,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 22],
      [15, 23]
    ],
    totalDataCodewords: 367,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [17, 15]
    ],
    totalDataCodewords: 283,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [5, 120],
      [1, 121]
    ],
    totalDataCodewords: 721,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [9, 43],
      [4, 44]
    ],
    totalDataCodewords: 563,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [1, 23]
    ],
    totalDataCodewords: 397,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [19, 15]
    ],
    totalDataCodewords: 313,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [3, 113],
      [4, 114]
    ],
    totalDataCodewords: 795,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 44],
      [11, 45]
    ],
    totalDataCodewords: 627,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 21],
      [4, 22]
    ],
    totalDataCodewords: 445,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [9, 13],
      [16, 14]
    ],
    totalDataCodewords: 341,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [3, 107],
      [5, 108]
    ],
    totalDataCodewords: 861,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 41],
      [13, 42]
    ],
    totalDataCodewords: 669,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [15, 24],
      [5, 25]
    ],
    totalDataCodewords: 485,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [15, 15],
      [10, 16]
    ],
    totalDataCodewords: 385,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 116],
      [4, 117]
    ],
    totalDataCodewords: 932,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 42]
    ],
    totalDataCodewords: 714,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [6, 23]
    ],
    totalDataCodewords: 512,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [19, 16],
      [6, 17]
    ],
    totalDataCodewords: 406,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [2, 111],
      [7, 112]
    ],
    totalDataCodewords: 1006,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 46]
    ],
    totalDataCodewords: 782,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [16, 25]
    ],
    totalDataCodewords: 568,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [34, 13]
    ],
    totalDataCodewords: 442,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [4, 121],
      [5, 122]
    ],
    totalDataCodewords: 1094,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 47],
      [14, 48]
    ],
    totalDataCodewords: 860,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [14, 25]
    ],
    totalDataCodewords: 614,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [16, 15],
      [14, 16]
    ],
    totalDataCodewords: 464,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 117],
      [4, 118]
    ],
    totalDataCodewords: 1174,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 45],
      [14, 46]
    ],
    totalDataCodewords: 914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [16, 25]
    ],
    totalDataCodewords: 664,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [30, 16],
      [2, 17]
    ],
    totalDataCodewords: 514,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 106],
      [4, 107]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 47],
      [13, 48]
    ],
    totalDataCodewords: 1e3,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [22, 25]
    ],
    totalDataCodewords: 718,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [13, 16]
    ],
    totalDataCodewords: 538,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [10, 114],
      [2, 115]
    ],
    totalDataCodewords: 1370,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [19, 46],
      [4, 47]
    ],
    totalDataCodewords: 1062,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [28, 22],
      [6, 23]
    ],
    totalDataCodewords: 754,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [33, 16],
      [4, 17]
    ],
    totalDataCodewords: 596,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 122],
      [4, 123]
    ],
    totalDataCodewords: 1468,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [22, 45],
      [3, 46]
    ],
    totalDataCodewords: 1128,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [8, 23],
      [26, 24]
    ],
    totalDataCodewords: 808,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [12, 15],
      [28, 16]
    ],
    totalDataCodewords: 628,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [3, 117],
      [10, 118]
    ],
    totalDataCodewords: 1531,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 45],
      [23, 46]
    ],
    totalDataCodewords: 1193,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [4, 24],
      [31, 25]
    ],
    totalDataCodewords: 871,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [31, 16]
    ],
    totalDataCodewords: 661,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [7, 116],
      [7, 117]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [21, 45],
      [7, 46]
    ],
    totalDataCodewords: 1267,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 23],
      [37, 24]
    ],
    totalDataCodewords: 911,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [26, 16]
    ],
    totalDataCodewords: 701,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [5, 115],
      [10, 116]
    ],
    totalDataCodewords: 1735,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [19, 47],
      [10, 48]
    ],
    totalDataCodewords: 1373,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 24],
      [25, 25]
    ],
    totalDataCodewords: 985,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [25, 16]
    ],
    totalDataCodewords: 745,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [3, 116]
    ],
    totalDataCodewords: 1843,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [2, 46],
      [29, 47]
    ],
    totalDataCodewords: 1455,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [42, 24],
      [1, 25]
    ],
    totalDataCodewords: 1033,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [28, 16]
    ],
    totalDataCodewords: 793,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115]
    ],
    totalDataCodewords: 1955,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [10, 46],
      [23, 47]
    ],
    totalDataCodewords: 1541,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [10, 24],
      [35, 25]
    ],
    totalDataCodewords: 1115,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [35, 16]
    ],
    totalDataCodewords: 845,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115],
      [1, 116]
    ],
    totalDataCodewords: 2071,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [21, 47]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [29, 24],
      [19, 25]
    ],
    totalDataCodewords: 1171,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [46, 16]
    ],
    totalDataCodewords: 901,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [6, 116]
    ],
    totalDataCodewords: 2191,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [23, 47]
    ],
    totalDataCodewords: 1725,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [44, 24],
      [7, 25]
    ],
    totalDataCodewords: 1231,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [59, 16],
      [1, 17]
    ],
    totalDataCodewords: 961,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [12, 121],
      [7, 122]
    ],
    totalDataCodewords: 2306,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [12, 47],
      [26, 48]
    ],
    totalDataCodewords: 1812,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [39, 24],
      [14, 25]
    ],
    totalDataCodewords: 1286,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [41, 16]
    ],
    totalDataCodewords: 986,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 121],
      [14, 122]
    ],
    totalDataCodewords: 2434,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 47],
      [34, 48]
    ],
    totalDataCodewords: 1914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [46, 24],
      [10, 25]
    ],
    totalDataCodewords: 1354,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [2, 15],
      [64, 16]
    ],
    totalDataCodewords: 1054,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 122],
      [4, 123]
    ],
    totalDataCodewords: 2566,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [29, 46],
      [14, 47]
    ],
    totalDataCodewords: 1992,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [49, 24],
      [10, 25]
    ],
    totalDataCodewords: 1426,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [24, 15],
      [46, 16]
    ],
    totalDataCodewords: 1096,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [4, 122],
      [18, 123]
    ],
    totalDataCodewords: 2702,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [13, 46],
      [32, 47]
    ],
    totalDataCodewords: 2102,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [48, 24],
      [14, 25]
    ],
    totalDataCodewords: 1502,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [42, 15],
      [32, 16]
    ],
    totalDataCodewords: 1142,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [20, 117],
      [4, 118]
    ],
    totalDataCodewords: 2812,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [40, 47],
      [7, 48]
    ],
    totalDataCodewords: 2216,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [43, 24],
      [22, 25]
    ],
    totalDataCodewords: 1582,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [10, 15],
      [67, 16]
    ],
    totalDataCodewords: 1222,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [19, 118],
      [6, 119]
    ],
    totalDataCodewords: 2956,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [18, 47],
      [31, 48]
    ],
    totalDataCodewords: 2334,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [34, 24],
      [34, 25]
    ],
    totalDataCodewords: 1666,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [20, 15],
      [61, 16]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 30
  }
}];

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-version.js
function getVersion(dataCodewordsCount, errorCorrectionLevel) {
  let x = 0, y = VersionsCodewordsInformation.length - 1, version = Math.floor(VersionsCodewordsInformation.length / 2);
  do {
    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {
      y = version;
    } else {
      x = version;
    }
    version = x + Math.floor((y - x) / 2);
  } while (y - x > 1);
  if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {
    return version + 1;
  }
  return y + 1;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/iso-encoder.js
var IsoEncoder = class extends class_default {
  getEncodingResult(inputString, errorCorrectionLevel) {
    let modes = getModes(inputString), dataCodewordsCount = getDataCodewordsCount(modes), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = getDataString(modes, version);
    return new EncodingResult(dataString, version);
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/utf8-encoder.js
var BYTE3 = "byte";
var Utf8Encoder = class extends class_default {
  constructor() {
    super();
    this.initProperties();
    this.mode = DataModeInstances[this.encodingMode];
  }
  initProperties() {
    extend10(this, {
      encodingMode: BYTE3,
      utfBOM: "111011111011101110111111",
      initialModeCountStringLength: 20,
      ranges: [128, 2048, 65536, 2097152, 67108864]
    });
  }
  getEncodingResult(inputString, errorCorrectionLevel) {
    let data = this.encode(inputString), dataCodewordsCount = this.getDataCodewordsCount(data), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = this.mode.getModeCountString(data.length / 8, version) + data;
    return new EncodingResult(dataString, version);
  }
  getDataCodewordsCount(data) {
    let dataLength = data.length, dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);
    return dataCodewordsCount;
  }
  encode(str) {
    let result = this.utfBOM;
    for (let i = 0; i < str.length; i++) {
      result += this.encodeCharacter(str.charCodeAt(i));
    }
    return result;
  }
  encodeCharacter(code) {
    let bytesCount = this.getBytesCount(code), bc = bytesCount - 1, result = "";
    if (bytesCount === 1) {
      result = toBitsString(code, 8);
    } else {
      let significantOnes = 8 - bytesCount;
      for (let i = 0; i < bc; i++) {
        result = toBitsString(code >> i * 6 & 63 | 128, 8) + result;
      }
      result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;
    }
    return result;
  }
  getBytesCount(code) {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      if (code < ranges[i]) {
        return i + 1;
      }
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js
var terminator = "0000";
var powersOfTwo = { "1": 0 };
var powersOfTwoResult = { "0": 1 };
var irregularAlignmentPatternsStartDistance = {
  15: 20,
  16: 20,
  18: 24,
  19: 24,
  22: 20,
  24: 22,
  26: 24,
  28: 20,
  30: 20,
  31: 24,
  32: 28,
  33: 24,
  36: 18,
  37: 22,
  39: 20,
  40: 24
};
var finderPattern = [1, 0, 1, 1, 1];
var alignmentPattern = [1, 0, 1];
var errorCorrectionPatterns = { L: "01", M: "00", Q: "11", H: "10" };
var formatMaskPattern = "101010000010010";
var formatGeneratorPolynomial = "10100110111";
var versionGeneratorPolynomial = "1111100100101";
var paddingCodewords = ["11101100", "00010001"];
var finderPatternValue = 93;
var maskPatternConditions = [
  (row, column) => {
    return (row + column) % 2 === 0;
  },
  (row, column) => {
    return row % 2 === 0;
  },
  (row, column) => {
    return column % 3 === 0;
  },
  (row, column) => {
    return (row + column) % 3 === 0;
  },
  (row, column) => {
    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;
  },
  (row, column) => {
    return row * column % 2 + row * column % 3 === 0;
  },
  (row, column) => {
    return (row * column % 2 + row * column % 3) % 2 === 0;
  },
  (row, column) => {
    return ((row + column) % 2 + row * column % 3) % 2 === 0;
  }
];
var generatorPolynomials = [[1, 0], [1, 25, 0]];
function fillFunctionCell(matrices, bit, x, y) {
  for (let i = 0; i < matrices.length; i++) {
    matrices[i][x][y] = bit;
  }
}
function fillDataCell(matrices, bit, x, y) {
  for (let i = 0; i < maskPatternConditions.length; i++) {
    matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);
  }
}
function fillData(matrices, blocks) {
  let cellVisitor = new FreeCellVisitor(matrices[0]), block, codewordIdx, cell;
  for (let blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
    block = blocks[blockIdx];
    codewordIdx = 0;
    while (block.length > 0) {
      for (let i = 0; i < block.length; i++) {
        for (let j = 0; j < 8; j++) {
          cell = cellVisitor.getNextCell();
          fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);
        }
      }
      codewordIdx++;
      while (block[0] && codewordIdx === block[0].length) {
        block.splice(0, 1);
      }
    }
  }
  while (cell = cellVisitor.getNextRemainderCell()) {
    fillDataCell(matrices, 0, cell.row, cell.column);
  }
}
function padDataString(initialDataString, totalDataCodewords) {
  let dataBitsCount = totalDataCodewords * 8, terminatorIndex = 0, paddingCodewordIndex = 0;
  let dataString = initialDataString;
  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {
    dataString += terminator.charAt(terminatorIndex++);
  }
  if (dataString.length % 8 !== 0) {
    dataString += new Array(9 - dataString.length % 8).join("0");
  }
  while (dataString.length < dataBitsCount) {
    dataString += paddingCodewords[paddingCodewordIndex];
    paddingCodewordIndex ^= 1;
  }
  return dataString;
}
function generatePowersOfTwo() {
  let result;
  let power;
  for (power = 1; power < 255; power++) {
    result = powersOfTwoResult[power - 1] * 2;
    if (result > 255) {
      result = result ^ 285;
    }
    powersOfTwoResult[power] = result;
    powersOfTwo[result] = power;
  }
  result = powersOfTwoResult[power - 1] * 2 ^ 285;
  powersOfTwoResult[power] = result;
  powersOfTwoResult[-1] = 0;
}
function xorPolynomials(x, y) {
  let result = [], idx = x.length - 2;
  for (let i = idx; i >= 0; i--) {
    result[i] = x[i] ^ y[i];
  }
  return result;
}
function multiplyPolynomials(x, y) {
  let result = [];
  for (let i = 0; i < x.length; i++) {
    for (let j = 0; j < y.length; j++) {
      if (result[i + j] === void 0) {
        result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;
      } else {
        result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];
      }
    }
  }
  return result;
}
function generateGeneratorPolynomials() {
  let maxErrorCorrectionCodeWordsCount = 68;
  for (let idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {
    let firstPolynomial = generatorPolynomials[idx - 1], secondPolynomial = [idx, 0];
    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);
  }
}
generatePowersOfTwo();
generateGeneratorPolynomials();
function multiplyByConstant(polynomial, power) {
  let result = [], idx = polynomial.length - 1;
  do {
    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];
    idx--;
  } while (polynomial[idx] !== void 0);
  return result;
}
function generateErrorCodewords(data, errorCodewordsCount) {
  let generator = generatorPolynomials[errorCodewordsCount - 1], result = new Array(errorCodewordsCount).concat(data), generatorPolynomial = new Array(result.length - generator.length).concat(generator), steps = data.length, errorCodewords = [], divisor, idx;
  for (idx = 0; idx < steps; idx++) {
    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);
    generatorPolynomial.splice(0, 1);
    result = xorPolynomials(divisor, result);
  }
  for (idx = result.length - 1; idx >= 0; idx--) {
    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);
  }
  return errorCodewords;
}
function getBlocks(dataStream, versionCodewordsInformation) {
  let codewordStart = 0, dataBlocks = [], errorBlocks = [], dataBlock, versionGroups = versionCodewordsInformation.groups, blockCodewordsCount, groupBlocksCount, messagePolynomial, codeword;
  for (let groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {
    groupBlocksCount = versionGroups[groupIdx][0];
    for (let blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {
      blockCodewordsCount = versionGroups[groupIdx][1];
      dataBlock = [];
      messagePolynomial = [];
      for (let codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {
        codeword = dataStream.substring(codewordStart, codewordStart + 8);
        dataBlock.push(codeword);
        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);
        codewordStart += 8;
      }
      dataBlocks.push(dataBlock);
      errorBlocks.push(generateErrorCodewords(
        messagePolynomial,
        versionCodewordsInformation.errorCodewordsPerBlock
      ));
    }
  }
  return [dataBlocks, errorBlocks];
}
function encodeFormatInformation(format) {
  let formatNumber = toDecimal(format), encodedString, result = "";
  if (formatNumber === 0) {
    return "101010000010010";
  }
  encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);
  for (let i = 0; i < encodedString.length; i++) {
    result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);
  }
  return result;
}
function encodeBCH(value2, generatorPolynomial, codeLength) {
  let generatorNumber = toDecimal(generatorPolynomial), polynomialLength = generatorPolynomial.length - 1, valueNumber = value2 << polynomialLength, length = codeLength - polynomialLength, valueString = toBitsString(value2, length), result = dividePolynomials(valueNumber, generatorNumber);
  result = valueString + toBitsString(result, polynomialLength);
  return result;
}
function dividePolynomials(numberX, numberY) {
  let yLength = numberY.toString(2).length, xLength = numberX.toString(2).length;
  let x = numberX;
  do {
    x ^= numberY << xLength - yLength;
    xLength = x.toString(2).length;
  } while (xLength >= yLength);
  return x;
}
function getNumberAt(str, idx) {
  return parseInt(str.charAt(idx), 10);
}
function initMatrices(version) {
  let matrices = [], modules = 17 + 4 * version;
  for (let i = 0; i < maskPatternConditions.length; i++) {
    matrices[i] = new Array(modules);
    for (let j = 0; j < modules; j++) {
      matrices[i][j] = new Array(modules);
    }
  }
  return matrices;
}
function addFormatInformation(matrices, formatString) {
  let matrix = matrices[0], x, y, idx = 0, length = formatString.length;
  for (x = 0, y = 8; x <= 8; x++) {
    if (x !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
    }
  }
  for (x = 8, y = 7; y >= 0; y--) {
    if (y !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
    }
  }
  idx = 0;
  for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
  }
  fillFunctionCell(matrices, 1, matrix.length - 8, 8);
  for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
  }
}
function encodeVersionInformation(version) {
  return encodeBCH(version, versionGeneratorPolynomial, 18);
}
function addVersionInformation(matrices, dataString) {
  let matrix = matrices[0], modules = matrix.length, x1 = 0, y1 = modules - 11, x2 = modules - 11, y2 = 0, quotient, mod, value2;
  for (let idx = 0; idx < dataString.length; idx++) {
    quotient = Math.floor(idx / 3);
    mod = idx % 3;
    value2 = getNumberAt(dataString, dataString.length - idx - 1);
    fillFunctionCell(matrices, value2, x1 + quotient, y1 + mod);
    fillFunctionCell(matrices, value2, x2 + mod, y2 + quotient);
  }
}
function addCentricPattern(matrices, pattern, x, y) {
  let size = pattern.length + 2, length = pattern.length + 1, value2;
  for (let i = 0; i < pattern.length; i++) {
    for (let j = i; j < size - i; j++) {
      value2 = pattern[i];
      fillFunctionCell(matrices, value2, x + j, y + i);
      fillFunctionCell(matrices, value2, x + i, y + j);
      fillFunctionCell(matrices, value2, x + length - j, y + length - i);
      fillFunctionCell(matrices, value2, x + length - i, y + length - j);
    }
  }
}
function addFinderSeparator(matrices, direction, x, y) {
  let nextX = x, nextY = y, matrix = matrices[0];
  do {
    fillFunctionCell(matrices, 0, nextX, y);
    fillFunctionCell(matrices, 0, x, nextY);
    nextX += direction[0];
    nextY += direction[1];
  } while (nextX >= 0 && nextX < matrix.length);
}
function addFinderPatterns(matrices) {
  let modules = matrices[0].length;
  addCentricPattern(matrices, finderPattern, 0, 0);
  addFinderSeparator(matrices, [-1, -1], 7, 7);
  addCentricPattern(matrices, finderPattern, modules - 7, 0);
  addFinderSeparator(matrices, [1, -1], modules - 8, 7);
  addCentricPattern(matrices, finderPattern, 0, modules - 7);
  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);
}
function addAlignmentPatterns(matrices, version) {
  if (version < 2) {
    return;
  }
  let matrix = matrices[0], modules = matrix.length, pointsCount = Math.floor(version / 7), points = [6], startDistance, distance, idx = 0;
  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {
    distance = (modules - 13 - startDistance) / pointsCount;
  } else {
    startDistance = distance = (modules - 13) / (pointsCount + 1);
  }
  points.push(points[idx++] + startDistance);
  while (points[idx] + distance < modules) {
    points.push(points[idx++] + distance);
  }
  for (let i = 0; i < points.length; i++) {
    for (let j = 0; j < points.length; j++) {
      if (matrix[points[i]][points[j]] === void 0) {
        addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);
      }
    }
  }
}
function addTimingFunctions(matrices) {
  let row = 6, column = 6, value2 = 1, modules = matrices[0].length;
  for (let i = 8; i < modules - 8; i++) {
    fillFunctionCell(matrices, value2, row, i);
    fillFunctionCell(matrices, value2, i, column);
    value2 ^= 1;
  }
}
function scoreMaskMatrixes(matrices) {
  let scores = [], previousBits = [], darkModules = [], patterns = [], adjacentSameBits = [], matrix, i, row = 0, column = 1, modulesLength = matrices[0].length;
  for (i = 0; i < matrices.length; i++) {
    scores[i] = 0;
    darkModules[i] = 0;
    adjacentSameBits[i] = [0, 0];
    patterns[i] = [0, 0];
    previousBits[i] = [];
  }
  for (let rowIndex = 0; rowIndex < modulesLength; rowIndex++) {
    for (let columnIndex = 0; columnIndex < modulesLength; columnIndex++) {
      for (let matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {
        matrix = matrices[matrixIndex];
        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);
        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {
          scores[matrixIndex] += 3;
        }
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);
      }
    }
  }
  let total = modulesLength * modulesLength, minIdx, min4 = Number.MAX_VALUE;
  for (i = 0; i < scores.length; i++) {
    scores[i] += calculateDarkModulesRatioScore(darkModules[i], total);
    if (scores[i] < min4) {
      min4 = scores[i];
      minIdx = i;
    }
  }
  return minIdx;
}
function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {
  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;
  if (patterns[idx][rowColumn] === finderPatternValue) {
    scores[idx] += 40;
  }
}
function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {
  if (previousBits[idx][rowColumn] === bit) {
    adjacentBits[idx][rowColumn]++;
  } else {
    previousBits[idx][rowColumn] = bit;
    if (adjacentBits[idx][rowColumn] >= 5) {
      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;
    }
    adjacentBits[idx][rowColumn] = 1;
  }
}
function calculateDarkModulesRatioScore(darkModules, total) {
  let percent = Math.floor(darkModules / total * 100), mod5 = percent % 5, previous = Math.abs(percent - mod5 - 50), next = Math.abs(percent + 5 - mod5 - 50), score = 10 * Math.min(previous / 5, next / 5);
  return score;
}
function createQRCodeDataEncoder(encoding) {
  if (encoding && encoding.toLowerCase().indexOf("utf_8") >= 0) {
    return new Utf8Encoder();
  }
  return new IsoEncoder();
}
function encodeData(inputString, errorCorrectionLevel, encoding) {
  let encoder = createQRCodeDataEncoder(encoding), encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel), version = encodingResult.version, versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel], dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords), blocks = getBlocks(dataString, versionInformation), matrices = initMatrices(version);
  addFinderPatterns(matrices);
  addAlignmentPatterns(matrices, version);
  addTimingFunctions(matrices);
  if (version >= 7) {
    addVersionInformation(matrices, toBitsString(0, 18));
  }
  addFormatInformation(matrices, toBitsString(0, 15));
  fillData(matrices, blocks);
  let minIdx = scoreMaskMatrixes(matrices), optimalMatrix = matrices[minIdx];
  if (version >= 7) {
    addVersionInformation([optimalMatrix], encodeVersionInformation(version));
  }
  let formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);
  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));
  return optimalMatrix;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/qrcode.js
var round2 = Math.round;
var crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];
var squarePattern = [[0, 1], [1, 1], [1, 0]];
var QRCodeDefaults = {
  DEFAULT_SIZE: 200,
  QUIET_ZONE_LENGTH: 4,
  DEFAULT_ERROR_CORRECTION_LEVEL: "L",
  DEFAULT_BACKGROUND: "#fff",
  DEFAULT_DARK_MODULE_COLOR: "#000",
  MIN_BASE_UNIT_SIZE: 1,
  DEFAULT_LOGO_SIZE: 7
};
var QRCode = class extends class_default {
  constructor(element, options, errorHandler = defaultErrorHandler) {
    super();
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.wrapper = this.element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this.setOptions(options);
  }
  destroy() {
    this._destroySurface();
  }
  _initElement() {
    addClass(this.element, "k-qrcode");
  }
  _initSurface() {
    const { options, surface } = this;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  }
  _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  }
  _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  }
  _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  }
  _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  }
  redraw() {
    let size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size,
      height: size
    });
    this.createVisual();
    this.surface.draw(this.visual);
  }
  getSize() {
    const element = this.element;
    const elementWidth = element.clientWidth;
    const elementHeight = element.clientHeight;
    const size = { width: 0, height: 0 };
    if (elementWidth > 0) {
      size.width = elementWidth;
    }
    if (elementHeight) {
      size.height = elementHeight;
    }
    return size;
  }
  _resize() {
    this.redraw();
  }
  createVisual() {
    this.visual = this._render();
  }
  exportVisual() {
    return this._render();
  }
  _render() {
    let value2 = this._value, baseUnit, border = this.options.border || {}, padding = this.options.padding || 0, borderWidth = border.width || 0, quietZoneSize, matrix, size, dataSize, contentSize;
    border.width = borderWidth;
    let visual = new drawing_exports.Group();
    try {
      if (value2) {
        matrix = encodeData(value2, this.options.errorCorrection, this.options.encoding);
        size = this._getSize();
        contentSize = size - 2 * (borderWidth + padding);
        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);
        dataSize = matrix.length * baseUnit;
        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;
        visual.append(this._renderBackground(size, border));
        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));
        if (this._hasCustomLogo()) {
          visual.append(this._renderLogo(size, baseUnit));
        } else if (this._isSwiss()) {
          visual.append(this._renderSwissCode(size, baseUnit));
        }
      }
    } catch (error) {
      this.onError(error);
    }
    return visual;
  }
  _renderLogo(qrSize, baseUnit) {
    let image;
    let imageRect;
    let center = round2(qrSize / 2);
    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    let logoUrl = this.options.overlay.imageUrl;
    let position = {
      x: center - logoSize.width / 2,
      y: center - logoSize.height / 2
    };
    imageRect = new geometry_exports.Rect(
      new geometry_exports.Point(position.x, position.y),
      new geometry_exports.Size(logoSize.width, logoSize.height)
    );
    image = new drawing_exports.Image(logoUrl, imageRect);
    return image;
  }
  _renderSwissCode(qrSize, baseUnit) {
    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    logoSize = Math.max(logoSize.width, logoSize.height);
    let crossSize = logoSize / 4;
    let crossOffset = crossSize / 2;
    let center = qrSize / 2;
    let start = {};
    let visual = new drawing_exports.Group();
    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);
    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, "#fff"));
    start.x = start.y = center - logoSize / 2;
    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));
    start.x = center + crossOffset - logoSize / 2;
    start.y = center + crossOffset + crossSize - logoSize / 2;
    visual.append(this._renderShape(start, crossSize, crossPattern, "#fff"));
    return visual;
  }
  _renderShape(start, step, pattern, color) {
    let path = new drawing_exports.MultiPath({
      fill: {
        color
      },
      stroke: null
    });
    path.moveTo(start.x, start.y);
    for (let i = 0; i < pattern.length; i++) {
      path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);
    }
    path.close();
    return path;
  }
  _getSize() {
    let size;
    if (this.options.size) {
      size = parseInt(this.options.size, 10);
    } else {
      const element = this.element;
      const elementSize2 = surfaceSize(element, this.options.renderAs);
      const min4 = Math.min(elementSize2.width, elementSize2.height);
      if (min4 > 0) {
        size = min4;
      } else {
        size = QRCodeDefaults.DEFAULT_SIZE;
      }
    }
    return size;
  }
  _calculateBaseUnit(size, matrixSize) {
    let baseUnit = Math.floor(size / matrixSize);
    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      const minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);
      this.onError(new Error(
        `Insufficient size for QR Code: the current size is ${size}px and the minimum size is ${minSize}px.`
      ));
    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      baseUnit--;
    }
    return baseUnit;
  }
  _renderMatrix(matrix, baseUnit, quietZoneSize) {
    let path = new drawing_exports.MultiPath({
      fill: {
        color: this.options.color
      },
      stroke: null
    });
    for (let row = 0; row < matrix.length; row++) {
      let y = quietZoneSize + row * baseUnit;
      let column = 0;
      while (column < matrix.length) {
        while (matrix[row][column] === 0 && column < matrix.length) {
          column++;
        }
        if (column < matrix.length) {
          let x = column;
          while (matrix[row][column] === 1) {
            column++;
          }
          let x1 = round2(quietZoneSize + x * baseUnit);
          let y1 = round2(y);
          let x2 = round2(quietZoneSize + column * baseUnit);
          let y2 = round2(y + baseUnit);
          path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x2, y2).lineTo(x2, y1).close();
        }
      }
    }
    return path;
  }
  _renderBackground(size, border) {
    const box = new box_default(0, 0, size, size).unpad(border.width / 2);
    const background = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: this.options.background
      },
      stroke: {
        color: border.color,
        width: border.width
      }
    });
    return background;
  }
  setOptions(options) {
    let newOptions = options || {};
    this.options = extend10(this.options, newOptions);
    if (options.value !== void 0) {
      this._value = String(this.options.value);
    }
    this._initSurface();
    this.redraw();
  }
  value(value2) {
    if (value2 === void 0) {
      return this._value;
    }
    this._value = String(value2);
    this.redraw();
  }
  _hasCustomLogo() {
    return Boolean(this.options.overlay.imageUrl);
  }
  _isSwiss() {
    return this.options.overlay.type === "swiss";
  }
  _getLogoSize(defautLogoSize) {
    let width = this.options.overlay.width;
    let height = this.options.overlay.height;
    if (!width && !height) {
      width = height = defautLogoSize;
    } else if (width && !height) {
      height = width;
    } else if (!width && height) {
      width = height;
    }
    return {
      width,
      height
    };
  }
};
setDefaultOptions(QRCode, {
  name: "QRCode",
  renderAs: "svg",
  encoding: "ISO_8859_1",
  value: "",
  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,
  background: QRCodeDefaults.DEFAULT_BACKGROUND,
  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,
  size: "",
  padding: 0,
  border: {
    color: "",
    width: 0
  },
  overlay: {
    type: "image",
    imageUrl: "",
    width: 0,
    height: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/map/datums.js
var WGS84 = {
  a: 6378137,
  // Semi-major radius
  b: 6356752314245179e-9,
  // Semi-minor radius
  f: 0.0033528106647474805,
  // Flattening
  e: 0.08181919084262149
  // Eccentricity
};
var datums = {
  WGS84
};

// node_modules/@progress/kendo-charts/dist/es/map/location.js
function toSquare(value2) {
  return value2 * value2;
}
var math = Math;
var abs = math.abs;
var atan = math.atan;
var atan2 = math.atan2;
var cos = math.cos;
var sin = math.sin;
var tan = math.tan;
var Location = class _Location extends class_default {
  constructor(lat, lng) {
    super();
    this.initProperties();
    if (arguments.length === 1) {
      this.lat = lat[0];
      this.lng = lat[1];
    } else {
      this.lat = lat;
      this.lng = lng;
    }
  }
  initProperties() {
    deepExtend(this, {
      DISTANCE_ITERATIONS: 100,
      DISTANCE_CONVERGENCE: 1e-12,
      DISTANCE_PRECISION: 2,
      FORMAT: "{0:N6}{1:N6}"
    });
  }
  toArray() {
    return [
      this.lat,
      this.lng
    ];
  }
  equals(loc) {
    return loc && loc.lat === this.lat && loc.lng === this.lng;
  }
  clone() {
    return new _Location(this.lat, this.lng);
  }
  round(precision) {
    this.lng = round(this.lng, precision);
    this.lat = round(this.lat, precision);
    return this;
  }
  wrap() {
    this.lng = this.lng % 180;
    this.lat = this.lat % 90;
    return this;
  }
  distanceTo(dest, datum) {
    return this.greatCircleTo(dest, datum).distance;
  }
  destination(distance, initialBearing, initialDatum) {
    let bearing = rad(initialBearing);
    let datum = initialDatum || datums.WGS84;
    let fromLat = rad(this.lat);
    let fromLng = rad(this.lng);
    let dToR = distance / datum.a;
    let lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));
    let lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));
    return new _Location(deg(lat), deg(lng));
  }
  greatCircleTo(initialDest, initialDatum) {
    let dest = _Location.create(dest);
    let datum = initialDatum || datums.WGS84;
    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {
      return {
        distance: 0,
        azimuthFrom: 0,
        azimuthTo: 0
      };
    }
    let a = datum.a;
    let b = datum.b;
    let f = datum.f;
    let L = rad(dest.lng - this.lng);
    let U1 = atan((1 - f) * tan(rad(this.lat)));
    let sinU1 = sin(U1);
    let cosU1 = cos(U1);
    let U2 = atan((1 - f) * tan(rad(dest.lat)));
    let sinU2 = sin(U2);
    let cosU2 = cos(U2);
    let lambda = L;
    let prevLambda;
    let i = this.DISTANCE_ITERATIONS;
    let converged = false;
    let sinLambda;
    let cosLambda;
    let sino;
    let cosA2;
    let coso;
    let cos2om;
    let sigma;
    while (!converged && i-- > 0) {
      sinLambda = sin(lambda);
      cosLambda = cos(lambda);
      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = atan2(sino, coso);
      let sinA = cosU1 * cosU2 * sinLambda / sino;
      cosA2 = 1 - toSquare(sinA);
      cos2om = 0;
      if (cosA2 !== 0) {
        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;
      }
      prevLambda = lambda;
      let C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));
      lambda = L + (1 - C) * f * sinA * (sigma + C * sino * (cos2om + C * coso * (-1 + 2 * toSquare(cos2om))));
      converged = abs(lambda - prevLambda) <= this.DISTANCE_CONVERGENCE;
    }
    let u2 = cosA2 * (toSquare(a) - toSquare(b)) / toSquare(b);
    let A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
    let B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
    let deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));
    let azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
    let azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
    return {
      distance: round(b * A * (sigma - deltao), this.DISTANCE_PRECISION),
      azimuthFrom: deg(azimuthFrom),
      azimuthTo: deg(azimuthTo)
    };
  }
  // IE < 9 doesn't allow to override toString on definition
  toString() {
    return String(this.lat) + "," + String(this.lng);
  }
  static fromLngLat(lngAndLat) {
    return new _Location(lngAndLat[1], lngAndLat[0]);
  }
  static fromLatLng(lngAndLat) {
    return new _Location(lngAndLat[0], lngAndLat[1]);
  }
  static create(a, b) {
    if (defined(a)) {
      if (a instanceof _Location) {
        return a.clone();
      } else if (arguments.length === 1 && a.length === 2) {
        return _Location.fromLatLng(a);
      }
      return new _Location(a, b);
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/crs.js
var math2 = Math;
var atan3 = math2.atan;
var exp = math2.exp;
var pow = math2.pow;
var sin2 = math2.sin;
var log2 = math2.log;
var tan2 = math2.tan;
var Point4 = geometry_exports.Point;
var PI = math2.PI;
var PI_DIV_2 = PI / 2;
var PI_DIV_4 = PI / 4;
var DEG_TO_RAD = PI / 180;
var WGS842 = datums.WGS84;
var Mercator = class extends class_default {
  constructor(options) {
    super();
    this.initProperties();
    this._initOptions(options);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  initProperties() {
    deepExtend(this, {
      MAX_LNG: 180,
      MAX_LAT: 85.0840590501,
      INVERSE_ITERATIONS: 15,
      INVERSE_CONVERGENCE: 1e-12
    });
  }
  forward(loc, clamp) {
    let proj = this, options = proj.options, datum = options.datum, r = datum.a, lng0 = options.centralMeridian, lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT), lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng, x = rad(lng - lng0) * r, y = proj._projectLat(lat);
    return new Point4(x, y);
  }
  _projectLat(lat) {
    let datum = this.options.datum, ecc = datum.e, r = datum.a, y = rad(lat), ts = tan2(PI_DIV_4 + y / 2), con = ecc * sin2(y), p = pow((1 - con) / (1 + con), ecc / 2);
    return r * log2(ts * p);
  }
  inverse(point, clamp) {
    let proj = this, options = proj.options, datum = options.datum, r = datum.a, lng0 = options.centralMeridian, lng = point.x / (DEG_TO_RAD * r) + lng0, lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);
    if (clamp) {
      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);
    }
    return new Location(lat, lng);
  }
  _inverseY(y) {
    let proj = this, datum = proj.options.datum, r = datum.a, ecc = datum.e, ecch = ecc / 2, ts = exp(-y / r), phi = PI_DIV_2 - 2 * atan3(ts), i;
    for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {
      let con = ecc * sin2(phi), p = pow((1 - con) / (1 + con), ecch), dphi = PI_DIV_2 - 2 * atan3(ts * p) - phi;
      phi += dphi;
      if (math2.abs(dphi) <= proj.INVERSE_CONVERGENCE) {
        break;
      }
    }
    return deg(phi);
  }
};
setDefaultOptions(Mercator, {
  centralMeridian: 0,
  datum: WGS842
});
var SphericalMercator = class extends Mercator {
  initProperties() {
    super.initProperties();
    deepExtend(this, {
      MAX_LAT: 85.0511287798
    });
  }
  _projectLat(lat) {
    let r = this.options.datum.a, y = rad(lat), ts = tan2(PI_DIV_4 + y / 2);
    return r * log2(ts);
  }
  _inverseY(y) {
    let r = this.options.datum.a, ts = exp(-y / r);
    return deg(PI_DIV_2 - 2 * atan3(ts));
  }
};
var EPSG3857 = class extends class_default {
  constructor() {
    super();
    let crs = this, proj = crs._proj = new SphericalMercator();
    let c = this.c = 2 * PI * proj.options.datum.a;
    this._tm = geometry_exports.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);
    this._itm = geometry_exports.transform().scale(c, -c).translate(-0.5, -0.5);
  }
  // Location <-> Point (screen coordinates for a given scale)
  toPoint(loc, scale, clamp) {
    let point = this._proj.forward(loc, clamp);
    return point.transform(this._tm).scale(scale || 1);
  }
  toLocation(point, scale, clamp) {
    let newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);
    return this._proj.inverse(newPoint, clamp);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/utils.js
var proxy = (method, context) => {
  return method.bind(context);
};
var convertToHtml = (html) => {
  const div = document.createElement("div");
  div.innerHTML = html;
  return div.firstChild;
};
var appendHtml = (html, element) => {
  const div = document.createElement("div");
  div.innerHTML = html;
  while (div.childNodes.length > 0) {
    element.appendChild(div.childNodes[0]);
  }
};
var removeChildren = (element) => {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
};
var prepend = (element, originElement) => {
  originElement.insertBefore(element, originElement.firstChild);
};
var wrapInner = (parent, wrapper) => {
  parent.appendChild(wrapper);
  while (parent.firstChild !== wrapper) {
    wrapper.appendChild(parent.firstChild);
  }
};
var toHyphens = (str) => {
  const result = str.replace(/([a-z][A-Z])/g, function(g) {
    return g.charAt(0) + "-" + g.charAt(1).toLowerCase();
  });
  return result;
};
var toPixels = (value2) => {
  let result;
  if (value2 && String(value2).endsWith("px")) {
    result = value2;
  } else {
    result = String(value2) + "px";
  }
  return result;
};
var hasNativeScrolling = (userAgent) => {
  const { mobileOS } = getSupportedFeatures(userAgent);
  return mobileOS.ios || mobileOS.android;
};
var setDefaultEvents = (type, events) => {
  const proto = type.prototype;
  if (proto.events) {
    events.forEach((event) => {
      if (proto.events.indexOf(event) < 0) {
        proto.events.push(event);
      }
    });
  } else {
    proto.events = events;
  }
};
var wheelDeltaY = (e) => {
  const deltaY = e.wheelDeltaY;
  let delta;
  if (e.wheelDelta) {
    if (deltaY === void 0 || deltaY) {
      delta = e.wheelDelta;
    }
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    delta = -e.detail * 10;
  }
  return delta;
};
var renderPos = (pos) => {
  let result = [];
  if (pos) {
    let parts = toHyphens(pos).split("-");
    for (let i = 0; i < parts.length; i++) {
      result.push("k-pos-" + parts[i]);
    }
  }
  return result.join(" ");
};

// node_modules/@progress/kendo-charts/dist/es/map/attribution.js
var Attribution = class extends Observable {
  constructor(element, options) {
    super();
    this.element = element;
    this._initOptions(options);
    this.items = [];
    addClass(this.element, "k-widget k-attribution");
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  filter(extent, zoom) {
    this._extent = extent;
    this._zoom = zoom;
    this._render();
  }
  add(item) {
    let newItem = item;
    if (defined(item)) {
      if (typeof item === "string") {
        newItem = {
          text: item
        };
      }
      this.items.push(newItem);
      this._render();
    }
  }
  remove(text) {
    let result = [];
    for (let i = 0; i < this.items.length; i++) {
      let item = this.items[i];
      if (item.text !== text) {
        result.push(item);
      }
    }
    this.items = result;
    this._render();
  }
  clear() {
    this.items = [];
    removeChildren(this.element);
  }
  _render() {
    let result = [];
    for (let i = 0; i < this.items.length; i++) {
      let item = this.items[i];
      let text = this._itemText(item);
      if (text !== "") {
        result.push(text);
      }
    }
    if (result.length > 0) {
      removeChildren(this.element);
      const html = result.join(this.options.separator);
      appendHtml(html, this.element);
      this.showElement();
    } else {
      this.hideElement();
    }
  }
  hideElement() {
    this.element.style.display = "none";
  }
  showElement() {
    this.element.style.display = "";
  }
  _itemText(item) {
    let text = "";
    let inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);
    let inArea = this._inArea(item.extent);
    if (inZoomLevel && inArea) {
      text += item.text;
    }
    return text;
  }
  _inZoomLevel(min4, max3) {
    let result = true;
    let newMin = valueOrDefault(min4, -Number.MAX_VALUE);
    let newMax = valueOrDefault(max3, Number.MAX_VALUE);
    result = this._zoom > newMin && this._zoom < newMax;
    return result;
  }
  _inArea(area) {
    let result = true;
    if (area) {
      result = area.contains(this._extent);
    }
    return result;
  }
};
setDefaultOptions(Attribution, {
  name: "Attribution",
  separator: "&nbsp;|&nbsp;"
});

// node_modules/@progress/kendo-charts/dist/es/map/navigator.js
var PAN = "pan";
var directionsMap = {
  up: {
    className: "k-navigator-n",
    iconClass: "k-i-caret-alt-up"
  },
  down: {
    className: "k-navigator-s",
    iconClass: "k-i-caret-alt-down"
  },
  right: {
    className: "k-navigator-e",
    iconClass: "k-i-caret-alt-right"
  },
  left: {
    className: "k-navigator-w",
    iconClass: "k-i-caret-alt-left"
  }
};
function createButton(direction, iconOptions) {
  const html = '<button class="k-button k-button-square k-rounded-full k-button-flat k-button-flat-base k-icon-button ' + directionsMap[direction].className + '" aria-label="move ' + direction + '">' + renderIcon({ icon: `caret-alt-${direction}`, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html);
}
var Navigator2 = class extends Observable {
  constructor(element, options) {
    super();
    this.element = element;
    this._initOptions(options);
    const navigateUpButton = createButton("up", options.icons);
    const navigateRightlButton = createButton("right", options.icons);
    const navigateDownButton = createButton("down", options.icons);
    const navigateLeftButton = createButton("left", options.icons);
    this.element.appendChild(navigateUpButton);
    this.element.appendChild(navigateRightlButton);
    this.element.appendChild(navigateDownButton);
    this.element.appendChild(navigateLeftButton);
    addClass(this.element, "k-widget k-navigator");
    on(this.element, "click", ".k-button", proxy(this._click, this));
    let parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = proxy(this._keydown, this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  destroy() {
    this.dispose();
  }
  // originates from the kendo.jquery version
  dispose() {
    off(this._keyroot, "keydown", this._keydownHandler);
  }
  _tabindex(target) {
    const targetElement = target || this.wrapper || this.element;
    let element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _pan(x, y) {
    let panStep = this.options.panStep;
    this.trigger(PAN, {
      x: x * panStep,
      y: y * panStep
    });
  }
  _click(e) {
    let x = 0;
    let y = 0;
    let button = e.currentTarget;
    if (button.matches(".k-navigator-n")) {
      y = 1;
    } else if (button.matches(".k-navigator-s")) {
      y = -1;
    } else if (button.matches(".k-navigator-e")) {
      x = 1;
    } else if (button.matches(".k-navigator-w")) {
      x = -1;
    }
    this._pan(x, y);
    e.preventDefault();
  }
  _keydown(e) {
    switch (e.which) {
      case keys_default.UP:
        this._pan(0, 1);
        e.preventDefault();
        break;
      case keys_default.DOWN:
        this._pan(0, -1);
        e.preventDefault();
        break;
      case keys_default.RIGHT:
        this._pan(1, 0);
        e.preventDefault();
        break;
      case keys_default.LEFT:
        this._pan(-1, 0);
        e.preventDefault();
        break;
      default:
        break;
    }
  }
};
setDefaultOptions(Navigator2, {
  name: "Navigator",
  panStep: 1
});
setDefaultEvents(Navigator2, [
  PAN
]);

// node_modules/@progress/kendo-charts/dist/es/map/zoom.js
function createButton2(direction, icon, iconOptions) {
  const html = '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-zoom-' + direction + '" title="zoom-' + direction + '" aria-label="zoom-' + direction + '">' + renderIcon({ icon, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html);
}
var PLUS = 187;
var MINUS = 189;
var FF_PLUS = 61;
var FF_MINUS = 173;
var CHANGE = "change";
var ZoomControl = class extends Observable {
  constructor(element, options, iconOptions) {
    super();
    this.element = element;
    this._initOptions(options);
    const zoomInButton = createButton2("in", "plus", iconOptions);
    const zoomOutButton = createButton2("out", "minus", iconOptions);
    this.element.appendChild(zoomInButton);
    this.element.appendChild(zoomOutButton);
    this.element.setAttribute("role", "group");
    addClass(this.element, "k-widget k-zoom-control k-button-group k-group-horizontal");
    this._clickHandler = this._click.bind(this);
    on(this.element, "click", ".k-button", this._clickHandler);
    let parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = this._keydown.bind(this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  destroy() {
    if (this.element) {
      off(this.element, "click", this._clickHandler);
    }
    if (this._keyroot) {
      off(this._keyroot, "keydown", this._keydownHandler);
    }
  }
  _tabindex(target) {
    const targetElement = target || this.wrapper || this.element;
    let element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _change(direction) {
    let zoomStep = this.options.zoomStep;
    this.trigger(CHANGE, { delta: direction * zoomStep });
  }
  _click(e) {
    let button = e.currentTarget;
    let direction = 1;
    if (hasClasses(button, "k-zoom-out")) {
      direction = -1;
    }
    this._change(direction);
    e.preventDefault();
  }
  _keydown(e) {
    switch (e.which) {
      case keys_default.NUMPAD_PLUS:
      case PLUS:
      case FF_PLUS:
        this._change(1);
        break;
      case keys_default.NUMPAD_MINUS:
      case MINUS:
      case FF_MINUS:
        this._change(-1);
        break;
      default:
        break;
    }
  }
};
setDefaultOptions(ZoomControl, {
  name: "ZoomControl",
  zoomStep: 1
});
setDefaultEvents(ZoomControl, [
  CHANGE
]);

// node_modules/@progress/kendo-charts/dist/es/map/extent.js
var math3 = Math;
var max2 = math3.max;
var min2 = math3.min;
var Extent = class _Extent extends class_default {
  constructor(initialNw, initialSe) {
    super();
    let nw = Location.create(initialNw);
    let se = Location.create(initialSe);
    if (nw.lng + 180 > se.lng + 180 && nw.lat + 90 < se.lat + 90) {
      this.se = nw;
      this.nw = se;
    } else {
      this.se = se;
      this.nw = nw;
    }
  }
  contains(loc) {
    let nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se.lng + 180 && lat + 90 >= se.lat + 90 && lat + 90 <= nw.lat + 90;
  }
  center() {
    let nw = this.nw;
    let se = this.se;
    let lng = nw.lng + (se.lng - nw.lng) / 2;
    let lat = nw.lat + (se.lat - nw.lat) / 2;
    return new Location(lat, lng);
  }
  containsAny(locs) {
    let result = false;
    for (let i = 0; i < locs.length; i++) {
      result = result || this.contains(locs[i]);
    }
    return result;
  }
  include(loc) {
    let nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    nw.lng = min2(nw.lng, lng);
    nw.lat = max2(nw.lat, lat);
    se.lng = max2(se.lng, lng);
    se.lat = min2(se.lat, lat);
  }
  includeAll(locs) {
    for (let i = 0; i < locs.length; i++) {
      this.include(locs[i]);
    }
  }
  edges() {
    let nw = this.nw, se = this.se;
    return {
      nw: this.nw,
      ne: new Location(nw.lat, se.lng),
      se: this.se,
      sw: new Location(se.lat, nw.lng)
    };
  }
  toArray() {
    let nw = this.nw, se = this.se;
    return [
      nw,
      new Location(nw.lat, se.lng),
      se,
      new Location(se.lat, nw.lng)
    ];
  }
  overlaps(extent) {
    return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());
  }
  static create(a, b) {
    if (a instanceof _Extent) {
      return a;
    } else if (a && b) {
      return new _Extent(a, b);
    } else if (a && a.length === 4 && !b) {
      return new _Extent([
        a[0],
        a[1]
      ], [
        a[2],
        a[3]
      ]);
    }
  }
  static get World() {
    return new _Extent([90, -180], [-90, 180]);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/constants.js
var SHOW_TOOLTIP2 = "showTooltip";
var HIDE_TOOLTIP2 = "hideTooltip";
var CENTER_CHANGE = "centerChange";
var ZOOM_CHANGE = "zoomChange";
var INIT = "init";

// node_modules/@progress/kendo-charts/dist/es/map/tooltip/tooltip.js
var Tooltip2 = class extends class_default {
  constructor(widgetService, options) {
    super();
    this.widgetService = widgetService;
    this.options = deepExtend({}, this.options, options);
    this.offset = { x: 0, y: 0 };
  }
  show(anchor, args) {
    if (this.location === args.location) {
      return;
    }
    this.anchor = anchor;
    this.location = args.location;
    this.widgetService.notify(
      SHOW_TOOLTIP2,
      Object.assign({ anchor: this.anchor }, args)
    );
    this.visible = true;
  }
  hide() {
    if (this.widgetService) {
      this.widgetService.notify(HIDE_TOOLTIP2);
    }
    this.visible = false;
    this.location = null;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(anchor) {
    const documentPoint = this.widgetService.widget._toDocumentCoordinates({
      x: anchor.left - this.offset.x,
      y: anchor.top - this.offset.y
    });
    this._anchor = {
      left: documentPoint.left,
      top: documentPoint.top
    };
  }
  destroy() {
    this.widgetService = null;
  }
};
setDefaultOptions(Tooltip2, {
  border: {
    width: 1
  },
  opacity: 1
});

// node_modules/@progress/kendo-charts/dist/es/map/layers/layer.js
var Layer = class extends class_default {
  constructor(map2, options) {
    super();
    this.support = getSupportedFeatures();
    this._initOptions(options);
    this.map = map2;
    let element = document.createElement("div");
    addClass(element, "k-layer");
    element.style.zIndex = this.options.zIndex;
    element.style.opacity = this.options.opacity;
    this.element = element;
    map2.scrollElement.appendChild(this.element);
    this._beforeReset = this._beforeReset.bind(this);
    this._reset = this._reset.bind(this);
    this._resize = this._resize.bind(this);
    this._panEnd = this._panEnd.bind(this);
    this._activate();
    this._updateAttribution();
  }
  destroy() {
    this._deactivate();
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  show() {
    this.reset();
    this._activate();
    this._applyExtent(true);
  }
  hide() {
    this._deactivate();
    this._setVisibility(false);
  }
  reset() {
    this._beforeReset();
    this._reset();
  }
  _reset() {
    this._applyExtent();
  }
  _beforeReset() {
  }
  _resize() {
  }
  _panEnd() {
    this._applyExtent();
  }
  _applyExtent() {
    let options = this.options;
    let zoom = this.map.zoom();
    let matchMinZoom = !defined(options.minZoom) || zoom >= options.minZoom;
    let matchMaxZoom = !defined(options.maxZoom) || zoom <= options.maxZoom;
    let extent = Extent.create(options.extent);
    let inside = !extent || extent.overlaps(this.map.extent());
    this._setVisibility(matchMinZoom && matchMaxZoom && inside);
  }
  _setVisibility(visible) {
    this.element.style.display = visible ? "" : "none";
  }
  _activate() {
    let map2 = this.map;
    this._deactivate();
    map2.bind("beforeReset", this._beforeReset);
    map2.bind("reset", this._reset);
    map2.bind("resize", this._resize);
    map2.bind("panEnd", this._panEnd);
  }
  _deactivate() {
    let map2 = this.map;
    map2.unbind("beforeReset", this._beforeReset);
    map2.unbind("reset", this._reset);
    map2.unbind("resize", this._resize);
    map2.unbind("panEnd", this._panEnd);
  }
  _updateAttribution() {
    const attribution = this.map.attribution;
    if (attribution) {
      attribution.add(this.options.attribution);
    }
  }
  _readData() {
    const data = this.options.data || [];
    return data;
  }
  _hasData() {
    return this._data && this._data.length > 0;
  }
  _layerIndex() {
    const layers = this.map.layers || [];
    return layers.indexOf(this);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/tile.js
var math4 = Math;
var Point5 = geometry_exports.Point;
function compileTemplate(template) {
  if (isFunction(template)) {
    return template;
  }
  return template_service_default.compile(template);
}
function roundPoint(point) {
  return new Point5(round(point.x), round(point.y));
}
function renderSize(size) {
  let newSize = size;
  if (typeof size !== "string") {
    newSize += "px";
  }
  return newSize;
}
var TileLayer = class extends Layer {
  constructor(map2, options) {
    super(map2, options);
    if (typeof this.options.subdomains === "string") {
      this.options.subdomains = this.options.subdomains.split("");
    }
    let viewType = this._viewType();
    this._view = new viewType(this.element, this.options);
  }
  destroy() {
    super.destroy();
    this._view.destroy();
    this._view = null;
  }
  _beforeReset() {
    let map2 = this.map;
    let origin = map2.locationToLayer(map2.extent().nw).round();
    this._view.viewOrigin(origin);
  }
  _reset() {
    super._reset();
    this._updateView();
    this._view.reset();
  }
  _viewType() {
    return TileView;
  }
  _activate() {
    super._activate();
    if (!this.support.mobileOS) {
      if (!this._pan) {
        this._pan = throttle(this._render.bind(this), 100);
      }
      this.map.bind("pan", this._pan);
    }
  }
  _deactivate() {
    super._deactivate();
    if (this._pan) {
      this.map.unbind("pan", this._pan);
    }
  }
  _updateView() {
    let view = this._view, map2 = this.map, extent = map2.extent(), extentToPoint = {
      nw: map2.locationToLayer(extent.nw).round(),
      se: map2.locationToLayer(extent.se).round()
    };
    view.center(map2.locationToLayer(map2.center()));
    view.extent(extentToPoint);
    view.zoom(map2.zoom());
  }
  _resize() {
    this._render();
  }
  _panEnd(e) {
    super._panEnd(e);
    this._render();
  }
  _render() {
    this._updateView();
    this._view.render();
  }
};
setDefaultOptions(TileLayer, {
  tileSize: 256,
  subdomains: ["a", "b", "c"],
  urlTemplate: "",
  zIndex: 1
});
var TileView = class extends class_default {
  constructor(element, options) {
    super();
    this.element = element;
    this._initOptions(options);
    this.pool = new TilePool();
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  center(center) {
    this._center = center;
  }
  extent(extent) {
    this._extent = extent;
  }
  viewOrigin(origin) {
    this._viewOrigin = origin;
  }
  zoom(zoom) {
    this._zoom = zoom;
  }
  pointToTileIndex(point) {
    return new Point5(math4.floor(point.x / this.options.tileSize), math4.floor(point.y / this.options.tileSize));
  }
  tileCount() {
    let size = this.size(), firstTileIndex = this.pointToTileIndex(this._extent.nw), nw = this._extent.nw, point = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);
    return {
      x: math4.ceil((math4.abs(point.x) + size.width) / this.options.tileSize),
      y: math4.ceil((math4.abs(point.y) + size.height) / this.options.tileSize)
    };
  }
  size() {
    let nw = this._extent.nw, se = this._extent.se, diff = se.clone().translate(-nw.x, -nw.y);
    return {
      width: diff.x,
      height: diff.y
    };
  }
  indexToPoint(index) {
    let x = index.x, y = index.y;
    return new Point5(x * this.options.tileSize, y * this.options.tileSize);
  }
  subdomainText() {
    let subdomains = this.options.subdomains;
    return subdomains[this.subdomainIndex++ % subdomains.length];
  }
  destroy() {
    removeChildren(this.element);
    this.pool.empty();
  }
  reset() {
    this.pool.reset();
    this.subdomainIndex = 0;
    this.render();
  }
  render() {
    let size = this.tileCount(), firstTileIndex = this.pointToTileIndex(this._extent.nw), tile, x, y;
    for (x = 0; x < size.x; x++) {
      for (y = 0; y < size.y; y++) {
        tile = this.createTile({
          x: firstTileIndex.x + x,
          y: firstTileIndex.y + y
        });
        if (!tile.visible) {
          tile.show();
        }
      }
    }
  }
  createTile(currentIndex) {
    let options = this.tileOptions(currentIndex);
    let tile = this.pool.get(this._center, options);
    if (!tile.element.parentNode) {
      this.element.append(tile.element);
    }
    return tile;
  }
  tileOptions(currentIndex) {
    let index = this.wrapIndex(currentIndex), point = this.indexToPoint(currentIndex), origin = this._viewOrigin, offset = point.clone().translate(-origin.x, -origin.y);
    return {
      index,
      currentIndex,
      point,
      offset: roundPoint(offset),
      zoom: this._zoom,
      size: this.options.tileSize,
      subdomain: this.subdomainText(),
      urlTemplate: this.options.urlTemplate,
      errorUrlTemplate: this.options.errorUrlTemplate
    };
  }
  wrapIndex(index) {
    let boundary = math4.pow(2, this._zoom);
    return {
      x: this.wrapValue(index.x, boundary),
      y: limitValue(index.y, 0, boundary - 1)
    };
  }
  wrapValue(value2, boundary) {
    let remainder = math4.abs(value2) % boundary;
    let wrappedValue = value2;
    if (value2 >= 0) {
      wrappedValue = remainder;
    } else {
      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);
    }
    return wrappedValue;
  }
};
var ImageTile = class extends class_default {
  constructor(id, options) {
    super();
    this.id = id;
    this.visible = true;
    this._initOptions(options);
    this.createElement();
    this.show();
  }
  destroy() {
    const element = this.element;
    const parentNode = element ? element.parentNode : null;
    if (element) {
      if (parentNode) {
        parentNode.removeChild(element);
      }
      this.element = null;
    }
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  createElement() {
    let el = document.createElement("img");
    const size = this.options.size + "px";
    el.setAttribute("alt", "");
    el.style.position = "absolute";
    el.style.display = "block";
    el.style.width = el.style.maxWidth = size;
    el.style.height = el.style.maxHeight = size;
    this.element = el;
  }
  show() {
    let element = this.element;
    element.style.top = renderSize(this.options.offset.y);
    element.style.left = renderSize(this.options.offset.x);
    let url = this.url();
    if (url) {
      element.setAttribute("src", url);
    }
    element.style.visibility = "visible";
    this.visible = true;
  }
  hide() {
    this.element.style.visibility = "hidden";
    this.visible = false;
  }
  url() {
    let urlResult = compileTemplate(this.options.urlTemplate);
    return urlResult(this.urlOptions());
  }
  errorUrl() {
    let urlResult = compileTemplate(this.options.errorUrlTemplate);
    return urlResult(this.urlOptions());
  }
  urlOptions() {
    let options = this.options;
    return {
      zoom: options.zoom,
      subdomain: options.subdomain,
      z: options.zoom,
      x: options.index.x,
      y: options.index.y,
      s: options.subdomain,
      quadkey: options.quadkey,
      q: options.quadkey,
      culture: options.culture,
      c: options.culture
    };
  }
};
setDefaultOptions(ImageTile, {
  urlTemplate: "",
  errorUrlTemplate: ""
});
var TilePool = class extends class_default {
  constructor() {
    super();
    this._items = [];
  }
  get(center, options) {
    if (this._items.length >= this.options.maxSize) {
      this._remove(center);
    }
    return this._create(options);
  }
  empty() {
    let items = this._items;
    for (let i = 0; i < items.length; i++) {
      items[i].destroy();
    }
    this._items = [];
  }
  reset() {
    let items = this._items;
    for (let i = 0; i < items.length; i++) {
      items[i].hide();
    }
  }
  _create(options) {
    let items = this._items;
    let tile;
    let id = hashKey(options.point.toString() + options.offset.toString() + options.zoom + options.urlTemplate);
    for (let i = 0; i < items.length; i++) {
      if (items[i].id === id) {
        tile = items[i];
        break;
      }
    }
    if (tile) {
      tile.show();
    } else {
      tile = new ImageTile(id, options);
      this._items.push(tile);
    }
    return tile;
  }
  _remove(center) {
    let items = this._items;
    let maxDist = -1;
    let index = -1;
    for (let i = 0; i < items.length; i++) {
      let dist = items[i].options.point.distanceTo(center);
      if (dist > maxDist && !items[i].visible) {
        index = i;
        maxDist = dist;
      }
    }
    if (index !== -1) {
      items[index].destroy();
      items.splice(index, 1);
    }
  }
};
setDefaultOptions(TilePool, {
  maxSize: 100
});

// node_modules/@progress/kendo-charts/dist/es/map/scroller/draggable.js
var extend11 = Object.assign;
var CHANGE2 = "change";
var TapCapture = class extends Observable {
  constructor(element, options) {
    super();
    let that = this, domElement = element[0] || element;
    that.capture = false;
    if (domElement.addEventListener) {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._press, that), true);
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._release, that), true);
      });
    } else {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._press, that));
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._release, that));
      });
    }
    that.bind([
      "press",
      "release"
    ], options || {});
  }
  captureNext() {
    this.capture = true;
  }
  cancelCapture() {
    this.capture = false;
  }
  _press(e) {
    let that = this;
    that.trigger("press");
    if (that.capture) {
      e.preventDefault();
    }
  }
  _release(e) {
    let that = this;
    that.trigger("release");
    if (that.capture) {
      e.preventDefault();
      that.cancelCapture();
    }
  }
};
var PaneDimension = class extends Observable {
  constructor(options) {
    super();
    let that = this;
    that.forcedEnabled = false;
    extend11(that, options);
    that.scale = 1;
    if (that.horizontal) {
      that.measure = "offsetWidth";
      that.scrollSize = "scrollWidth";
      that.axis = "x";
    } else {
      that.measure = "offsetHeight";
      that.scrollSize = "scrollHeight";
      that.axis = "y";
    }
  }
  makeVirtual() {
    extend11(this, {
      virtual: true,
      forcedEnabled: true,
      _virtualMin: 0,
      _virtualMax: 0
    });
  }
  virtualSize(min4, max3) {
    if (this._virtualMin !== min4 || this._virtualMax !== max3) {
      this._virtualMin = min4;
      this._virtualMax = max3;
      this.update();
    }
  }
  outOfBounds(offset) {
    return offset > this.max || offset < this.min;
  }
  forceEnabled() {
    this.forcedEnabled = true;
  }
  getSize() {
    return this.container[this.measure];
  }
  getTotal() {
    return this.element[this.scrollSize];
  }
  rescale(scale) {
    this.scale = scale;
  }
  update(silent) {
    let that = this, total = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total * that.scale, size = that.getSize();
    if (total === 0 && !that.forcedEnabled) {
      return;
    }
    that.max = that.virtual ? -that._virtualMin : 0;
    that.size = size;
    that.total = scaledTotal;
    that.min = Math.min(that.max, size - scaledTotal);
    that.minScale = size / total;
    that.centerOffset = (scaledTotal - size) / 2;
    that.enabled = that.forcedEnabled || scaledTotal > size;
    if (!silent) {
      that.trigger(CHANGE2, that);
    }
  }
};
var PaneDimensions = class extends Observable {
  constructor(options) {
    super();
    let that = this;
    that.x = new PaneDimension(extend11({
      horizontal: true
    }, options));
    that.y = new PaneDimension(extend11({
      horizontal: false
    }, options));
    that.container = options.container;
    that.forcedMinScale = options.minScale;
    that.maxScale = options.maxScale || 100;
    that.bind(CHANGE2, options);
  }
  rescale(newScale) {
    this.x.rescale(newScale);
    this.y.rescale(newScale);
    this.refresh();
  }
  centerCoordinates() {
    return {
      x: Math.min(0, -this.x.centerOffset),
      y: Math.min(0, -this.y.centerOffset)
    };
  }
  refresh() {
    let that = this;
    that.x.update();
    that.y.update();
    that.enabled = that.x.enabled || that.y.enabled;
    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
    that.fitScale = Math.max(that.x.minScale, that.y.minScale);
    that.trigger(CHANGE2);
  }
};
var PaneAxis = class extends Observable {
  constructor(options) {
    super();
    extend11(this, options);
  }
  outOfBounds() {
    return this.dimension.outOfBounds(this.movable[this.axis]);
  }
  dragMove(delta) {
    let that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position = movable[axis] + delta;
    if (!dimension.enabled) {
      return;
    }
    let dragDelta = delta;
    if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {
      dragDelta *= that.resistance;
    }
    movable.translateAxis(axis, dragDelta);
    that.trigger(CHANGE2, that);
  }
};
var Pane2 = class extends class_default {
  constructor(options) {
    super();
    let that = this, x, y, resistance, movable;
    extend11(that, {
      elastic: true
    }, options);
    resistance = that.elastic ? 0.5 : 0;
    movable = that.movable;
    that.x = x = new PaneAxis({
      axis: "x",
      dimension: that.dimensions.x,
      resistance,
      movable
    });
    that.y = y = new PaneAxis({
      axis: "y",
      dimension: that.dimensions.y,
      resistance,
      movable
    });
    that.userEvents.bind([
      "press",
      "move",
      "end",
      "gesturestart",
      "gesturechange"
    ], {
      gesturestart(e) {
        that.gesture = e;
        that.offset = elementOffset(that.dimensions.container);
      },
      press(e) {
        const closestAnchor = e.event.target.closest("a");
        if (closestAnchor && closestAnchor.matches("[data-navigate-on-press=true]")) {
          e.sender.cancel();
        }
      },
      gesturechange(e) {
        let previousGesture = that.gesture, previousCenter = previousGesture.center, center = e.center, scaleDelta = e.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
        if (movable.scale <= minScale && scaleDelta < 1) {
          scaleDelta += (1 - scaleDelta) * 0.8;
        }
        if (movable.scale * scaleDelta >= maxScale) {
          scaleDelta = maxScale / movable.scale;
        }
        let offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
        coordinates = {
          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
        };
        movable.scaleWith(scaleDelta);
        x.dragMove(coordinates.x);
        y.dragMove(coordinates.y);
        that.dimensions.rescale(movable.scale);
        that.gesture = e;
        e.preventDefault();
      },
      move(e) {
        if (e.event.target.tagName.match(/textarea|input/i)) {
          return;
        }
        if (x.dimension.enabled || y.dimension.enabled) {
          x.dragMove(e.x.delta);
          y.dragMove(e.y.delta);
          e.preventDefault();
        } else {
          e.touch.skip();
        }
      },
      end(e) {
        e.preventDefault();
      }
    });
  }
};
var translate = function(x, y, scale) {
  return "translate3d(" + x + "px," + y + "px,0) scale(" + scale + ")";
};
var Movable = class extends Observable {
  constructor(element) {
    super();
    let that = this;
    that.element = element;
    that.element.style.transformOrigin = "left top";
    that.x = 0;
    that.y = 0;
    that.scale = 1;
    const coordinates = translate(that.x, that.y, that.scale);
    that.element.style.transform = coordinates;
    that._saveCoordinates(coordinates);
  }
  translateAxis(axis, by) {
    this[axis] += by;
    this.refresh();
  }
  scaleTo(scale) {
    this.scale = scale;
    this.refresh();
  }
  scaleWith(scaleDelta) {
    this.scale *= scaleDelta;
    this.refresh();
  }
  translate(coordinates) {
    this.x += coordinates.x;
    this.y += coordinates.y;
    this.refresh();
  }
  moveAxis(axis, value2) {
    this[axis] = value2;
    this.refresh();
  }
  moveTo(coordinates) {
    extend11(this, coordinates);
    this.refresh();
  }
  refresh() {
    let that = this, x = that.x, y = that.y, newCoordinates;
    if (that.round) {
      x = Math.round(x);
      y = Math.round(y);
    }
    newCoordinates = translate(x, y, that.scale);
    if (newCoordinates !== that.coordinates) {
      that.element.style.transform = newCoordinates;
      that._saveCoordinates(newCoordinates);
      that.trigger(CHANGE2);
    }
  }
  _saveCoordinates(coordinates) {
    this.coordinates = coordinates;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/shape.js
var Group8 = drawing_exports.Group;
var ShapeLayer = class extends Layer {
  constructor(map2, options) {
    super(map2, options);
    this._pan = proxy(this._pan, this);
    this.surface = drawing_exports.Surface.create(this.element, {
      width: map2.scrollElement.clientWidth,
      height: map2.scrollElement.clientHeight
    });
    this._initRoot();
    this.movable = new Movable(this.surface.element);
    this._markers = [];
    this._click = this._handler("shapeClick");
    this.surface.bind("click", this._click);
    this._mouseleave = this._handler("shapeMouseLeave");
    this.surface.bind("mouseleave", this._mouseleave);
    this.surface.bind("mouseenter", this._mouseenter.bind(this));
  }
  destroy() {
    super.destroy();
    this.surface.destroy();
  }
  _reset() {
    super._reset();
    this._translateSurface();
    this._data = this._readData();
    if (this._hasData()) {
      this._load(this._data);
    }
  }
  _initRoot() {
    this._root = new Group8();
    this.surface.draw(this._root);
  }
  _beforeReset() {
    this.surface.clear();
    this._initRoot();
  }
  _resize() {
    this.surface.size(this.map.size());
  }
  _readData() {
    const data = super._readData();
    if (data.type === "FeatureCollection") {
      return data.features;
    }
    if (data.type === "GeometryCollection") {
      return data.geometries;
    }
    return data;
  }
  _load(data) {
    this._data = data;
    this._clearMarkers();
    if (!this._loader) {
      this._loader = new GeoJsonLoader(this.map, this.options.style, this);
    }
    let container = new Group8();
    for (let i = 0; i < data.length; i++) {
      let shape = this._loader.parse(data[i]);
      if (shape) {
        container.append(shape);
      }
    }
    this._root.clear();
    this._root.append(container);
  }
  shapeCreated(shape) {
    let cancelled = false;
    if (shape instanceof drawing_exports.Circle && this.map.options.renderPointsAsMarkers) {
      cancelled = defined(this._createMarker(shape));
    }
    if (!cancelled) {
      let args = {
        layer: this,
        shape
      };
      cancelled = this.map.trigger("shapeCreated", args);
    }
    return cancelled;
  }
  featureCreated(e) {
    e.layer = this;
    this.map.trigger("shapeFeatureCreated", e);
  }
  _createMarker(shape) {
    let marker = this.map.markers.bind({
      location: shape.location
    }, shape.dataItem);
    if (marker) {
      this._markers.push(marker);
    }
    return marker;
  }
  _clearMarkers() {
    for (let i = 0; i < this._markers.length; i++) {
      this.map.markers.remove(this._markers[i]);
    }
    this._markers = [];
  }
  _pan() {
    if (!this._panning) {
      this._panning = true;
      this.surface.suspendTracking();
    }
  }
  _panEnd(e) {
    super._panEnd(e);
    this._translateSurface();
    this.surface.resumeTracking();
    this._panning = false;
  }
  _translateSurface() {
    let map2 = this.map;
    let nw = map2.locationToView(map2.extent().nw);
    if (this.surface.translate) {
      this.surface.translate(nw);
      this.movable.moveTo({
        x: nw.x,
        y: nw.y
      });
    }
  }
  _eventArgs(e) {
    return {
      layer: this,
      layerIndex: this._layerIndex(),
      shape: e.element,
      shapeIndex: (this._data || []).indexOf(e.element.dataItem),
      originalEvent: e.originalEvent
    };
  }
  _handler(eventName) {
    return (e) => {
      if (e.element) {
        this.map.trigger(eventName, this._eventArgs(e));
      }
    };
  }
  _mouseenter(e) {
    if (!e.element) {
      return;
    }
    this.map.trigger("shapeMouseEnter", this._eventArgs(e));
    const shape = e.element;
    const anchor = this._tooltipAnchor(e);
    this.map._tooltip.show(anchor, this._tooltipContext(shape));
  }
  _tooltipContext(shape) {
    return {
      type: "shape",
      layerIndex: this._layerIndex(),
      className: "k-map-shape-tooltip",
      dataItem: shape.dataItem,
      location: shape.location
    };
  }
  _tooltipAnchor(e) {
    const cursor = this.map.eventOffset(e.originalEvent);
    return {
      top: cursor.y,
      left: cursor.x
    };
  }
  _activate() {
    super._activate();
    this._panHandler = proxy(this._pan, this);
    this.map.bind("pan", this.panHandler);
  }
  _deactivate() {
    super._deactivate();
    this.map.unbind("pan", this._panHandler);
  }
};
setDefaultOptions(ShapeLayer, {
  autoBind: true,
  zIndex: 100
});
var GeoJsonLoader = class extends class_default {
  constructor(locator, defaultStyle, observer) {
    super();
    this.observer = observer;
    this.locator = locator;
    this.style = defaultStyle;
  }
  parse(item) {
    let root = new Group8();
    let unwrap = true;
    if (item.type === "Feature") {
      unwrap = false;
      this._loadGeometryTo(root, item.geometry, item);
      this._featureCreated(root, item);
    } else {
      this._loadGeometryTo(root, item, item);
    }
    if (unwrap && root.children.length < 2) {
      root = root.children[0];
    }
    return root;
  }
  _shapeCreated(shape) {
    let cancelled = false;
    if (this.observer && this.observer.shapeCreated) {
      cancelled = this.observer.shapeCreated(shape);
    }
    return cancelled;
  }
  _featureCreated(group, dataItem) {
    if (this.observer && this.observer.featureCreated) {
      this.observer.featureCreated({
        group,
        dataItem,
        properties: dataItem.properties
      });
    }
  }
  _loadGeometryTo(container, geometry, dataItem) {
    let coords = geometry.coordinates;
    let i;
    let path;
    switch (geometry.type) {
      case "LineString":
        path = this._loadPolygon(container, [coords], dataItem);
        this._setLineFill(path);
        break;
      case "MultiLineString":
        for (i = 0; i < coords.length; i++) {
          path = this._loadPolygon(container, [coords[i]], dataItem);
          this._setLineFill(path);
        }
        break;
      case "Polygon":
        this._loadPolygon(container, coords, dataItem);
        break;
      case "MultiPolygon":
        for (i = 0; i < coords.length; i++) {
          this._loadPolygon(container, coords[i], dataItem);
        }
        break;
      case "Point":
        this._loadPoint(container, coords, dataItem);
        break;
      case "MultiPoint":
        for (i = 0; i < coords.length; i++) {
          this._loadPoint(container, coords[i], dataItem);
        }
        break;
      default:
        break;
    }
  }
  _setLineFill(path) {
    let segments = path.segments;
    if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {
      path.options.fill = null;
    }
  }
  _loadShape(container, shape) {
    if (!this._shapeCreated(shape)) {
      container.append(shape);
    }
    return shape;
  }
  _loadPolygon(container, rings, dataItem) {
    let shape = this._buildPolygon(rings);
    shape.dataItem = dataItem;
    shape.location = this.locator.viewToLocation(shape.bbox().center());
    return this._loadShape(container, shape);
  }
  _buildPolygon(rings) {
    let type = rings.length > 1 ? drawing_exports.MultiPath : drawing_exports.Path;
    let path = new type(this.style);
    for (let i = 0; i < rings.length; i++) {
      for (let j = 0; j < rings[i].length; j++) {
        let point = this.locator.locationToView(Location.fromLngLat(rings[i][j]));
        if (j === 0) {
          path.moveTo(point.x, point.y);
        } else {
          path.lineTo(point.x, point.y);
        }
      }
    }
    return path;
  }
  _loadPoint(container, coords, dataItem) {
    let location = Location.fromLngLat(coords);
    let point = this.locator.locationToView(location);
    let circle = new geometry_exports.Circle(point, 10);
    let shape = new drawing_exports.Circle(circle, this.style);
    shape.dataItem = dataItem;
    shape.location = location;
    return this._loadShape(container, shape);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/bubble.js
var BubbleLayer = class extends ShapeLayer {
  _readData() {
    const data = this.options.data || [];
    return data;
  }
  _load(data) {
    this._data = data;
    this.surface.clear();
    if (data.length === 0) {
      return;
    }
    let options = this.options;
    let getValue = getter(options.valueField);
    let newData = data.slice(0);
    newData.sort(function(a, b) {
      return getValue(b) - getValue(a);
    });
    let scaleType = this._scaleType();
    let scale;
    let getLocation = getter(this.options.locationField);
    for (let i = 0; i < newData.length; i++) {
      let dataItem = newData[i];
      let location = getLocation(dataItem);
      let value2 = getValue(dataItem);
      if (defined(location) && defined(value2)) {
        if (!scale) {
          scale = new scaleType([
            0,
            value2
          ], [
            options.minSize,
            options.maxSize
          ]);
        }
        location = Location.create(location);
        let center = this.map.locationToView(location);
        let size = scale.map(value2);
        let symbol = this._createSymbol({
          center,
          size,
          style: options.style,
          dataItem,
          location
        });
        symbol.dataItem = dataItem;
        symbol.location = location;
        symbol.value = value2;
        this._drawSymbol(symbol);
      }
    }
  }
  _scaleType() {
    let scale = this.options.scale;
    if (isFunction(scale)) {
      return scale;
    }
    return Scales[scale];
  }
  _createSymbol(args) {
    let symbol = this.options.symbol;
    if (!isFunction(symbol)) {
      symbol = Symbols[symbol];
    }
    return symbol(args);
  }
  _drawSymbol(shape) {
    let args = {
      layer: this,
      shape
    };
    let cancelled = this.map.trigger("shapeCreated", args);
    if (!cancelled) {
      this.surface.draw(shape);
    }
  }
  _tooltipContext(shape) {
    return {
      type: "bubble",
      layerIndex: this._layerIndex(),
      className: "k-map-bubble-tooltip",
      dataItem: shape.dataItem,
      location: shape.location,
      value: shape.value
    };
  }
  _tooltipAnchor(e) {
    const shape = e.element;
    const center = shape.bbox().center();
    return {
      top: center.y,
      left: center.x
    };
  }
};
setDefaultOptions(BubbleLayer, {
  // autoBind: true,
  locationField: "location",
  valueField: "value",
  minSize: 0,
  maxSize: 100,
  scale: "sqrt",
  symbol: "circle",
  // ensure bubble layers are displayed over tile and shape layers
  zIndex: 200
});
var SqrtScale = class extends class_default {
  constructor(domain, range) {
    super();
    this._domain = domain;
    this._range = range;
    let domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);
    let outputRange = range[1] - range[0];
    this._ratio = outputRange / domainRange;
  }
  map(value2) {
    let rel = (Math.sqrt(value2) - Math.sqrt(this._domain[0])) * this._ratio;
    return this._range[0] + rel;
  }
};
var Scales = {
  sqrt: SqrtScale
};
var Symbols = {
  circle: function(args) {
    let geo = new geometry_exports.Circle(args.center, args.size / 2);
    return new drawing_exports.Circle(geo, args.style);
  },
  square: function(args) {
    let path = new drawing_exports.Path(args.style);
    let halfSize = args.size / 2;
    let center = args.center;
    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();
    return path;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/marker.js
var CLICK = "click";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var extend12 = Object.assign;
var MARKER_CLASS_NAME = "k-marker";
var MARKER_CLASS = "." + MARKER_CLASS_NAME;
var MarkerLayer = class extends Layer {
  constructor(map2, options) {
    super(map2, options);
    this._markerClickHandler = proxy(this._markerClick, this);
    on(this.element, CLICK, MARKER_CLASS, this._markerClickHandler);
    this.items = [];
    this._load(this._readData());
  }
  destroy() {
    super.destroy();
    off(this.element, CLICK, this._markerClickHandler);
    this.clear();
  }
  add(args) {
    if (isArray(args)) {
      for (let i = 0; i < args.length; i++) {
        this._addOne(args[i]);
      }
    } else {
      return this._addOne(args);
    }
  }
  remove(marker) {
    marker.destroy();
    let index = (this.items || []).indexOf(marker);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  }
  clear() {
    for (let i = 0; i < this.items.length; i++) {
      this.items[i].destroy();
    }
    this.items = [];
  }
  update(marker) {
    let location = marker.location();
    if (location) {
      marker.showAt(this.map.locationToView(location));
      let args = {
        marker,
        layer: this
      };
      this.map.trigger("markerActivate", args);
    }
  }
  _reset() {
    super._reset();
    let items = this.items;
    for (let i = 0; i < items.length; i++) {
      this.update(items[i]);
    }
  }
  bind(options, dataItem) {
    let marker = Marker.create(options, this.options);
    marker.dataItem = dataItem;
    let args = {
      marker,
      layer: this
    };
    let cancelled = this.map.trigger("markerCreated", args);
    if (!cancelled) {
      this.add(marker);
      return marker;
    }
  }
  _addOne(arg) {
    let marker = Marker.create(arg, this.options);
    marker.addTo(this);
    return marker;
  }
  _readData() {
    const data = this.options.data || [];
    return data;
  }
  _load(data) {
    this._data = data;
    this.clear();
    let getLocation = getter(this.options.locationField);
    let getTitle = getter(this.options.titleField);
    for (let i = 0; i < data.length; i++) {
      let dataItem = data[i];
      this.bind({
        location: getLocation(dataItem),
        title: getTitle(dataItem)
      }, dataItem);
    }
  }
  _markerClick(e) {
    const marker = e.currentTarget._kendoNode;
    let args = {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker),
      originalEvent: e
    };
    this.map.trigger("markerClick", args);
  }
  _markerMouseEnter(e) {
    const args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseEnter", args);
  }
  _markerMouseLeave(e) {
    const args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseLeave", args);
  }
  _createMarkerEventArgs(e) {
    const marker = e.marker;
    let args = extend12({}, {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker)
    }, e);
    return args;
  }
};
setDefaultOptions(MarkerLayer, {
  zIndex: 1e3,
  autoBind: true,
  locationField: "location",
  titleField: "title",
  template: ""
});
var Marker = class _Marker extends class_default {
  constructor(options) {
    super();
    this.options = options || {};
  }
  destroy() {
    this.layer = null;
    this.unbindEvents();
    this.hide();
  }
  addTo(parent) {
    this.layer = parent.markers || parent;
    this.layer.items.push(this);
    this.layer.update(this);
  }
  location(value2) {
    if (value2) {
      this.options.location = Location.create(value2).toArray();
      if (this.layer) {
        this.layer.update(this);
      }
      return this;
    }
    return Location.create(this.options.location);
  }
  showAt(point) {
    this.render();
    this._anchor = { left: Math.round(point.x), top: Math.round(point.y) };
    this.element.style.left = toPixels(this._anchor.left);
    this.element.style.top = toPixels(this._anchor.top);
  }
  hide() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  }
  bindEvents() {
    if (!this.element) {
      return;
    }
    this._mouseEnterHandler = proxy(this._mouseEnter, this);
    on(this.element, MOUSE_ENTER, MARKER_CLASS, this._mouseEnterHandler);
    this._mouseLeaveHandler = proxy(this._mouseLeave, this);
    on(this.element, MOUSE_LEAVE, MARKER_CLASS, this._mouseLeaveHandler);
  }
  unbindEvents() {
    if (!this.element) {
      return;
    }
    off(this.element, MOUSE_ENTER, this._mouseEnterHandler);
    off(this.element, MOUSE_LEAVE, this._mouseLeaveHandler);
  }
  render() {
    if (!this.element) {
      let options = this.options;
      let layer = this.layer;
      let element = document.createElement("span");
      addClass(element, MARKER_CLASS_NAME);
      if (this.options.template) {
        const templateFn = this._compileTemplate(this.options.template);
        const templateHtml = templateFn(this.dataItem);
        const templateElement = convertToHtml(templateHtml);
        element.appendChild(templateElement);
      } else if (options.svgIcon) {
        renderIcon(element, { icon: options.svgIcon, iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: "svg" });
      } else {
        let iconOptions = { icon: "map-marker", iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: this.options.icons.type };
        if (options.shape) {
          if (options.shape === "pinTarget") {
            iconOptions.icon = "map-marker-target";
            renderIcon(element, iconOptions);
          } else if (options.shape === "pin") {
            renderIcon(element, iconOptions);
          } else {
            addClass(element, "k-icon k-icon-xxl k-i-marker-" + toHyphens(options.shape || "pin"));
          }
        } else {
          renderIcon(element, iconOptions);
        }
      }
      if (options.title) {
        element.setAttribute("title", options.title);
      }
      const attributes = options.attributes || {};
      Object.keys(attributes).forEach(function(key) {
        element.setAttribute(key, attributes[key]);
      });
      element._kendoNode = this;
      element.style.zIndex = options.zIndex;
      this.element = element;
      if (layer) {
        layer.element.appendChild(this.element);
      }
      this.bindEvents();
    }
  }
  _mouseEnter(e) {
    const args = this._createEventArgs(e);
    this.layer._markerMouseEnter(args);
    this.layer.map._tooltip.show({
      top: this._anchor.top - this.element.offsetHeight,
      left: this._anchor.left
    }, this._tooltipContext());
  }
  _tooltipContext() {
    return {
      type: "marker",
      layerIndex: this.layer._layerIndex(),
      className: "k-map-marker-tooltip",
      dataItem: this.dataItem,
      title: this.options.title,
      location: this.location()
    };
  }
  _mouseLeave(e) {
    const args = this._createEventArgs(e);
    this.layer._markerMouseLeave(args);
  }
  _createEventArgs(e) {
    let args = {
      marker: this,
      originalEvent: e
    };
    return args;
  }
  _compileTemplate(template) {
    return template_service_default.compile(template, {
      paramName: "dataItem",
      useWithBlock: false
    });
  }
  static create(arg, defaults) {
    if (arg instanceof _Marker) {
      return arg;
    }
    return new _Marker(deepExtend({}, defaults, arg));
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/scroller/fx.js
var extend13 = Object.assign;
function animationFrame(callback) {
  window.requestAnimationFrame(callback);
}
var Animation = class extends class_default {
  constructor() {
    super();
    let that = this;
    that._tickProxy = proxy(that._tick, that);
    that._started = false;
  }
  tick() {
  }
  done() {
  }
  onEnd() {
  }
  onCancel() {
  }
  start() {
    if (!this.enabled()) {
      return;
    }
    if (!this.done()) {
      this._started = true;
      animationFrame(this._tickProxy);
    } else {
      this.onEnd();
    }
  }
  enabled() {
    return true;
  }
  cancel() {
    this._started = false;
    this.onCancel();
  }
  _tick() {
    let that = this;
    if (!that._started) {
      return;
    }
    that.tick();
    if (!that.done()) {
      animationFrame(that._tickProxy);
    } else {
      that._started = false;
      that.onEnd();
    }
  }
};
var Transition = class extends Animation {
  constructor(options) {
    super();
    extend13(this, options);
  }
  done() {
    return this.timePassed() >= this.duration;
  }
  timePassed() {
    return Math.min(this.duration, now() - this.startDate);
  }
  moveTo(options) {
    let that = this, movable = that.movable;
    that.initial = movable[that.axis];
    that.delta = options.location - that.initial;
    that.duration = typeof options.duration === "number" ? options.duration : 300;
    that.tick = that._easeProxy(options.ease);
    that.startDate = now();
    that.start();
  }
  _easeProxy(ease) {
    let that = this;
    return function() {
      that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
    };
  }
  static easeOutExpo(t, b, c, d) {
    return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  }
  // static easeOutBack(t, b, c, d) {
  //     let s = 1.70158;
  //     return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  // }
};

// node_modules/@progress/kendo-charts/dist/es/map/scroller/scroller.js
var extend14 = Object.assign;
var abs2 = Math.abs;
var SNAPBACK_DURATION = 500;
var SCROLLBAR_OPACITY = 0.7;
var FRICTION = 0.96;
var VELOCITY_MULTIPLIER = 10;
var MAX_VELOCITY = 55;
var OUT_OF_BOUNDS_FRICTION = 0.5;
var ANIMATED_SCROLLER_PRECISION = 5;
var PULL = "pull";
var CHANGE3 = "change";
var RESIZE = "resize";
var SCROLL = "scroll";
var MOUSE_WHEEL_ID = 2;
var ZoomSnapBack = class extends Animation {
  constructor(options) {
    super(options);
    let that = this;
    extend14(that, options);
    that.userEvents.bind("gestureend", that.start.bind(this));
    that.tapCapture.bind("press", that.cancel.bind(this));
  }
  enabled() {
    return this.movable.scale < this.dimensions.minScale;
  }
  done() {
    return this.dimensions.minScale - this.movable.scale < 0.01;
  }
  tick() {
    let movable = this.movable;
    movable.scaleWith(1.1);
    this.dimensions.rescale(movable.scale);
  }
  onEnd() {
    let movable = this.movable;
    movable.scaleTo(this.dimensions.minScale);
    this.dimensions.rescale(movable.scale);
  }
};
var DragInertia = class extends Animation {
  constructor(options) {
    super();
    let that = this;
    extend14(that, options, {
      transition: new Transition({
        axis: options.axis,
        movable: options.movable,
        onEnd() {
          that._end();
        }
      })
    });
    that.tapCapture.bind("press", function() {
      that.cancel();
    });
    that.userEvents.bind("end", proxy(that.start, that));
    that.userEvents.bind("gestureend", proxy(that.start, that));
    that.userEvents.bind("tap", proxy(that.onEnd, that));
  }
  onCancel() {
    this.transition.cancel();
  }
  freeze(location) {
    let that = this;
    that.cancel();
    that._moveTo(location);
  }
  onEnd() {
    let that = this;
    if (that.paneAxis.outOfBounds()) {
      that._snapBack();
    } else {
      that._end();
    }
  }
  done() {
    return abs2(this.velocity) < 1;
  }
  start(e) {
    let that = this, velocity;
    if (!that.dimension.enabled) {
      return;
    }
    if (that.paneAxis.outOfBounds()) {
      if (that.transition._started) {
        that.transition.cancel();
        that.velocity = Math.min(e.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);
        super.start();
      } else {
        that._snapBack();
      }
    } else {
      velocity = e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[that.axis].velocity;
      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
      that.tapCapture.captureNext();
      super.start();
    }
  }
  tick() {
    let that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
    if (!that.elastic && dimension.outOfBounds(location)) {
      location = Math.max(Math.min(location, dimension.max), dimension.min);
      that.velocity = 0;
    }
    that.movable.moveAxis(that.axis, location);
  }
  _end() {
    this.tapCapture.cancelCapture();
    this.end();
  }
  _snapBack() {
    let that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
    that._moveTo(snapBack);
  }
  _moveTo(location) {
    this.transition.moveTo({
      location,
      duration: SNAPBACK_DURATION,
      ease: Transition.easeOutExpo
    });
  }
};
var AnimatedScroller = class extends Animation {
  constructor(options) {
    super(options);
    let that = this;
    extend14(that, options, {
      origin: {},
      destination: {},
      offset: {}
    });
  }
  tick() {
    this._updateCoordinates();
    this.moveTo(this.origin);
  }
  done() {
    return abs2(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs2(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
  }
  onEnd() {
    this.moveTo(this.destination);
    if (this.callback) {
      this.callback.call();
    }
  }
  setCoordinates(from, to) {
    this.offset = {};
    this.origin = from;
    this.destination = to;
  }
  /* eslint-disable no-param-reassign */
  setCallback(callback) {
    if (callback && isFunction(callback)) {
      this.callback = callback;
    } else {
      callback = void 0;
    }
  }
  /* eslint-enable no-param-reassign */
  _updateCoordinates() {
    this.offset = {
      x: (this.destination.x - this.origin.x) / 4,
      y: (this.destination.y - this.origin.y) / 4
    };
    this.origin = {
      y: this.origin.y + this.offset.y,
      x: this.origin.x + this.offset.x
    };
  }
};
var ScrollBar = class extends class_default {
  constructor(options) {
    super();
    let that = this, horizontal = options.axis === "x";
    const orientation = horizontal ? "horizontal" : "vertical";
    const element = convertToHtml('<div class="km-touch-scrollbar km-' + orientation + '-scrollbar" />');
    extend14(that, options, {
      element,
      elementSize: 0,
      movable: new Movable(element),
      scrollMovable: options.movable,
      alwaysVisible: options.alwaysVisible,
      size: horizontal ? "width" : "height"
    });
    that.scrollMovable.bind(CHANGE3, that.refresh.bind(that));
    that.container.appendChild(element);
    if (options.alwaysVisible) {
      that.show();
    }
  }
  refresh() {
    let that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
    if (sizeRatio >= 1) {
      this.element.style.display = "none";
    } else {
      this.element.style.display = "";
    }
    if (position + size > paneSize) {
      size = paneSize - position;
    } else if (position < 0) {
      size += position;
      position = 0;
    }
    if (that.elementSize !== size) {
      that.element.style[that.size] = size + "px";
      that.elementSize = size;
    }
    that.movable.moveAxis(axis, position);
  }
  show() {
    this.element.style.opacity = SCROLLBAR_OPACITY;
    this.element.style.visibility = "visible";
  }
  hide() {
    if (!this.alwaysVisible) {
      this.element.style.opacity = 0;
    }
  }
};
var Scroller = class extends Observable {
  constructor(element, options) {
    super();
    let that = this;
    this.element = element;
    this._initOptions(options);
    const hasScrolling = hasNativeScrolling(navigator.userAgent);
    that._native = that.options.useNative && hasScrolling;
    const scrollHeader = convertToHtml('<div class="km-scroll-header"/>');
    if (that._native) {
      addClass(element, "km-native-scroller");
      prepend(scrollHeader, element);
      extend14(that, {
        scrollElement: element,
        fixedContainer: element.children[0]
      });
      return;
    }
    element.style.overflow = "hidden";
    addClass(element, "km-scroll-wrapper");
    const scrollContainer = convertToHtml('<div class="km-scroll-container"/>');
    wrapInner(element, scrollContainer);
    prepend(scrollHeader, element);
    let inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({
      element: inner,
      container: element,
      forcedEnabled: that.options.zoom
    }), avoidScrolling = this.options.avoidScrolling, userEvents = new UserEvents(element, {
      touchAction: "none",
      allowSelection: true,
      preventDragEvent: true,
      captureUpIfMoved: true,
      multiTouch: that.options.zoom,
      supportDoubleTap: that.options.supportDoubleTap,
      start(e) {
        dimensions.refresh();
        let velocityX = abs2(e.x.velocity), velocityY = abs2(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = that.fixedContainer.contains(e.event.target), verticalSwipe = velocityY * 2 >= velocityX;
        if (!originatedFromFixedContainer && !avoidScrolling(e) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
          userEvents.capture();
        } else {
          userEvents.cancel();
        }
      }
    }), pane = new Pane2({
      movable,
      dimensions,
      userEvents,
      elastic: that.options.elastic
    }), zoomSnapBack = new ZoomSnapBack({
      movable,
      dimensions,
      userEvents,
      tapCapture
    }), animatedScroller = new AnimatedScroller({
      moveTo(coordinates) {
        that.scrollTo(coordinates.x, coordinates.y);
      }
    });
    movable.bind(CHANGE3, function() {
      that.scrollTop = -movable.y;
      that.scrollLeft = -movable.x;
      that.trigger(SCROLL, {
        scrollTop: that.scrollTop,
        scrollLeft: that.scrollLeft
      });
    });
    if (that.options.mousewheelScrolling) {
      this._wheelScrollHandler = this._wheelScroll.bind(this);
      on(element, "wheel", this._wheelScrollHandler);
    }
    extend14(that, {
      movable,
      dimensions,
      zoomSnapBack,
      animatedScroller,
      userEvents,
      pane,
      tapCapture,
      pulled: false,
      enabled: true,
      scrollElement: inner,
      scrollTop: 0,
      scrollLeft: 0,
      fixedContainer: element.children[0]
    });
    that._initAxis("x");
    that._initAxis("y");
    that._wheelEnd = function() {
      that._wheel = false;
      that.userEvents.end(0, that._wheelY);
    };
    dimensions.refresh();
    if (that.options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _wheelScroll(e) {
    if (e.ctrlKey) {
      return;
    }
    if (!this._wheel) {
      this._wheel = true;
      this._wheelY = 0;
      this.userEvents.press(0, this._wheelY);
    }
    clearTimeout(this._wheelTimeout);
    this._wheelTimeout = setTimeout(this._wheelEnd, 50);
    let delta = wheelDeltaY(e);
    if (delta) {
      this._wheelY += delta;
      this.userEvents.move(0, this._wheelY);
    }
    e.preventDefault();
  }
  makeVirtual() {
    this.dimensions.y.makeVirtual();
  }
  virtualSize(min4, max3) {
    this.dimensions.y.virtualSize(min4, max3);
  }
  height() {
    return this.dimensions.y.size;
  }
  scrollHeight() {
    return this.scrollElement.scrollHeight;
  }
  scrollWidth() {
    return this.scrollElement.scrollWidth;
  }
  _resize() {
    if (!this._native) {
      this.contentResized();
    }
  }
  setOptions(options) {
    let that = this;
    this._initOptions(options);
    if (options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  reset() {
    if (this._native) {
      this.scrollElement.scrollTop(0);
    } else {
      this.movable.moveTo({
        x: 0,
        y: 0
      });
      this._scale(1);
    }
  }
  contentResized() {
    this.dimensions.refresh();
    if (this.pane.x.outOfBounds()) {
      this.movable.moveAxis("x", this.dimensions.x.min);
    }
    if (this.pane.y.outOfBounds()) {
      this.movable.moveAxis("y", this.dimensions.y.min);
    }
  }
  zoomOut() {
    let dimensions = this.dimensions;
    dimensions.refresh();
    this._scale(dimensions.fitScale);
    this.movable.moveTo(dimensions.centerCoordinates());
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
  scrollTo(x, y) {
    if (this._native) {
      this.scrollElement.scrollLeft(abs2(x));
      this.scrollElement.scrollTop(abs2(y));
    } else {
      this.dimensions.refresh();
      this.movable.moveTo({
        x,
        y
      });
    }
  }
  animatedScrollTo(x, y, callback) {
    let from, to;
    if (this._native) {
      this.scrollTo(x, y);
    } else {
      from = {
        x: this.movable.x,
        y: this.movable.y
      };
      to = {
        x,
        y
      };
      this.animatedScroller.setCoordinates(from, to);
      this.animatedScroller.setCallback(callback);
      this.animatedScroller.start();
    }
  }
  // kept for API compatibility, not used
  pullHandled() {
  }
  destroy() {
    const element = this.element;
    off(element, "wheel", this._wheelScrollHandler);
    if (this.userEvents) {
      this.userEvents.destroy();
    }
  }
  _scale(scale) {
    this.dimensions.rescale(scale);
    this.movable.scaleTo(scale);
  }
  _initPullToRefresh() {
  }
  // kept for API compatibility, not used
  _dragEnd() {
  }
  // kept for API compatibility, not used
  _paneChange() {
  }
  _initAxis(axis) {
    let that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
      axis,
      movable,
      dimension,
      container: that.element,
      alwaysVisible: that.options.visibleScrollHints
    });
    dimension.bind(CHANGE3, function() {
      scrollBar.refresh();
    });
    paneAxis.bind(CHANGE3, function() {
      scrollBar.show();
    });
    that[axis + "inertia"] = new DragInertia({
      axis,
      paneAxis,
      movable,
      tapCapture,
      userEvents: that.userEvents,
      dimension,
      elastic: that.options.elastic,
      friction: that.options.friction || FRICTION,
      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,
      end() {
        scrollBar.hide();
        that.trigger("scrollEnd", {
          axis,
          scrollTop: that.scrollTop,
          scrollLeft: that.scrollLeft
        });
      }
    });
  }
};
setDefaultOptions(Scroller, {
  name: "Scroller",
  zoom: false,
  pullOffset: 140,
  visibleScrollHints: false,
  elastic: true,
  useNative: false,
  mousewheelScrolling: true,
  avoidScrolling() {
    return false;
  },
  pullToRefresh: false,
  messages: {
    pullTemplate: "Pull to refresh",
    releaseTemplate: "Release to refresh",
    refreshTemplate: "Refreshing"
  }
});
setDefaultEvents(Scroller, [
  PULL,
  SCROLL,
  RESIZE
]);

// node_modules/@progress/kendo-charts/dist/es/services/map-service.js
var MapService = class {
  constructor(widget, context = {}) {
    this.sender = context.sender || widget;
    this.widget = widget;
    this.rtl = Boolean(context.rtl);
  }
  notify(name, args) {
    if (this.widget) {
      this.widget.trigger(name, args);
    }
  }
};
var map_service_default = MapService;

// node_modules/@progress/kendo-charts/dist/es/map/map.js
var math5 = Math;
var min3 = math5.min;
var pow2 = math5.pow;
var Point6 = geometry_exports.Point;
var MARKER = "marker";
var LOCATION = "location";
var FRICTION2 = 0.9;
var FRICTION_MOBILE = 0.93;
var MOUSEWHEEL2 = "wheel";
var MOUSEWHEEL_THROTTLE = 50;
var VELOCITY_MULTIPLIER2 = 5;
var DEFAULT_ZOOM_RATE = 1;
var layersMap = {
  bubble: BubbleLayer,
  shape: ShapeLayer,
  tile: TileLayer,
  [MARKER]: MarkerLayer
};
var Map2 = class extends Observable {
  constructor(element, options = {}, themeOptions = {}, context = {}) {
    super();
    this._init(element, options, themeOptions, context);
  }
  destroy() {
    this.scroller.destroy();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this.navigator) {
      this.navigator.destroy();
    }
    if (this.attribution) {
      this.attribution.destroy();
    }
    if (this.zoomControl) {
      this.zoomControl.destroy();
    }
    if (isArray(this.markers)) {
      this.markers.forEach((markerLayer) => {
        markerLayer.destroy();
      });
    } else {
      this.markers.destroy();
    }
    for (let i = 0; i < this.layers.length; i++) {
      this.layers[i].destroy();
    }
    off(this.element, MOUSEWHEEL2, this._mousewheelHandler);
    super.destroy();
  }
  // eslint-disable-next-line no-unused-vars
  _init(element, options = {}, themeOptions = {}, context = {}) {
    this.support = getSupportedFeatures();
    this.context = context;
    this.initObserver(context);
    this.initServices(context);
    this._notifyObserver(INIT);
    this._initOptions(options);
    this._setEvents(options);
    this.crs = new EPSG3857();
    this._initElement(element);
    this._viewOrigin = this._getOrigin();
    this._tooltip = this._createTooltip();
    this._initScroller();
    this._initMarkers();
    this._initControls();
    this._initLayers();
    this._reset();
    const mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);
    this._mousewheelHandler = (e) => {
      e.preventDefault();
      mousewheelThrottled(e);
    };
    on(this.element, MOUSEWHEEL2, this._mousewheelHandler);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _initElement(element) {
    this.element = element;
    addClass(element, "k-map");
    element.style.position = "relative";
    element.setAttribute("data-role", "map");
    removeChildren(element);
    const div = convertToHtml("<div />");
    this.element.appendChild(div);
  }
  initServices(context = {}) {
    this.widgetService = new map_service_default(this, context);
  }
  initObserver(context = {}) {
    this.observers = [];
    this.addObserver(context.observer);
  }
  addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  }
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  }
  requiresHandlers(eventNames) {
    const observers = this.observers;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  }
  trigger(name, args = {}) {
    args.sender = this;
    const observers = this.observers;
    let isDefaultPrevented2 = false;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name, args)) {
        isDefaultPrevented2 = true;
      }
    }
    if (!isDefaultPrevented2) {
      super.trigger(name, args);
    }
    return isDefaultPrevented2;
  }
  _notifyObserver(name, args = {}) {
    args.sender = this;
    const observers = this.observers;
    let isDefaultPrevented2 = false;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  }
  zoom(level) {
    let options = this.options;
    let result;
    if (defined(level)) {
      const zoomLevel = math5.round(limitValue(level, options.minZoom, options.maxZoom));
      if (options.zoom !== zoomLevel) {
        options.zoom = zoomLevel;
        this.widgetService.notify(ZOOM_CHANGE, { zoom: options.zoom });
        this._reset();
      }
      result = this;
    } else {
      result = options.zoom;
    }
    return result;
  }
  center(center) {
    let result;
    if (center) {
      const current4 = Location.create(center);
      const previous = Location.create(this.options.center);
      if (!current4.equals(previous)) {
        this.options.center = current4.toArray();
        this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
        this._reset();
      }
      result = this;
    } else {
      result = Location.create(this.options.center);
    }
    return result;
  }
  extent(extent) {
    let result;
    if (extent) {
      this._setExtent(extent);
      result = this;
    } else {
      result = this._getExtent();
    }
    return result;
  }
  setOptions(options = {}) {
    const element = this.element;
    this.destroy();
    removeChildren(element);
    this._init(element, options, {}, this.context);
    this._reset();
  }
  locationToLayer(location, zoom) {
    let clamp = !this.options.wraparound;
    const locationObject = Location.create(location);
    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);
  }
  layerToLocation(point, zoom) {
    let clamp = !this.options.wraparound;
    const pointObject = Point6.create(point);
    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);
  }
  locationToView(location) {
    const locationObject = Location.create(location);
    let origin = this.locationToLayer(this._viewOrigin);
    let point = this.locationToLayer(locationObject);
    return point.translateWith(origin.scale(-1));
  }
  viewToLocation(point, zoom) {
    const origin = this.locationToLayer(this._getOrigin(), zoom);
    const pointObject = Point6.create(point);
    const pointResult = pointObject.clone().translateWith(origin);
    return this.layerToLocation(pointResult, zoom);
  }
  eventOffset(e) {
    let x;
    let y;
    let offset = elementOffset(this.element);
    if (e.x && e.x[LOCATION] || e.y && e.y[LOCATION]) {
      x = e.x[LOCATION] - offset.left;
      y = e.y[LOCATION] - offset.top;
    } else {
      let event = e.originalEvent || e;
      x = valueOrDefault(event.pageX, event.clientX) - offset.left;
      y = valueOrDefault(event.pageY, event.clientY) - offset.top;
    }
    const point = new geometry_exports.Point(x, y);
    return point;
  }
  eventToView(e) {
    let cursor = this.eventOffset(e);
    return this.locationToView(this.viewToLocation(cursor));
  }
  eventToLayer(e) {
    return this.locationToLayer(this.eventToLocation(e));
  }
  eventToLocation(e) {
    let cursor = this.eventOffset(e);
    return this.viewToLocation(cursor);
  }
  viewSize() {
    let element = this.element;
    let scale = this._layerSize();
    let width = element.clientWidth;
    if (!this.options.wraparound) {
      width = min3(scale, width);
    }
    return {
      width,
      height: min3(scale, element.clientHeight)
    };
  }
  exportVisual() {
    this._reset();
    return false;
  }
  hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  }
  _setOrigin(origin, zoom) {
    let size = this.viewSize(), topLeft;
    const originLocation = this._origin = Location.create(origin);
    topLeft = this.locationToLayer(originLocation, zoom);
    topLeft.x += size.width / 2;
    topLeft.y += size.height / 2;
    this.options.center = this.layerToLocation(topLeft, zoom).toArray();
    this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
    return this;
  }
  _getOrigin(invalidate) {
    let size = this.viewSize(), topLeft;
    if (invalidate || !this._origin) {
      topLeft = this.locationToLayer(this.center());
      topLeft.x -= size.width / 2;
      topLeft.y -= size.height / 2;
      this._origin = this.layerToLocation(topLeft);
    }
    return this._origin;
  }
  _setExtent(newExtent) {
    let raw = Extent.create(newExtent);
    let se = raw.se.clone();
    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {
      se.lng = 180 + (180 + se.lng);
    }
    const extent = new Extent(raw.nw, se);
    this.center(extent.center());
    let width = this.element.clientWidth;
    let height = this.element.clientHeight;
    let zoom;
    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {
      let topLeft = this.locationToLayer(extent.nw, zoom);
      let bottomRight = this.locationToLayer(extent.se, zoom);
      let layerWidth = math5.abs(bottomRight.x - topLeft.x);
      let layerHeight = math5.abs(bottomRight.y - topLeft.y);
      if (layerWidth <= width && layerHeight <= height) {
        break;
      }
    }
    this.zoom(zoom);
  }
  _getExtent() {
    let nw = this._getOrigin();
    let bottomRight = this.locationToLayer(nw);
    let size = this.viewSize();
    bottomRight.x += size.width;
    bottomRight.y += size.height;
    let se = this.layerToLocation(bottomRight);
    return new Extent(nw, se);
  }
  _zoomAround(pivot, level) {
    this._setOrigin(this.layerToLocation(pivot, level), level);
    this.zoom(level);
  }
  _initControls() {
    let controls = this.options.controls;
    if (controls.attribution) {
      this._createAttribution(controls.attribution);
    }
    if (!this.support.mobileOS) {
      if (controls.navigator) {
        this._createNavigator(controls.navigator);
      }
      if (controls.zoom) {
        this._createZoomControl(controls.zoom);
      }
    }
  }
  _createControlElement(options, defaultPosition) {
    let pos = options.position || defaultPosition;
    let posSelector = "." + renderPos(pos).replace(" ", ".");
    let wrap = this.element.querySelector(".k-map-controls" + posSelector) || [];
    if (wrap.length === 0) {
      let div2 = document.createElement("div");
      addClass(div2, "k-map-controls " + renderPos(pos));
      wrap = div2;
      this.element.appendChild(wrap);
    }
    let div = document.createElement("div");
    wrap.appendChild(div);
    return div;
  }
  _createAttribution(options) {
    let element = this._createControlElement(options, "bottomRight");
    this.attribution = new Attribution(element, options);
  }
  _createNavigator(options) {
    let element = this._createControlElement(options, "topLeft");
    let navigator2 = this.navigator = new Navigator2(element, deepExtend({}, options, { icons: this.options.icons }));
    this._navigatorPan = this._navigatorPan.bind(this);
    navigator2.bind("pan", this._navigatorPan);
    this._navigatorCenter = this._navigatorCenter.bind(this);
    navigator2.bind("center", this._navigatorCenter);
  }
  _navigatorPan(e) {
    let scroller = this.scroller;
    let x = scroller.scrollLeft + e.x;
    let y = scroller.scrollTop - e.y;
    let bounds = this._virtualSize;
    let width = this.element.clientWidth;
    let height = this.element.clientHeight;
    x = limitValue(x, bounds.x.min, bounds.x.max - width);
    y = limitValue(y, bounds.y.min, bounds.y.max - height);
    this.scroller.one("scroll", proxy(this._scrollEnd, this));
    this.scroller.scrollTo(-x, -y);
  }
  _navigatorCenter() {
    this.center(this.options.center);
  }
  _createZoomControl(options) {
    let element = this._createControlElement(options, "topLeft");
    let zoomControl = this.zoomControl = new ZoomControl(element, options, this.options.icons);
    this._zoomControlChange = this._zoomControlChange.bind(this);
    zoomControl.bind("change", this._zoomControlChange);
  }
  _zoomControlChange(e) {
    if (!this.trigger("zoomStart", { originalEvent: e })) {
      this.zoom(this.zoom() + e.delta);
      this.trigger("zoomEnd", {
        originalEvent: e
      });
    }
  }
  _initScroller() {
    let friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION2;
    let zoomable = this.options.zoomable !== false;
    let scroller = this.scroller = new Scroller(this.element.children[0], {
      friction,
      velocityMultiplier: VELOCITY_MULTIPLIER2,
      zoom: zoomable,
      mousewheelScrolling: false,
      supportDoubleTap: true
    });
    scroller.bind("scroll", proxy(this._scroll, this));
    scroller.bind("scrollEnd", proxy(this._scrollEnd, this));
    scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));
    scroller.userEvents.bind("gestureend", proxy(this._scale, this));
    scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));
    scroller.userEvents.bind("tap", proxy(this._tap, this));
    this.scrollElement = scroller.scrollElement;
  }
  _initLayers() {
    let defs = this.options.layers, layers = this.layers = [];
    for (let i = 0; i < defs.length; i++) {
      let options = defs[i];
      const layer = this._createLayer(options);
      layers.push(layer);
    }
  }
  _createLayer(options) {
    let type = options.type || "shape";
    let layerDefaults = this.options.layerDefaults[type];
    let layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options, { icons: this.options.icons }) : deepExtend({}, layerDefaults, options);
    let layerConstructor = layersMap[type];
    let layer = new layerConstructor(this, layerOptions);
    if (type === MARKER) {
      this.markers = layer;
    }
    return layer;
  }
  _createTooltip() {
    return new Tooltip2(this.widgetService, this.options.tooltip);
  }
  /* eslint-disable arrow-body-style */
  _initMarkers() {
    const markerLayers = (this.options.layers || []).filter((x) => {
      return x && x.type === MARKER;
    });
    if (markerLayers.length > 0) {
      return;
    }
    this.markers = new MarkerLayer(this, deepExtend({}, this.options.markerDefaults, { icons: this.options.icons }));
    this.markers.add(this.options.markers);
  }
  /* eslint-enable arrow-body-style */
  _scroll(e) {
    let origin = this.locationToLayer(this._viewOrigin).round();
    let movable = e.sender.movable;
    let offset = new geometry_exports.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);
    origin.x += offset.x;
    origin.y += offset.y;
    this._scrollOffset = offset;
    this._tooltip.offset = offset;
    this.hideTooltip();
    this._setOrigin(this.layerToLocation(origin));
    this.trigger("pan", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  }
  _scrollEnd(e) {
    if (!this._scrollOffset || !this._panComplete()) {
      return;
    }
    this._scrollOffset = null;
    this._panEndTimestamp = now();
    this.trigger("panEnd", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  }
  _panComplete() {
    return now() - (this._panEndTimestamp || 0) > 50;
  }
  _scaleStart(e) {
    if (this.trigger("zoomStart", { originalEvent: e })) {
      let touch = e.touches[1];
      if (touch) {
        touch.cancel();
      }
    }
  }
  _scale(e) {
    let scale = this.scroller.movable.scale;
    let zoom = this._scaleToZoom(scale);
    let gestureCenter = new geometry_exports.Point(e.center.x, e.center.y);
    let centerLocation = this.viewToLocation(gestureCenter, zoom);
    let centerPoint = this.locationToLayer(centerLocation, zoom);
    let originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);
    this._zoomAround(originPoint, zoom);
    this.trigger("zoomEnd", {
      originalEvent: e
    });
  }
  _scaleToZoom(scaleDelta) {
    let scale = this._layerSize() * scaleDelta;
    let tiles = scale / this.options.minSize;
    let zoom = math5.log(tiles) / math5.log(2);
    return math5.round(zoom);
  }
  _reset() {
    if (this.attribution) {
      this.attribution.filter(this.center(), this.zoom());
    }
    this._viewOrigin = this._getOrigin(true);
    this._resetScroller();
    this.hideTooltip();
    this.trigger("beforeReset");
    this.trigger("reset");
  }
  _resetScroller() {
    let scroller = this.scroller;
    let x = scroller.dimensions.x;
    let y = scroller.dimensions.y;
    let scale = this._layerSize();
    let nw = this.extent().nw;
    let topLeft = this.locationToLayer(nw).round();
    scroller.movable.round = true;
    scroller.reset();
    scroller.userEvents.cancel();
    let zoom = this.zoom();
    scroller.dimensions.forcedMinScale = pow2(2, this.options.minZoom - zoom);
    scroller.dimensions.maxScale = pow2(2, this.options.maxZoom - zoom);
    let xBounds = {
      min: -topLeft.x,
      max: scale - topLeft.x
    };
    let yBounds = {
      min: -topLeft.y,
      max: scale - topLeft.y
    };
    if (this.options.wraparound) {
      xBounds.max = 20 * scale;
      xBounds.min = -xBounds.max;
    }
    if (this.options.pannable === false) {
      let viewSize = this.viewSize();
      xBounds.min = yBounds.min = 0;
      xBounds.max = viewSize.width;
      yBounds.max = viewSize.height;
    }
    x.makeVirtual();
    y.makeVirtual();
    x.virtualSize(xBounds.min, xBounds.max);
    y.virtualSize(yBounds.min, yBounds.max);
    this._virtualSize = {
      x: xBounds,
      y: yBounds
    };
  }
  // kept for API compatibility, not used
  _renderLayers() {
  }
  _layerSize(zoom) {
    const newZoom = valueOrDefault(zoom, this.options.zoom);
    return this.options.minSize * pow2(2, newZoom);
  }
  _tap(e) {
    if (!this._panComplete()) {
      return;
    }
    let cursor = this.eventOffset(e);
    this.hideTooltip();
    this.trigger("click", {
      originalEvent: e,
      location: this.viewToLocation(cursor)
    });
  }
  _doubleTap(e) {
    let options = this.options;
    if (options.zoomable !== false) {
      if (!this.trigger("zoomStart", { originalEvent: e })) {
        let toZoom = this.zoom() + DEFAULT_ZOOM_RATE;
        let cursor = this.eventOffset(e);
        let location = this.viewToLocation(cursor);
        let postZoom = this.locationToLayer(location, toZoom);
        let origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  }
  _mousewheel(e) {
    let delta = mousewheelDelta(e) > 0 ? -1 : 1;
    let options = this.options;
    let fromZoom = this.zoom();
    let toZoom = limitValue(fromZoom + delta, options.minZoom, options.maxZoom);
    if (options.zoomable !== false && toZoom !== fromZoom) {
      if (!this.trigger("zoomStart", { originalEvent: e })) {
        let cursor = this.eventOffset(e);
        let location = this.viewToLocation(cursor);
        let postZoom = this.locationToLayer(location, toZoom);
        let origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  }
  _toDocumentCoordinates(point) {
    const offset = elementOffset(this.element);
    return {
      left: round(point.x + offset.left),
      top: round(point.y + offset.top)
    };
  }
};
setDefaultOptions(Map2, {
  name: "Map",
  controls: {
    attribution: true,
    navigator: {
      panStep: 100
    },
    zoom: true
  },
  layers: [],
  layerDefaults: {
    shape: {
      style: {
        fill: {
          color: "#fff"
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    bubble: {
      style: {
        fill: {
          color: "#fff",
          opacity: 0.5
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    marker: {
      shape: "pinTarget",
      tooltip: {
        position: "top"
      }
    }
  },
  center: [
    0,
    0
  ],
  icons: {
    type: "font",
    svgIcons: {}
  },
  zoom: 3,
  minSize: 256,
  minZoom: 1,
  maxZoom: 19,
  markers: [],
  markerDefaults: {
    shape: "pinTarget",
    tooltip: {
      position: "top"
    }
  },
  wraparound: true,
  // If set to true, GeoJSON layer "Point" features will be rendered as markers.
  // Otherwise, the points will be rendered as circles.
  // Defaults to `true` for KUI/jQuery, `false` everywhere else.
  renderPointsAsMarkers: false
});
setDefaultEvents(Map2, [
  "beforeReset",
  "click",
  "markerActivate",
  "markerClick",
  "markerCreated",
  // Events for implementing custom tooltips.
  "markerMouseEnter",
  "markerMouseLeave",
  "pan",
  "panEnd",
  "reset",
  "shapeClick",
  "shapeCreated",
  "shapeFeatureCreated",
  "shapeMouseEnter",
  "shapeMouseLeave",
  "zoomEnd",
  "zoomStart"
]);

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/get-wizard-data-from-data-rows.js
function getWizardDataFromDataRows(dataRows) {
  const result = [];
  dataRows.forEach((item) => {
    const { dataItem, dataColumns } = item;
    const row = [];
    dataColumns.forEach((column) => {
      row.push({
        field: column.title || column.field,
        value: getter(column.field)(dataItem)
      });
    });
    result.push(row);
  });
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/state.js
var ActionTypes = Object.freeze({
  seriesType: 0,
  stacked: 1,
  categoryAxisX: 2,
  valueAxisY: 3,
  seriesChange: 4,
  areaMarginLeft: 5,
  areaMarginRight: 6,
  areaMarginTop: 7,
  areaMarginBottom: 8,
  areaBackground: 9,
  titleText: 10,
  titleFontName: 11,
  titleFontSize: 12,
  titleColor: 13,
  subtitleText: 14,
  subtitleFontName: 15,
  subtitleFontSize: 16,
  subtitleColor: 17,
  seriesColor: 18,
  seriesLabel: 19,
  legendVisible: 20,
  legendFontName: 21,
  legendFontSize: 22,
  legendColor: 23,
  legendPosition: 24,
  categoryAxisTitleText: 25,
  categoryAxisTitleFontName: 26,
  categoryAxisTitleFontSize: 27,
  categoryAxisTitleColor: 28,
  categoryAxisLabelsFontName: 29,
  categoryAxisLabelsFontSize: 30,
  categoryAxisLabelsColor: 31,
  categoryAxisLabelsRotation: 32,
  categoryAxisReverseOrder: 33,
  valueAxisTitleText: 34,
  valueAxisTitleFontName: 35,
  valueAxisTitleFontSize: 36,
  valueAxisTitleColor: 37,
  valueAxisLabelsFormat: 38,
  valueAxisLabelsFontName: 39,
  valueAxisLabelsFontSize: 40,
  valueAxisLabelsColor: 41,
  valueAxisLabelsRotation: 42
});
var fontSizes = [
  { text: "10", value: "10px" },
  { text: "12", value: "12px" },
  { text: "14", value: "14px" },
  { text: "16", value: "16px" },
  { text: "20", value: "20px" },
  { text: "28", value: "28px" },
  { text: "42", value: "42px" },
  { text: "56", value: "56px" }
];
var titleSizeDefault = "20px";
var subtitleSizeDefault = "16px";
var labelSizeDefault = "12px";
var axisTitleSizeDefault = "16px";
var fontNames = [
  {
    text: "Arial",
    value: "Arial, Helvetica, sans-serif",
    style: { fontFamily: "Arial, Helvetica, sans-serif" }
  },
  {
    text: "Courier New",
    value: "'Courier New', Courier, monospace",
    style: { fontFamily: "'Courier New', Courier, monospace" }
  },
  {
    text: "Georgia",
    value: "Georgia, serif",
    style: { fontFamily: "Georgia, serif" }
  },
  {
    text: "Impact",
    value: "Impact, Charcoal, sans-serif",
    style: { fontFamily: "Impact, Charcoal, sans-serif" }
  },
  {
    text: "Lucida Console",
    value: "'Lucida Console', Monaco, monospace",
    style: { fontFamily: "'Lucida Console', Monaco, monospace" }
  },
  {
    text: "Tahoma",
    value: "Tahoma, Geneva, sans-serif",
    style: { fontFamily: "Tahoma, Geneva, sans-serif" }
  },
  {
    text: "Times New Roman",
    value: "'Times New Roman', Times,serif",
    style: { fontFamily: "'Times New Roman', Times,serif" }
  },
  {
    text: "Trebuchet MS",
    value: "'Trebuchet MS', Helvetica, sans-serif",
    style: { fontFamily: "'Trebuchet MS', Helvetica, sans-serif" }
  },
  {
    text: "Verdana",
    value: "Verdana, Geneva, sans-serif",
    style: { fontFamily: "Verdana, Geneva, sans-serif" }
  }
];
var fontNameDefault = fontNames[0].value;
var columnType = "column";
var barType = "bar";
var lineType = "line";
var pieType = "pie";
var scatterType = "scatter";
var categoricalTypes = [columnType, barType, lineType, scatterType];
var scatterSeries2 = {
  type: lineType,
  width: 0
};
function isCategorical(type) {
  return type && categoricalTypes.includes(type);
}
var categoryTypes = ["string", "date", "number"];
var valueTypes = ["number"];
var axesDefinitions = {
  bar: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  column: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  line: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  pie: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes, count: 1 }
  ],
  scatter: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ]
};
function getFont2(font, size) {
  return `${size || ""} ${font || ""}`.trim();
}
function parseFont(font) {
  const spaceIndex = (font || "").indexOf(" ");
  const size = font && font.substring(0, spaceIndex);
  const name = font && font.substring(spaceIndex + 1);
  return { size, name };
}
var updateFontName = (fontName, defaultSize, currentFont) => {
  const { size } = parseFont(currentFont);
  return fontName ? getFont2(fontName, size || defaultSize) : "";
};
var updateFontSize = (fontSize, defaultFontName, currentFont) => {
  const { name } = parseFont(currentFont);
  return fontSize ? getFont2(name || defaultFontName, fontSize) : "";
};
var hasValue3 = (value2) => value2 !== void 0 && value2 !== null;
var recordWithValues = (data) => {
  const result = structuredClone(data[0]);
  result.forEach((item, i) => {
    if (!hasValue3(item.value)) {
      for (let index = 0; index < data.length; index++) {
        const value2 = data[index][i].value;
        if (hasValue3(value2)) {
          item.value = value2;
          break;
        }
      }
    }
  });
  return result;
};
var getCategoryColumnIndex = (data, categoryDef) => {
  const candidates = [];
  const sampleRecord = recordWithValues(data);
  categoryDef.types.forEach((type) => {
    sampleRecord.forEach((item, i) => {
      if (typeof item.value === type) {
        candidates.push(i);
      }
    });
  });
  const result = candidates.findIndex((index) => {
    const values = data.map((record) => record[index].value);
    return new Set(values).size === values.length;
  });
  return Math.max(result, 0);
};
var getValueColumnIndexes = (data, valuesDef) => {
  const candidates = [];
  const sampleRecord = recordWithValues(data);
  valuesDef.forEach((def) => {
    def.types.forEach((type) => {
      sampleRecord.forEach((item, i) => {
        if (typeof item.value === type) {
          candidates.push(i);
        }
      });
    });
  });
  return candidates;
};
var emptyState = () => structuredClone({
  columns: [],
  data: [],
  series: [],
  initialSeries: [],
  categoryAxis: [{ categories: [], labels: { visible: true, rotation: "auto" }, title: { text: "" } }],
  valueAxis: [{ labels: { visible: true, rotation: "auto" } }],
  area: {
    margin: {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }
  },
  title: { text: "" },
  subtitle: { text: "" },
  stack: false
});
var categoryValueChartState = (data, seriesType, options) => {
  const state = emptyState();
  state.seriesType = seriesType;
  state.data = data || [];
  state.legend = { visible: true, position: "bottom" };
  const chartDef = axesDefinitions[seriesType];
  if (!chartDef || !data.length) {
    return state;
  }
  const firstRecord = data[0].slice();
  state.columns = data[0].map((i) => String(i.field));
  const categoryDef = chartDef.find((def) => def.axisType === "category");
  let catIndex = -1;
  if (categoryDef) {
    catIndex = options && options.categoryAxis ? state.columns.indexOf(options.categoryAxis) : getCategoryColumnIndex(data, categoryDef);
  }
  const valuesDef = chartDef.filter((def) => def.axisType === "value");
  let valuesIndexes = getValueColumnIndexes(data, valuesDef);
  if (valuesIndexes.includes(catIndex)) {
    if (valuesIndexes.length > 1) {
      valuesIndexes = valuesIndexes.filter((index) => index !== catIndex);
    } else {
      catIndex = -1;
    }
  }
  const series = [];
  valuesIndexes.forEach((index) => {
    const valuesColumn = firstRecord[index];
    const valuesResult = [];
    data.forEach((record) => {
      valuesResult.push(record[index].value);
    });
    series.push(Object.assign(
      {},
      {
        name: valuesColumn.field,
        type: seriesType,
        data: valuesResult,
        stack: false,
        labels: { visible: false }
      },
      seriesType === scatterType ? scatterSeries2 : {}
    ));
  });
  const categories = catIndex > -1 ? data.map(
    (item) => String(
      hasValue3(item[catIndex].value) ? item[catIndex].value : " "
    )
  ) : [];
  if (series.length) {
    state.series = series.map((s, i) => Object.assign({}, s, { id: i }));
    state.initialSeries = structuredClone(state.series);
  }
  state.categoryAxis = [
    { categories, labels: { visible: true, rotation: "auto" } }
  ];
  state.categoryField = state.columns[catIndex];
  return state;
};
var pieChartState = (data, seriesType, options) => {
  const state = emptyState();
  state.seriesType = seriesType;
  state.data = data || [];
  const chartDef = axesDefinitions[seriesType];
  if (!chartDef || !data.length) {
    return state;
  }
  const categoriesAxis = data[0].map((i) => i.field);
  const categoryDef = chartDef.find((def) => def.axisType === "category");
  let catIndex = -1;
  if (categoryDef) {
    catIndex = options && options.categoryAxis ? categoriesAxis.indexOf(options.categoryAxis) : getCategoryColumnIndex(data, categoryDef);
  }
  const valuesDef = chartDef.filter((def) => def.axisType === "value");
  let valuesIndexes = [];
  if (options && options.valueAxis) {
    valuesIndexes = [categoriesAxis.indexOf(options.valueAxis)];
  } else {
    valuesIndexes = getValueColumnIndexes(data, valuesDef);
  }
  if (valuesIndexes.includes(catIndex) && valuesIndexes.length > 1) {
    valuesIndexes = valuesIndexes.filter((index) => index !== catIndex);
  }
  if (typeof valuesDef[0].count === "number") {
    valuesIndexes = valuesIndexes.slice(0, valuesDef[0].count);
  }
  const categories = catIndex > -1 ? data.map((item) => String(item[catIndex].value)) : [];
  const flatData = [];
  data.forEach((item) => {
    const record = {};
    valuesIndexes.forEach((index) => {
      const col = item[index];
      record[col.field] = col.value || 0;
      record[item[catIndex].field] = item[catIndex].value || " ";
    });
    flatData.push(record);
  });
  state.columns = categoriesAxis;
  state.categoryAxis = [{ categories, title: { text: "" } }];
  state.series = [
    {
      id: 0,
      data: flatData,
      type: seriesType,
      name: categoriesAxis[catIndex],
      labels: { visible: true },
      categoryField: categoriesAxis[catIndex],
      field: categoriesAxis[valuesIndexes[0]]
    }
  ];
  state.categoryField = categoriesAxis[catIndex];
  state.valueField = categoriesAxis[valuesIndexes[0]];
  state.initialSeries = structuredClone(state.series);
  return state;
};
function createInitialState(data, seriesType, defaultState) {
  const state = createState(
    data,
    defaultState && defaultState.seriesType || seriesType
  );
  return typeof (defaultState && defaultState.stack) !== "undefined" ? updateState(state, ActionTypes.stacked, defaultState.stack) : state;
}
function createState(data, seriesType) {
  return (isCategorical(seriesType) ? categoryValueChartState : pieChartState)(
    data,
    seriesType
  );
}
function mergeStates(source, target) {
  const newState = structuredClone(target);
  newState.legend = source.legend;
  newState.area = source.area;
  newState.title = source.title;
  newState.subtitle = source.subtitle;
  if (newState.series.length === source.series.length) {
    for (let i = 0; i < newState.series.length; i++) {
      newState.series[i].color = source.series[i].color;
      newState.series[i].labels = source.series[i].labels;
    }
  }
  if (source.series.every((s) => s.labels && s.labels.visible) && isCategorical(newState.seriesType) && isCategorical(source.seriesType)) {
    newState.series.forEach((s) => {
      s.labels = s.labels || {};
      s.labels.visible = true;
    });
  }
  return newState;
}
function updateState(currentState, action, value2) {
  const state = Object.assign({}, currentState);
  switch (action) {
    case ActionTypes.seriesType:
      return createState(state.data, value2);
    case ActionTypes.stacked:
      state.series = state.series.map((s) => Object.assign({}, s, { stack: value2 }));
      state.stack = value2;
      return state;
    case ActionTypes.categoryAxisX: {
      if (state.seriesType && isCategorical(state.seriesType)) {
        const newState = categoryValueChartState(
          state.data,
          state.seriesType,
          { categoryAxis: value2 }
        );
        return mergeStates(state, newState);
      } else if (state.seriesType === pieType) {
        const newState = pieChartState(state.data, state.seriesType, {
          categoryAxis: value2
        });
        return mergeStates(state, newState);
      }
      return state;
    }
    case ActionTypes.valueAxisY: {
      if (state.seriesType === pieType) {
        const newState = pieChartState(state.data, state.seriesType, {
          categoryAxis: state.categoryField,
          valueAxis: value2
        });
        return mergeStates(state, newState);
      }
      return state;
    }
    case ActionTypes.seriesChange:
      state.series = value2;
      return state;
    case ActionTypes.areaMarginLeft:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { left: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginRight:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { right: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginTop:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { top: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginBottom:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { bottom: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaBackground:
      state.area = Object.assign({}, state.area, { background: value2 });
      return state;
    case ActionTypes.titleText:
      state.title = Object.assign({}, state.title, { text: value2 });
      return state;
    case ActionTypes.titleFontName: {
      state.title = Object.assign(
        {},
        state.title,
        { font: updateFontName(
          value2,
          titleSizeDefault,
          state.title && state.title.font
        ) }
      );
      return state;
    }
    case ActionTypes.titleFontSize:
      state.title = Object.assign(
        {},
        state.title,
        { font: updateFontSize(
          value2,
          fontNameDefault,
          state.title && state.title.font
        ) }
      );
      return state;
    case ActionTypes.titleColor:
      state.title = Object.assign({}, state.title, { color: value2 });
      return state;
    case ActionTypes.subtitleText:
      state.subtitle = Object.assign({}, state.subtitle, { text: value2 });
      return state;
    case ActionTypes.subtitleFontName:
      state.subtitle = Object.assign(
        {},
        state.subtitle,
        { font: updateFontName(
          value2,
          subtitleSizeDefault,
          state.subtitle && state.subtitle.font
        ) }
      );
      return state;
    case ActionTypes.subtitleFontSize:
      state.subtitle = Object.assign(
        {},
        state.subtitle,
        { font: updateFontSize(
          value2,
          fontNameDefault,
          state.subtitle && state.subtitle.font
        ) }
      );
      return state;
    case ActionTypes.subtitleColor:
      state.subtitle = Object.assign({}, state.subtitle, { color: value2 });
      return state;
    case ActionTypes.seriesColor:
      state.series = state.series.map((s) => Object.assign(
        {},
        s,
        { color: value2.seriesName === s.name ? value2.color : s.color }
      ));
      return state;
    case ActionTypes.seriesLabel:
      state.series = state.series.map((s) => {
        if (value2.all || value2.seriesName === s.name) {
          return Object.assign({}, s, { labels: { visible: value2.visible } });
        }
        return s;
      });
      return state;
    case ActionTypes.legendVisible:
      state.legend = Object.assign({}, state.legend, { visible: value2 });
      return state;
    case ActionTypes.legendFontName: {
      const legend2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend2,
        { labels: Object.assign(
          {},
          legend2.labels,
          { font: updateFontName(
            value2,
            labelSizeDefault,
            legend2.labels && legend2.labels.font
          ) }
        ) }
      );
      return state;
    }
    case ActionTypes.legendFontSize: {
      const legend2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend2,
        { labels: Object.assign(
          {},
          legend2.labels,
          { font: updateFontSize(
            value2,
            fontNameDefault,
            legend2.labels && legend2.labels.font
          ) }
        ) }
      );
      return state;
    }
    case ActionTypes.legendColor: {
      const legend2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend2,
        { labels: Object.assign({}, legend2.labels, { color: value2 }) }
      );
      return state;
    }
    case ActionTypes.legendPosition:
      state.legend = Object.assign({}, state.legend, { position: value2 });
      return state;
    case ActionTypes.categoryAxisTitleText:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { text: value2 }) }));
      return state;
    case ActionTypes.categoryAxisTitleFontName: {
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontName(value2, axisTitleSizeDefault, axis.title && axis.title.font) }) }));
      return state;
    }
    case ActionTypes.categoryAxisTitleFontSize:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontSize(value2, fontNameDefault, axis.title && axis.title.font) }) }));
      return state;
    case ActionTypes.categoryAxisTitleColor:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { color: value2 }) }));
      return state;
    case ActionTypes.categoryAxisLabelsFontName: {
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontName(value2, labelSizeDefault, axis.labels && axis.labels.font) }) }));
      return state;
    }
    case ActionTypes.categoryAxisLabelsFontSize:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontSize(value2, fontNameDefault, axis.labels && axis.labels.font) }) }));
      return state;
    case ActionTypes.categoryAxisLabelsColor:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { color: value2 }) }));
      return state;
    case ActionTypes.categoryAxisLabelsRotation: {
      const rotation = hasValue3(value2) ? value2 : "auto";
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { rotation }) }));
      return state;
    }
    case ActionTypes.categoryAxisReverseOrder:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { reverse: value2 }));
      return state;
    case ActionTypes.valueAxisTitleText: {
      if (!state.valueAxis || state.valueAxis.length === 0) {
        state.valueAxis = [{ title: { text: value2 } }];
      } else {
        state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { text: value2 }) }));
      }
      return state;
    }
    case ActionTypes.valueAxisTitleFontName: {
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontName(value2, axisTitleSizeDefault, axis.title && axis.title.font) }) }));
      return state;
    }
    case ActionTypes.valueAxisTitleFontSize:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontSize(value2, fontNameDefault, axis.title && axis.title.font) }) }));
      return state;
    case ActionTypes.valueAxisTitleColor:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { color: value2 }) }));
      return state;
    case ActionTypes.valueAxisLabelsFormat:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { format: value2 }) }));
      return state;
    case ActionTypes.valueAxisLabelsFontName: {
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontName(value2, labelSizeDefault, axis.labels && axis.labels.font) }) }));
      return state;
    }
    case ActionTypes.valueAxisLabelsFontSize:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontSize(value2, fontNameDefault, axis.labels && axis.labels.font) }) }));
      return state;
    case ActionTypes.valueAxisLabelsColor:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { color: value2 }) }));
      return state;
    case ActionTypes.valueAxisLabelsRotation: {
      const rotation = hasValue3(value2) ? value2 : "auto";
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { rotation }) }));
      return state;
    }
    default:
      return state;
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/messages.js
var messages = Object.freeze({
  windowTitle: "Chart Preview",
  exportButton: "Export",
  exportPDFButton: "PDF File",
  exportSVGButton: "SVG File",
  exportPNGButton: "PNG File",
  tabChart: "Chart",
  tabData: "Data",
  tabFormat: "Format",
  barChart: "Bar Chart",
  barChartBar: "Bar",
  barChartStackedBar: "Stacked Bar",
  barChart100StackedBar: "100% Stacked Bar",
  pieChart: "Pie Chart",
  pieChartPie: "Pie",
  columnChart: "Column Chart",
  columnChartColumn: "Column",
  columnChartStackedColumn: "Stacked Column",
  columnChart100StackedColumn: "100% Stacked Column",
  lineChart: "Line Chart",
  lineChartLine: "Line",
  lineChartStackedLine: "Stacked Line",
  lineChart100StackedLine: "100% Stacked Line",
  scatterChart: "Scatter Chart",
  scatterChartScatter: "Scatter",
  configuration: "Configuration",
  configurationCategoryAxis: "Category Axis",
  configurationXAxis: "X Axis",
  configurationValueAxis: "Value Axis",
  configurationSeries: "Series",
  configurationSeriesAdd: "Add",
  formatChartArea: "Chart Area",
  formatChartAreaMargins: "Margins",
  formatChartAreaMarginsAuto: "Auto",
  formatChartAreaMarginsLeft: "Left",
  formatChartAreaMarginsRight: "Right",
  formatChartAreaMarginsTop: "Top",
  formatChartAreaMarginsBottom: "Bottom",
  formatChartAreaBackground: "Background",
  formatChartAreaBackgroundColor: "Color",
  formatTitle: "Title",
  formatTitleApplyTo: "Apply to",
  formatTitleChartTitle: "Chart Title",
  formatTitleChartSubtitle: "Chart Subtitle",
  formatTitleLabel: "Title",
  formatTitleFont: "Font",
  formatTitleFontPlaceholder: "(inherited font)",
  formatTitleSize: "Size",
  formatTitleSizePlaceholder: "px",
  formatTitleColor: "Color",
  formatSeries: "Series",
  formatSeriesApplyTo: "Apply to",
  formatSeriesAllSeries: "All Series",
  formatSeriesColor: "Color",
  formatSeriesShowLabels: "Show Labels",
  formatLegend: "Legend",
  formatLegendShowLegend: "Show Legend",
  formatLegendFont: "Font",
  formatLegendFontPlaceholder: "(inherited font)",
  formatLegendSize: "Size",
  formatLegendSizePlaceholder: "px",
  formatLegendColor: "Color",
  formatLegendPosition: "Position",
  formatLegendPositionTop: "Top",
  formatLegendPositionBottom: "Bottom",
  formatLegendPositionLeft: "Left",
  formatLegendPositionRight: "Right",
  formatCategoryAxis: "Category Axis",
  formatXAxis: "X Axis",
  formatCategoryAxisTitle: "Title",
  formatCategoryAxisTitlePlaceholder: "Axis Title",
  formatCategoryAxisTitleFont: "Font",
  formatCategoryAxisTitleFontPlaceholder: "(inherited font)",
  formatCategoryAxisTitleSize: "Size",
  formatCategoryAxisTitleSizePlaceholder: "px",
  formatCategoryAxisTitleColor: "Color",
  formatCategoryAxisLabels: "Labels",
  formatCategoryAxisLabelsFont: "Font",
  formatCategoryAxisLabelsFontPlaceholder: "(inherited font)",
  formatCategoryAxisLabelsSize: "Size",
  formatCategoryAxisLabelsSizePlaceholder: "px",
  formatCategoryAxisLabelsColor: "Color",
  formatCategoryAxisLabelsRotation: "Rotation",
  formatCategoryAxisLabelsRotationAuto: "Auto",
  formatCategoryAxisLabelsReverseOrder: "Reverse Order",
  formatValueAxis: "Value Axis",
  formatYAxis: "Y Axis",
  formatValueAxisTitle: "Title",
  formatValueAxisTitlePlaceholder: "Axis Title",
  formatValueAxisTitleFont: "Font",
  formatValueAxisTitleFontPlaceholder: "(inherited font)",
  formatValueAxisTitleSize: "Size",
  formatValueAxisTitleSizePlaceholder: "px",
  formatValueAxisTitleColor: "Color",
  formatValueAxisLabels: "Labels",
  formatValueAxisLabelsFormat: "Label Format",
  formatValueAxisLabelsFormatText: "Text",
  formatValueAxisLabelsFormatNumber: "Number",
  formatValueAxisLabelsFormatCurrency: "Currency",
  formatValueAxisLabelsFormatPercent: "Percent",
  formatValueAxisLabelsFont: "Font",
  formatValueAxisLabelsFontPlaceholder: "(inherited font)",
  formatValueAxisLabelsSize: "Size",
  formatValueAxisLabelsSizePlaceholder: "px",
  formatValueAxisLabelsColor: "Color",
  formatValueAxisLabelsRotation: "Rotation",
  formatValueAxisLabelsRotationAuto: "Auto"
});

// node_modules/@progress/kendo-charts/dist/es/chart-wizard.js
var ChartWizardCommon = Object.freeze({
  getWizardDataFromDataRows,
  ActionTypes,
  createInitialState,
  createState,
  fontNames,
  fontSizes,
  isCategorical,
  mergeStates,
  parseFont,
  updateState,
  messages
});

export {
  deepExtend,
  instance_observer_default,
  date_category_axis_default,
  date_value_axis_default,
  chart_default,
  sparkline_default,
  stock_chart_default,
  linear_gauge_default,
  radial_gauge_default,
  arc_gauge_default,
  circular_gauge_default,
  Sankey2 as Sankey,
  createSankeyData,
  baseTheme,
  gaugeTheme,
  sankeyTheme,
  chartTheme
};
//# sourceMappingURL=chunk-7OI3DNUN.js.map
